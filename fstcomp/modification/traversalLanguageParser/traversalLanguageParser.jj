options {	//DEBUG_PARSER=true;	//LOOKAHEAD=5;	STATIC=false;	//FORCE_LA_CHECK=true;}PARSER_BEGIN(TraversalLanguageParser)package modification.traversalLanguageParser;import java.io.Reader;import java.io.StringReader;import java.util.List;import java.util.LinkedList;import modification.traversalLanguageParser.addressManagement.NameTypePatternToken;import modification.traversalLanguageParser.addressManagement.TreeAddress;import modification.traversalLanguageParser.addressManagement.TreeAddressToken;import modification.traversalLanguageParser.addressManagement.WildcardToken;import de.ovgu.cide.fstgen.ast.FSTNode;import de.ovgu.cide.fstgen.ast.FSTNonTerminal;public class TraversalLanguageParser{	/**    *     */	private FSTNode root = null;		/**	*	*/	private static final String JAVA_REGEX_PATTERN_STRING_WILDCARD = "(.)*";	/**    *     */    public List<FSTNode> parse() throws ParseException {		return expression();    }	/**    *     */    public TraversalLanguageParser(String traversal, FSTNode root) {		this((Reader) (new StringReader(traversal)));		this.root=root;    }        /**    *     */    private List<FSTNode> minus(List<FSTNode> a, List<FSTNode> b) {	List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);                        return result;           }    /**    *     */    private List<FSTNode> and(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.retainAll(b);         return result;    }    /**    *     */    private List<FSTNode> or(List<FSTNode> a, List<FSTNode> b) {		List<FSTNode> result = new LinkedList<FSTNode>(a);		result.removeAll(b);		result.addAll(b);        return result;    }        /**    *     */    private List<FSTNode> addSiblings(List<FSTNode> l) {		List<FSTNode> result = new LinkedList<FSTNode>(l);		for (FSTNode n : l) {			if (n.getParent() != null)				for (FSTNode sib: ((FSTNonTerminal)n.getParent()).getChildren()) {					if (n != sib)						result.add(sib);				}		}		        return result;    }}PARSER_END(TraversalLanguageParser)SKIP:{	" "	| "\t"	| "\n"	| "\r"}	TOKEN:{	<UNION:"||">	| <INTERSECTION:"&&">	| <MINUS:"--">	| <ADDSIB:"sib+">	| <ADDRESS_DIVIDER:".">	| <TYPE_DIVIDER:":">	| <ADDRESS_WILDCARD:"..">	| <STRING_WILDCARD:"*">	| <COND_RIGHT_BRACE:"]">	| <COND_LEFT_BRACE:"[">	| <LEFT_BRACE:"(">	| <RIGHT_BRACE:")">}TOKEN:{	<NUMBER:["0"-"9"]>	| <SMALL_CHARACTER:["a"-"z"]>	| <GREAT_CHARACTER:["A"-"Z"]>	| <ANY_CHAR:~[]>}  TOKEN:{    <LITERAL_START_FLAG:"%s"> : LITERAL_MODE}    <LITERAL_MODE> TOKEN:{	<LITERAL_END_FLAG:"%e"> : DEFAULT	| <ANY_CHAR_LITERAL:~[]>}/*** independent expression*/
List<FSTNode> expression():{	List<FSTNode> nodeListOp1 = new LinkedList<FSTNode>();	List<FSTNode> nodeListOp2 = new LinkedList<FSTNode>();	List<FSTNode> nodeListRes = new LinkedList<FSTNode>();}{	nodeListOp1 = traversalTerm()	{nodeListRes = nodeListOp1;}	(				<UNION> nodeListOp2 = traversalTerm()		{nodeListRes = nodeListOp1 = or(nodeListOp1, nodeListOp2);}		|		<INTERSECTION> nodeListOp2 = traversalTerm()		{nodeListRes = nodeListOp1 = and(nodeListOp1, nodeListOp2);}		|		<MINUS> nodeListOp2 = traversalTerm()		{nodeListRes = nodeListOp1 = minus(nodeListOp1, nodeListOp2);}			)* 		<EOF>	{return nodeListRes;}}/*** traversal term without operators outside braces*/List<FSTNode> traversalTerm():{	List<FSTNode> nodeList = new LinkedList<FSTNode>();	TreeAddress treeAddress;	TreeAddress conditionalTreeAddress;}{	(				(			<LEFT_BRACE> 			nodeList = expression() 			<RIGHT_BRACE>			{return nodeList;}		)				|		(			treeAddress = treeAddress()			(				<COND_LEFT_BRACE>				conditionalTreeAddress = treeAddress()				<COND_RIGHT_BRACE>				{										for (FSTNode n : treeAddress.resolve(root)) {						if (conditionalTreeAddress.resolve(n).size() > 0)							nodeList.add(n);						}					return nodeList;				}			)?			{return treeAddress.resolve(root);}		)		|		(			<ADDSIB>		 	treeAddress = treeAddress()		 	{return addSiblings(treeAddress.resolve(root));}		)			)	}/*** single tree address without operators. * Differentiation with "|" to suppress the empty string.* splits off <ADDRESS_WILDCARD>s to treat seperately.*/TreeAddress treeAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	List<TreeAddressToken> tempTokenList;}{		(					(			tempTokenList = literalAddress()			{tokenList.addAll(tempTokenList);}			(				<ADDRESS_WILDCARD>				{tokenList.add(new WildcardToken());}								tempTokenList = literalAddress() 				{tokenList.addAll(tempTokenList);}			)*		)							|		(			<ADDRESS_WILDCARD>			{tokenList.add(new WildcardToken());}						tempTokenList = literalAddress()			{tokenList.addAll(tempTokenList);}		)+	)	{return new TreeAddress(tokenList);}}/*** literalAddress consisting of nameTypePatternTokens and <ADDRESS_DIVIDER>s*/List<TreeAddressToken> literalAddress():{	List<TreeAddressToken> tokenList = new LinkedList<TreeAddressToken>();	TreeAddressToken token;}{	token = nameTypePatternToken()	{tokenList.add(token);}		(		<ADDRESS_DIVIDER>				token = nameTypePatternToken() 		{tokenList.add(token);}	)*		{return tokenList;}}/*** tokens split by <ADDRESS_DIVIDER> in literal addresses*/TreeAddressToken nameTypePatternToken():{	String name;	String type;}{	name = name()	<TYPE_DIVIDER>	type = type()	{return new NameTypePatternToken(name,type);}}/*** regex pattern for name part of nameTypePatternTokens*/String name():{	String name;}{	name = stringWithWildcards()	{return name;}}/*** regex pattern for type part of nameTypePatternTokens*/String type():{	String type;}{	type = stringWithWildcards() 	{return type;}	}/*** contains <STRING_WILDCARD>s and words mixed up in different ways*/String stringWithWildcards():{	String result = "";	Token t;	String s;}{		(				(			<STRING_WILDCARD>			{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}			s = wildcardExtension()			{result = result.concat(s.toString());}							)			|				(			s = word()			{result = result.concat(s.toString());}			s = wordExtension()			{result = result.concat(s.toString());}							)	)		{return result;}}/*** possible extends for word*/String wordExtension():{	String result = "";	Token t;	String s;}{	(		(			<STRING_WILDCARD>			{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}			(				s = word()				{result = result.concat(s.toString());}				s = wordExtension()				{result = result.concat(s.toString());}			)?		)?	)	{return result;}	}/*** possible extends for <STRING_WILDCARD>*/String wildcardExtension():{	String result = "";	Token t;	String s;}{	(		(			s = word()			{result = result.concat(s.toString());}			(				<STRING_WILDCARD>				{result = result.concat(JAVA_REGEX_PATTERN_STRING_WILDCARD);}				s = wildcardExtension()				{result = result.concat(s.toString());}			)?		)?	)	{return result;}}/*** word is consisting of <SMALL_CHARACTER>s, <GREAT_CHARACTER>s, * <NUMBER>s and specialCharacters (treated seperately)*/String word():{	String m;	String s = "";	Token t;}{	(		t = <SMALL_CHARACTER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		t = <GREAT_CHARACTER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		t = <NUMBER>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|				t = <ANY_CHAR>		{s = s.concat("\\Q" + t.toString() + "\\E");}		|		m = literalString()		{s = s.concat(m);}	)+	{return s;}}String literalString():{	String s = "";	Token t;}{	<LITERAL_START_FLAG>	(		(			t = <ANY_CHAR_LITERAL>			{s = s.concat("\\Q" + t.toString() + "\\E");}		)*	)	<LITERAL_END_FLAG>	{return s;}}