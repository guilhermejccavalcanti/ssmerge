revision;file;leftImport;rightImport;conflictUnmerge
/home/ines/gjcc/fpfnanalysis/samplerpl/java_rxjava/rev_1a7e5_92ba6/rev_1a7e5-92ba6.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_rxjava/rev_1a7e5_92ba6/rev_1a7e5-92ba6/rxjava-core/src/test/java/rx/ObservableTests.java;importrx.concurrency.TestScheduler;;importrx.schedulers.TestScheduler;;
import rx.concurrency.Schedulers;
import rx.concurrency.TestScheduler;
=======
import rx.schedulers.TestScheduler;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Financial/src/main/java/com/opengamma/financial/marketdatasnapshot/StructuredSnapper.java;importcom.opengamma.engine.view.calc.ComputationCycleQuery;;importcom.opengamma.engine.view.cycle.ComputationCycleQuery;;
import com.opengamma.engine.view.calc.ComputationCycleQuery;
import com.opengamma.engine.view.calc.ComputationCacheResponse;
import com.opengamma.engine.view.calc.ViewCycle;
import com.opengamma.lambdava.tuple.Pair;
import com.opengamma.id.ExternalId;
=======
import com.opengamma.engine.view.cycle.ComputationCacheResponse;
import com.opengamma.engine.view.cycle.ComputationCycleQuery;
import com.opengamma.engine.view.cycle.ViewCycle;
import com.opengamma.id.ExternalIdBundle;
import com.opengamma.util.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Financial/src/main/java/com/opengamma/financial/marketdatasnapshot/StructuredSnapper.java;importcom.opengamma.engine.view.calc.ComputationCacheResponse;;importcom.opengamma.engine.view.cycle.ComputationCacheResponse;;
import com.opengamma.engine.view.calc.ComputationCycleQuery;
import com.opengamma.engine.view.calc.ComputationCacheResponse;
import com.opengamma.engine.view.calc.ViewCycle;
import com.opengamma.lambdava.tuple.Pair;
import com.opengamma.id.ExternalId;
=======
import com.opengamma.engine.view.cycle.ComputationCacheResponse;
import com.opengamma.engine.view.cycle.ComputationCycleQuery;
import com.opengamma.engine.view.cycle.ViewCycle;
import com.opengamma.id.ExternalIdBundle;
import com.opengamma.util.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Financial/src/main/java/com/opengamma/financial/marketdatasnapshot/StructuredSnapper.java;importcom.opengamma.engine.view.calc.ViewCycle;;importcom.opengamma.engine.view.cycle.ViewCycle;;
import com.opengamma.engine.view.calc.ComputationCycleQuery;
import com.opengamma.engine.view.calc.ComputationCacheResponse;
import com.opengamma.engine.view.calc.ViewCycle;
import com.opengamma.lambdava.tuple.Pair;
import com.opengamma.id.ExternalId;
=======
import com.opengamma.engine.view.cycle.ComputationCacheResponse;
import com.opengamma.engine.view.cycle.ComputationCycleQuery;
import com.opengamma.engine.view.cycle.ViewCycle;
import com.opengamma.id.ExternalIdBundle;
import com.opengamma.util.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/pnl/OptionGreekUnderlyingPriceSeriesFunction.java;importcom.opengamma.util.timeseries.DoubleTimeSeries;;importcom.opengamma.timeseries.DoubleTimeSeries;;
import com.opengamma.util.timeseries.DoubleTimeSeries;
import com.opengamma.lambdava.tuple.Pair;
=======
import com.opengamma.timeseries.DoubleTimeSeries;
import com.opengamma.util.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/timeseries/AbstractHistoricalTimeSeriesShiftFunction.java;importcom.opengamma.util.timeseries.DoubleTimeSeriesOperators.UnaryOperator;;importcom.opengamma.timeseries.DoubleTimeSeriesOperators.UnaryOperator;;
import com.opengamma.util.timeseries.DoubleTimeSeriesOperators.UnaryOperator;
=======
import com.opengamma.timeseries.DoubleTimeSeriesOperators.UnaryOperator;
import com.opengamma.util.functional.Function3;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/SABRSensitivityNodeCalculatorTest.java;importcom.opengamma.analytics.util.surface.SurfaceValue;;importcom.opengamma.analytics.util.amount.SurfaceValue;;
import com.opengamma.analytics.util.surface.SurfaceValue;
import com.opengamma.lambdava.tuple.DoublesPair;
=======
import com.opengamma.analytics.util.amount.SurfaceValue;
import com.opengamma.util.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/curve/NodalObjectObjectCurveTest.java;importcom.opengamma.analytics.math.ParallelArrayBinarySort;;importcom.opengamma.util.ParallelArrayBinarySort;;
import com.opengamma.analytics.math.ParallelArrayBinarySort;
import com.opengamma.lambdava.tuple.ObjectsPair;
import com.opengamma.lambdava.tuple.Pair;
=======
import com.opengamma.util.ParallelArrayBinarySort;
import com.opengamma.util.tuple.ObjectsPair;
import com.opengamma.util.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/SABRSensitivityNodeCalculator.java;importcom.opengamma.analytics.util.surface.SurfaceValue;;importcom.opengamma.analytics.util.amount.SurfaceValue;;
import com.opengamma.analytics.util.surface.SurfaceValue;
import com.opengamma.lambdava.tuple.DoublesPair;
=======
import com.opengamma.analytics.util.amount.SurfaceValue;
import com.opengamma.util.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/PresentValueBlackSwaptionSensitivity.java;importcom.opengamma.analytics.util.surface.SurfaceValue;;importcom.opengamma.analytics.util.amount.SurfaceValue;;
import com.opengamma.analytics.util.surface.SurfaceValue;
import com.opengamma.lambdava.tuple.DoublesPair;
=======
import com.opengamma.analytics.util.amount.SurfaceValue;
import com.opengamma.util.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Component/src/main/java/com/opengamma/component/factory/master/InMemoryFunctionCostsMasterComponentFactory.java;importcom.opengamma.engine.view.calcnode.stats.DataFunctionCostsMasterResource;;importcom.opengamma.engine.calcnode.stats.DataFunctionCostsMasterResource;;
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.view.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.view.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   *
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the classifier that the factory should publish under.
   *
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   *
   * @param classifier the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   *
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   *
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   *
   * @param publishRest the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   *
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {

    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------

    /**
     * The meta-property for the {@code classifier} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}=======
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }
  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the classifier that the factory should publish under.
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   * @param classifier  the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   * @param publishRest  the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code classifier} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Component/src/main/java/com/opengamma/component/factory/master/InMemoryFunctionCostsMasterComponentFactory.java;importcom.opengamma.engine.view.calcnode.stats.FunctionCostsMaster;;importcom.opengamma.engine.calcnode.stats.FunctionCostsMaster;;
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.view.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.view.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   *
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the classifier that the factory should publish under.
   *
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   *
   * @param classifier the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   *
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   *
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   *
   * @param publishRest the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   *
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {

    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------

    /**
     * The meta-property for the {@code classifier} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}=======
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }
  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the classifier that the factory should publish under.
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   * @param classifier  the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   * @param publishRest  the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code classifier} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Component/src/main/java/com/opengamma/component/factory/master/InMemoryFunctionCostsMasterComponentFactory.java;importcom.opengamma.engine.view.calcnode.stats.InMemoryFunctionCostsMaster;;importcom.opengamma.engine.calcnode.stats.InMemoryFunctionCostsMaster;;
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.view.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.view.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   *
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the classifier that the factory should publish under.
   *
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   *
   * @param classifier the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   *
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   *
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   *
   * @param publishRest the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   *
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {

    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------

    /**
     * The meta-property for the {@code classifier} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}=======
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }
  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the classifier that the factory should publish under.
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   * @param classifier  the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   * @param publishRest  the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code classifier} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b433_a6994/rev_1b433-a6994/projects/OG-Component/src/main/java/com/opengamma/component/factory/master/InMemoryFunctionCostsMasterComponentFactory.java;importcom.opengamma.engine.view.calcnode.stats.RemoteFunctionCostsMaster;;importcom.opengamma.engine.calcnode.stats.RemoteFunctionCostsMaster;;
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.view.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.view.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.view.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   *
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the classifier that the factory should publish under.
   *
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   *
   * @param classifier the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   *
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   *
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   *
   * @param publishRest the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   *
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------

  /**
   * The meta-bean for {@code InMemoryConfigMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {

    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------

    /**
     * The meta-property for the {@code classifier} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     *
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------
}=======
/**
 * Copyright (C) 2012 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.component.factory.master;

import java.util.LinkedHashMap;
import java.util.Map;

import org.joda.beans.BeanBuilder;
import org.joda.beans.BeanDefinition;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.opengamma.component.ComponentInfo;
import com.opengamma.component.ComponentRepository;
import com.opengamma.component.factory.AbstractComponentFactory;
import com.opengamma.component.factory.ComponentInfoAttributes;
import com.opengamma.engine.calcnode.stats.DataFunctionCostsMasterResource;
import com.opengamma.engine.calcnode.stats.FunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.InMemoryFunctionCostsMaster;
import com.opengamma.engine.calcnode.stats.RemoteFunctionCostsMaster;

/**
 * Component factory for an in-memory function blacklist provider.
 */
@BeanDefinition
public class InMemoryFunctionCostsMasterComponentFactory extends AbstractComponentFactory {

  /**
   * The classifier that the factory should publish under.
   */
  @PropertyDefinition(validate = "notNull")
  private String _classifier;
  /**
   * The flag determining whether the component should be published by REST (default true).
   */
  @PropertyDefinition
  private boolean _publishRest = true;


  @Override
  public void init(final ComponentRepository repo, final LinkedHashMap<String, String> configuration) {
    final FunctionCostsMaster master = new InMemoryFunctionCostsMaster();
    final ComponentInfo info = new ComponentInfo(FunctionCostsMaster.class, getClassifier());
    info.addAttribute(ComponentInfoAttributes.LEVEL, 1);
    info.addAttribute(ComponentInfoAttributes.REMOTE_CLIENT_JAVA, RemoteFunctionCostsMaster.class);
    repo.registerComponent(info, master);

    if (isPublishRest()) {
      repo.getRestComponents().publish(info, new DataFunctionCostsMasterResource(master));
    }
  }

  //------------------------- AUTOGENERATED START -------------------------
  ///CLOVER:OFF
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   * @return the meta-bean, not null
   */
  public static InMemoryFunctionCostsMasterComponentFactory.Meta meta() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }
  static {
    JodaBeanUtils.registerMetaBean(InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE);
  }

  @Override
  public InMemoryFunctionCostsMasterComponentFactory.Meta metaBean() {
    return InMemoryFunctionCostsMasterComponentFactory.Meta.INSTANCE;
  }

  @Override
  protected Object propertyGet(String propertyName, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        return getClassifier();
      case -614707837:  // publishRest
        return isPublishRest();
    }
    return super.propertyGet(propertyName, quiet);
  }

  @Override
  protected void propertySet(String propertyName, Object newValue, boolean quiet) {
    switch (propertyName.hashCode()) {
      case -281470431:  // classifier
        setClassifier((String) newValue);
        return;
      case -614707837:  // publishRest
        setPublishRest((Boolean) newValue);
        return;
    }
    super.propertySet(propertyName, newValue, quiet);
  }

  @Override
  protected void validate() {
    JodaBeanUtils.notNull(_classifier, "classifier");
    super.validate();
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      InMemoryFunctionCostsMasterComponentFactory other = (InMemoryFunctionCostsMasterComponentFactory) obj;
      return JodaBeanUtils.equal(getClassifier(), other.getClassifier()) &&
          JodaBeanUtils.equal(isPublishRest(), other.isPublishRest()) &&
          super.equals(obj);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash += hash * 31 + JodaBeanUtils.hashCode(getClassifier());
    hash += hash * 31 + JodaBeanUtils.hashCode(isPublishRest());
    return hash ^ super.hashCode();
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the classifier that the factory should publish under.
   * @return the value of the property, not null
   */
  public String getClassifier() {
    return _classifier;
  }

  /**
   * Sets the classifier that the factory should publish under.
   * @param classifier  the new value of the property, not null
   */
  public void setClassifier(String classifier) {
    JodaBeanUtils.notNull(classifier, "classifier");
    this._classifier = classifier;
  }

  /**
   * Gets the the {@code classifier} property.
   * @return the property, not null
   */
  public final Property<String> classifier() {
    return metaBean().classifier().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the flag determining whether the component should be published by REST (default true).
   * @return the value of the property
   */
  public boolean isPublishRest() {
    return _publishRest;
  }

  /**
   * Sets the flag determining whether the component should be published by REST (default true).
   * @param publishRest  the new value of the property
   */
  public void setPublishRest(boolean publishRest) {
    this._publishRest = publishRest;
  }

  /**
   * Gets the the {@code publishRest} property.
   * @return the property, not null
   */
  public final Property<Boolean> publishRest() {
    return metaBean().publishRest().createProperty(this);
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code InMemoryFunctionCostsMasterComponentFactory}.
   */
  public static class Meta extends AbstractComponentFactory.Meta {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code classifier} property.
     */
    private final MetaProperty<String> _classifier = DirectMetaProperty.ofReadWrite(
        this, "classifier", InMemoryFunctionCostsMasterComponentFactory.class, String.class);
    /**
     * The meta-property for the {@code publishRest} property.
     */
    private final MetaProperty<Boolean> _publishRest = DirectMetaProperty.ofReadWrite(
        this, "publishRest", InMemoryFunctionCostsMasterComponentFactory.class, Boolean.TYPE);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> _metaPropertyMap$ = new DirectMetaPropertyMap(
        this, (DirectMetaPropertyMap) super.metaPropertyMap(),
        "classifier",
        "publishRest");

    /**
     * Restricted constructor.
     */
    protected Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -281470431:  // classifier
          return _classifier;
        case -614707837:  // publishRest
          return _publishRest;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends InMemoryFunctionCostsMasterComponentFactory> builder() {
      return new DirectBeanBuilder<InMemoryFunctionCostsMasterComponentFactory>(new InMemoryFunctionCostsMasterComponentFactory());
    }

    @Override
    public Class<? extends InMemoryFunctionCostsMasterComponentFactory> beanType() {
      return InMemoryFunctionCostsMasterComponentFactory.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return _metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    /**
     * The meta-property for the {@code classifier} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<String> classifier() {
      return _classifier;
    }

    /**
     * The meta-property for the {@code publishRest} property.
     * @return the meta-property, not null
     */
    public final MetaProperty<Boolean> publishRest() {
      return _publishRest;
    }

  }

  ///CLOVER:ON
  //-------------------------- AUTOGENERATED END --------------------------


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c/src/java/org/apache/cassandra/cql3/KSPropDefs.java;importjava.util.*;;importorg.apache.cassandra.exceptions.*;;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.util.*;

import org.apache.cassandra.config.KSMetaData;
import org.apache.cassandra.config.ConfigurationException;
import org.apache.cassandra.thrift.InvalidRequestException;

public class KSPropDefs extends PropertyDefinitions
{
    public static final String KW_DURABLE_WRITES = "durable_writes";

    public static final String KW_REPLICATION_STRATEGY = "strategy_class";

    public static final Set<String> keywords = new HashSet<String>();
    public static final Set<String> obsoleteKeywords = new HashSet<String>();

    static
    {
        keywords.add(KW_DURABLE_WRITES);
        keywords.add(KW_REPLICATION_STRATEGY);
    }

    private String strategyClass;
    private final Map<String, String> strategyOptions = new HashMap<String, String>();

    public void validate() throws ConfigurationException, InvalidRequestException
    {
        validate(keywords, obsoleteKeywords);

        if (!properties.containsKey("strategy_class"))
            throw new InvalidRequestException("missing required argument \"strategy_class\"");
        strategyClass = properties.get("strategy_class");
    }

    @Override
    public void addProperty(String name, String value) throws InvalidRequestException
    {
        // optional
        if (name.contains(":") && name.startsWith("strategy_options"))
            strategyOptions.put(name.split(":")[1], value);
        else
            super.addProperty(name, value);
    }

    public String getReplicationStrategyClass()
    {
        return strategyClass;
    }

    public Map<String, String> getReplicationOptions()
    {
        return strategyOptions;
    }

    public KSMetaData asKSMetadata(String ksName) throws InvalidRequestException, ConfigurationException
    {
        return KSMetaData.newKeyspace(ksName, getReplicationStrategyClass(), getReplicationOptions(), getBoolean(KW_DURABLE_WRITES, true));
    }

    public KSMetaData asKSMetadataUpdate(KSMetaData old) throws InvalidRequestException, ConfigurationException
    {
        String sClass = strategyClass;
        Map<String, String> sOptions = getReplicationOptions();
        if (sClass == null)
        {
            sClass = old.strategyClass.getName();
            sOptions = old.strategyOptions;
        }
        return KSMetaData.newKeyspace(old.name, sClass, sOptions, getBoolean(KW_DURABLE_WRITES, old.durableWrites));
    }
}=======
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.util.*;

import org.apache.cassandra.config.KSMetaData;
import org.apache.cassandra.exceptions.*;

public class KSPropDefs extends PropertyDefinitions
{
    public static final String KW_DURABLE_WRITES = "durable_writes";
    public static final String KW_REPLICATION = "replication";

    public static final String REPLICATION_STRATEGY_CLASS_KEY = "class";

    public static final Set<String> keywords = new HashSet<String>();
    public static final Set<String> obsoleteKeywords = new HashSet<String>();

    static
    {
        keywords.add(KW_DURABLE_WRITES);
        keywords.add(KW_REPLICATION);

        obsoleteKeywords.add("strategy_class");
    }

    private String strategyClass;

    public void validate() throws ConfigurationException, SyntaxException
    {
        validate(keywords, obsoleteKeywords);

        Map<String, String> replicationOptions = getReplicationOptions();
        if (!replicationOptions.isEmpty())
        {
            strategyClass = replicationOptions.get(REPLICATION_STRATEGY_CLASS_KEY);
            replicationOptions.remove(REPLICATION_STRATEGY_CLASS_KEY);
        }
    }

    public Map<String, String> getReplicationOptions() throws SyntaxException
    {
        Map<String, String> replicationOptions = getMap(KW_REPLICATION);
        if (replicationOptions == null)
            return Collections.<String, String>emptyMap();
        return replicationOptions;
    }

    public String getReplicationStrategyClass()
    {
        return strategyClass;
    }

    public KSMetaData asKSMetadata(String ksName) throws RequestValidationException
    {
        return KSMetaData.newKeyspace(ksName, getReplicationStrategyClass(), getReplicationOptions(), getBoolean(KW_DURABLE_WRITES, true));
    }

    public KSMetaData asKSMetadataUpdate(KSMetaData old) throws RequestValidationException
    {
        String sClass = strategyClass;
        Map<String, String> sOptions = getReplicationOptions();
        if (sClass == null)
        {
            sClass = old.strategyClass.getName();
            sOptions = old.strategyOptions;
        }
        return KSMetaData.newKeyspace(old.name, sClass, sOptions, getBoolean(KW_DURABLE_WRITES, old.durableWrites));
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java;importorg.apache.cassandra.config.*;;importorg.apache.cassandra.exceptions.*;;
import org.apache.cassandra.config.*;
import org.apache.cassandra.db.marshal.*;
=======
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.*;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2ce7b_e863c/rev_2ce7b-e863c/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java;importorg.apache.cassandra.db.marshal.*;;importorg.apache.cassandra.exceptions.*;;
import org.apache.cassandra.config.*;
import org.apache.cassandra.db.marshal.*;
=======
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.*;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_2e1ed_53d5c/rev_2e1ed-53d5c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_2e1ed_53d5c/rev_2e1ed-53d5c/subprojects/core/src/main/groovy/org/gradle/api/internal/file/archive/ZipFileTree.java;importorg.gradle.internal.nativeplatform.FileSystem;;importorg.gradle.internal.nativeplatform.filesystem.FileSystem;;
import org.gradle.internal.nativeplatform.FileSystem;
=======
import org.gradle.internal.nativeplatform.filesystem.FileSystem;
import org.gradle.util.DeprecationLogger;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bba0_94e1a/rev_4bba0-94e1a/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration.java;importcom.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;;importcom.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.TreynorRatioPositionFunction;
=======
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMBetaModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.CAPMFromRegressionModelPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.JensenAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PortfolioEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.PositionEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.SharpeRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.StandardEquityModelFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TotalRiskAlphaPositionFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TradeEquityPnLFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPortfolioNodeFunction;
import com.opengamma.financial.analytics.model.equity.portfoliotheory.TreynorRatioPositionFunction;
import com.opengamma.financial.analytics.model.equity.variance.Grid2DInterpolatedVolatilitySurfaceFunction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Financial/src/main/java/com/opengamma/financial/marketdatasnapshot/StructuredSnapper.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.id.ExternalId;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.id.UniqueId;
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/option/callspreadblack/FXDigitalCallSpreadBlackPV01Function.java;importcom.opengamma.util.tuple.DoublesPair;;importcom.opengamma.lambdava.tuple.DoublesPair;;
import com.opengamma.util.tuple.DoublesPair;
=======
import com.opengamma.util.money.UnorderedCurrencyPair;
import com.opengamma.lambdava.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/forward/FXForwardPV01Function.java;importcom.opengamma.util.tuple.DoublesPair;;importcom.opengamma.lambdava.tuple.DoublesPair;;
import com.opengamma.util.tuple.DoublesPair;
=======
import com.opengamma.util.money.UnorderedCurrencyPair;
import com.opengamma.lambdava.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/forward/FXForwardYCNSFunction.java;importcom.opengamma.util.tuple.DoublesPair;;importcom.opengamma.lambdava.tuple.DoublesPair;;
import com.opengamma.util.tuple.DoublesPair;
=======
import com.opengamma.util.money.UnorderedCurrencyPair;
import com.opengamma.lambdava.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/cds/ISDAApproxCDSPriceFunction.java;importcom.opengamma.util.tuple.DoublesPair;;importcom.opengamma.lambdava.tuple.DoublesPair;;
import com.opengamma.util.tuple.DoublesPair;
=======
import com.opengamma.util.async.AsynchronousExecution;
import com.opengamma.lambdava.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Web/src/main/java/com/opengamma/web/analytics/PortfolioGridStructure.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.tuple.Pair;
import com.opengamma.web.analytics.blotter.BlotterColumn;
import com.opengamma.web.analytics.blotter.BlotterColumnMapper;
=======
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Engine/src/test/java/com/opengamma/engine/view/cache/WriteBehindViewComputationCacheTest.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.test.Timeout;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Engine/src/main/java/com/opengamma/engine/function/resolver/DefaultCompiledFunctionResolver.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.functional.Function2;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Engine/src/main/java/com/opengamma/engine/fudgemsg/ViewDefinitionFudgeBuilder.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.money.UnorderedCurrencyPair;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Engine/src/main/java/com/opengamma/engine/view/compilation/ViewDefinitionCompiler.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.util.ArgumentChecker;
import com.opengamma.util.monitor.OperationTimer;
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/equity/variance/pricing/VarianceSwapStaticReplication.java;importcom.opengamma.util.tuple.DoublesPair;;importcom.opengamma.lambdava.tuple.DoublesPair;;
import com.opengamma.util.ArgumentChecker;
import com.opengamma.util.tuple.DoublesPair;
=======
import com.opengamma.lambdava.tuple.DoublesPair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-BloombergExample/src/main/java/com/opengamma/bloombergexample/loader/DemoEquityOptionCollarPortfolioLoader.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.time.DateUtils;
import com.opengamma.util.tuple.Pair;
=======
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80/projects/OG-Util/src/main/java/com/opengamma/util/map/HashMap2.java;importcom.opengamma.util.tuple.Pair;;importcom.opengamma.lambdava.tuple.Pair;;
import com.opengamma.util.tuple.Pair;
=======
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.MapMaker;
import com.opengamma.lambdava.tuple.Pair;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae/projects/OG-Analytics/src/com/opengamma/financial/interestrate/AbstractInterestRateDerivativeVisitor.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ZZZForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae/projects/OG-Analytics/src/com/opengamma/financial/interestrate/InterestRateDerivativeVisitor.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ZZZForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae/projects/OG-Analytics/src/com/opengamma/financial/interestrate/PresentValueCalculator.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ZZZForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.method.ForwardRateAgreementDiscountingMethod;
import com.opengamma.financial.interestrate.future.definition.InterestRateFuture;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.ForwardRateAgreementDiscountingMethod;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InterestRateDerivativeVisitorTest.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ZZZForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5/projects/OG-Analytics/src/com/opengamma/financial/interestrate/PresentValueSensitivityCalculator.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ZZZForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.method.ForwardRateAgreementDiscountingMethod;
import com.opengamma.financial.interestrate.future.definition.BondFutureTransaction;
import com.opengamma.financial.interestrate.future.definition.InterestRateFuture;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.definition.InterestRateFutureSecurity;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_34d29_c2bdb/rev_34d29-c2bdb.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_34d29_c2bdb/rev_34d29-c2bdb/src/main/java/org/junit/rules/ExpectedException.java;importorg.junit.internal.matchers.TypeSafeMatcher;;importorg.hamcrest.TypeSafeMatcher;;
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.matchers.TypeSafeMatcher;
=======
import org.hamcrest.TypeSafeMatcher;
import org.junit.Assert;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java;importorg.apache.cassandra.avro.Mutation;;importorg.apache.cassandra.hadoop.avro.Mutation;;
import org.apache.cassandra.avro.Mutation;
import org.apache.cassandra.avro.Deletion;
import org.apache.cassandra.avro.ColumnOrSuperColumn;
=======
import org.apache.cassandra.hadoop.avro.Mutation;
import org.apache.cassandra.hadoop.avro.Deletion;
import org.apache.cassandra.hadoop.avro.ColumnOrSuperColumn;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java;importorg.apache.cassandra.avro.Deletion;;importorg.apache.cassandra.hadoop.avro.Deletion;;
import org.apache.cassandra.avro.Mutation;
import org.apache.cassandra.avro.Deletion;
import org.apache.cassandra.avro.ColumnOrSuperColumn;
=======
import org.apache.cassandra.hadoop.avro.Mutation;
import org.apache.cassandra.hadoop.avro.Deletion;
import org.apache.cassandra.hadoop.avro.ColumnOrSuperColumn;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java;importorg.apache.cassandra.avro.ColumnOrSuperColumn;;importorg.apache.cassandra.hadoop.avro.ColumnOrSuperColumn;;
import org.apache.cassandra.avro.Mutation;
import org.apache.cassandra.avro.Deletion;
import org.apache.cassandra.avro.ColumnOrSuperColumn;
=======
import org.apache.cassandra.hadoop.avro.Mutation;
import org.apache.cassandra.hadoop.avro.Deletion;
import org.apache.cassandra.hadoop.avro.ColumnOrSuperColumn;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/EventManagerTest.java;importorg.junit.Test;;importorg.testng.annotations.Test;;
package roboguice.event;

import org.easymock.EasyMock;
import org.junit.Before;
import org.junit.Test;

import android.app.Application;
import android.content.Context;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

/**
 * Test class verifying eventManager functionality
 *
 * @author John Ericksen
 */
public class EventManagerTest {

    private EventManager eventManager;
    private Context context;
    private ContextObserverTesterImpl tester;
    private List<Method> eventOneMethods;
    private List<Method> eventTwoMethods;
    private List<Method> methods;
    private EventOne event;

    @Before
    public void setup() throws NoSuchMethodException {
        eventManager = new EventManager();
        context = EasyMock.createMock(Context.class);
        tester = new ContextObserverTesterImpl();
        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
        methods = new ArrayList<Method>();
        methods.addAll(eventOneMethods);
        methods.addAll(eventTwoMethods);

        event = new EventOne();
    }

    @Test
    public void testRegistrationLifeCycle(){
        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventTwoMethods){
            eventManager.registerObserver(context, tester, method, EventTwo.class);
        }

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);

        //reset
        tester.reset();

        eventManager.unregisterObserver(context, tester, EventOne.class);
        eventManager.unregisterObserver(context, tester, EventTwo.class);

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }

    @Test
    public void testRegistrationClear(){
        Context contextTwo = EasyMock.createMock(Context.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventOneMethods){
            eventManager.registerObserver(contextTwo, tester, method, EventOne.class);
        }

        eventManager.clear(context);

        eventManager.fire(context, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);

        eventManager.fire(contextTwo, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
    }

    @Test(expected = RuntimeException.class)
    public void testApplicationContextEvent(){
        Context applicationContext = EasyMock.createMock(Application.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(applicationContext, tester, method, EventOne.class);
        }
    }
}=======
package roboguice.event;

import android.app.Application;
import android.content.Context;
import org.easymock.EasyMock;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

/**
 * @author John Ericksen
 */
public class EventManagerTest {

    private EventManager eventManager;
    private Context context;
    private ContextObserverTesterImpl tester;
    private List<Method> eventOneMethods;
    private List<Method> eventTwoMethods;
    private List<Method> methods;
    private EventOne event;

    @BeforeClass(groups = "roboguice")
    public void setup() throws NoSuchMethodException {
        eventManager = new EventManager();
        context = EasyMock.createMock(Context.class);
        tester = new ContextObserverTesterImpl();
        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
        methods = new ArrayList<Method>();
        methods.addAll(eventOneMethods);
        methods.addAll(eventTwoMethods);

        event = new EventOne();
    }

    @BeforeMethod(groups = "roboguice")
    public void reset(){
        tester.reset();
    }

    @Test(groups = "roboguice")
    public void testRegistrationLifeCycle(){
        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventTwoMethods){
            eventManager.registerObserver(context, tester, method, EventTwo.class);
        }

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);

        //reset
        tester.reset();

        eventManager.unregisterObserver(context, tester, EventOne.class);
        eventManager.unregisterObserver(context, tester, EventTwo.class);

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }

    @Test(groups = "roboguice")
    public void testRegistrationClear(){
        Context contextTwo = EasyMock.createMock(Context.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventOneMethods){
            eventManager.registerObserver(contextTwo, tester, method, EventOne.class);
        }

        eventManager.clear(context);

        eventManager.fire(context, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);

        eventManager.fire(contextTwo, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
    }

    @Test(groups = "roboguice", expectedExceptions = RuntimeException.class)
    public void testApplicationContextEvent(){
        Context applicationContext = EasyMock.createMock(Application.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(applicationContext, tester, method, EventOne.class);
        }
    }

    @Test(groups = "roboguice")
    public void testInheritanceMethodCalling() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {

        ClassOne one = new ClassOne();

        Method baseMethod = ClassTwo.class.getDeclaredMethod("bar", null);

        baseMethod.invoke(one, null);
    }

    public class ClassOne extends ClassTwo{
        public void bar(){
            System.out.println("I get called");
        }
    }

    public class ClassTwo{
        public void bar(){
            System.out.println("I don't");
        }
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java;importorg.junit.Test;;importorg.testng.annotations.Test;;
package roboguice.event;

import org.junit.Before;
import org.junit.Test;

import java.lang.reflect.Method;

import static junit.framework.Assert.assertEquals;

/**
 * Test class exercising the ObserverReferences
 *
 * @author John Ericksen
 */
public class ObserverReferenceTest {

    protected EqualityTestClass test;
    protected EqualityTestClass test2;
    protected Method methodOneBase;
    protected Method methodOne;
    protected Method methodTwoBase;
    protected Method methodTwo;


    @Before
    public void setup() throws NoSuchMethodException {
        methodOne = EqualityTestClass.class.getDeclaredMethod("one", Integer.TYPE, Character.TYPE, Boolean.TYPE);
        methodOneBase = EqualityTestOverrideClass.class.getDeclaredMethod("one", Integer.TYPE, Character.TYPE, Boolean.TYPE);
        methodTwo = EqualityTestClass.class.getDeclaredMethod("two", Object.class, String.class);
        methodTwoBase = EqualityTestOverrideClass.class.getDeclaredMethod("two", Object.class, String.class);

        test =  new EqualityTestClass();
        test2 = new EqualityTestClass();
    }

    @Test
    public void testEquality() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOneBase);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test
    public void testEqualityOfSameGuts() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenSameClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentInstances() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    public class EqualityTestClass{

        public void one(int i, char c, boolean b){}

        public void two(Object one, String two){}
    }

    public class EqualityTestOverrideClass extends EqualityTestClass{
        public void one(int i, char c, boolean b){}

        public void two(Object one, String two){}
    }
}=======
package roboguice.event;

import org.testng.annotations.Test;

import java.lang.reflect.Method;

import static org.testng.Assert.assertEquals;

/**
 * @author John Ericksen
 */
public class ObserverReferenceTest {

    @Test(groups = "roboguice")
    public void testEquality() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

     @Test(groups = "roboguice")
    public void testEqualityOfSameGuts() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenSameClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstances() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
         assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    public class EqualityTestClass{

        public void one(){}

        public void two(){}
    }

    public class EqualityTestOverrideClass extends EqualityTestClass{
        public void one(){}

        public void two(){}
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java;importstaticjunit.framework.Assert.assertEquals;;importstaticorg.testng.Assert.assertEquals;;
package roboguice.event;

import org.junit.Before;
import org.junit.Test;

import java.lang.reflect.Method;

import static junit.framework.Assert.assertEquals;

/**
 * Test class exercising the ObserverReferences
 *
 * @author John Ericksen
 */
public class ObserverReferenceTest {

    protected EqualityTestClass test;
    protected EqualityTestClass test2;
    protected Method methodOneBase;
    protected Method methodOne;
    protected Method methodTwoBase;
    protected Method methodTwo;


    @Before
    public void setup() throws NoSuchMethodException {
        methodOne = EqualityTestClass.class.getDeclaredMethod("one", Integer.TYPE, Character.TYPE, Boolean.TYPE);
        methodOneBase = EqualityTestOverrideClass.class.getDeclaredMethod("one", Integer.TYPE, Character.TYPE, Boolean.TYPE);
        methodTwo = EqualityTestClass.class.getDeclaredMethod("two", Object.class, String.class);
        methodTwoBase = EqualityTestOverrideClass.class.getDeclaredMethod("two", Object.class, String.class);

        test =  new EqualityTestClass();
        test2 = new EqualityTestClass();
    }

    @Test
    public void testEquality() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOneBase);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test
    public void testEqualityOfSameGuts() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenSameClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentInstances() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    public class EqualityTestClass{

        public void one(int i, char c, boolean b){}

        public void two(Object one, String two){}
    }

    public class EqualityTestOverrideClass extends EqualityTestClass{
        public void one(int i, char c, boolean b){}

        public void two(Object one, String two){}
    }
}=======
package roboguice.event;

import org.testng.annotations.Test;

import java.lang.reflect.Method;

import static org.testng.Assert.assertEquals;

/**
 * @author John Ericksen
 */
public class ObserverReferenceTest {

    @Test(groups = "roboguice")
    public void testEquality() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

     @Test(groups = "roboguice")
    public void testEqualityOfSameGuts() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenSameClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstances() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    @Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
         assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }

    public class EqualityTestClass{

        public void one(){}

        public void two(){}
    }

    public class EqualityTestOverrideClass extends EqualityTestClass{
        public void one(){}

        public void two(){}
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObservesTypeListenerTest.java;importorg.junit.Test;;importorg.testng.annotations.Test;;
package roboguice.event;

import org.easymock.EasyMock;
import org.junit.Before;
import org.junit.Test;
import roboguice.config.EventManagerModule;

import android.content.Context;

import com.google.inject.*;

import java.lang.reflect.Method;
import java.util.List;

/**
 * @author John Ericksen
 */
public class ObservesTypeListenerTest {

    private EventManager eventManager;
    private Provider<Context> contextProvider;
    private Context context;
    private Injector injector;
    private List<Method> eventOneMethods;
    private List<Method> eventTwoMethods;

    @Before
    public void setup() throws NoSuchMethodException {
        context = EasyMock.createMock(Context.class);
        
        contextProvider = new Provider<Context>() {
            public Context get() {
                return context;
            }
        };

        Module eventManagerModule = new EventManagerModule(new EventManager(), contextProvider);

        Module contextProviderModule = new AbstractModule() {
            public void configure() {
                bind(Context.class).toProvider(contextProvider);
            }
        };

        injector = Guice.createInjector(eventManagerModule, contextProviderModule);

        eventManager = injector.getInstance(EventManager.class);

        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
    }

    @Test
    public void simulateInjection() {
        InjectedTestClass testClass = new InjectedTestClass();
        injector.injectMembers(testClass);

        eventManager.fire(new EventOne());

        testClass.getTester().verifyCallCount(eventOneMethods, EventOne.class, 1);
        testClass.getTester().verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }

    @Test(expected = RuntimeException.class)
    public void invalidObservesMethodSignature(){
        injector.getInstance(MalformedObserves.class);
    }

    public class InjectedTestClass{
        @Inject
        public ContextObserverTesterImpl tester;

        public ContextObserverTesterImpl getTester() {
            return tester;
        }
    }

    public class MalformedObserves{
        public void malformedObserves(int val, @Observes EventOne event){}
    }
}=======
package roboguice.event;

import org.easymock.EasyMock;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import android.content.Context;

import com.google.inject.*;
import com.google.inject.matcher.Matchers;

import java.lang.reflect.Method;
import java.util.List;

/**
 * @author John Ericksen
 */
public class ObservesTypeListenerTest {

    private EventManager contextAwareEventManager;
    private Provider<Context> contextProvider;
    private Context context;
    private Injector injector;
    private List<Method> eventOneMethods;
    private List<Method> eventTwoMethods;

    @BeforeClass(groups = "roboguice")
    public void setup() throws NoSuchMethodException {
        context = EasyMock.createMock(Context.class);

        contextAwareEventManager = new EventManager();

        contextProvider = new Provider<Context>() {
            public Context get() {
                return context;
            }
        };

        Module eventManagerModule = new EventManagerModule(new EventManager(), contextProvider);

        Module contextProviderModule = new AbstractModule() {
            public void configure() {
                bind(Context.class).toProvider(contextProvider);
            }
        };

        injector = Guice.createInjector(eventManagerModule, contextProviderModule);
        injector.injectMembers(contextAwareEventManager);

        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
    }

    @Test(groups = "roboguice")
    public void simulateInjection() {
        InjectedTestClass testClass = new InjectedTestClass();
        injector.injectMembers(testClass);

        contextAwareEventManager.fire(new EventOne());

        testClass.getTester().verifyCallCount(eventOneMethods, EventOne.class, 1);
        testClass.getTester().verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }

    @Test(groups = "roboguice", expectedExceptions = RuntimeException.class)
    public void invalidObservesMethodSignature(){
        MalformedObserves testClass = new MalformedObserves();

        injector.injectMembers(testClass);
    }

    public class InjectedTestClass{
        @Inject
        public ContextObserverTesterImpl tester;

        public ContextObserverTesterImpl getTester() {
            return tester;
        }
    }

    public class MalformedObserves{
        public void malformedObserves(int val, @Observes EventOne event){}
    }
}


class EventManagerModule extends AbstractModule {

    protected EventManager eventManager;
    protected Provider<Context> contextProvider;

    public EventManagerModule(EventManager eventManager, Provider<Context> contextProvider) {
        this.eventManager = eventManager;
        this.contextProvider = contextProvider;
    }

    @Override
    protected void configure() {

        // Context observers
        bind(EventManager.class).toInstance(eventManager);

        if (eventManager.isEnabled())
            bindListener(Matchers.any(), new ObservesTypeListener(contextProvider, eventManager));

        requestInjection(eventManager);
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ContextObserverBase.java;importstaticorg.junit.Assert.assertEquals;;importstaticorg.testng.Assert.assertEquals;;
package roboguice.event;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/**
 * Base Context Observer testing class exercising the various implementation combinations.
 *
 * @author John Ericksen
 */
public class ContextObserverBase {

    private Map<String, Map<Class<?>, Integer>> callCount = new HashMap<String, Map<Class<?>, Integer>>();

    public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){

            assertTrue("Method: " + method.getName() + " was not called.",
                    callCount.containsKey(method.getName()) || expectedCount == 0);

            if(callCount.containsKey(method.getName())){

            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());

                if(expectedCount > 0){

                    assertTrue("Event: " + event.getName() + " was not observed.",
                            callCountClass.containsKey(event) || expectedCount == 0);

                    if(callCountClass.containsKey(event)){
                        assertEquals(
                                "Call count was not expected",
                                callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }

    public void reset() {
        for(Map.Entry<String, Map<Class<?>, Integer>> callCountEntry : callCount.entrySet()){
            for(Map.Entry<Class<?>, Integer> callCountClassEntry : callCountEntry.getValue().entrySet()){
                callCountClassEntry.setValue(0);
            }
        }
    }

    public static final String[] methods = {
        "baseObservesEvent",
        "baseObservesProtectedEvent",
        "baseObservesPackagePrivateEvent",
        "baseObservesPrivateEvent",
    };

    public static final String OVERLOADED_METHOD = "baseObservesOverloadedEvent";

    public void baseObservesEvent(@Observes EventOne event){
        triggerCalled(methods[0], EventOne.class);
    }

    public void baseObservesEvent(@Observes EventTwo event){
        triggerCalled(methods[0], EventTwo.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventOne event){
        triggerCalled(methods[1], EventOne.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventTwo event){
        triggerCalled(methods[1], EventTwo.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(methods[2], EventOne.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[2], EventTwo.class);
    }

    private void baseObservesPrivateEvent(@Observes EventOne event){
        triggerCalled(methods[3], EventOne.class);
    }

    private void baseObservesPrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[3], EventTwo.class);
    }

    public void observesOverloadedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    public void observesOverloadedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    public void triggerCalled(String method, Class eventClass) {
        if(!callCount.containsKey(method)){
            callCount.put(method, new HashMap<Class<?>, Integer>());
        }
        Map<Class<?>, Integer> callCountClass = callCount.get(method);

        if(!callCountClass.containsKey(eventClass)){
            callCountClass.put(eventClass, 0);
        }
        callCountClass.put(eventClass, callCountClass.get(eventClass) + 1);
    }

    public static List<Method> getMethods(Class<?> eventClass) throws NoSuchMethodException {
        List<Method> methodList = new ArrayList<Method>();

        for(String method : ContextObserverBase.methods){
            methodList.add(ContextObserverBase.class.getDeclaredMethod(method, eventClass));
        }

        return methodList;
    }
}=======
package roboguice.event;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;

/**
 * @author John Ericksen
 */
public class ContextObserverBase {

    private Map<String, Map<Class<?>, Integer>> callCount = new HashMap<String, Map<Class<?>, Integer>>();

    public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){
            assertTrue(callCount.containsKey(method.getName()) || expectedCount == 0);
            if(callCount.containsKey(method.getName())){
            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());
                if(expectedCount > 0){
                    assertTrue(callCountClass.containsKey(event) || expectedCount == 0);
                    if(callCountClass.containsKey(event)){
                        assertEquals(callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }

    public void reset() {
        for(Map.Entry<String, Map<Class<?>, Integer>> callCountEntry : callCount.entrySet()){
            for(Map.Entry<Class<?>, Integer> callCountClassEntry : callCountEntry.getValue().entrySet()){
                callCountClassEntry.setValue(0);
            }
        }
    }

    public static final String[] methods = {
        "baseObservesEvent",
        "baseObservesProtectedEvent",
        "baseObservesPackagePrivateEvent",
        "baseObservesPrivateEvent",
    };

    public static final String OVERLOADED_METHOD = "baseObservesOverloadedEvent";

    public void baseObservesEvent(@Observes EventOne event){
        triggerCalled(methods[0], EventOne.class);
    }

    public void baseObservesEvent(@Observes EventTwo event){
        triggerCalled(methods[0], EventTwo.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventOne event){
        triggerCalled(methods[1], EventOne.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventTwo event){
        triggerCalled(methods[1], EventTwo.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(methods[2], EventOne.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[2], EventTwo.class);
    }

    private void baseObservesPrivateEvent(@Observes EventOne event){
        triggerCalled(methods[3], EventOne.class);
    }

    private void baseObservesPrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[3], EventTwo.class);
    }

    public void observesOverloadedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    public void observesOverloadedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    public void triggerCalled(String method, Class eventClass) {
        if(!callCount.containsKey(method)){
            callCount.put(method, new HashMap<Class<?>, Integer>());
        }
        Map<Class<?>, Integer> callCountClass = callCount.get(method);

        if(!callCountClass.containsKey(eventClass)){
            callCountClass.put(eventClass, 0);
        }
        callCountClass.put(eventClass, callCountClass.get(eventClass) + 1);
    }

    public static List<Method> getMethods(Class<?> eventClass) throws NoSuchMethodException {
        List<Method> methodList = new ArrayList<Method>();

        for(String method : ContextObserverBase.methods){
            methodList.add(ContextObserverBase.class.getDeclaredMethod(method, eventClass));
        }

        return methodList;
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ContextObserverBase.java;importstaticorg.junit.Assert.assertTrue;;importstaticorg.testng.Assert.assertTrue;;
package roboguice.event;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/**
 * Base Context Observer testing class exercising the various implementation combinations.
 *
 * @author John Ericksen
 */
public class ContextObserverBase {

    private Map<String, Map<Class<?>, Integer>> callCount = new HashMap<String, Map<Class<?>, Integer>>();

    public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){

            assertTrue("Method: " + method.getName() + " was not called.",
                    callCount.containsKey(method.getName()) || expectedCount == 0);

            if(callCount.containsKey(method.getName())){

            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());

                if(expectedCount > 0){

                    assertTrue("Event: " + event.getName() + " was not observed.",
                            callCountClass.containsKey(event) || expectedCount == 0);

                    if(callCountClass.containsKey(event)){
                        assertEquals(
                                "Call count was not expected",
                                callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }

    public void reset() {
        for(Map.Entry<String, Map<Class<?>, Integer>> callCountEntry : callCount.entrySet()){
            for(Map.Entry<Class<?>, Integer> callCountClassEntry : callCountEntry.getValue().entrySet()){
                callCountClassEntry.setValue(0);
            }
        }
    }

    public static final String[] methods = {
        "baseObservesEvent",
        "baseObservesProtectedEvent",
        "baseObservesPackagePrivateEvent",
        "baseObservesPrivateEvent",
    };

    public static final String OVERLOADED_METHOD = "baseObservesOverloadedEvent";

    public void baseObservesEvent(@Observes EventOne event){
        triggerCalled(methods[0], EventOne.class);
    }

    public void baseObservesEvent(@Observes EventTwo event){
        triggerCalled(methods[0], EventTwo.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventOne event){
        triggerCalled(methods[1], EventOne.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventTwo event){
        triggerCalled(methods[1], EventTwo.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(methods[2], EventOne.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[2], EventTwo.class);
    }

    private void baseObservesPrivateEvent(@Observes EventOne event){
        triggerCalled(methods[3], EventOne.class);
    }

    private void baseObservesPrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[3], EventTwo.class);
    }

    public void observesOverloadedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    public void observesOverloadedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    public void triggerCalled(String method, Class eventClass) {
        if(!callCount.containsKey(method)){
            callCount.put(method, new HashMap<Class<?>, Integer>());
        }
        Map<Class<?>, Integer> callCountClass = callCount.get(method);

        if(!callCountClass.containsKey(eventClass)){
            callCountClass.put(eventClass, 0);
        }
        callCountClass.put(eventClass, callCountClass.get(eventClass) + 1);
    }

    public static List<Method> getMethods(Class<?> eventClass) throws NoSuchMethodException {
        List<Method> methodList = new ArrayList<Method>();

        for(String method : ContextObserverBase.methods){
            methodList.add(ContextObserverBase.class.getDeclaredMethod(method, eventClass));
        }

        return methodList;
    }
}=======
package roboguice.event;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;

/**
 * @author John Ericksen
 */
public class ContextObserverBase {

    private Map<String, Map<Class<?>, Integer>> callCount = new HashMap<String, Map<Class<?>, Integer>>();

    public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){
            assertTrue(callCount.containsKey(method.getName()) || expectedCount == 0);
            if(callCount.containsKey(method.getName())){
            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());
                if(expectedCount > 0){
                    assertTrue(callCountClass.containsKey(event) || expectedCount == 0);
                    if(callCountClass.containsKey(event)){
                        assertEquals(callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }

    public void reset() {
        for(Map.Entry<String, Map<Class<?>, Integer>> callCountEntry : callCount.entrySet()){
            for(Map.Entry<Class<?>, Integer> callCountClassEntry : callCountEntry.getValue().entrySet()){
                callCountClassEntry.setValue(0);
            }
        }
    }

    public static final String[] methods = {
        "baseObservesEvent",
        "baseObservesProtectedEvent",
        "baseObservesPackagePrivateEvent",
        "baseObservesPrivateEvent",
    };

    public static final String OVERLOADED_METHOD = "baseObservesOverloadedEvent";

    public void baseObservesEvent(@Observes EventOne event){
        triggerCalled(methods[0], EventOne.class);
    }

    public void baseObservesEvent(@Observes EventTwo event){
        triggerCalled(methods[0], EventTwo.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventOne event){
        triggerCalled(methods[1], EventOne.class);
    }

    protected void baseObservesProtectedEvent(@Observes EventTwo event){
        triggerCalled(methods[1], EventTwo.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(methods[2], EventOne.class);
    }

    void baseObservesPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[2], EventTwo.class);
    }

    private void baseObservesPrivateEvent(@Observes EventOne event){
        triggerCalled(methods[3], EventOne.class);
    }

    private void baseObservesPrivateEvent(@Observes EventTwo event){
        triggerCalled(methods[3], EventTwo.class);
    }

    public void observesOverloadedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    public void observesOverloadedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    protected void observesOverloadedProtectedEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventOne event){
        triggerCalled(OVERLOADED_METHOD, EventOne.class);
    }

    void observesOverloadedPackagePrivateEvent(@Observes EventTwo event){
        triggerCalled(OVERLOADED_METHOD, EventTwo.class);
    }

    public void triggerCalled(String method, Class eventClass) {
        if(!callCount.containsKey(method)){
            callCount.put(method, new HashMap<Class<?>, Integer>());
        }
        Map<Class<?>, Integer> callCountClass = callCount.get(method);

        if(!callCountClass.containsKey(eventClass)){
            callCountClass.put(eventClass, 0);
        }
        callCountClass.put(eventClass, callCountClass.get(eventClass) + 1);
    }

    public static List<Method> getMethods(Class<?> eventClass) throws NoSuchMethodException {
        List<Method> methodList = new ArrayList<Method>();

        for(String method : ContextObserverBase.methods){
            methodList.add(ContextObserverBase.class.getDeclaredMethod(method, eventClass));
        }

        return methodList;
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_323ee_b3deb/rev_323ee-b3deb.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_323ee_b3deb/rev_323ee-b3deb/src/java/org/apache/cassandra/hadoop/streaming/AvroOutputReader.java;importorg.apache.cassandra.avro.Mutation;;importorg.apache.cassandra.hadoop.avro.Mutation;;
import org.apache.cassandra.avro.Mutation;
import org.apache.cassandra.avro.StreamingMutation;
import org.apache.cassandra.io.util.FileUtils;
=======
import org.apache.cassandra.hadoop.avro.Mutation;
import org.apache.cassandra.hadoop.avro.StreamingMutation;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_323ee_b3deb/rev_323ee-b3deb.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_323ee_b3deb/rev_323ee-b3deb/src/java/org/apache/cassandra/hadoop/streaming/AvroOutputReader.java;importorg.apache.cassandra.avro.StreamingMutation;;importorg.apache.cassandra.hadoop.avro.StreamingMutation;;
import org.apache.cassandra.avro.Mutation;
import org.apache.cassandra.avro.StreamingMutation;
import org.apache.cassandra.io.util.FileUtils;
=======
import org.apache.cassandra.hadoop.avro.Mutation;
import org.apache.cassandra.hadoop.avro.StreamingMutation;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f/projects/OG-Analytics/src/com/opengamma/financial/interestrate/AbstractInterestRateDerivativeVisitor.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.ZZZForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureTransaction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f/projects/OG-Analytics/src/com/opengamma/financial/interestrate/PresentValueSensitivityCalculator.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.definition.InterestRateFuture;
import com.opengamma.financial.interestrate.future.definition.InterestRateFutureTransaction;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureTransaction;
import com.opengamma.financial.interestrate.future.method.InterestRateFutureSecurityDiscountingMethod;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f/projects/OG-Analytics/src/com/opengamma/financial/interestrate/InterestRateDerivativeVisitor.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.ZZZForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureTransaction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f/projects/OG-Analytics/src/com/opengamma/financial/interestrate/ParRateCalculator.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.definition.InterestRateFuture;
import com.opengamma.financial.interestrate.future.definition.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.definition.InterestRateFutureTransaction;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.ForwardRateAgreementDiscountingMethod;
import com.opengamma.financial.interestrate.future.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureTransaction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_635a1_7986f/rev_635a1-7986f/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InterestRateDerivativeVisitorTest.java;importcom.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;;importcom.opengamma.financial.interestrate.fra.ForwardRateAgreement;;
import com.opengamma.financial.interestrate.fra.ZZZForwardRateAgreement;
import com.opengamma.financial.interestrate.fra.definition.ForwardRateAgreement;
=======
import com.opengamma.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionMarginTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureOptionPremiumTransaction;
import com.opengamma.financial.interestrate.future.InterestRateFutureSecurity;
import com.opengamma.financial.interestrate.future.InterestRateFutureTransaction;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_828f2_bbead/rev_828f2-bbead.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_828f2_bbead/rev_828f2-bbead/subprojects/plugins/src/main/groovy/org/gradle/api/tasks/compile/Compile.java;importorg.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoExtractor;;importorg.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoExtractor;;
import org.gradle.api.internal.tasks.compile.incremental.*;
import org.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoExtractor;
import org.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoSerializer;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
=======
import org.gradle.api.internal.tasks.compile.incremental.CompilationSourceDirs;
import org.gradle.api.internal.tasks.compile.incremental.IncrementalCompilationSupport;
import org.gradle.api.internal.tasks.compile.incremental.SourceToNameConverter;
import org.gradle.api.internal.tasks.compile.incremental.analyzer.ClassDependenciesAnalyzer;
import org.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoExtractor;
import org.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoSerializer;
import org.gradle.api.internal.tasks.compile.incremental.jar.ClassSnapshotter;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotCache;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotFeeder;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotter;
import org.gradle.api.internal.tasks.compile.incremental.recomp.RecompilationSpecProvider;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_828f2_bbead/rev_828f2-bbead.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_828f2_bbead/rev_828f2-bbead/subprojects/plugins/src/main/groovy/org/gradle/api/tasks/compile/Compile.java;importorg.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoSerializer;;importorg.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoSerializer;;
import org.gradle.api.internal.tasks.compile.incremental.*;
import org.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoExtractor;
import org.gradle.api.internal.tasks.compile.incremental.graph.ClassDependencyInfoSerializer;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
=======
import org.gradle.api.internal.tasks.compile.incremental.CompilationSourceDirs;
import org.gradle.api.internal.tasks.compile.incremental.IncrementalCompilationSupport;
import org.gradle.api.internal.tasks.compile.incremental.SourceToNameConverter;
import org.gradle.api.internal.tasks.compile.incremental.analyzer.ClassDependenciesAnalyzer;
import org.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoExtractor;
import org.gradle.api.internal.tasks.compile.incremental.deps.ClassDependencyInfoSerializer;
import org.gradle.api.internal.tasks.compile.incremental.jar.ClassSnapshotter;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotCache;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotFeeder;
import org.gradle.api.internal.tasks.compile.incremental.jar.JarSnapshotter;
import org.gradle.api.internal.tasks.compile.incremental.recomp.RecompilationSpecProvider;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_988c4_738bd/rev_988c4-738bd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_988c4_738bd/rev_988c4-738bd/src/java/org/apache/cassandra/dht/BootStrapper.java;importjava.util.*;;importorg.apache.cassandra.net.*;;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;

 import com.google.common.base.Charsets;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.gms.*;

 import org.apache.commons.lang.ArrayUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.net.IAsyncCallback;
 import org.apache.cassandra.net.IVerbHandler;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.streaming.OperationType;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.SimpleCondition;

=======
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.net.InetAddress;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.ConfigurationException;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.Table;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.TokenMetadata;
import org.apache.cassandra.net.*;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.streaming.OperationType;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.SimpleCondition;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_988c4_738bd/rev_988c4-738bd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_988c4_738bd/rev_988c4-738bd/src/java/org/apache/cassandra/dht/BootStrapper.java;importorg.apache.cassandra.gms.*;;importorg.apache.cassandra.net.*;;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;

 import com.google.common.base.Charsets;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.gms.*;

 import org.apache.commons.lang.ArrayUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.net.IAsyncCallback;
 import org.apache.cassandra.net.IVerbHandler;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.streaming.OperationType;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.SimpleCondition;

=======
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.net.InetAddress;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.ConfigurationException;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.Table;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.TokenMetadata;
import org.apache.cassandra.net.*;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.streaming.OperationType;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.SimpleCondition;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4925f_b2d66/rev_4925f-b2d66.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4925f_b2d66/rev_4925f-b2d66/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/credit/isdayieldcurve/ISDAYieldCurve.java;importjavax.time.calendar.ZonedDateTime;;importorg.threeten.bp.ZonedDateTime;;
import java.util.Calendar;

import javax.time.calendar.ZonedDateTime;
=======
import org.threeten.bp.ZonedDateTime;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/loader/DemoEquityOptionCollarPortfolioLoader.java;importcom.opengamma.bbg.ReferenceDataProvider;;importcom.opengamma.bbg.referencedata.ReferenceDataProvider;;
import com.opengamma.bbg.PerSecurityReferenceDataResult;
import com.opengamma.bbg.ReferenceDataProvider;
import com.opengamma.bbg.ReferenceDataResult;
=======
import com.opengamma.bbg.referencedata.ReferenceDataProvider;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/component/ExampleToolContextComponentFactory.java;importcom.opengamma.bbg.ReferenceDataProvider;;importcom.opengamma.bbg.referencedata.ReferenceDataProvider;;
import com.opengamma.bbg.BloombergSecuritySource;
import com.opengamma.bbg.ReferenceDataProvider;
=======
import com.opengamma.bbg.referencedata.ReferenceDataProvider;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_28938_8d783/rev_28938-8d783.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_28938_8d783/rev_28938-8d783/src/main/java/org/junit/matchers/JUnitMatchers.java;importorg.junit.internal.matchers.CombinableMatcher;;importorg.hamcrest.core.CombinableMatcher;;
import org.junit.internal.matchers.CombinableMatcher;
import org.junit.internal.matchers.Each;
import org.junit.internal.matchers.IsCollectionContaining;
import org.junit.internal.matchers.StringContains;
import org.junit.internal.matchers.CauseMatcher;
=======
import org.hamcrest.core.CombinableMatcher;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/equity/varianceswap/EquityVarianceSwapFunction.java;importcom.opengamma.engine.ComputationTargetType;;importcom.opengamma.engine.target.ComputationTargetType;;
import java.util.Collections;
import java.util.Set;

import com.google.common.collect.Sets;
import com.opengamma.OpenGammaRuntimeException;
import com.opengamma.analytics.financial.model.interestrate.curve.ForwardCurve;
import com.opengamma.analytics.financial.model.volatility.smile.fitting.sabr.SmileSurfaceDataBundle;
import com.opengamma.core.holiday.HolidaySource;
import com.opengamma.core.id.ExternalSchemes;
import com.opengamma.core.marketdatasnapshot.VolatilitySurfaceData;
import com.opengamma.core.value.MarketDataRequirementNames;
import com.opengamma.engine.ComputationTarget;
import com.opengamma.engine.ComputationTargetType;
import com.opengamma.engine.function.AbstractFunction;
import com.opengamma.engine.function.FunctionCompilationContext;
import com.opengamma.engine.function.FunctionInputs;
import com.opengamma.engine.value.ValueProperties;
import com.opengamma.engine.value.ValuePropertyNames;
import com.opengamma.engine.value.ValueRequirement;
import com.opengamma.engine.value.ValueRequirementNames;
import com.opengamma.engine.value.ValueSpecification;
import com.opengamma.financial.OpenGammaCompilationContext;
import com.opengamma.financial.analytics.conversion.EquityVarianceSwapConverter;
import com.opengamma.financial.analytics.model.InstrumentTypeProperties;
import com.opengamma.financial.analytics.model.volatility.local.PDEPropertyNamesAndValues;
import com.opengamma.financial.analytics.model.volatility.surface.black.BlackVolatilitySurfaceUtils;
import com.opengamma.financial.analytics.timeseries.DateConstraint;
import com.opengamma.financial.analytics.timeseries.HistoricalTimeSeriesFunctionUtils;
import com.opengamma.financial.security.FinancialSecurityUtils;
import com.opengamma.financial.security.equity.EquityVarianceSwapSecurity;
import com.opengamma.id.ExternalId;
import com.opengamma.id.UniqueId;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolutionResult;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolver;
import com.opengamma.util.money.Currency;

=======
import java.util.Set;

import javax.time.calendar.Clock;
import javax.time.calendar.ZonedDateTime;

import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.opengamma.OpenGammaRuntimeException;
import com.opengamma.analytics.financial.equity.StaticReplicationDataBundle;
import com.opengamma.analytics.financial.instrument.varianceswap.VarianceSwapDefinition;
import com.opengamma.analytics.financial.model.interestrate.curve.ForwardCurve;
import com.opengamma.analytics.financial.model.interestrate.curve.YieldCurve;
import com.opengamma.analytics.financial.model.volatility.surface.BlackVolatilitySurface;
import com.opengamma.analytics.financial.model.volatility.surface.BlackVolatilitySurfaceStrike;
import com.opengamma.analytics.financial.model.volatility.surface.VolatilitySurface;
import com.opengamma.analytics.financial.varianceswap.VarianceSwap;
import com.opengamma.analytics.util.time.TimeCalculator;
import com.opengamma.core.historicaltimeseries.HistoricalTimeSeries;
import com.opengamma.core.holiday.HolidaySource;
import com.opengamma.core.id.ExternalSchemes;
import com.opengamma.core.value.MarketDataRequirementNames;
import com.opengamma.engine.ComputationTarget;
import com.opengamma.engine.ComputationTargetSpecification;
import com.opengamma.engine.function.AbstractFunction;
import com.opengamma.engine.function.FunctionCompilationContext;
import com.opengamma.engine.function.FunctionExecutionContext;
import com.opengamma.engine.function.FunctionInputs;
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ComputedValue;
import com.opengamma.engine.value.ValueProperties;
import com.opengamma.engine.value.ValuePropertyNames;
import com.opengamma.engine.value.ValueRequirement;
import com.opengamma.engine.value.ValueRequirementNames;
import com.opengamma.engine.value.ValueSpecification;
import com.opengamma.financial.OpenGammaCompilationContext;
import com.opengamma.financial.analytics.conversion.EquityVarianceSwapConverter;
import com.opengamma.financial.analytics.model.InstrumentTypeProperties;
import com.opengamma.financial.analytics.timeseries.DateConstraint;
import com.opengamma.financial.analytics.timeseries.HistoricalTimeSeriesFunctionUtils;
import com.opengamma.financial.security.FinancialSecurityTypes;
import com.opengamma.financial.security.equity.EquityVarianceSwapSecurity;
import com.opengamma.id.ExternalId;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolutionResult;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolver;
import com.opengamma.util.ArgumentChecker;



/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22/projects/OG-Web/src/main/java/com/opengamma/web/analytics/PortfolioGridViewport.java;importcom.opengamma.engine.ComputationTargetType;;importcom.opengamma.engine.target.ComputationTargetType;;
import com.opengamma.engine.ComputationTargetType;
import com.opengamma.engine.view.calc.ViewCycle;
=======
import com.opengamma.engine.target.ComputationTargetType;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ac1d7_b505b/rev_ac1d7-b505b.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ac1d7_b505b/rev_ac1d7-b505b/test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java;importstaticorg.apache.cassandra.service.AntiEntropyService.*;;importstaticorg.apache.cassandra.service.ActiveRepairService.*;;
import static org.apache.cassandra.service.AntiEntropyService.*;

import org.apache.cassandra.net.MessagingService;
=======
import static org.apache.cassandra.service.ActiveRepairService.*;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_b2d48_f592c/rev_b2d48-f592c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_b2d48_f592c/rev_b2d48-f592c/lucene/src/test/org/apache/lucene/index/TestIndexWriterConfig.java;importorg.apache.lucene.index.DocumentsWriter.IndexingChain;;importorg.apache.lucene.index.DocumentsWriterPerThread.IndexingChain;;
import org.apache.lucene.index.DocumentsWriter.IndexingChain;
=======
import org.apache.lucene.index.DocumentsWriterPerThread.IndexingChain;
import org.apache.lucene.index.IndexWriter.IndexReaderWarmer;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b5ad0_383c9/rev_b5ad0-383c9.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b5ad0_383c9/rev_b5ad0-383c9/projects/OG-Analytics/src/com/opengamma/financial/interestrate/ParRateCurveSensitivityCalculator.java;importstaticcom.opengamma.financial.interestrate.PresentValueSensitivityUtils.*;;importstaticcom.opengamma.financial.interestrate.InterestRateCurveSensitivityUtils.*;;
import static com.opengamma.financial.interestrate.PresentValueSensitivityUtils.*;
=======
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.Validate;
import static com.opengamma.financial.interestrate.InterestRateCurveSensitivityUtils.*;



/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b5ad0_383c9/rev_b5ad0-383c9.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b5ad0_383c9/rev_b5ad0-383c9/projects/OG-Analytics/src/com/opengamma/financial/interestrate/PresentValueSensitivityCalculator.java;importstaticcom.opengamma.financial.interestrate.PresentValueSensitivityUtils.*;;importstaticcom.opengamma.financial.interestrate.InterestRateCurveSensitivityUtils.*;;
import static com.opengamma.financial.interestrate.PresentValueSensitivityUtils.*;
=======
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import static com.opengamma.financial.interestrate.InterestRateCurveSensitivityUtils.*;

import org.apache.commons.lang.Validate;



/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bbc88_67f2c/rev_bbc88-67f2c.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bbc88_67f2c/rev_bbc88-67f2c/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/LastTimeCalculator.java;importcom.opengamma.analytics.financial.interestrate.fra.ForwardRateAgreement;;importcom.opengamma.analytics.financial.interestrate.fra.derivative.ForwardRateAgreement;;
import com.opengamma.analytics.financial.interestrate.fra.ForwardRateAgreement;
import com.opengamma.analytics.financial.interestrate.future.derivative.BondFutureOptionPremiumSecurity;
import com.opengamma.analytics.financial.interestrate.future.derivative.BondFutureOptionPremiumTransaction;
=======
import com.opengamma.analytics.financial.interestrate.fra.derivative.ForwardRateAgreement;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bf8c1_62b1e/rev_bf8c1-62b1e.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bf8c1_62b1e/rev_bf8c1-62b1e/test/unit/org/apache/cassandra/service/StorageServiceServerTest.java;importorg.apache.cassandra.config.ConfigurationException;;importorg.apache.cassandra.exceptions.ConfigurationException;;
import org.apache.cassandra.OrderedJUnit4ClassRunner;
import org.apache.cassandra.config.ConfigurationException;
=======
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.db.Table;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0302_50069/rev_c0302-50069.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0302_50069/rev_c0302-50069/src/com/opengamma/financial/analytics/model/equity/StandardEquityModelFunction.java;importcom.opengamma.financial.security.EquitySecurity;;importcom.opengamma.financial.security.equity.EquitySecurity;;
import com.opengamma.financial.security.EquitySecurity;
import com.opengamma.livedata.normalization.MarketDataRequirementNames;
=======
import com.opengamma.financial.security.equity.EquitySecurity;
import com.opengamma.livedata.normalization.MarketDataFieldNames;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/admin/CoordinatorAdminRequestHandler.java;importjava.io.ByteArrayOutputStream;;importorg.apache.commons.io.output.ByteArrayOutputStream;;
/*
 * Copyright 2013 LinkedIn, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.rest.coordinator.admin;

import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONTENT_LENGTH;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.NO_CONTENT;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.OK;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import org.apache.log4j.Logger;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpChunk;
import org.jboss.netty.handler.codec.http.HttpMethod;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponse;

import voldemort.rest.RestErrorHandler;
import voldemort.rest.RestMessageHeaders;

public class CoordinatorAdminRequestHandler extends SimpleChannelHandler {

    public HttpRequest request;
    private boolean readingChunks;
    private final Logger logger = Logger.getLogger(CoordinatorAdminRequestHandler.class);

    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {
        // TODO handle message here. Depending on the type of request, different handlers will be called.
        // This is just for testing purposes.
        sendResponse(messageEvent);
    }

    public void sendResponse(MessageEvent messageEvent) {
        // TODO Remove the code below with actual code for the response. This was for testing purposes.
        // Fill in the actual response that you want to send.
        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
        response.setHeader(CONTENT_LENGTH, "4");
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            outputStream.write("allo".getBytes());
        } catch (IOException e) {
        e.printStackTrace(); //To change body of catch statement use File | Settings | File Templates.
        }
        ChannelBuffer responseContent = ChannelBuffers.dynamicBuffer();
        responseContent.writeBytes(outputStream.toByteArray());
        response.setContent(responseContent);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}=======
/*
 * Copyright 2013 LinkedIn, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.rest.coordinator.admin;

import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONTENT_LENGTH;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.NO_CONTENT;
import static org.jboss.netty.handler.codec.http.HttpResponseStatus.OK;
import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;

import org.apache.commons.io.output.ByteArrayOutputStream;
import org.apache.log4j.Logger;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpChunk;
import org.jboss.netty.handler.codec.http.HttpMethod;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponse;

import voldemort.rest.RestErrorHandler;
import voldemort.rest.RestMessageHeaders;

import java.io.IOException;

public class CoordinatorAdminRequestHandler extends SimpleChannelHandler {

    public HttpRequest request;
    private boolean readingChunks;
    private final Logger logger = Logger.getLogger(CoordinatorAdminRequestHandler.class);

    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {
        logger.info("messageReceived!! (omg)");
        sendResponse(messageEvent);
//        if (!readingChunks) {
//            HttpRequest request = this.request = (HttpRequest) messageEvent.getMessage();
//            String requestURI = this.request.getUri();
//            if (logger.isDebugEnabled()) {
//                logger.debug("Request URI: " + requestURI);
//            }
//
//            if (request.isChunked()) {
//                readingChunks = true;
//            } else {
//                // Instantiate the appropriate error handler
//                HttpMethod httpMethod = request.getMethod();
//                if (httpMethod.equals(HttpMethod.GET)) {
//                    if(logger.isDebugEnabled()) {
//                        logger.debug("Received a Http GET request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handleGet()
//                } else if (httpMethod.equals(HttpMethod.POST)) {
//                    if (logger.isDebugEnabled()) {
//                        logger.debug("Recieved a Http POST request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handlePut
//                } else if (httpMethod.equals(HttpMethod.DELETE)) {
//                    if (logger.isDebugEnabled()) {
//                        logger.debug("Received a Http DELETE request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handleDelete
//                } else {
//                    String errorMessage = "Illegal Http request received at " + System.currentTimeMillis() + " ms";
//                    logger.error(errorMessage);
//                    RestErrorHandler.writeErrorResponse(messageEvent, BAD_REQUEST, errorMessage);
//                    return;
//                }
//            }
//        } else {
//            HttpChunk chunk = (HttpChunk) messageEvent.getMessage();
//            if (chunk.isLast()) {
//                readingChunks = false;
//            }
//        }
        //sendResponse(messageEvent);
    }

    public void sendResponse(MessageEvent messageEvent) {
        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
        response.setHeader(CONTENT_LENGTH, "4");
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            outputStream.write("allo".getBytes());
        } catch (IOException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        ChannelBuffer responseContent = ChannelBuffers.dynamicBuffer();
        responseContent.writeBytes(outputStream.toByteArray());
        response.setContent(responseContent);
        messageEvent.getChannel().write(response);
        logger.info("Sent");
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_c8657_99a84/rev_c8657-99a84.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_c8657_99a84/rev_c8657-99a84/src/test/java/org/junit/tests/running/classes/TestClassTest.java;importorg.junit.experimental.interceptor.MethodRule;;importorg.junit.rules.MethodRule;;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
=======
import org.junit.rules.MethodRule;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/query/src/main/java/org/infinispan/query/impl/LifecycleManager.java;importorg.hibernate.search.cfg.SearchConfiguration;;importorg.hibernate.search.cfg.spi.SearchConfiguration;;
import org.hibernate.search.cfg.SearchConfiguration;
=======
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;

import org.hibernate.search.cfg.spi.SearchConfiguration;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd/src/java/org/apache/cassandra/auth/IAuthority2.java;importorg.apache.cassandra.thrift.InvalidRequestException;;importorg.apache.cassandra.exceptions.InvalidRequestException;;
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.auth;

import org.apache.cassandra.cql3.CFName;
import org.apache.cassandra.thrift.CqlResult;
import org.apache.cassandra.thrift.InvalidRequestException;

public interface IAuthority2 extends IAuthority
{
    /**
     * Setup is called each time upon system startup
     */
    public void setup();

    /**
     * GRANT <permission> ON <resource> TO <user> [WITH GRANT OPTION];
     *
     * @param granter The user who grants the permission
     * @param permission The specific permission
     * @param to Grantee of the permission
     * @param resource The resource which is affect by permission change
     * @param grantOption Does grantee has a permission to grant the same kind of permission on this particular resource?
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public void grant(AuthenticatedUser granter, Permission permission, String to, CFName resource, boolean grantOption) throws InvalidRequestException;

    /**
     * REVOKE <permission> ON <resource> FROM <user_name>;
     *
     * @param revoker The user know requests permission revoke
     * @param permission The permission to revoke
     * @param from The user to revoke permission from.
     * @param resource The resource affected by permission change.
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public void revoke(AuthenticatedUser revoker, Permission permission, String from, CFName resource) throws InvalidRequestException;

    /**
     * LIST GRANTS FOR <user>;
     * Not 'SHOW' because it's reserved for CQLsh for commands like 'show cluster'
     *
     * @param username The username to look for permissions.
     *
     * @return All of the permission of this particular user.
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public CqlResult listPermissions(String username) throws InvalidRequestException;
}=======
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.auth;

import org.apache.cassandra.cql3.CFName;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.UnauthorizedException;
import org.apache.cassandra.transport.messages.ResultMessage;

public interface IAuthority2 extends IAuthority
{
    /**
     * Setup is called each time upon system startup
     */
    public void setup();

    /**
     * GRANT <permission> ON <resource> TO <user> [WITH GRANT OPTION];
     *
     * @param granter The user who grants the permission
     * @param permission The specific permission
     * @param to Grantee of the permission
     * @param resource The resource which is affect by permission change
     * @param grantOption Does grantee has a permission to grant the same kind of permission on this particular resource?
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public void grant(AuthenticatedUser granter, Permission permission, String to, CFName resource, boolean grantOption) throws UnauthorizedException, InvalidRequestException;

    /**
     * REVOKE <permission> ON <resource> FROM <user_name>;
     *
     * @param revoker The user know requests permission revoke
     * @param permission The permission to revoke
     * @param from The user to revoke permission from.
     * @param resource The resource affected by permission change.
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public void revoke(AuthenticatedUser revoker, Permission permission, String from, CFName resource) throws UnauthorizedException, InvalidRequestException;

    /**
     * LIST GRANTS FOR <user>;
     * Not 'SHOW' because it's reserved for CQLsh for commands like 'show cluster'
     *
     * @param username The username to look for permissions.
     *
     * @return All of the permission of this particular user.
     *
     * @throws InvalidRequestException upon parameter misconfiguration or internal error.
     */
    public ResultMessage listPermissions(String username) throws UnauthorizedException, InvalidRequestException;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd/src/java/org/apache/cassandra/auth/IAuthorityContainer.java;importorg.apache.cassandra.thrift.InvalidRequestException;;importorg.apache.cassandra.exceptions.InvalidRequestException;;
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.auth;

import org.apache.cassandra.cql3.CFName;
import org.apache.cassandra.thrift.CqlResult;
import org.apache.cassandra.thrift.InvalidRequestException;

/**
 * 1.1.x : Temporary measure to unable dynamic operations without changing IAuthority interface.
 */
public class IAuthorityContainer
{
    private final IAuthority authority;
    private final IAuthority2 dynamicAuthority;

    public IAuthorityContainer(IAuthority authority)
    {
        this.authority = authority;
        dynamicAuthority = (authority instanceof IAuthority2) ? ((IAuthority2) authority) : null;
    }

    public void setup()
    {
        if (dynamicAuthority != null)
            dynamicAuthority.setup();
    }

    public boolean isDynamic()
    {
        return dynamicAuthority != null;
    }

    public IAuthority getAuthority()
    {
        return authority;
    }

    public void grant(AuthenticatedUser granter, Permission permission, String to, CFName resource, boolean grantOption) throws InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("GRANT operation is not supported by your authority: " + authority);

        if (permission.equals(Permission.READ) || permission.equals(Permission.WRITE))
            throw new InvalidRequestException(String.format("Error setting permission to: %s, available permissions are %s", permission, Permission.GRANULAR_PERMISSIONS));

        dynamicAuthority.grant(granter, permission, to, resource, grantOption);
    }

    public void revoke(AuthenticatedUser revoker, Permission permission, String from, CFName resource) throws InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("REVOKE operation is not supported by your authority: " + authority);

        dynamicAuthority.revoke(revoker, permission, from, resource);
    }

    public CqlResult listPermissions(String username) throws InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("LIST GRANTS operation is not supported by your authority: " + authority);

        return dynamicAuthority.listPermissions(username);
    }
}=======
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.auth;

import org.apache.cassandra.cql3.CFName;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.UnauthorizedException;
import org.apache.cassandra.thrift.CqlResult;
import org.apache.cassandra.transport.messages.ResultMessage;

/**
 * 1.1.x : Temporary measure to unable dynamic operations without changing IAuthority interface.
 */
public class IAuthorityContainer
{
    private final IAuthority authority;
    private final IAuthority2 dynamicAuthority;

    public IAuthorityContainer(IAuthority authority)
    {
        this.authority = authority;
        dynamicAuthority = (authority instanceof IAuthority2) ? ((IAuthority2) authority) : null;
    }

    public void setup()
    {
        if (dynamicAuthority != null)
            dynamicAuthority.setup();
    }

    public boolean isDynamic()
    {
        return dynamicAuthority != null;
    }

    public IAuthority getAuthority()
    {
        return authority;
    }

    public void grant(AuthenticatedUser granter, Permission permission, String to, CFName resource, boolean grantOption) throws UnauthorizedException, InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("GRANT operation is not supported by your authority: " + authority);

        if (permission.equals(Permission.READ) || permission.equals(Permission.WRITE))
            throw new InvalidRequestException(String.format("Error setting permission to: %s, available permissions are %s", permission, Permission.GRANULAR_PERMISSIONS));

        dynamicAuthority.grant(granter, permission, to, resource, grantOption);
    }

    public void revoke(AuthenticatedUser revoker, Permission permission, String from, CFName resource) throws UnauthorizedException, InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("REVOKE operation is not supported by your authority: " + authority);

        dynamicAuthority.revoke(revoker, permission, from, resource);
    }

    public ResultMessage listPermissions(String username) throws UnauthorizedException, InvalidRequestException
    {
        if (dynamicAuthority == null)
            throw new InvalidRequestException("LIST GRANTS operation is not supported by your authority: " + authority);

        return dynamicAuthority.listPermissions(username);
    }


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd/src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java;importorg.apache.cassandra.config.ConfigurationException;;importorg.apache.cassandra.exceptions.ConfigurationException;;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.ConfigurationException;
=======
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.auth.Permission;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd/src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java;importorg.apache.cassandra.config.ConfigurationException;;importorg.apache.cassandra.exceptions.ConfigurationException;;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.ConfigurationException;
=======
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.RequestValidationException;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.exceptions.UnauthorizedException;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd/src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java;importorg.apache.cassandra.config.*;;importorg.apache.cassandra.exceptions.*;;
import org.apache.cassandra.config.*;
import org.apache.cassandra.service.ClientState;
=======
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.service.ClientState;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48/projects/OG-MasterDB/src/test/java/com/opengamma/masterdb/batch/DbBatchWriterTest.java;importcom.opengamma.engine.ComputationTargetType;;importcom.opengamma.engine.target.ComputationTargetType;;
import com.opengamma.engine.ComputationTargetType;
import com.opengamma.engine.value.ComputedValueResult;
=======
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ComputedValue;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48/projects/OG-MasterDB/src/main/java/com/opengamma/masterdb/batch/DbBatchMaster.java;importcom.opengamma.engine.ComputationTargetType;;importcom.opengamma.engine.target.ComputationTargetType;;
import com.opengamma.engine.ComputationTargetType;
import com.opengamma.engine.value.ComputedValueResult;
=======
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ComputedValue;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ef255_41b98/rev_ef255-41b98.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ef255_41b98/rev_ef255-41b98/src/java/org/apache/cassandra/avro/AvroValidation.java;importstaticorg.apache.cassandra.avro.ErrorFactory.newInvalidRequestException;;importstaticorg.apache.cassandra.avro.AvroErrorFactory.newInvalidRequestException;;
import static org.apache.cassandra.avro.AvroRecordFactory.newColumnPath;
import static org.apache.cassandra.avro.ErrorFactory.newInvalidRequestException;
=======
import static org.apache.cassandra.avro.AvroErrorFactory.newInvalidRequestException;
import static org.apache.cassandra.avro.AvroRecordFactory.newColumnPath;


/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java;importstaticvoldemort.utils.Ec2RemoteTestUtils.createInstances;;importstaticvoldemort.utils.Ec2InstanceRemoteTestUtils.createInstances;;
/*
 * Copyright 2009 LinkedIn, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.utils;

import static voldemort.utils.Ec2RemoteTestUtils.createInstances;
import static voldemort.utils.Ec2RemoteTestUtils.destroyInstances;
import static voldemort.utils.RemoteTestUtils.deploy;
import static voldemort.utils.RemoteTestUtils.executeRemoteTest;
import static voldemort.utils.RemoteTestUtils.generateClusterDescriptor;
import static voldemort.utils.RemoteTestUtils.startClusterAsync;
import static voldemort.utils.RemoteTestUtils.startClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterQuiet;
import static voldemort.utils.RemoteTestUtils.toHostNames;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.log4j.Logger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Ec2SmokeTest contains two examples that interact with EC2.
 * 
 * There are quite a few properties that are needed which are provided for these
 * tests to run. Please see {@link Ec2SmokeTestConfig} for details.
 * 
 * @author Kirk True
 */

public class Ec2SmokeTest {

    private static Ec2SmokeTestConfig ec2SmokeTestConfig;
    private static List<HostNamePair> hostNamePairs;
    private static List<String> hostNames;
    private static Map<String, Integer> nodeIds;

    private static final Logger logger = Logger.getLogger(Ec2SmokeTest.class);

    @BeforeClass
    public static void setUpClass() throws Exception {
        ec2SmokeTestConfig = new Ec2SmokeTestConfig();
        hostNamePairs = createInstances(ec2SmokeTestConfig);
        hostNames = toHostNames(hostNamePairs);
        nodeIds = generateClusterDescriptor(hostNamePairs, "test", ec2SmokeTestConfig);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(hostNames, ec2SmokeTestConfig);
    }

    @Before
    public void setUp() throws Exception {
        deploy(hostNames, ec2SmokeTestConfig);
        startClusterAsync(hostNames, ec2SmokeTestConfig, nodeIds);
    }

    @After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, ec2SmokeTestConfig);
    }

    @Test
    public void testRemoteTest() throws Exception {
        Map<String, String> commands = new HashMap<String, String>();
        int i = 0;
        int numRequests = ec2SmokeTestConfig.numRequests;
        int iterations = ec2SmokeTestConfig.iterations;
        String storeName = "test";
        String bootstrapUrl = "tcp://" + hostNamePairs.get(0).getInternalHostName() + ":6666";

        for(HostNamePair hostNamePair: hostNamePairs) {
            int startKey = i * numRequests;
            int rampTime = i * ec2SmokeTestConfig.rampTime;

            String sleepCommand = "sleep " + rampTime;
            String cdCommand = "cd " + ec2SmokeTestConfig.getVoldemortRootDirectory();
            String remoteTestCommand = "./bin/voldemort-remote-test.sh -w -d --iterations "
                                       + iterations + " --start-key-index " + startKey + " "
                                       + bootstrapUrl + " " + storeName + " " + numRequests;

            commands.put(hostNamePair.getExternalHostName(), sleepCommand + " ; " + cdCommand
                                                             + " ; " + remoteTestCommand);
            i++;
        }

        executeRemoteTest(hostNames, ec2SmokeTestConfig, commands);
    }

    @Test
    public void testTemporaryNodeOffline() throws Exception {
        String offlineHostName = hostNames.get(0);
        Integer nodeId = nodeIds.get(offlineHostName);

        stopClusterNode(offlineHostName, ec2SmokeTestConfig);
        startClusterNode(offlineHostName, ec2SmokeTestConfig, nodeId);
    }

    /**
     * Ec2SmokeTestConfig contains configuration for {@link Ec2SmokeTest}.
     * 
     * There are quite a few properties that are needed which are provided in a
     * *.properties file, the path of which is provided in the
     * "ec2PropertiesFile" System property. Below is a table of the properties
     * <i>in addition to those from {@link Ec2RemoteTestConfig}</i>:
     * 
     * <table>
     * <th>Name</th>
     * <th>Description</th>
     * <tr>
     * <td>ec2RampTime</td>
     * <td>For the remote test, the number of seconds to wait for each instance
     * before connecting to the server. Prevents the server nodes from being
     * flooded all at once.</td>
     * </tr>
     * <tr>
     * <td>ec2Iterations</td>
     * <td>For the remote test, the number of remote test iterations.</td>
     * </tr>
     * <tr>
     * <td>ec2NumRequests</td>
     * <td>For the remote test, the number of remote test requests per each
     * iteration.</td>
     * </tr>
     * </table>
     * 
     * @author Kirk True
     */

    private static class Ec2SmokeTestConfig extends Ec2RemoteTestConfig {

        private int rampTime;

        private int iterations;

        private int numRequests;

        @Override
        protected void init(Properties properties) {
            super.init(properties);

            rampTime = getIntProperty(properties, "ec2RampTime");
            iterations = getIntProperty(properties, "ec2Iterations");
            numRequests = getIntProperty(properties, "ec2NumRequests");
        }

        @Override
        protected List<String> getRequiredPropertyNames() {
            List<String> requireds = super.getRequiredPropertyNames();
            requireds.addAll(Arrays.asList("ec2RampTime", "ec2Iterations", "ec2NumRequests"));
            return requireds;
        }

    }

}=======
/*
 * Copyright 2009 LinkedIn, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.utils;

import static voldemort.utils.Ec2InstanceRemoteTestUtils.createInstances;
import static voldemort.utils.Ec2InstanceRemoteTestUtils.destroyInstances;
import static voldemort.utils.RemoteTestUtils.deploy;
import static voldemort.utils.RemoteTestUtils.executeRemoteTest;
import static voldemort.utils.RemoteTestUtils.generateClusterDescriptor;
import static voldemort.utils.RemoteTestUtils.startClusterAsync;
import static voldemort.utils.RemoteTestUtils.startClusterNode;
import static voldemort.utils.RemoteTestUtils.stopCluster;
import static voldemort.utils.RemoteTestUtils.stopClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterQuiet;
import static voldemort.utils.RemoteTestUtils.toHostNames;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Ec2SmokeTest contains two examples that interact with EC2.
 * 
 * There are quite a few properties that are needed which are provided in a
 * *.properties file, the path of which is provided in the "ec2PropertiesFile"
 * System property. Below is a table of the properties:
 * 
 * <table>
 * <th>Name</th>
 * <th>Description</th>
 * <tr>
 * <td>ec2AccessId</td>
 * <td>EC2 access ID, provided by Amazon</td>
 * </tr>
 * <tr>
 * <td>ec2SecretKey</td>
 * <td>EC2 secret key, provided by Amazon</td>
 * </tr>
 * <tr>
 * <td>ec2Ami</td>
 * <td>ID of the EC2 AMI used for the instances that are started</td>
 * </tr>
 * <tr>
 * <td>ec2KeyPairId</td>
 * <td>Key pair ID</td>
 * </tr>
 * <tr>
 * <td>ec2SshPrivateKeyPath</td>
 * <td>SSH private key path to key used to connect to instances (optional)</td>
 * </tr>
 * <tr>
 * <td>ec2HostUserId</td>
 * <td>User ID on the hosts; for EC2 this is usually "root"</td>
 * </tr>
 * <tr>
 * <td>ec2VoldemortRootDirectory</td>
 * <td>Root directory on remote instances that points to the the Voldemort
 * "distribution" directory; relative to the host user ID's home directory. For
 * example, if the remote user's home directory is /root and the Voldemort
 * distribution directory is /root/voldemort, ec2VoldemortRootDirectory would be
 * "voldemort"</td>
 * </tr>
 * <tr>
 * <td>ec2VoldemortHomeDirectory</td>
 * <td>Home directory on remote instances that points to the configuration
 * directory, relative to the host user ID's home directory. For example, if the
 * remote user's home directory is /root and the Voldemort configuration
 * directory is /root/voldemort/config/single_node_cluster,
 * ec2VoldemortHomeDirectory would be "voldemort/config/single_node_cluster"</td>
 * </tr>
 * <tr>
 * <td>ec2SourceDirectory</td>
 * <td>Source directory on <b>local</b> machine from which to copy the Voldemort
 * "distribution" to the remote hosts; e.g. "/home/kirk/voldemortdev/voldemort"</td>
 * </tr>
 * <tr>
 * <td>ec2ParentDirectory</td>
 * <td>Parent directory on the <b>remote</b> machine into which to copy the
 * Voldemort "distribution". For example, if the remote user's home directory is
 * /root and the Voldemort distribution directory is /root/voldemort,
 * ec2ParentDirectory would be "." or "/root".</td>
 * </tr>
 * <tr>
 * <td>ec2ClusterXmlFile</td>
 * <td><b>Local</b> path to which cluster.xml will be written with EC2 hosts;
 * this needs to live under the ec2SourceDirectory's configuration directory
 * that is copied to the remote host.</td>
 * </tr>
 * <tr>
 * <td>ec2InstanceCount</td>
 * <td>The number of instances to create.</td>
 * </tr>
 * <tr>
 * <td>ec2RampTime</td>
 * <td>For the remote test, the number of seconds to wait for each instance
 * before connecting to the server. Prevents the server nodes from being flooded
 * all at once.</td>
 * </tr>
 * <tr>
 * <td>ec2Iterations</td>
 * <td>For the remote test, the number of remote test iterations.</td>
 * </tr>
 * <tr>
 * <td>ec2NumRequests</td>
 * <td>For the remote test, the number of remote test requests per each
 * iteration.</td>
 * </tr>
 * </table>
 * 
 * @author Kirk True
 */

public class Ec2SmokeTest {

    private static String accessId;
    private static String secretKey;
    private static String ami;
    private static String keyPairId;
    private static String sshPrivateKeyPath;
    private static String hostUserId;
    private static File sshPrivateKey;
    private static String voldemortRootDirectory;
    private static String voldemortHomeDirectory;
    private static File sourceDirectory;
    private static String parentDirectory;
    private static File clusterXmlFile;
    private static int rampTime;
    private static int iterations;
    private static int numRequests;
    private static List<HostNamePair> hostNamePairs;
    private static List<String> hostNames;
    private static Map<String, Integer> nodeIds;

    private static final Logger logger = Logger.getLogger(Ec2SmokeTest.class);

    @BeforeClass
    public static void setUpClass() throws Exception {
        Properties properties = getEc2Properties();
        accessId = properties.getProperty("ec2AccessId");
        secretKey = properties.getProperty("ec2SecretKey");
        ami = properties.getProperty("ec2Ami");
        keyPairId = properties.getProperty("ec2KeyPairId");
        sshPrivateKeyPath = properties.getProperty("ec2SshPrivateKeyPath");
        hostUserId = properties.getProperty("ec2HostUserId");
        sshPrivateKey = sshPrivateKeyPath != null ? new File(sshPrivateKeyPath) : null;
        voldemortRootDirectory = properties.getProperty("ec2VoldemortRootDirectory");
        voldemortHomeDirectory = properties.getProperty("ec2VoldemortHomeDirectory");
        sourceDirectory = new File(properties.getProperty("ec2SourceDirectory"));
        parentDirectory = properties.getProperty("ec2ParentDirectory");
        clusterXmlFile = new File(properties.getProperty("ec2ClusterXmlFile"));
        int ec2InstanceCount = Integer.parseInt(properties.getProperty("ec2InstanceCount"));
        rampTime = Integer.parseInt(properties.getProperty("ec2RampTime"));
        iterations = Integer.parseInt(properties.getProperty("ec2Iterations"));
        numRequests = Integer.parseInt(properties.getProperty("ec2NumRequests"));

        hostNamePairs = createInstances(accessId, secretKey, ami, keyPairId, ec2InstanceCount);

        hostNames = toHostNames(hostNamePairs);

        nodeIds = generateClusterDescriptor(hostNamePairs, "test", clusterXmlFile);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(accessId, secretKey, hostNames);
    }

    @After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
    }

    @Test
    public void testRemoteTest() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            executeRemoteTest(hostNamePairs,
                              voldemortRootDirectory,
                              sshPrivateKey,
                              hostUserId,
                              rampTime,
                              iterations,
                              numRequests);
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }

    @Test
    public void testTemporaryNodeOffline() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            String offlineHostName = hostNames.get(0);

            stopClusterNode(offlineHostName, sshPrivateKey, hostUserId, voldemortRootDirectory);

            startClusterNode(offlineHostName,
                             sshPrivateKey,
                             hostUserId,
                             voldemortRootDirectory,
                             voldemortHomeDirectory,
                             nodeIds.get(hostNames.get(0)));
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }

    private static Properties getEc2Properties() throws Exception {
        String propertiesFileName = System.getProperty("ec2PropertiesFile");

        String[] requireds = { "ec2AccessId", "ec2SecretKey", "ec2Ami", "ec2KeyPairId",
                "ec2HostUserId", "ec2VoldemortRootDirectory", "ec2VoldemortHomeDirectory",
                "ec2SourceDirectory", "ec2ParentDirectory", "ec2ClusterXmlFile",
                "ec2InstanceCount", "ec2RampTime", "ec2Iterations", "ec2NumRequests" };

        if(propertiesFileName == null)
            throw new Exception("ec2PropertiesFile system property must be defined that "
                                + "provides the path to file containing the following "
                                + "required Ec2SmokeTest properties: "
                                + StringUtils.join(requireds, ", "));

        Properties properties = new Properties();
        InputStream in = null;

        try {
            in = new FileInputStream(propertiesFileName);
            properties.load(in);
        } finally {
            IOUtils.closeQuietly(in);
        }

        for(String required: requireds) {
            // Allow system properties to override
            if(System.getProperties().containsKey(required))
                properties.put(required, System.getProperty(required));

            if(!properties.containsKey(required))
                throw new Exception("Required properties for Ec2SmokeTest: "
                                    + StringUtils.join(requireds, ", ") + "; missing " + required);
        }

        return properties;
    }



/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac.revisions;/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java;importstaticvoldemort.utils.Ec2RemoteTestUtils.destroyInstances;;importstaticvoldemort.utils.Ec2InstanceRemoteTestUtils.destroyInstances;;
/*
 * Copyright 2009 LinkedIn, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.utils;

import static voldemort.utils.Ec2RemoteTestUtils.createInstances;
import static voldemort.utils.Ec2RemoteTestUtils.destroyInstances;
import static voldemort.utils.RemoteTestUtils.deploy;
import static voldemort.utils.RemoteTestUtils.executeRemoteTest;
import static voldemort.utils.RemoteTestUtils.generateClusterDescriptor;
import static voldemort.utils.RemoteTestUtils.startClusterAsync;
import static voldemort.utils.RemoteTestUtils.startClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterQuiet;
import static voldemort.utils.RemoteTestUtils.toHostNames;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.log4j.Logger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Ec2SmokeTest contains two examples that interact with EC2.
 * 
 * There are quite a few properties that are needed which are provided for these
 * tests to run. Please see {@link Ec2SmokeTestConfig} for details.
 * 
 * @author Kirk True
 */

public class Ec2SmokeTest {

    private static Ec2SmokeTestConfig ec2SmokeTestConfig;
    private static List<HostNamePair> hostNamePairs;
    private static List<String> hostNames;
    private static Map<String, Integer> nodeIds;

    private static final Logger logger = Logger.getLogger(Ec2SmokeTest.class);

    @BeforeClass
    public static void setUpClass() throws Exception {
        ec2SmokeTestConfig = new Ec2SmokeTestConfig();
        hostNamePairs = createInstances(ec2SmokeTestConfig);
        hostNames = toHostNames(hostNamePairs);
        nodeIds = generateClusterDescriptor(hostNamePairs, "test", ec2SmokeTestConfig);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(hostNames, ec2SmokeTestConfig);
    }

    @Before
    public void setUp() throws Exception {
        deploy(hostNames, ec2SmokeTestConfig);
        startClusterAsync(hostNames, ec2SmokeTestConfig, nodeIds);
    }

    @After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, ec2SmokeTestConfig);
    }

    @Test
    public void testRemoteTest() throws Exception {
        Map<String, String> commands = new HashMap<String, String>();
        int i = 0;
        int numRequests = ec2SmokeTestConfig.numRequests;
        int iterations = ec2SmokeTestConfig.iterations;
        String storeName = "test";
        String bootstrapUrl = "tcp://" + hostNamePairs.get(0).getInternalHostName() + ":6666";

        for(HostNamePair hostNamePair: hostNamePairs) {
            int startKey = i * numRequests;
            int rampTime = i * ec2SmokeTestConfig.rampTime;

            String sleepCommand = "sleep " + rampTime;
            String cdCommand = "cd " + ec2SmokeTestConfig.getVoldemortRootDirectory();
            String remoteTestCommand = "./bin/voldemort-remote-test.sh -w -d --iterations "
                                       + iterations + " --start-key-index " + startKey + " "
                                       + bootstrapUrl + " " + storeName + " " + numRequests;

            commands.put(hostNamePair.getExternalHostName(), sleepCommand + " ; " + cdCommand
                                                             + " ; " + remoteTestCommand);
            i++;
        }

        executeRemoteTest(hostNames, ec2SmokeTestConfig, commands);
    }

    @Test
    public void testTemporaryNodeOffline() throws Exception {
        String offlineHostName = hostNames.get(0);
        Integer nodeId = nodeIds.get(offlineHostName);

        stopClusterNode(offlineHostName, ec2SmokeTestConfig);
        startClusterNode(offlineHostName, ec2SmokeTestConfig, nodeId);
    }

    /**
     * Ec2SmokeTestConfig contains configuration for {@link Ec2SmokeTest}.
     * 
     * There are quite a few properties that are needed which are provided in a
     * *.properties file, the path of which is provided in the
     * "ec2PropertiesFile" System property. Below is a table of the properties
     * <i>in addition to those from {@link Ec2RemoteTestConfig}</i>:
     * 
     * <table>
     * <th>Name</th>
     * <th>Description</th>
     * <tr>
     * <td>ec2RampTime</td>
     * <td>For the remote test, the number of seconds to wait for each instance
     * before connecting to the server. Prevents the server nodes from being
     * flooded all at once.</td>
     * </tr>
     * <tr>
     * <td>ec2Iterations</td>
     * <td>For the remote test, the number of remote test iterations.</td>
     * </tr>
     * <tr>
     * <td>ec2NumRequests</td>
     * <td>For the remote test, the number of remote test requests per each
     * iteration.</td>
     * </tr>
     * </table>
     * 
     * @author Kirk True
     */

    private static class Ec2SmokeTestConfig extends Ec2RemoteTestConfig {

        private int rampTime;

        private int iterations;

        private int numRequests;

        @Override
        protected void init(Properties properties) {
            super.init(properties);

            rampTime = getIntProperty(properties, "ec2RampTime");
            iterations = getIntProperty(properties, "ec2Iterations");
            numRequests = getIntProperty(properties, "ec2NumRequests");
        }

        @Override
        protected List<String> getRequiredPropertyNames() {
            List<String> requireds = super.getRequiredPropertyNames();
            requireds.addAll(Arrays.asList("ec2RampTime", "ec2Iterations", "ec2NumRequests"));
            return requireds;
        }

    }

}=======
/*
 * Copyright 2009 LinkedIn, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package voldemort.utils;

import static voldemort.utils.Ec2InstanceRemoteTestUtils.createInstances;
import static voldemort.utils.Ec2InstanceRemoteTestUtils.destroyInstances;
import static voldemort.utils.RemoteTestUtils.deploy;
import static voldemort.utils.RemoteTestUtils.executeRemoteTest;
import static voldemort.utils.RemoteTestUtils.generateClusterDescriptor;
import static voldemort.utils.RemoteTestUtils.startClusterAsync;
import static voldemort.utils.RemoteTestUtils.startClusterNode;
import static voldemort.utils.RemoteTestUtils.stopCluster;
import static voldemort.utils.RemoteTestUtils.stopClusterNode;
import static voldemort.utils.RemoteTestUtils.stopClusterQuiet;
import static voldemort.utils.RemoteTestUtils.toHostNames;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Ec2SmokeTest contains two examples that interact with EC2.
 * 
 * There are quite a few properties that are needed which are provided in a
 * *.properties file, the path of which is provided in the "ec2PropertiesFile"
 * System property. Below is a table of the properties:
 * 
 * <table>
 * <th>Name</th>
 * <th>Description</th>
 * <tr>
 * <td>ec2AccessId</td>
 * <td>EC2 access ID, provided by Amazon</td>
 * </tr>
 * <tr>
 * <td>ec2SecretKey</td>
 * <td>EC2 secret key, provided by Amazon</td>
 * </tr>
 * <tr>
 * <td>ec2Ami</td>
 * <td>ID of the EC2 AMI used for the instances that are started</td>
 * </tr>
 * <tr>
 * <td>ec2KeyPairId</td>
 * <td>Key pair ID</td>
 * </tr>
 * <tr>
 * <td>ec2SshPrivateKeyPath</td>
 * <td>SSH private key path to key used to connect to instances (optional)</td>
 * </tr>
 * <tr>
 * <td>ec2HostUserId</td>
 * <td>User ID on the hosts; for EC2 this is usually "root"</td>
 * </tr>
 * <tr>
 * <td>ec2VoldemortRootDirectory</td>
 * <td>Root directory on remote instances that points to the the Voldemort
 * "distribution" directory; relative to the host user ID's home directory. For
 * example, if the remote user's home directory is /root and the Voldemort
 * distribution directory is /root/voldemort, ec2VoldemortRootDirectory would be
 * "voldemort"</td>
 * </tr>
 * <tr>
 * <td>ec2VoldemortHomeDirectory</td>
 * <td>Home directory on remote instances that points to the configuration
 * directory, relative to the host user ID's home directory. For example, if the
 * remote user's home directory is /root and the Voldemort configuration
 * directory is /root/voldemort/config/single_node_cluster,
 * ec2VoldemortHomeDirectory would be "voldemort/config/single_node_cluster"</td>
 * </tr>
 * <tr>
 * <td>ec2SourceDirectory</td>
 * <td>Source directory on <b>local</b> machine from which to copy the Voldemort
 * "distribution" to the remote hosts; e.g. "/home/kirk/voldemortdev/voldemort"</td>
 * </tr>
 * <tr>
 * <td>ec2ParentDirectory</td>
 * <td>Parent directory on the <b>remote</b> machine into which to copy the
 * Voldemort "distribution". For example, if the remote user's home directory is
 * /root and the Voldemort distribution directory is /root/voldemort,
 * ec2ParentDirectory would be "." or "/root".</td>
 * </tr>
 * <tr>
 * <td>ec2ClusterXmlFile</td>
 * <td><b>Local</b> path to which cluster.xml will be written with EC2 hosts;
 * this needs to live under the ec2SourceDirectory's configuration directory
 * that is copied to the remote host.</td>
 * </tr>
 * <tr>
 * <td>ec2InstanceCount</td>
 * <td>The number of instances to create.</td>
 * </tr>
 * <tr>
 * <td>ec2RampTime</td>
 * <td>For the remote test, the number of seconds to wait for each instance
 * before connecting to the server. Prevents the server nodes from being flooded
 * all at once.</td>
 * </tr>
 * <tr>
 * <td>ec2Iterations</td>
 * <td>For the remote test, the number of remote test iterations.</td>
 * </tr>
 * <tr>
 * <td>ec2NumRequests</td>
 * <td>For the remote test, the number of remote test requests per each
 * iteration.</td>
 * </tr>
 * </table>
 * 
 * @author Kirk True
 */

public class Ec2SmokeTest {

    private static String accessId;
    private static String secretKey;
    private static String ami;
    private static String keyPairId;
    private static String sshPrivateKeyPath;
    private static String hostUserId;
    private static File sshPrivateKey;
    private static String voldemortRootDirectory;
    private static String voldemortHomeDirectory;
    private static File sourceDirectory;
    private static String parentDirectory;
    private static File clusterXmlFile;
    private static int rampTime;
    private static int iterations;
    private static int numRequests;
    private static List<HostNamePair> hostNamePairs;
    private static List<String> hostNames;
    private static Map<String, Integer> nodeIds;

    private static final Logger logger = Logger.getLogger(Ec2SmokeTest.class);

    @BeforeClass
    public static void setUpClass() throws Exception {
        Properties properties = getEc2Properties();
        accessId = properties.getProperty("ec2AccessId");
        secretKey = properties.getProperty("ec2SecretKey");
        ami = properties.getProperty("ec2Ami");
        keyPairId = properties.getProperty("ec2KeyPairId");
        sshPrivateKeyPath = properties.getProperty("ec2SshPrivateKeyPath");
        hostUserId = properties.getProperty("ec2HostUserId");
        sshPrivateKey = sshPrivateKeyPath != null ? new File(sshPrivateKeyPath) : null;
        voldemortRootDirectory = properties.getProperty("ec2VoldemortRootDirectory");
        voldemortHomeDirectory = properties.getProperty("ec2VoldemortHomeDirectory");
        sourceDirectory = new File(properties.getProperty("ec2SourceDirectory"));
        parentDirectory = properties.getProperty("ec2ParentDirectory");
        clusterXmlFile = new File(properties.getProperty("ec2ClusterXmlFile"));
        int ec2InstanceCount = Integer.parseInt(properties.getProperty("ec2InstanceCount"));
        rampTime = Integer.parseInt(properties.getProperty("ec2RampTime"));
        iterations = Integer.parseInt(properties.getProperty("ec2Iterations"));
        numRequests = Integer.parseInt(properties.getProperty("ec2NumRequests"));

        hostNamePairs = createInstances(accessId, secretKey, ami, keyPairId, ec2InstanceCount);

        hostNames = toHostNames(hostNamePairs);

        nodeIds = generateClusterDescriptor(hostNamePairs, "test", clusterXmlFile);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(accessId, secretKey, hostNames);
    }

    @After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
    }

    @Test
    public void testRemoteTest() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            executeRemoteTest(hostNamePairs,
                              voldemortRootDirectory,
                              sshPrivateKey,
                              hostUserId,
                              rampTime,
                              iterations,
                              numRequests);
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }

    @Test
    public void testTemporaryNodeOffline() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            String offlineHostName = hostNames.get(0);

            stopClusterNode(offlineHostName, sshPrivateKey, hostUserId, voldemortRootDirectory);

            startClusterNode(offlineHostName,
                             sshPrivateKey,
                             hostUserId,
                             voldemortRootDirectory,
                             voldemortHomeDirectory,
                             nodeIds.get(hostNames.get(0)));
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }

    private static Properties getEc2Properties() throws Exception {
        String propertiesFileName = System.getProperty("ec2PropertiesFile");

        String[] requireds = { "ec2AccessId", "ec2SecretKey", "ec2Ami", "ec2KeyPairId",
                "ec2HostUserId", "ec2VoldemortRootDirectory", "ec2VoldemortHomeDirectory",
                "ec2SourceDirectory", "ec2ParentDirectory", "ec2ClusterXmlFile",
                "ec2InstanceCount", "ec2RampTime", "ec2Iterations", "ec2NumRequests" };

        if(propertiesFileName == null)
            throw new Exception("ec2PropertiesFile system property must be defined that "
                                + "provides the path to file containing the following "
                                + "required Ec2SmokeTest properties: "
                                + StringUtils.join(requireds, ", "));

        Properties properties = new Properties();
        InputStream in = null;

        try {
            in = new FileInputStream(propertiesFileName);
            properties.load(in);
        } finally {
            IOUtils.closeQuietly(in);
        }

        for(String required: requireds) {
            // Allow system properties to override
            if(System.getProperties().containsKey(required))
                properties.put(required, System.getProperty(required));

            if(!properties.containsKey(required))
                throw new Exception("Required properties for Ec2SmokeTest: "
                                    + StringUtils.join(requireds, ", ") + "; missing " + required);
        }

        return properties;
    }



