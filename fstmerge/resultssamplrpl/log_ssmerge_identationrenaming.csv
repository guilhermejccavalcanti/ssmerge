/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4;/src/java/voldemort/store/rebalancing/RedirectingStore;proxyGet(ByteArray,int);;private List<Versioned<byte[]>> proxyGet(ByteArray key, int donorNodeId) {
        Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
        checkNodeAvailable(donorNode);
        long startNs = System.nanoTime();
        try {
            Store<ByteArray, byte[]> redirectingStore = getRedirectingSocketStore(getName(), donorNodeId);
            List<Versioned<byte[]>> values = redirectingStore.get(key);
            recordSuccess(donorNode, startNs);
            return values;
        } catch (UnreachableStoreException e) {
            recordException(donorNode, startNs, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
        }
    };private List<Versioned<byte[]>> proxyGet(ByteArray key, int donorNodeId) {
        Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
        checkNodeAvailable(donorNode);
        long startNs = System.nanoTime();
        try {
            Store<ByteArray, byte[]> redirectingStore = getRedirectingSocketStore(getName(),
                                                                                  donorNodeId);
            List<Versioned<byte[]>> values = redirectingStore.get(key);
            recordSuccess(donorNode, startNs);
            return values;
        } catch(UnreachableStoreException e) {
            recordException(donorNode, startNs, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4;/src/java/voldemort/store/rebalancing/RedirectingStore;proxyGetAll(List<ByteArray>,List<RebalancePartitionsInfo>);;private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAll(List<ByteArray> keys,
                                                                List<RebalancePartitionsInfo> stealInfoList)
            throws VoldemortException {
        Multimap<Integer, ByteArray> scatterMap = HashMultimap.create(stealInfoList.size(),
                                                                      keys.size());
        int numKeys=0;
        for (ByteArray key: keys) {
            numKeys++;
            for (RebalancePartitionsInfo stealInfo: stealInfoList) {
                byte[] keyBytes = key.get();
                
                for (int p: metadata.getRoutingStrategy(getName()).getPartitionList(keyBytes)) {
                    if (stealInfo.getPartitionList().contains(p))
                        scatterMap.put(stealInfo.getDonorId(), key);
                }
            }
        }

        Map<ByteArray, List<Versioned<byte[]>>> gatherMap = Maps.newHashMapWithExpectedSize(numKeys);

        for (int donorNodeId: scatterMap.keySet()) {
            Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
            checkNodeAvailable(donorNode);
            long startNs = System.nanoTime();

            try {
                Map<ByteArray, List<Versioned<byte[]>>> resultsForNode = getRedirectingSocketStore(getName(),
                                                                                                   donorNodeId).getAll(scatterMap.get(donorNodeId));
                recordSuccess(donorNode, startNs);

                for (Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: resultsForNode.entrySet()) {
                    gatherMap.put(entry.getKey(), entry.getValue());
                }
            } catch (UnreachableStoreException e) {
                recordException(donorNode, startNs, e);
                throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
            }
        }

        return gatherMap;
    };private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAll(List<ByteArray> keys,
                                                                List<RebalancePartitionsInfo> stealInfoList)
            throws VoldemortException {
        Multimap<Integer, ByteArray> scatterMap = HashMultimap.create(stealInfoList.size(),
                                                                      keys.size());
        int numKeys = 0;
        for(ByteArray key: keys) {
            numKeys++;
            for(RebalancePartitionsInfo stealInfo: stealInfoList) {
                byte[] keyBytes = key.get();

                for(int p: metadata.getRoutingStrategy(getName()).getPartitionList(keyBytes)) {
                    if(stealInfo.getPartitionList().contains(p))
                        scatterMap.put(stealInfo.getDonorId(), key);
                }
            }
        }

        Map<ByteArray, List<Versioned<byte[]>>> gatherMap = Maps.newHashMapWithExpectedSize(numKeys);

        for(int donorNodeId: scatterMap.keySet()) {
            Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
            checkNodeAvailable(donorNode);
            long startNs = System.nanoTime();

            try {
                Map<ByteArray, List<Versioned<byte[]>>> resultsForNode = getRedirectingSocketStore(getName(),
                                                                                                   donorNodeId).getAll(scatterMap.get(donorNodeId));
                recordSuccess(donorNode, startNs);

                for(Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: resultsForNode.entrySet()) {
                    gatherMap.put(entry.getKey(), entry.getValue());
                }
            } catch(UnreachableStoreException e) {
                recordException(donorNode, startNs, e);
                throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
            }
        }

        return gatherMap;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4;/test/unit/voldemort/store/rebalancing/RedirectingStoreTest;checkGetAllEntries(Map<ByteArray,byte[]>,VoldemortServer,Store<ByteArray,byte[]>,List<Integer>);;private void checkGetAllEntries(Map<ByteArray, byte[]> entryMap,
                                    VoldemortServer server,
                                    Store<ByteArray, byte[]> store,
                                    List<Integer> availablePartition) {
        RoutingStrategy routing = server.getMetadataStore().getRoutingStrategy(store.getName());
        List<ByteArray> keysInPartitions = new ArrayList<ByteArray>();
        for (ByteArray key: entryMap.keySet()) {
            List<Integer> partitions = routing.getPartitionList(key.get());
            if (availablePartition.containsAll(partitions)) {
                keysInPartitions.add(key);
            }
        }
        Map<ByteArray, List<Versioned<byte[]>>> results = store.getAll(keysInPartitions);
        for (Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
            assertEquals("Values should match",
                         new String(entry.getValue().get(0).getValue()),
                         new String(entryMap.get(entry.getKey())));
        }
    };private void checkGetAllEntries(Map<ByteArray, byte[]> entryMap,
                                    VoldemortServer server,
                                    Store<ByteArray, byte[]> store,
                                    List<Integer> availablePartition) {
        RoutingStrategy routing = server.getMetadataStore().getRoutingStrategy(store.getName());
        List<ByteArray> keysInPartitions = new ArrayList<ByteArray>();
        for(ByteArray key: entryMap.keySet()) {
            List<Integer> partitions = routing.getPartitionList(key.get());
            if(availablePartition.containsAll(partitions)) {
                keysInPartitions.add(key);
            }
        }
        Map<ByteArray, List<Versioned<byte[]>>> results = store.getAll(keysInPartitions);
        for(Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
            assertEquals("Values should match",
                         new String(entry.getValue().get(0).getValue()),
                         new String(entryMap.get(entry.getKey())));
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1efbe_57f6a/rev_1efbe-57f6a;/tests/unit/com/opengamma/financial/security/db/WritableSecurityMasterTestCase;indexFuture();;@Test
  public void indexFuture() throws Exception {
    final IndexFutureSecurity indexFutureSecurity = makeIndexFuture();
    _secMaster.putSecurity(new Date(), indexFutureSecurity);
    final IdentifierBundle id = new IdentifierBundle (new Identifier (IdentificationScheme.BLOOMBERG_TICKER, "SPM0 Index"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof IndexFutureSecurity);
    assertEquals(indexFutureSecurity, security);
  };@Test
  public void indexFuture() throws Exception {
    final IndexFutureSecurity indexFutureSecurity = makeIndexFuture();
    _secMaster.putSecurity(new Date(), indexFutureSecurity);
    final IdentifierBundle id = new IdentifierBundle(new Identifier(IdentificationScheme.BLOOMBERG_TICKER, "SPM0 Index"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof IndexFutureSecurity);
    assertEquals(indexFutureSecurity, security);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1efbe_57f6a/rev_1efbe-57f6a;/tests/unit/com/opengamma/financial/security/db/WritableSecurityMasterTestCase;currencyFuture();;@Test
  @Ignore
  public void currencyFuture() throws Exception {
    final FXFutureSecurity currencyFuture = makeAUDUSDCurrencyFuture();
    _secMaster.putSecurity(new Date(), currencyFuture);
    final IdentifierBundle  id = new IdentifierBundle (Identifier.of(IdentificationScheme.BLOOMBERG_TICKER, "LNM0 Curncy"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof FXFutureSecurity);
    assertEquals(currencyFuture, security);
  };@Test
  @Ignore
  public void currencyFuture() throws Exception {
    final FXFutureSecurity currencyFuture = makeAUDUSDCurrencyFuture();
    _secMaster.putSecurity(new Date(), currencyFuture);
    final IdentifierBundle id = new IdentifierBundle(Identifier.of(IdentificationScheme.BLOOMBERG_TICKER, "LNM0 Curncy"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof FXFutureSecurity);
    assertEquals(currencyFuture, security);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1efbe_57f6a/rev_1efbe-57f6a;/tests/unit/com/opengamma/financial/security/db/WritableSecurityMasterTestCase;metalFuture();;@Test
  public void metalFuture() throws Exception {
    final MetalFutureSecurity silverFuture = makeSilverFuture();
    _secMaster.putSecurity(new Date(), silverFuture);
    final IdentifierBundle  id = new IdentifierBundle (new Identifier (IdentificationScheme.BLOOMBERG_TICKER, "SIM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof MetalFutureSecurity);
    assertEquals(silverFuture, security);
  };@Test
  public void metalFuture() throws Exception {
    final MetalFutureSecurity silverFuture = makeSilverFuture();
    _secMaster.putSecurity(new Date(), silverFuture);
    final IdentifierBundle id = new IdentifierBundle(new Identifier(IdentificationScheme.BLOOMBERG_TICKER, "SIM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof MetalFutureSecurity);
    assertEquals(silverFuture, security);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1efbe_57f6a/rev_1efbe-57f6a;/tests/unit/com/opengamma/financial/security/db/WritableSecurityMasterTestCase;energyFuture();;@Test
  public void energyFuture() throws Exception {
    final EnergyFutureSecurity ethanolFuture = makeEthanolFuture();
    _secMaster.putSecurity(new Date(), ethanolFuture);
    final IdentifierBundle  id = new IdentifierBundle (new Identifier (IdentificationScheme.BLOOMBERG_TICKER, "DLM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof EnergyFutureSecurity);
    assertEquals(ethanolFuture, security);
  };@Test
  public void energyFuture() throws Exception {
    final EnergyFutureSecurity ethanolFuture = makeEthanolFuture();
    _secMaster.putSecurity(new Date(), ethanolFuture);
    final IdentifierBundle id = new IdentifierBundle(new Identifier(IdentificationScheme.BLOOMBERG_TICKER, "DLM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof EnergyFutureSecurity);
    assertEquals(ethanolFuture, security);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1efbe_57f6a/rev_1efbe-57f6a;/tests/unit/com/opengamma/financial/security/db/WritableSecurityMasterTestCase;interestRateFuture();;@Test
  public void interestRateFuture() throws Exception {
    final InterestRateFutureSecurity euroDollarFuture = makeInterestRateFuture();
    _secMaster.putSecurity(new Date(), euroDollarFuture);
    final IdentifierBundle  id = new IdentifierBundle (new Identifier (IdentificationScheme.BLOOMBERG_TICKER, "EDM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof InterestRateFutureSecurity);
    assertEquals(euroDollarFuture, security);
  };@Test
  public void interestRateFuture() throws Exception {
    final InterestRateFutureSecurity euroDollarFuture = makeInterestRateFuture();
    _secMaster.putSecurity(new Date(), euroDollarFuture);
    final IdentifierBundle id = new IdentifierBundle(new Identifier(IdentificationScheme.BLOOMBERG_TICKER, "EDM0 Comdty"));
    final Security security = _secMaster.getSecurity(id);
    assertNotNull(security);
    assertTrue(security instanceof InterestRateFutureSecurity);
    assertEquals(euroDollarFuture, security);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_1f4c6_23c62/rev_1f4c6-23c62;/lucene/src/java/org/apache/lucene/index/SegmentMerger;getMergedFiles(SegmentInfo);;final Collection<String> getMergedFiles(final SegmentInfo info) throws IOException {
    Set<String> fileSet = new HashSet<String>();

    // Basic files
    for (String ext : IndexFileNames.COMPOUND_EXTENSIONS_NOT_CODEC) {
      fileSet.add(IndexFileNames.segmentFileName(segment, "", ext));
    }

    segmentWriteState.segmentCodecs.files(directory, info, fileSet);
    
    // Fieldable norm files
    int numFIs = fieldInfos.size();
    for (int i = 0; i < numFIs; i++) {
      FieldInfo fi = fieldInfos.fieldInfo(i);
      if (fi.isIndexed && !fi.omitNorms) {
        fileSet.add(IndexFileNames.segmentFileName(segment, "", IndexFileNames.NORMS_EXTENSION));
        break;
      }
    }

    // Vector files
    if (fieldInfos.hasVectors()) {
      for (String ext : IndexFileNames.VECTOR_EXTENSIONS) {
        fileSet.add(IndexFileNames.segmentFileName(segment, "", ext));
      }
    }

    return fileSet;
  };final Collection<String> getMergedFiles(final SegmentInfo info) throws IOException {
    Set<String> fileSet = new HashSet<String>();

    // Basic files
    for (String ext : IndexFileNames.COMPOUND_EXTENSIONS_NOT_CODEC) {
      fileSet.add(IndexFileNames.segmentFileName(segment, "", ext));
    }

    segmentWriteState.segmentCodecs.files(directory, info, fileSet);

    // Fieldable norm files
    int numFIs = fieldInfos.size();
    for (int i = 0; i < numFIs; i++) {
      FieldInfo fi = fieldInfos.fieldInfo(i);
      if (fi.isIndexed && !fi.omitNorms) {
        fileSet.add(IndexFileNames.segmentFileName(segment, "", IndexFileNames.NORMS_EXTENSION));
        break;
      }
    }

    // Vector files
    if (fieldInfos.hasVectors()) {
      for (String ext : IndexFileNames.VECTOR_EXTENSIONS) {
        fileSet.add(IndexFileNames.segmentFileName(segment, "", ext));
      }
    }

    return fileSet;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4;/src/java/voldemort/client/protocol/admin/AdminClient;getAsyncRequestStatus(int,String);;public abstract Pair<String,Boolean> getAsyncRequestStatus(int nodeId, String requestId);;public abstract Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4;/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat;getAsyncRequestStatus(int,String);;@Override
    public Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId) {
        VAdminProto.AsyncStatusRequest asyncRequest = VAdminProto.AsyncStatusRequest.newBuilder()
                .setRequestId(requestId)
                .build();
        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()
                .setType(VAdminProto.AdminRequestType.ASYNC_STATUS)
                .setAsyncStatus(asyncRequest)
                .build();
        VAdminProto.AsyncStatusResponse.Builder response = sendAndReceive(nodeId, adminRequest,
                VAdminProto.AsyncStatusResponse.newBuilder());

        if (response.hasError())
            throwException(response.getError());

        return new Pair<String,Boolean>(response.getStatus(), response.getIsComplete());
    };@Override
    public Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId) {
        VAdminProto.AsyncStatusRequest asyncRequest = VAdminProto.AsyncStatusRequest.newBuilder()
                                                                                    .setRequestId(requestId)
                                                                                    .build();
        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                          .setType(VAdminProto.AdminRequestType.ASYNC_STATUS)
                                                                                          .setAsyncStatus(asyncRequest)
                                                                                          .build();
        VAdminProto.AsyncStatusResponse.Builder response = sendAndReceive(nodeId,
                                                                          adminRequest,
                                                                          VAdminProto.AsyncStatusResponse.newBuilder());

        if(response.hasError())
            throwException(response.getError());

        return new Pair<String, Boolean>(response.getStatus(), response.getIsComplete());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4;/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler;handleAsyncStatus(VAdminProto.AsyncStatusRequest);;public VAdminProto.AsyncStatusResponse handleAsyncStatus(VAdminProto.AsyncStatusRequest request) {
        VAdminProto.AsyncStatusResponse.Builder response = VAdminProto.AsyncStatusResponse.newBuilder();
        try {
            String requestId = request.getRequestId();
            String requestStatus = asyncRunner.getRequestStatus(requestId);
            boolean requestComplete = asyncRunner.isComplete(requestId);

            response.setIsComplete(requestComplete);
            response.setStatus(requestStatus);
        } catch (VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
        }

        return response.build();
    };public VAdminProto.AsyncStatusResponse handleAsyncStatus(VAdminProto.AsyncStatusRequest request) {
        VAdminProto.AsyncStatusResponse.Builder response = VAdminProto.AsyncStatusResponse.newBuilder();
        try {
            String requestId = request.getRequestId();
            String requestStatus = asyncRunner.getRequestStatus(requestId);
            boolean requestComplete = asyncRunner.isComplete(requestId);

            response.setIsComplete(requestComplete);
            response.setStatus(requestStatus);
        } catch(VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
        }

        return response.build();
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/lucene/src/java/org/apache/lucene/index/FieldsWriter;flushDocument(int,RAMOutputStream);;void flushDocument(int numStoredFields, RAMOutputStream buffer) throws IOException {
      indexStream.writeLong(fieldsStream.getFilePointer());
      fieldsStream.writeVInt(numStoredFields);
      buffer.writeTo(fieldsStream);
    };void flushDocument(int numStoredFields, RAMOutputStream buffer) throws IOException {
    indexStream.writeLong(fieldsStream.getFilePointer());
    fieldsStream.writeVInt(numStoredFields);
    buffer.writeTo(fieldsStream);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/lucene/src/java/org/apache/lucene/index/FieldsWriter;writeField(FieldInfo,Fieldable);;final void writeField(FieldInfo fi, Fieldable field) throws IOException {
      fieldsStream.writeVInt(fi.number);
      byte bits = 0;
      if (field.isTokenized())
        bits |= FieldsWriter.FIELD_IS_TOKENIZED;
      if (field.isBinary())
        bits |= FieldsWriter.FIELD_IS_BINARY;
                
      fieldsStream.writeByte(bits);
                
      if (field.isBinary()) {
        final byte[] data;
        final int len;
        final int offset;
        data = field.getBinaryValue();
        len = field.getBinaryLength();
        offset =  field.getBinaryOffset();

        fieldsStream.writeVInt(len);
        fieldsStream.writeBytes(data, offset, len);
      }
      else {
        fieldsStream.writeString(field.stringValue());
      }
    };final void writeField(FieldInfo fi, Fieldable field) throws IOException {
    fieldsStream.writeVInt(fi.number);
    byte bits = 0;
    if (field.isTokenized())
      bits |= FieldsWriter.FIELD_IS_TOKENIZED;
    if (field.isBinary())
      bits |= FieldsWriter.FIELD_IS_BINARY;

    fieldsStream.writeByte(bits);

    if (field.isBinary()) {
      final byte[] data;
      final int len;
      final int offset;
      data = field.getBinaryValue();
      len = field.getBinaryLength();
      offset =  field.getBinaryOffset();

      fieldsStream.writeVInt(len);
      fieldsStream.writeBytes(data, offset, len);
    }
    else {
      fieldsStream.writeString(field.stringValue());
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;_testMultipleThreadsFailure(MockRAMDirectory.Failure);;public void _testMultipleThreadsFailure(MockRAMDirectory.Failure failure) throws Exception {

    int NUM_THREADS = 3;

    for(int iter=0;iter<2;iter++) {
      MockRAMDirectory dir = new MockRAMDirectory();
      IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT,
          new MockAnalyzer()).setMaxBufferedDocs(2);
      // We expect disk full exceptions in the merge threads
      ((ConcurrentMergeScheduler) conf.getMergeScheduler()).setSuppressExceptions();
      IndexWriter writer = new IndexWriter(dir, conf);
      ((LogMergePolicy) writer.getConfig().getMergePolicy()).setMergeFactor(4);

      IndexerThread[] threads = new IndexerThread[NUM_THREADS];

      for(int i=0;i<NUM_THREADS;i++)
        threads[i] = new IndexerThread(writer, true);

      for(int i=0;i<NUM_THREADS;i++)
        threads[i].start();

      Thread.sleep(10);

      dir.failOn(failure);
      failure.setDoFail();

      for(int i=0;i<NUM_THREADS;i++) {
        threads[i].join();
        assertTrue("hit unexpected Throwable", threads[i].error == null);
      }

      boolean success = false;
      try {
        writer.close(false);
        success = true;
      } catch (IOException ioe) {
        failure.clearDoFail();
        writer.close(false);
      }

      if (success) {
        IndexReader reader = IndexReader.open(dir, true);
        for(int j=0;j<reader.maxDoc();j++) {
          if (!reader.isDeleted(j)) {
            reader.document(j);
            reader.getTermFreqVectors(j);
          }
        }
        reader.close();
      }

      dir.close();
    }
  };public void _testMultipleThreadsFailure(MockRAMDirectory.Failure failure) throws Exception {

    int NUM_THREADS = 3;

    for(int iter=0;iter<2;iter++) {
      MockRAMDirectory dir = new MockRAMDirectory();
      IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT,
          new MockAnalyzer()).setMaxBufferedDocs(2);
      // We expect disk full exceptions in the merge threads
      ((ConcurrentMergeScheduler) conf.getMergeScheduler()).setSuppressExceptions();
      IndexWriter writer = new IndexWriter(dir, conf);
      ((LogMergePolicy) writer.getConfig().getMergePolicy()).setMergeFactor(4);

      IndexerThread[] threads = new IndexerThread[NUM_THREADS];

      for(int i=0;i<NUM_THREADS;i++)
        threads[i] = new IndexerThread(writer, true);

      for(int i=0;i<NUM_THREADS;i++)
        threads[i].start();

      Thread.sleep(10);

      dir.failOn(failure);
      failure.setDoFail();

      for(int i=0;i<NUM_THREADS;i++) {
        threads[i].join();
        assertTrue("hit unexpected Throwable ", threads[i].error == null);
      }

      boolean success = false;
      try {
        writer.close(false);
        success = true;
      } catch (IOException ioe) {
        failure.clearDoFail();
        writer.close(false);
      }

      if (success) {
        IndexReader reader = IndexReader.open(dir, true);
        for(int j=0;j<reader.maxDoc();j++) {
          if (!reader.isDeleted(j)) {
            reader.document(j);
            reader.getTermFreqVectors(j);
          }
        }
        reader.close();
      }

      dir.close();
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49;/src/java/voldemort/VoldemortAdminTool;executeFetchEntries(Integer,AdminClient,List<Integer>,String,List<String>,boolean);;@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null,
												           false);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    };@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null,
                                                                                                           false);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49;/src/java/voldemort/VoldemortAdminTool;readEntriesAscii(File,String,StoreDefinition);;private static Iterator<Pair<ByteArray,Versioned<byte[]>>> readEntriesAscii(File inputDir,
                                                                                String storeName,
                                                                                StoreDefinition storeDefinition)
                   throws IOException {
        File inputFile = new File(inputDir, storeName + ".entries");
        if (!inputFile.exists()) {
            throw new FileNotFoundException("File " + inputFile.getAbsolutePath() + " does not exist!");
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>> () {
            @Override
            protected Pair<ByteArray, Versioned<byte[]>> computeNext() {
                System.err.println("Updating stores from ASCII/JSON data is not yet supported!");
                return endOfData();
            }
        };
    };private static Iterator<Pair<ByteArray,Versioned<byte[]>>> readEntriesAscii(File inputDir,
                                                                                String storeName,
                                                                                StoreDefinition storeDefinition)
                   throws IOException {
        File inputFile = new File(inputDir, storeName + ".entries");
        if(!inputFile.exists()) {
            throw new FileNotFoundException("File " + inputFile.getAbsolutePath() + " does not exist!");
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>> () {

            @Override
            protected Pair<ByteArray, Versioned<byte[]>> computeNext() {
                System.err.println("Updating stores from ASCII/JSON data is not yet supported!");
                return endOfData();
            }
        };
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getAll();;public List<Object> getAll() {
        return getAll(0);
    };public List<Object> getAll() {
	return getAll(0);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;startPollingForServiceUninstallLifecycleEvents(String,String,int);;private UUID startPollingForServiceUninstallLifecycleEvents(final String applicationName, final String serviceName,
			final int timeoutInMinutes) {
		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName, timeoutInMinutes, TimeUnit.MINUTES);
		restPollingRunnable.addService(serviceName, 0);
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);

		final ScheduledFuture<?> scheduleWithFixedDelay =
				scheduledExecutor.scheduleWithFixedDelay(restPollingRunnable, 0, LIFECYCLE_EVENT_POLLING_INTERVAL_SEC,
						TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID, restPollingRunnable);
		logger.log(Level.INFO, "polling container UUID is " + lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;
	};private UUID startPollingForServiceUninstallLifecycleEvents(
			final String applicationName, final String serviceName,
			final int timeoutInMinutes) {
		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName,
				timeoutInMinutes, TimeUnit.MINUTES);
		restPollingRunnable.addService(serviceName, 0);
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable
				.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);

		final ScheduledFuture<?> scheduleWithFixedDelay = scheduledExecutor
				.scheduleWithFixedDelay(restPollingRunnable, 0,
						LIFECYCLE_EVENT_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID,
				restPollingRunnable);
		logger.log(Level.INFO, "polling container UUID is "
				+ lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;startPollingForApplicationUninstallLifecycleEvents(String,List<ProcessingUnit>,int);;private UUID startPollingForApplicationUninstallLifecycleEvents(final String applicationName,
			final List<ProcessingUnit> uninstallOrder, final int timeoutInMinutes) {

		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName, timeoutInMinutes, TimeUnit.MINUTES);
		for (final ProcessingUnit processingUnit : uninstallOrder) {
			final String processingUnitName = processingUnit.getName();
			final String serviceName = ServiceUtils.getApplicationServiceName(processingUnitName, applicationName);
			restPollingRunnable.addService(serviceName, 0);
		}
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID, restPollingRunnable);
		final ScheduledFuture<?> scheduleWithFixedDelay =
				scheduledExecutor.scheduleWithFixedDelay(restPollingRunnable, 0, LIFECYCLE_EVENT_POLLING_INTERVAL_SEC,
						TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);

		logger.log(Level.INFO, "polling container UUID is " + lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;

	};private UUID startPollingForApplicationUninstallLifecycleEvents(
			final String applicationName,
			final List<ProcessingUnit> uninstallOrder,
			final int timeoutInMinutes) {

		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName,
				timeoutInMinutes, TimeUnit.MINUTES);
		for (final ProcessingUnit processingUnit : uninstallOrder) {
			final String processingUnitName = processingUnit.getName();
			final String serviceName = ServiceUtils.getApplicationServiceName(
					processingUnitName, applicationName);
			restPollingRunnable.addService(serviceName, 0);
		}
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable
				.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID,
				restPollingRunnable);
		final ScheduledFuture<?> scheduleWithFixedDelay = scheduledExecutor
				.scheduleWithFixedDelay(restPollingRunnable, 0,
						LIFECYCLE_EVENT_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);

		logger.log(Level.INFO, "polling container UUID is "
				+ lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;

	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_5d010_18d30/rev_5d010-18d30;/handler/src/test/java/io/netty/handler/ipfilter/IpFilterRuleTest;testIpFilterRule();;@Test
    public void testIpFilterRule() throws Exception
    {
        IpFilterRuleHandler h = new IpFilterRuleHandler();
        h.addAll(new IpFilterRuleList("+n:localhost, -n:*"));
        InetSocketAddress addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));
        
        h.clear();
        h.addAll(new IpFilterRuleList("+n:*"+InetAddress.getLocalHost().getHostName().substring(1)+", -n:*"));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        h.addAll(new IpFilterRuleList("+c:"+InetAddress.getLocalHost().getHostAddress()+"/32, -n:*"));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        h.addAll(new IpFilterRuleList(""));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

    };@Test
    public void testIpFilterRule() throws Exception {
        IpFilterRuleHandler h = new IpFilterRuleHandler();
        h.addAll(new IpFilterRuleList("+n:localhost, -n:*"));
        InetSocketAddress addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        h.addAll(new IpFilterRuleList("+n:*" + InetAddress.getLocalHost().getHostName().substring(1) + ", -n:*"));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        h.addAll(new IpFilterRuleList("+c:" + InetAddress.getLocalHost().getHostAddress() + "/32, -n:*"));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertFalse(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        h.addAll(new IpFilterRuleList(""));
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

        h.clear();
        addr = new InetSocketAddress(InetAddress.getLocalHost(), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName("127.0.0.2"), 8080);
        assertTrue(accept(h, addr));
        addr = new InetSocketAddress(InetAddress.getByName(InetAddress.getLocalHost().getHostName()), 8080);
        assertTrue(accept(h, addr));

    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/SecurityToFixedIncomeFutureDefinitionConverter;visitBondFutureSecurity(BondFutureSecurity);;@Override
  public FixedIncomeFutureInstrumentDefinition<?> visitBondFutureSecurity(final BondFutureSecurity security) {
    Validate.notNull(security, "security");
    if (_underlyingConverter == null) {
      _underlyingConverter = new SecurityToFixedIncomeDefinitionConverter(_holidaySource, _conventionSource, _regionSource);
    }
//    final LocalDate deliveryDateLD = null; //deliveryDate.toLocalDate();
//    final List<BondFutureDeliverable> deliverableBasket = security.getBasket();
//    final int n = deliverableBasket.size();
//    final BondDefinition[] deliverableBonds = new BondDefinition[n];
//    final double[] conversionFactors = new double[n];
//    final int i = 0;
//    for (final BondFutureDeliverable bfd : deliverableBasket) {
//      final BondSecurity underlyingBond = null;
//      final LocalDate lastTradeDate = underlyingBond.getLastTradeDate().getExpiry().toLocalDate();
//      Validate.isTrue(deliveryDateLD.isBefore(lastTradeDate), "The bond has expired before delivery");
//      //TODO bond futures are exchange-traded - check that this is the same calendar for the exchange as the currency
//      final Calendar calendar = new HolidaySourceCalendarAdapter(_holidaySource, security.getCurrency());
//      final Currency currency = security.getCurrency();
//      final String conventionName = currency + "_BOND_FUTURE_DELIVERABLE_CONVENTION";
//      final Identifier id = Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, conventionName);
//      final ConventionBundle conventionBundle = _conventionSource.getConventionBundle(id);
//      Validate.notNull(conventionBundle, "convention bundle " + conventionName);
//      final BusinessDayConvention businessDayConvention = conventionBundle.getBusinessDayConvention();
      //final BondDefinition deliverable = (BondDefinition) _underlyingConverter.visitBondSecurity(underlyingBond, conventionBundle);
      //final BondConvention bondForwardConvention = new BondConvention(conventionBundle.getSettlementDays(), conventionBundle.getDayCount(), businessDayConvention, calendar,
      //    conventionBundle.isEOMConvention(), conventionName, conventionBundle.getExDividendDays(), conventionBundle.getYieldConvention());

//    }
    return null; //new BondForwardDefinition(underlyingBond, deliveryDate.toLocalDate(), bondForwardConvention);
  };@Override
  public FixedIncomeFutureInstrumentDefinition<?> visitBondFutureSecurity(final BondFutureSecurity security) {
    Validate.notNull(security, "security");
    if (_underlyingConverter == null) {
      _underlyingConverter = new SecurityToFixedIncomeDefinitionConverter(_holidaySource, _conventionSource, _regionSource);
    }
    //    final LocalDate deliveryDateLD = null; //deliveryDate.toLocalDate();
    //    final List<BondFutureDeliverable> deliverableBasket = security.getBasket();
    //    final int n = deliverableBasket.size();
    //    final BondDefinition[] deliverableBonds = new BondDefinition[n];
    //    final double[] conversionFactors = new double[n];
    //    final int i = 0;
    //    for (final BondFutureDeliverable bfd : deliverableBasket) {
    //      final BondSecurity underlyingBond = null;
    //      final LocalDate lastTradeDate = underlyingBond.getLastTradeDate().getExpiry().toLocalDate();
    //      Validate.isTrue(deliveryDateLD.isBefore(lastTradeDate), "The bond has expired before delivery");
    //      //TODO bond futures are exchange-traded - check that this is the same calendar for the exchange as the currency
    //      final Calendar calendar = new HolidaySourceCalendarAdapter(_holidaySource, security.getCurrency());
    //      final Currency currency = security.getCurrency();
    //      final String conventionName = currency + "_BOND_FUTURE_DELIVERABLE_CONVENTION";
    //      final Identifier id = Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, conventionName);
    //      final ConventionBundle conventionBundle = _conventionSource.getConventionBundle(id);
    //      Validate.notNull(conventionBundle, "convention bundle " + conventionName);
    //      final BusinessDayConvention businessDayConvention = conventionBundle.getBusinessDayConvention();
    //final BondDefinition deliverable = (BondDefinition) _underlyingConverter.visitBondSecurity(underlyingBond, conventionBundle);
    //final BondConvention bondForwardConvention = new BondConvention(conventionBundle.getSettlementDays(), conventionBundle.getDayCount(), businessDayConvention, calendar,
    //    conventionBundle.isEOMConvention(), conventionName, conventionBundle.getExDividendDays(), conventionBundle.getYieldConvention());

    //    }
    return null; //new BondForwardDefinition(underlyingBond, deliveryDate.toLocalDate(), bondForwardConvention);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_6dd24_ae1ff/rev_6dd24-ae1ff;/src/test/java/org/junit/tests/running/classes/TestClassTest;methodToBeMatched();;@Ignore
    	@Test
    	public String methodToBeMatched() { 
    		return "jupiter";
    	};@Ignore
    	@Test
    	public String methodToBeMatched() {
    		return "jupiter";
    	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718;/core/src/com/google/inject/spi/InjectionPoint;forStaticMethodsAndFields(TypeLiteral<?>);;public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral<?> type) {
    Errors errors = new Errors();
    
    Set<InjectionPoint> result;
    
    if (type.getRawType().isInterface()) {
      errors.staticInjectionOnInterface(type.getRawType());
      result = null;
    } else {
      result = getInjectionPoints(type, true, errors);
    }
    
    if (errors.hasErrors()) {
      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
  };public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral<?> type) {
    Errors errors = new Errors();

    Set<InjectionPoint> result;

    if (type.getRawType().isInterface()) {
      errors.staticInjectionOnInterface(type.getRawType());
      result = null;
    } else {
      result = getInjectionPoints(type, true, errors);
    }

    if (errors.hasErrors()) {
      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718;/core/src/com/google/inject/spi/InjectionPoint;removeIfOverriddenBy(Method,boolean,InjectableMethod);;boolean removeIfOverriddenBy(Method method, boolean alwaysRemove, 
        InjectableMethod injectableMethod) {
      if (position == Position.TOP) {
        // If we're at the top of the hierarchy, there's nothing to override.
        return false;
      }

      if (bySignature == null) {
        // We encountered a method in a subclass. Time to index the
        // methods in the parent class.
        bySignature = new HashMap<Signature, List<InjectableMethod>>();
        for (InjectableMember member = injectableMembers.head; member != null;
            member = member.next) {
          if (!(member instanceof InjectableMethod)) continue;
          InjectableMethod im = (InjectableMethod) member;
          if (im.isFinal()) continue;
          List<InjectableMethod> methods = new ArrayList<InjectableMethod>();
          methods.add(im);
          bySignature.put(new Signature(im.method), methods);
        }
      }

      lastMethod = method;
      Signature signature = lastSignature = new Signature(method);
      List<InjectableMethod> methods = bySignature.get(signature);
      boolean removed = false;
      if (methods != null) {
        for (Iterator<InjectableMethod> iterator = methods.iterator();
            iterator.hasNext();) {
          InjectableMethod possiblyOverridden = iterator.next();
          if (overrides(method, possiblyOverridden.method)) {
            boolean wasGuiceInject =
              !possiblyOverridden.jsr330 || possiblyOverridden.overrodeGuiceInject;
            if(injectableMethod != null) {
              injectableMethod.overrodeGuiceInject = wasGuiceInject;
            }
            // Only actually remove the methods if we want to force
            // remove or if the signature never specified @com.google.inject.Inject
            // somewhere.
            if(alwaysRemove || !wasGuiceInject) {
              removed = true;
              iterator.remove();
              injectableMembers.remove(possiblyOverridden);
            }
          }
        }
      }
      return removed;
    };boolean removeIfOverriddenBy(Method method, boolean alwaysRemove,
        InjectableMethod injectableMethod) {
      if (position == Position.TOP) {
        // If we're at the top of the hierarchy, there's nothing to override.
        return false;
      }

      if (bySignature == null) {
        // We encountered a method in a subclass. Time to index the
        // methods in the parent class.
        bySignature = new HashMap<Signature, List<InjectableMethod>>();
        for (InjectableMember member = injectableMembers.head; member != null;
            member = member.next) {
          if (!(member instanceof InjectableMethod)) continue;
          InjectableMethod im = (InjectableMethod) member;
          if (im.isFinal()) continue;
          List<InjectableMethod> methods = new ArrayList<InjectableMethod>();
          methods.add(im);
          bySignature.put(new Signature(im.method), methods);
        }
      }

      lastMethod = method;
      Signature signature = lastSignature = new Signature(method);
      List<InjectableMethod> methods = bySignature.get(signature);
      boolean removed = false;
      if (methods != null) {
        for (Iterator<InjectableMethod> iterator = methods.iterator();
            iterator.hasNext();) {
          InjectableMethod possiblyOverridden = iterator.next();
          if (overrides(method, possiblyOverridden.method)) {
            boolean wasGuiceInject =
              !possiblyOverridden.jsr330 || possiblyOverridden.overrodeGuiceInject;
            if(injectableMethod != null) {
              injectableMethod.overrodeGuiceInject = wasGuiceInject;
            }
            // Only actually remove the methods if we want to force
            // remove or if the signature never specified @com.google.inject.Inject
            // somewhere.
            if(alwaysRemove || !wasGuiceInject) {
              removed = true;
              iterator.remove();
              injectableMembers.remove(possiblyOverridden);
            }
          }
        }
      }
      return removed;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718;/core/src/com/google/inject/spi/InjectionPoint;hierarchyFor(TypeLiteral<?>);;private static List<TypeLiteral<?>> hierarchyFor(TypeLiteral<?> type) {
    List<TypeLiteral<?>> hierarchy = new ArrayList<TypeLiteral<?>>();
    TypeLiteral<?> current = type;
    while (current.getRawType() != Object.class) {
      hierarchy.add(current);
      current = current.getSupertype(current.getRawType().getSuperclass());
    }
    return hierarchy;
  };private static List<TypeLiteral<?>> hierarchyFor(TypeLiteral<?> type) {
    List<TypeLiteral<?>> hierarchy = new ArrayList<TypeLiteral<?>>();
    TypeLiteral<?> current = type;
    while (current.getRawType() != Object.class) {
      hierarchy.add(current);
      current = current.getSupertype(current.getRawType().getSuperclass());
    }
    return hierarchy;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7a14d_87efa/rev_7a14d-87efa;/tests/unit/com/opengamma/engine/client/merging/RateLimitingMergingUpdateProviderTest;testPassThrough();;@Test
  public void testPassThrough() {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), new Timer("Custom timer"));
    
    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);
    
    // OK, it doesn't really test the 'synchronous' bit, but it at least checks that no merging has happened.
    addResults(provider, 1000);
    assertEquals(1000, testListener.consumeResults().size());
    
    provider.setPaused(true);
    addResults(provider, 1000);
    assertEquals(0, testListener.consumeResults().size());
    provider.setPaused(false);
    assertEquals(1, testListener.consumeResults().size());
    
    provider.setPaused(false);
    addResults(provider, 1000);
    assertEquals(1000, testListener.consumeResults().size());
    
    provider.destroy();
  };@Test
  public void testPassThrough() {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), new Timer(
        "Custom timer"));

    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);

    // OK, it doesn't really test the 'synchronous' bit, but it at least checks that no merging has happened.
    addResults(provider, 1000);
    assertEquals(1000, testListener.consumeResults().size());

    provider.setPaused(true);
    addResults(provider, 1000);
    assertEquals(0, testListener.consumeResults().size());
    provider.setPaused(false);
    assertEquals(1, testListener.consumeResults().size());

    provider.setPaused(false);
    addResults(provider, 1000);
    assertEquals(1000, testListener.consumeResults().size());

    provider.destroy();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7a14d_87efa/rev_7a14d-87efa;/tests/unit/com/opengamma/engine/client/merging/RateLimitingMergingUpdateProviderTest;testMergingWhenRateLimiting();;@Test
  public void testMergingWhenRateLimiting() throws InterruptedException {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), 500);
    
    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);
    
    addResults(provider, 1000);
    Thread.sleep(500);
    assertEquals(1, testListener.consumeResults().size());
    
    provider.destroy();
  };@Test
  public void testMergingWhenRateLimiting() throws InterruptedException {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), 500);

    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);

    addResults(provider, 1000);
    Thread.sleep(500);
    assertEquals(1, testListener.consumeResults().size());

    provider.destroy();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7a14d_87efa/rev_7a14d-87efa;/tests/unit/com/opengamma/engine/client/merging/RateLimitingMergingUpdateProviderTest;testModifiableUpdatePeriod();;@Test
  public void testModifiableUpdatePeriod() throws InterruptedException {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), 500);
    
    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);
    
    assertCorrectUpdateRate(provider, testListener, 100);
    assertCorrectUpdateRate(provider, testListener, 400);
    assertCorrectUpdateRate(provider, testListener, 50);
    
    provider.destroy();
  };@Test
  public void testModifiableUpdatePeriod() throws InterruptedException {
    RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider = new RateLimitingMergingUpdateProvider<ViewComputationResultModel>(new ViewComputationResultModelMerger(), 500);

    TestMergingUpdateListener testListener = new TestMergingUpdateListener();
    provider.addUpdateListener(testListener);

    assertCorrectUpdateRate(provider, testListener, 100);
    assertCorrectUpdateRate(provider, testListener, 400);
    assertCorrectUpdateRate(provider, testListener, 50);

    provider.destroy();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7a14d_87efa/rev_7a14d-87efa;/tests/unit/com/opengamma/engine/client/merging/RateLimitingMergingUpdateProviderTest;assertCorrectUpdateRate(RateLimitingMergingUpdateProvider<ViewComputationResultModel>,TestMergingUpdateListener,int);;private void assertCorrectUpdateRate(RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider, TestMergingUpdateListener testListener, int period) throws InterruptedException {
    provider.setMinimumUpdatePeriodMillis(period);
    testUpdateRate(provider, testListener, period);
    
    // If the provider is paused then all updates should be merged regardless of the time elapsed or the rate
    provider.setPaused(true);
    for (int i = 0; i < 3; i++) {
      addResults(provider, 10);
      Thread.sleep(period);
    }
    assertEquals(0, testListener.consumeResults().size());
    provider.setPaused(false);
    Thread.sleep(2 * period);
    assertEquals(1, testListener.consumeResults().size());
    
    // Once unpaused, everything should be back to normal
    testUpdateRate(provider, testListener, period);
  };private void assertCorrectUpdateRate(RateLimitingMergingUpdateProvider<ViewComputationResultModel> provider, TestMergingUpdateListener testListener, int period) throws InterruptedException {
    provider.setMinimumUpdatePeriodMillis(period);
    testUpdateRate(provider, testListener, period);

    // If the provider is paused then all updates should be merged regardless of the time elapsed or the rate
    provider.setPaused(true);
    for (int i = 0; i < 3; i++) {
      addResults(provider, 10);
      Thread.sleep(period);
    }
    assertEquals(0, testListener.consumeResults().size());
    provider.setPaused(false);
    Thread.sleep(2 * period);
    assertEquals(1, testListener.consumeResults().size());

    // Once unpaused, everything should be back to normal
    testUpdateRate(provider, testListener, period);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7b3fb_6494c/rev_7b3fb-6494c;/projects/OG-Examples/src/main/java/com/opengamma/examples/function/ExampleStandardFunctionConfiguration;addHistoricalDataFunctions(List<FunctionConfiguration>,String);;protected static void addHistoricalDataFunctions(final List<FunctionConfiguration> functionConfigs, final String requirementName) {
    addUnitScalingFunction(functionConfigs, requirementName);
    functionConfigs.add(functionConfiguration(LastHistoricalValueFunction.class, requirementName));
//    functionConfigs.add(functionConfiguration(HistoricalTimeSeriesFunction.class));
//    functionConfigs.add(functionConfiguration(HistoricalTimeSeriesLatestValueFunction.class));
//    functionConfigs.add(functionConfiguration(YieldCurveHistoricalTimeSeriesFunction.class));
//    functionConfigs.add(functionConfiguration(YieldCurveInstrumentConversionHistoricalTimeSeriesFunction.class));
//    functionConfigs.add(functionConfiguration(YieldCurveInstrumentConversionHistoricalTimeSeriesFunctionDeprecated.class));
  };protected static void addHistoricalDataFunctions(final List<FunctionConfiguration> functionConfigs, final String requirementName) {
    addUnitScalingFunction(functionConfigs, requirementName);
    functionConfigs.add(functionConfiguration(LastHistoricalValueFunction.class, requirementName));
    //    functionConfigs.add(functionConfiguration(HistoricalTimeSeriesFunction.class));
    //    functionConfigs.add(functionConfiguration(HistoricalTimeSeriesLatestValueFunction.class));
    //    functionConfigs.add(functionConfiguration(YieldCurveHistoricalTimeSeriesFunction.class));
    //    functionConfigs.add(functionConfiguration(YieldCurveInstrumentConversionHistoricalTimeSeriesFunction.class));
    //    functionConfigs.add(functionConfiguration(YieldCurveInstrumentConversionHistoricalTimeSeriesFunctionDeprecated.class));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7f2c9_148a3/rev_7f2c9-148a3;/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedFundingAndForwardCurveFunction;getInterestRateDerivative(FixedIncomeStrip,Calendar,Region,LocalDate,double);;private InterestRateDerivative getInterestRateDerivative(final FixedIncomeStrip strip, final Calendar calendar, final Region region, final LocalDate now, final double rateOrPrice) {
    if (strip.getInstrumentType() == StripInstrument.SWAP) {
      return getSwap(strip, calendar, region, now, rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.CASH) {
      return getCash(strip, calendar, now,rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.FRA) {
      return getFRA(strip, calendar, now,rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.FUTURE) {
      return getIRFuture(strip, calendar, now,rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.LIBOR) {
      return getLibor(strip, calendar, now,rateOrPrice);
    }
    return null;
  };private InterestRateDerivative getInterestRateDerivative(final FixedIncomeStrip strip, final Calendar calendar, final Region region, final LocalDate now, final double rateOrPrice) {
    if (strip.getInstrumentType() == StripInstrument.SWAP) {
      return getSwap(strip, calendar, region, now, rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.CASH) {
      return getCash(strip, calendar, now, rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.FRA) {
      return getFRA(strip, calendar, now, rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.FUTURE) {
      return getIRFuture(strip, calendar, now, rateOrPrice);
    } else if (strip.getInstrumentType() == StripInstrument.LIBOR) {
      return getLibor(strip, calendar, now, rateOrPrice);
    }
    return null;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7f2c9_148a3/rev_7f2c9-148a3;/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedFundingAndForwardCurveFunction;getSwap(FixedIncomeStrip,Calendar,Region,LocalDate,double);;private FixedFloatSwap getSwap(final FixedIncomeStrip swapStrip, final Calendar calendar, final Region region, final LocalDate now, final double swapRate) {
    final BusinessDayConvention convention = swapStrip.getBusinessDayConvention();
    final ZonedDateTime effectiveDate = swapStrip.getStartDate().atStartOfDayInZone(TimeZone.UTC); //TODO change this
    final ZonedDateTime maturityDate = swapStrip.getEndDate().atStartOfDayInZone(TimeZone.UTC); //TODO change this
    final Frequency frequency = PeriodFrequency.SEMI_ANNUAL; //TODO change this
    final DayCount dayCount = swapStrip.getDayCount();
    final ZonedDateTime[] unadjustedDates = ScheduleCalculator.getUnadjustedDateSchedule(effectiveDate, maturityDate, frequency);
    final ZonedDateTime[] adjustedDates = ScheduleCalculator.getAdjustedDateSchedule(unadjustedDates, convention, calendar);
    final double[] swapPaymentDates = ScheduleCalculator.getTimes(adjustedDates, dayCount, now.atStartOfDayInZone(TimeZone.UTC));
    final int n = swapPaymentDates.length;
    final double[] delta = new double[n];
    for (int i = 0; i < n; i++) {
      delta[i] = 0;
    }
    return new FixedFloatSwap(swapPaymentDates,  swapPaymentDates, swapRate,delta, delta, FUNDING_CURVE_NAME, LIBOR_CURVE_NAME);
  };private FixedFloatSwap getSwap(final FixedIncomeStrip swapStrip, final Calendar calendar, final Region region, final LocalDate now, final double swapRate) {
    final BusinessDayConvention convention = swapStrip.getBusinessDayConvention();
    final ZonedDateTime effectiveDate = swapStrip.getStartDate().atStartOfDayInZone(TimeZone.UTC); //TODO change this
    final ZonedDateTime maturityDate = swapStrip.getEndDate().atStartOfDayInZone(TimeZone.UTC); //TODO change this
    final Frequency frequency = PeriodFrequency.SEMI_ANNUAL; //TODO change this
    final DayCount dayCount = swapStrip.getDayCount();
    final ZonedDateTime[] unadjustedDates = ScheduleCalculator.getUnadjustedDateSchedule(effectiveDate, maturityDate, frequency);
    final ZonedDateTime[] adjustedDates = ScheduleCalculator.getAdjustedDateSchedule(unadjustedDates, convention, calendar);
    final double[] swapPaymentDates = ScheduleCalculator.getTimes(adjustedDates, dayCount, now.atStartOfDayInZone(TimeZone.UTC));
    final int n = swapPaymentDates.length;
    final double[] delta = new double[n];
    for (int i = 0; i < n; i++) {
      delta[i] = 0;
    }
    return new FixedFloatSwap(swapPaymentDates,  swapPaymentDates, swapRate, delta, delta, FUNDING_CURVE_NAME, LIBOR_CURVE_NAME);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_9d6c3_e80de/rev_9d6c3-e80de;/projects/OG-Bloomberg/src/com/opengamma/bbg/EHCachingReferenceDataProvider;persistSecurityFields(PerSecurityReferenceDataResult);;@Override
  protected void persistSecurityFields(PerSecurityReferenceDataResult securityResult) {
    String securityKey = securityResult.getSecurity();
    FudgeMsg fieldData = securityResult.getFieldData();
    
    if (securityKey != null && fieldData != null) {
      s_logger.info("Persisting fields for \"{}\": {}", securityKey, securityResult.getFieldData());
      CachedPerSecurityReferenceDataResult cachedObject = createCachedObject(securityResult);
      s_logger.debug("cachedObject={}", cachedObject);
      Element element = new Element(securityKey, cachedObject);
      _cache.put(element);
    }
  };@Override
  protected void persistSecurityFields(PerSecurityReferenceDataResult securityResult) {
    String securityKey = securityResult.getSecurity();
    FudgeMsg fieldData = securityResult.getFieldData();

    if (securityKey != null && fieldData != null) {
      s_logger.info("Persisting fields for \"{}\": {}", securityKey, securityResult.getFieldData());
      CachedPerSecurityReferenceDataResult cachedObject = createCachedObject(securityResult);
      s_logger.debug("cachedObject={}", cachedObject);
      Element element = new Element(securityKey, cachedObject);
      _cache.put(element);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9f36c_673f8/rev_9f36c-673f8;/src/java/org/apache/cassandra/utils/FBUtilities;byteBufferToInt(ByteBuffer);;public static int byteBufferToInt(ByteBuffer bytes)
    {
        if (bytes.remaining() < 4 )
        {
            throw new IllegalArgumentException("An integer must be 4 bytes in size.");
        }
        int n = 0;
        for ( int i = 0; i < 4; ++i )
        {
            n <<= 8;
            n |= bytes.get(bytes.position() + i) & 0xFF;
        }
        return n;
    };public static int byteBufferToInt(ByteBuffer bytes)
    {
        if (bytes.remaining() < 4)
        {
            throw new IllegalArgumentException("An integer must be 4 bytes in size.");
        }
        int n = 0;
        for (int i = 0; i < 4; ++i)
        {
            n <<= 8;
            n |= bytes.get(bytes.position() + i) & 0xFF;
        }
        return n;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_14a74_b79ae/rev_14a74-b79ae;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/fra/ZZZForwardRateAgreementDefinitionTest;toDerivativeFixed();;@Test
  public void toDerivativeFixed() {
    final ZonedDateTime referenceFixed = DateUtil.getUTCDate(2011, 1, 4);
    final ZZZForwardRateAgreementDefinition fraFixed = new ZZZForwardRateAgreementDefinition(CUR, PAYMENT_DATE, ACCRUAL_START_DATE, ACCRUAL_END_DATE, ACCRUAL_FACTOR_PAYMENT, NOTIONAL, FIXING_DATE,
        INDEX,
        FRA_RATE);
    final double shift = 0.01;
    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {FIXING_DATE}, new double[] {FRA_RATE + shift});
    //fraFixed.fixingProcess(FRA_RATE + shift);
    final DayCount actAct = DayCountFactory.INSTANCE.getDayCount("Actual/Actual ISDA");
    final ZonedDateTime zonedDate = ZonedDateTime.of(LocalDateTime.ofMidnight(referenceFixed), TimeZone.UTC);
    final double paymentTime = actAct.getDayCountFraction(zonedDate, PAYMENT_DATE);
    final String fundingCurve = "Funding";
    final String forwardCurve = "Forward";
    final String[] curves = {fundingCurve, forwardCurve};
    final CouponFixed fra = new CouponFixed(CUR, paymentTime, fundingCurve, ACCRUAL_FACTOR_PAYMENT, NOTIONAL, (FRA_RATE + shift) - FRA_RATE);
    final Payment convertedFra = fraFixed.toDerivative(referenceFixed, fixingTS, curves);
    assertEquals(convertedFra.equals(fra), true);
  };@Test
  public void toDerivativeFixed() {
    final ZonedDateTime referenceFixed = DateUtil.getUTCDate(2011, 1, 4);
    final ZZZForwardRateAgreementDefinition fraFixed = new ZZZForwardRateAgreementDefinition(CUR, PAYMENT_DATE, ACCRUAL_START_DATE, ACCRUAL_END_DATE, ACCRUAL_FACTOR_PAYMENT, NOTIONAL, FIXING_DATE,
        INDEX, FRA_RATE);
    final double shift = 0.01;
    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {FIXING_DATE}, new double[] {FRA_RATE + shift});
    //fraFixed.fixingProcess(FRA_RATE + shift);
    final DayCount actAct = DayCountFactory.INSTANCE.getDayCount("Actual/Actual ISDA");
    final ZonedDateTime zonedDate = ZonedDateTime.of(LocalDateTime.ofMidnight(referenceFixed), TimeZone.UTC);
    final double paymentTime = actAct.getDayCountFraction(zonedDate, PAYMENT_DATE);
    final String fundingCurve = "Funding";
    final String forwardCurve = "Forward";
    final String[] curves = {fundingCurve, forwardCurve};
    final CouponFixed fra = new CouponFixed(CUR, paymentTime, fundingCurve, ACCRUAL_FACTOR_PAYMENT, NOTIONAL, (FRA_RATE + shift) - FRA_RATE);
    final Payment convertedFra = fraFixed.toDerivative(referenceFixed, fixingTS, curves);
    assertEquals(convertedFra.equals(fra), true);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_25c55_5c709/rev_25c55-5c709;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,ComputationTargetSpecification,String,InterpolatedYieldCurveSpecificationWithSecurities,Map<ExternalId,Double>,boolean,boolean,boolean);;private Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final ComputationTargetSpecification targetSpec, final String curveName,
      final InterpolatedYieldCurveSpecificationWithSecurities specificationWithSecurities, final Map<ExternalId, Double> marketDataMap, final boolean createYieldCurve,
      final boolean createJacobian, final boolean createSensitivities) {
    final Clock snapshotClock = executionContext.getValuationClock();
    final ZonedDateTime now = snapshotClock.zonedDateTime();
    final HistoricalTimeSeriesSource dataSource = OpenGammaExecutionContext.getHistoricalTimeSeriesSource(executionContext);
    final List<InstrumentDerivative> derivatives = new ArrayList<InstrumentDerivative>();
    final int n = specificationWithSecurities.getStrips().size();
    final double[] initialRatesGuess = new double[n];
    final double[] nodeTimes = new double[n];
    final double[] marketValues = new double[n];
    int i = 0;
    for (final FixedIncomeStripWithSecurity strip : specificationWithSecurities.getStrips()) {
      final Double marketValue = marketDataMap.get(strip.getSecurityIdentifier());
      if (marketValue == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      InstrumentDerivative derivative;
      final FinancialSecurity financialSecurity = (FinancialSecurity) strip.getSecurity();
      final String[] curveNames = FixedIncomeInstrumentCurveExposureHelper.getCurveNamesForFundingCurveInstrument(strip.getInstrumentType(), curveName, curveName);
      final InstrumentDefinition<?> definition = getSecurityConverter().visit(financialSecurity);
      derivative = getDefinitionConverter().convert(financialSecurity, definition, now, curveNames, dataSource);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      if (PRESENT_VALUE_STRING.equals(getCalculationType())) {
        marketValues[i] = 0;
      } else {
        marketValues[i] = marketValue;
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.01;
      nodeTimes[i] = LAST_DATE_CALCULATOR.visit(derivative);
      i++;
    }
    ParallelArrayBinarySort.parallelBinarySort(nodeTimes, initialRatesGuess);
    final LinkedHashMap<String, double[]> curveKnots = new LinkedHashMap<String, double[]>();
    curveKnots.put(curveName, nodeTimes);
    final LinkedHashMap<String, double[]> curveNodes = new LinkedHashMap<String, double[]>();
    final LinkedHashMap<String, Interpolator1D> interpolators = new LinkedHashMap<String, Interpolator1D>();
    curveNodes.put(curveName, nodeTimes);
    interpolators.put(curveName, getInterpolator(specificationWithSecurities));
    // TODO have use finite difference or not as an input [FIN-147]
    final MultipleYieldCurveFinderDataBundle data = new MultipleYieldCurveFinderDataBundle(derivatives, marketValues, null, curveNodes, interpolators, false);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderFunction(data, getCalculator());
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderJacobian(data, getSensitivityCalculator());
    NewtonVectorRootFinder rootFinder;
    double[] yields = null;
    try {
      // TODO have the decomposition as an optional input [FIN-146]
      rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.LU_COMMONS_NAME));
      final DoubleMatrix1D result = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess));
      yields = result.getData();
    } catch (final Exception eLU) {
      try {
        s_logger.warn("Could not find root using LU decomposition and present value method for curve " + curveName + "; trying SV. Error was: " + eLU.getMessage());
        rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
        yields = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess)).getData();
      } catch (final Exception eSV) {
        s_logger.warn("Could not find root using SV decomposition and present value method for curve " + curveName + ". Error was: " + eSV.getMessage());
        throw new OpenGammaRuntimeException(eSV.getMessage());
      }
    }
    final YieldAndDiscountCurve curve;
    if (createSensitivities || createYieldCurve) {
      curve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, getInterpolator(specificationWithSecurities)));
    } else {
      curve = null;
    }
    final Set<ComputedValue> result = Sets.newHashSetWithExpectedSize(4);
    final ValueProperties.Builder properties = createValueProperties().with(ValuePropertyNames.CURVE_CALCULATION_METHOD, getCalculationType())
        .with(YieldCurveFunction.PROPERTY_FORWARD_CURVE, curveName).with(YieldCurveFunction.PROPERTY_FUNDING_CURVE, curveName);
    if (createJacobian) {
      final DoubleMatrix2D jacobianMatrix = jacobianCalculator.evaluate(new DoubleMatrix1D(yields));
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.YIELD_CURVE_JACOBIAN, targetSpec, properties.get()), jacobianMatrix.getData()));
    }
    if (createSensitivities) {
      final double[] couponSensitivities = new double[derivatives.size()];
      int ii = 0;
      final String[] curveNames = new String[] {curveName, curveName };
      final YieldAndDiscountCurve[] curves = new YieldAndDiscountCurve[] {curve, curve };
      final YieldCurveBundle curveBundle = new YieldCurveBundle(curveNames, curves);
      for (final InstrumentDerivative derivative : derivatives) {
        couponSensitivities[ii++] = getCouponSensitivityCalculator().visit(derivative, curveBundle);
      }
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.PRESENT_VALUE_COUPON_SENSITIVITY, targetSpec, properties.get()), new DoubleMatrix1D(couponSensitivities)));
    }
    if (createYieldCurve) {
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.YIELD_CURVE, targetSpec, properties.with(ValuePropertyNames.CURVE, curveName).get()), curve));
    }
    return result;
  };private Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final ComputationTargetSpecification targetSpec, final String curveName,
      final InterpolatedYieldCurveSpecificationWithSecurities specificationWithSecurities, final Map<ExternalId, Double> marketDataMap, final boolean createYieldCurve, final boolean createJacobian,
      final boolean createSensitivities) {
    final Clock snapshotClock = executionContext.getValuationClock();
    final ZonedDateTime now = snapshotClock.zonedDateTime();
    final HistoricalTimeSeriesSource dataSource = OpenGammaExecutionContext.getHistoricalTimeSeriesSource(executionContext);
    final List<InstrumentDerivative> derivatives = new ArrayList<InstrumentDerivative>();
    final int n = specificationWithSecurities.getStrips().size();
    final double[] initialRatesGuess = new double[n];
    final double[] nodeTimes = new double[n];
    final double[] marketValues = new double[n];
    int i = 0;
    for (final FixedIncomeStripWithSecurity strip : specificationWithSecurities.getStrips()) {
      final Double marketValue = marketDataMap.get(strip.getSecurityIdentifier());
      if (marketValue == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      InstrumentDerivative derivative;
      final FinancialSecurity financialSecurity = (FinancialSecurity) strip.getSecurity();
      final String[] curveNames = FixedIncomeInstrumentCurveExposureHelper.getCurveNamesForFundingCurveInstrument(strip.getInstrumentType(), curveName, curveName);
      final InstrumentDefinition<?> definition = getSecurityConverter().visit(financialSecurity);
      derivative = getDefinitionConverter().convert(financialSecurity, definition, now, curveNames, dataSource);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      if (PRESENT_VALUE_STRING.equals(getCalculationType())) {
        marketValues[i] = 0;
      } else {
        marketValues[i] = marketValue;
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.01;
      nodeTimes[i] = LAST_DATE_CALCULATOR.visit(derivative);
      i++;
    }
    ParallelArrayBinarySort.parallelBinarySort(nodeTimes, initialRatesGuess);
    final LinkedHashMap<String, double[]> curveKnots = new LinkedHashMap<String, double[]>();
    curveKnots.put(curveName, nodeTimes);
    final LinkedHashMap<String, double[]> curveNodes = new LinkedHashMap<String, double[]>();
    final LinkedHashMap<String, Interpolator1D> interpolators = new LinkedHashMap<String, Interpolator1D>();
    curveNodes.put(curveName, nodeTimes);
    interpolators.put(curveName, getInterpolator(specificationWithSecurities));
    // TODO have use finite difference or not as an input [FIN-147]
    final MultipleYieldCurveFinderDataBundle data = new MultipleYieldCurveFinderDataBundle(derivatives, marketValues, null, curveNodes, interpolators, false);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderFunction(data, getCalculator());
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderJacobian(data, getSensitivityCalculator());
    NewtonVectorRootFinder rootFinder;
    double[] yields = null;
    try {
      // TODO have the decomposition as an optional input [FIN-146]
      rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.LU_COMMONS_NAME));
      final DoubleMatrix1D result = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess));
      yields = result.getData();
    } catch (final Exception eLU) {
      try {
        s_logger.warn("Could not find root using LU decomposition and present value method for curve " + curveName + "; trying SV. Error was: " + eLU.getMessage());
        rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
        yields = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess)).getData();
      } catch (final Exception eSV) {
        s_logger.warn("Could not find root using SV decomposition and present value method for curve " + curveName + ". Error was: " + eSV.getMessage());
        throw new OpenGammaRuntimeException(eSV.getMessage());
      }
    }
    final YieldAndDiscountCurve curve;
    if (createSensitivities || createYieldCurve) {
      curve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, getInterpolator(specificationWithSecurities)));
    } else {
      curve = null;
    }
    final Set<ComputedValue> result = Sets.newHashSetWithExpectedSize(4);
    final ValueProperties.Builder properties = createValueProperties().with(ValuePropertyNames.CURVE_CALCULATION_METHOD, getCalculationType())
        .with(YieldCurveFunction.PROPERTY_FORWARD_CURVE, curveName).with(YieldCurveFunction.PROPERTY_FUNDING_CURVE, curveName);
    if (createJacobian) {
      final DoubleMatrix2D jacobianMatrix = jacobianCalculator.evaluate(new DoubleMatrix1D(yields));
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.YIELD_CURVE_JACOBIAN, targetSpec, properties.get()), jacobianMatrix.getData()));
    }
    if (createSensitivities) {
      final double[] couponSensitivities = new double[derivatives.size()];
      int ii = 0;
      final String[] curveNames = new String[] {curveName, curveName};
      final YieldAndDiscountCurve[] curves = new YieldAndDiscountCurve[] {curve, curve};
      final YieldCurveBundle curveBundle = new YieldCurveBundle(curveNames, curves);
      for (final InstrumentDerivative derivative : derivatives) {
        couponSensitivities[ii++] = getCouponSensitivityCalculator().visit(derivative, curveBundle);
      }
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.PRESENT_VALUE_COUPON_SENSITIVITY, targetSpec, properties.get()), new DoubleMatrix1D(couponSensitivities)));
    }
    if (createYieldCurve) {
      result.add(new ComputedValue(new ValueSpecification(ValueRequirementNames.YIELD_CURVE, targetSpec, properties.with(ValuePropertyNames.CURVE, curveName).get()), curve));
    }
    return result;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_54b18_72172/rev_54b18-72172;/doc/ref/examples/src/com/tightdb/refdoc/ReadTransactionIntro;typedReadTransactionIntro();;public static void typedReadTransactionIntro(){
        // Open existing database file in a shared group
        SharedGroup group = new SharedGroup("mydatabase.tightdb"); 

        // Create read transaction from the shared group
        ReadTransaction rt = group.beginRead();

        // Inside transaction is a fully consistent and immutable view of the group
        try {
            // Get a table from the group
            PeopleTable people = new PeopleTable(rt);

            // Read from the first row, the name column
            String name = people.get(0).getName();

            // Do more table read operations here...

        } finally {
            // End the read transaction in a finally block. If the read-transaction is not
            // closed, a new one cannot be started using the same SharedGroup instance.
            rt.endRead();
        }  
    };public static void typedReadTransactionIntro() {
        // Open existing database file in a shared group
        SharedGroup group = new SharedGroup("mydatabase.tightdb"); 

        // Create read transaction from the shared group
        ReadTransaction rt = group.beginRead();

        // Inside transaction is a fully consistent and immutable view of the group
        try {
            // Get a table from the group
            PeopleTable people = new PeopleTable(rt);

            // Read from the first row, the name column
            String name = people.get(0).getName();

            // Do more table read operations here...

        } finally {
            // End the read transaction in a finally block. If the read-transaction is not
            // closed, a new one cannot be started using the same SharedGroup instance.
            rt.endRead();
        }  
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_54b18_72172/rev_54b18-72172;/doc/ref/examples/src/com/tightdb/refdoc/ReadTransactionIntro;dynamicReadTransactionIntro();;public static void dynamicReadTransactionIntro(){
        // Open existing database file in a shared group
        SharedGroup group = new SharedGroup("mydatabase.tightdb");

        // Create a read transaction from the group
        ReadTransaction rt = group.beginRead();

        // Inside transaction is a fully consistent and immutable view of the group
        try {
            // Get a table from the group
            Table table = rt.getTable("people");

            // Actions inside a ReadTransacton will never affect the original group and tables
            String name = table.getString(0, 0);

            // Do more table read operations here...
            
        } finally {
            // End the read transaction in a finally block. If the read-transaction is not
            // closed, a new one cannot be started using the same SharedGroup instance.
            rt.endRead();
        }  
    };public static void dynamicReadTransactionIntro() {
        // Open existing database file in a shared group
        SharedGroup group = new SharedGroup("mydatabase.tightdb");

        // Create a read transaction from the group
        ReadTransaction rt = group.beginRead();

        // Inside transaction is a fully consistent and immutable view of the group
        try {
            // Get a table from the group
            Table table = rt.getTable("people");

            // Actions inside a ReadTransacton will never affect the original group and tables
            String name = table.getString(0, 0);

            // Do more table read operations here...
            
        } finally {
            // End the read transaction in a finally block. If the read-transaction is not
            // closed, a new one cannot be started using the same SharedGroup instance.
            rt.endRead();
        }  
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_54b18_72172/rev_54b18-72172;/doc/ref/examples/src/com/tightdb/refdoc/DynTableViewExamples;main(String[]);;public static void main(String[] args) throws FileNotFoundException  {

        // View methods:
        sizeExample();
        isEmptyExample();
        clearExample();


        // Columns methods: 
        getColumnCountExample();
        getColumnNameExample();
        getColumnIndexExample();
        getColumnTypeExample();



        // Rows methods:
        removeExample();
        removeLastExample();
        adjustExample();


        // Cells methods:
        getExamples();
        setExamples();
        //TODO getSubtableSize();
        //TODO clearSubtable


        // Searching methods:
        findFirstExamples();
        findAllExample();
        whereExample();

        // Aggregates methods:
        sumExample();
        maximumExample();
        minimumExample();
        averageExample();

        // Dump methods:
        toJsonExample();




    };public static void main(String[] args) throws FileNotFoundException  {

        // View methods:
        sizeExample();
        isEmptyExample();
        clearExample();

        // Columns methods:
        getColumnCountExample();
        getColumnNameExample();
        getColumnIndexExample();
        getColumnTypeExample();

        // Rows methods:
        removeExample();
        removeLastExample();
        adjustExample();

        // Cells methods:
        getExamples();
        setExamples();
        //TODO getSubtableSize();
        //TODO clearSubtable

        // Searching methods:
        findFirstExamples();
        findAllExample();
        whereExample();

        // Aggregates methods:
        sumExample();
        maximumExample();
        minimumExample();
        averageExample();

        // Dump methods:
        toJsonExample();
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_54b18_72172/rev_54b18-72172;/doc/ref/examples/src/com/tightdb/refdoc/DynTableExamples;main(String[]);;public static void main(String[] args) throws FileNotFoundException  {
        
        // Table methods:
        isValidExample();
        sizeExample();
        isEmptyExample();
        clearExample();
        //TODO getSortedViewExample();
        //TODO optimizeExample();
        //TODO setIndexExample();
        //TODO hasIndexExample();
        
        
        // Columns methods: 
        addColumnExample();
        removeColumnExample();
        renameColumnExample();
        getColumnCountExample();
        getColumnNameExample();
        getColumnIndexExample();
        getColumnTypeExample();
        
        
        
        // Rows methods:
        addAtExample();
        addAtExample();
        setRowExample();
        removeExample();
        removeLastExample();
        addEmptyRowExample();
        addEmptyRowsExample();
        adjustExample();
        
        
        // Cells methods:
        getExamples();
        setExamples();
        //TODO getSubtableSize();
        //TODO clearSubtable
        
        
        // Searching methods:
        findFirstExamples();
        findAllExample();
        getDistinctViewExample();
        whereExample();
        
        // Aggregates methods:
       sumExample();
       maximumExample();
       minimumExample();
       averageExample();
        
        // Dump methods:
        toJsonExample();
        
        
        

    };public static void main(String[] args) throws FileNotFoundException  {
        
        // Table methods:
        isValidExample();
        sizeExample();
        isEmptyExample();
        clearExample();
        //TODO getSortedViewExample();
        //TODO optimizeExample();
        //TODO setIndexExample();
        //TODO hasIndexExample();
        
        // Columns methods: 
        addColumnExample();
        removeColumnExample();
        renameColumnExample();
        getColumnCountExample();
        getColumnNameExample();
        getColumnIndexExample();
        getColumnTypeExample();
        
        // Rows methods:
        addAtExample();
        addAtExample();
        setRowExample();
        removeExample();
        removeLastExample();
        addEmptyRowExample();
        addEmptyRowsExample();
        adjustExample();
        
        // Cells methods:
        getExamples();
        setExamples();
        //TODO getSubtableSize();
        //TODO clearSubtable
        
        // Searching methods:
        findFirstExamples();
        findAllExample();
        getDistinctViewExample();
        whereExample();
        
        // Aggregates methods:
       sumExample();
       maximumExample();
       minimumExample();
       averageExample();
        
        // Dump methods:
        toJsonExample();
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa;/samples/src/roboguice/astroboy/activity/AstroPrefActivity;onCreatePreferences();;@Override
  protected void onCreatePreferences() {
    addPreferencesFromResource(R.xml.preference);
  };@Override
    protected void onCreatePreferences() {
        addPreferencesFromResource(R.xml.preference);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa;/samples/src/roboguice/astroboy/activity/AstroPrefActivity;onCreate(Bundle);;@Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

      //example of binding a event listener through a preference change listener
    boolPref.setOnPreferenceChangeListener(preferenceChangeEventListener);
  };@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        //example of binding a event listener through a preference change listener
        boolPref.setOnPreferenceChangeListener(preferenceChangeEventListener);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_65e50_27632/rev_65e50-27632;/lucene/src/java/org/apache/lucene/index/IndexWriter;getCurrentFieldInfos();;private FieldInfos getCurrentFieldInfos() throws IOException {
    final FieldInfos fieldInfos;
    if (segmentInfos.size() > 0) {
        fieldInfos = new FieldInfos();
        for(SegmentInfo info : segmentInfos) {
          final FieldInfos segFieldInfos = getFieldInfos(info);
        for (FieldInfo fi : segFieldInfos) {
          fieldInfos.add(fi);
          }
        }
      } else {
      fieldInfos = new FieldInfos();
    }
    return fieldInfos;
  };private FieldInfos getCurrentFieldInfos() throws IOException {
    final FieldInfos fieldInfos;
    if (segmentInfos.size() > 0) {
        fieldInfos = new FieldInfos();
        for(SegmentInfo info : segmentInfos) {
          final FieldInfos segFieldInfos = getFieldInfos(info);
          for (FieldInfo fi : segFieldInfos) {
            fieldInfos.add(fi);
          }
        }
      } else {
      fieldInfos = new FieldInfos();
    }
    return fieldInfos;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Jedis;zrange(String,int,int);;public Set<String> zrange(final String key, final int start, final int end) {
        checkIsInMulti();
        client.zrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
    };public Set<String> zrange(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Jedis;zrevrange(String,int,int);;public Set<String> zrevrange(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrevrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
    };public Set<String> zrevrange(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Jedis;zrangeWithScores(String,int,int);;public Set<Tuple> zrangeWithScores(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
    };public Set<Tuple> zrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Jedis;zrevrangeWithScores(String,int,int);;public Set<Tuple> zrevrangeWithScores(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrevrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
    };public Set<Tuple> zrevrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Jedis;zremrangeByRank(String,int,int);;public Long zremrangeByRank(final String key, final int start, final int end) {
        checkIsInMulti();
        client.zremrangeByRank(key, start, end);
        return client.getIntegerReply();
    };public Long zremrangeByRank(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/BinaryClient;zrange(byte[],int,int);;public void zrange(final byte[] key, final int start, final int end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
    };public void zrange(final byte[] key, final int start, final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/BinaryClient;zrevrange(byte[],int,int);;public void zrevrange(final byte[] key, final int start, final int end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
    };public void zrevrange(final byte[] key, final int start, final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/BinaryClient;zrangeWithScores(byte[],int,int);;public void zrangeWithScores(final byte[] key, final int start,
            final int end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
    };public void zrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/BinaryClient;zrevrangeWithScores(byte[],int,int);;public void zrevrangeWithScores(final byte[] key, final int start,
            final int end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
    };public void zrevrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/BinaryClient;zremrangeByRank(byte[],int,int);;public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    };public void zremrangeByRank(final byte[] key, final int start, final int end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Commands;zrangeWithScores(String,int,int);;public void zrangeWithScores(final String key, final int start,
            final int end);;public void zrangeWithScores(final String key, final int start,
	    final int end);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Commands;zrevrangeWithScores(String,int,int);;public void zrevrangeWithScores(final String key, final int start,
            final int end);;public void zrevrangeWithScores(final String key, final int start,
	    final int end);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/ShardedJedis;zrange(String,int,int);;public Set<String> zrange(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrange(key, start, end);
    };public Set<String> zrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrange(key, start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/ShardedJedis;zrevrange(String,int,int);;public Set<String> zrevrange(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrevrange(key, start, end);
    };public Set<String> zrevrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrange(key, start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/ShardedJedis;zrangeWithScores(String,int,int);;public Set<Tuple> zrangeWithScores(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrangeWithScores(key, start, end);
    };public Set<Tuple> zrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrangeWithScores(key, start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/ShardedJedis;zrevrangeWithScores(String,int,int);;public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrevrangeWithScores(key, start, end);
    };public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrangeWithScores(key, start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/ShardedJedis;zremrangeByRank(String,int,int);;public Long zremrangeByRank(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zremrangeByRank(key, start, end);
    };public Long zremrangeByRank(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zremrangeByRank(key, start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Client;zrange(String,int,int);;public void zrange(final String key, final int start, final int end) {
        zrange(SafeEncoder.encode(key), start, end);
    };public void zrange(final String key, final int start, final int end) {
	zrange(SafeEncoder.encode(key), start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Client;zrevrange(String,int,int);;public void zrevrange(final String key, final int start, final int end) {
        zrevrange(SafeEncoder.encode(key), start, end);
    };public void zrevrange(final String key, final int start, final int end) {
	zrevrange(SafeEncoder.encode(key), start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Client;zrangeWithScores(String,int,int);;public void zrangeWithScores(final String key, final int start,
            final int end) {
        zrangeWithScores(SafeEncoder.encode(key), start, end);
    };public void zrangeWithScores(final String key, final int start,
	    final int end) {
	zrangeWithScores(SafeEncoder.encode(key), start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Client;zrevrangeWithScores(String,int,int);;public void zrevrangeWithScores(final String key, final int start,
            final int end) {
        zrevrangeWithScores(SafeEncoder.encode(key), start, end);
    };public void zrevrangeWithScores(final String key, final int start,
	    final int end) {
	zrevrangeWithScores(SafeEncoder.encode(key), start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_088f8_457cc/rev_088f8-457cc;/src/main/java/redis/clients/jedis/Client;zremrangeByRank(String,int,int);;public void zremrangeByRank(final String key, final int start, final int end) {
        zremrangeByRank(SafeEncoder.encode(key), start, end);
    };public void zremrangeByRank(final String key, final int start, final int end) {
	zremrangeByRank(SafeEncoder.encode(key), start, end);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_093b1_84fff/rev_093b1-84fff;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/volatility/surface/black/EquityBlackVolatilitySurfaceFunction;isCorrectIdType(ComputationTarget);;@Override
  protected boolean isCorrectIdType(final ComputationTarget target) {
    if (target.getUniqueId() == null) {
      s_logger.error("Target unique id was null; {}", target);
      return false;
    }
    final String targetScheme = target.getUniqueId().getScheme();
    return (targetScheme.equalsIgnoreCase(ExternalSchemes.BLOOMBERG_TICKER.getName()) ||
        targetScheme.equalsIgnoreCase(ExternalSchemes.BLOOMBERG_TICKER_WEAK.getName()));
  };@Override
  protected boolean isCorrectIdType(final ComputationTarget target) {
    if (target.getUniqueId() == null) {
      s_logger.error("Target unique id was null; {}", target);
      return false;
    }
    final String targetScheme = target.getUniqueId().getScheme();
    return (targetScheme.equalsIgnoreCase(ExternalSchemes.BLOOMBERG_TICKER.getName()) || targetScheme.equalsIgnoreCase(ExternalSchemes.BLOOMBERG_TICKER_WEAK.getName()));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_97cf6_0dc5c/rev_97cf6-0dc5c;/projects/OG-Web/src/main/java/com/opengamma/web/spring/DemoStandardFunctionConfiguration;addLocalVolatilityCalculators(List<FunctionConfiguration>);;private static void addLocalVolatilityCalculators(final List<FunctionConfiguration> functionConfigs) {
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalInterpolatorFunction.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSABRInterpolatorFunction.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorFunction.Exception.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorFunction.Quiet.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.Spline.class.getName()));


    functionConfigs.add(new StaticFunctionConfiguration(EquityBlackVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityBlackVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    addLocalVolatilityGridFunctions(functionConfigs);
    addFXLocalVolatilityDefaultProperties(functionConfigs);
  };private static void addLocalVolatilityCalculators(final List<FunctionConfiguration> functionConfigs) {
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalInterpolatorFunction.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSABRInterpolatorFunction.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorFunction.Exception.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorFunction.Quiet.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexBlackVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(EquityBlackVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityBlackVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(ForexDupireLocalVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.MixedLogNormal.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.SABR.class.getName()));
    functionConfigs.add(new StaticFunctionConfiguration(EquityDupireLocalVolatilitySurfaceFunction.Spline.class.getName()));

    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEPipsPresentValueFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEDualGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardDeltaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardGammaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVegaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVannaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEForwardVommaFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SPLINE)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.SABR)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(FXOptionLocalVolatilityForwardPDEImpliedVolatilityFunction.class.getName(), Arrays
        .asList(BlackVolatilitySurfacePropertyNamesAndValues.MIXED_LOG_NORMAL)));
    addLocalVolatilityGridFunctions(functionConfigs);
    addFXLocalVolatilityDefaultProperties(functionConfigs);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_233ea_bc575/rev_233ea-bc575;/src/java/org/apache/cassandra/gms/PureRandom;main(String[]);;public static void main(String[] args) throws Throwable
    {
    	Random pr = new PureRandom();
        int ubs[] = new int[] { 2, 3, 1, 10, 5, 0};

        for (int ub : ubs)
        {
            System.out.println("UB: " + String.valueOf(ub));
            for (int j = 0; j < 10; j++)
            {
                int junk = pr.nextInt(ub);
                // Do something with junk so JVM doesn't optimize away
                System.out.println(junk);
            }
        }
    };public static void main(String[] args) throws Throwable
    {
        Random pr = new PureRandom();
        int ubs[] = new int[]{ 2, 3, 1, 10, 5, 0 };

        for (int ub : ubs)
        {
            System.out.println("UB: " + String.valueOf(ub));
            for (int j = 0; j < 10; j++)
            {
                int junk = pr.nextInt(ub);
                // Do something with junk so JVM doesn't optimize away
                System.out.println(junk);
            }
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;ensureContiguousMerge(MergePolicy.OneMerge);;private int ensureContiguousMerge(MergePolicy.OneMerge merge) {

    int first = segmentInfos.indexOf(merge.segments.info(0));
    if (first == -1)
      throw new MergePolicy.MergeException("could not find segment " + merge.segments.info(0).name + " in current index " + segString(), directory);

    final int numSegments = segmentInfos.size();
    
    final int numSegmentsToMerge = merge.segments.size();
    for(int i=0;i<numSegmentsToMerge;i++) {
      final SegmentInfo info = merge.segments.info(i);

      if (first + i >= numSegments || !segmentInfos.info(first+i).equals(info)) {
        if (segmentInfos.indexOf(info) == -1)
          throw new MergePolicy.MergeException("MergePolicy selected a segment (" + info.name + ") that is not in the current index " + segString(), directory);
        else
          throw new MergePolicy.MergeException("MergePolicy selected non-contiguous segments to merge (" + merge.segString(directory) + " vs " + segString() + "), which IndexWriter (currently) cannot handle",
                                               directory);
      }
    }

    return first;
  };private int ensureContiguousMerge(MergePolicy.OneMerge merge) {

    int first = segmentInfos.indexOf(merge.segments.info(0));
    if (first == -1)
      throw new MergePolicy.MergeException("could not find segment " + merge.segments.info(0).name + " in current index " + segString(), directory);

    final int numSegments = segmentInfos.size();

    final int numSegmentsToMerge = merge.segments.size();
    for(int i=0;i<numSegmentsToMerge;i++) {
      final SegmentInfo info = merge.segments.info(i);

      if (first + i >= numSegments || !segmentInfos.info(first+i).equals(info)) {
        if (segmentInfos.indexOf(info) == -1)
          throw new MergePolicy.MergeException("MergePolicy selected a segment (" + info.name + ") that is not in the current index " + segString(), directory);
        else
          throw new MergePolicy.MergeException("MergePolicy selected non-contiguous segments to merge (" + merge.segString(directory) + " vs " + segString() + "), which IndexWriter (currently) cannot handle",
                                               directory);
      }
    }

    return first;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;setMergeDocStoreIsCompoundFile(MergePolicy.OneMerge);;private synchronized void setMergeDocStoreIsCompoundFile(MergePolicy.OneMerge merge) {
    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); 
    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {
      final int size = segmentInfos.size();
      for(int i=0;i<size;i++) {
        final SegmentInfo info = segmentInfos.info(i);
        final String docStoreSegment = info.getDocStoreSegment();
        if (docStoreSegment != null &&
            docStoreSegment.equals(mergeDocStoreSegment) && 
            info.getDocStoreIsCompoundFile()) {
          merge.info.setDocStoreIsCompoundFile(true);
          break;
        }
      }
    }
  };private synchronized void setMergeDocStoreIsCompoundFile(MergePolicy.OneMerge merge) {
    final String mergeDocStoreSegment = merge.info.getDocStoreSegment();
    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {
      final int size = segmentInfos.size();
      for(int i=0;i<size;i++) {
        final SegmentInfo info = segmentInfos.info(i);
        final String docStoreSegment = info.getDocStoreSegment();
        if (docStoreSegment != null &&
            docStoreSegment.equals(mergeDocStoreSegment) &&
            info.getDocStoreIsCompoundFile()) {
          merge.info.setDocStoreIsCompoundFile(true);
          break;
        }
      }
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/FieldInfos;addInternal(String,boolean,boolean,boolean,boolean,boolean,boolean,boolean);;private FieldInfo addInternal(String name, boolean isIndexed,
                                boolean storeTermVector, boolean storePositionWithTermVector, 
                                boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {
    name = StringHelper.intern(name);
    FieldInfo fi = new FieldInfo(name, isIndexed, byNumber.size(), storeTermVector, storePositionWithTermVector,
                                 storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    byNumber.add(fi);
    byName.put(name, fi);
    return fi;
  };private FieldInfo addInternal(String name, boolean isIndexed,
                                boolean storeTermVector, boolean storePositionWithTermVector,
                                boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {
    name = StringHelper.intern(name);
    FieldInfo fi = new FieldInfo(name, isIndexed, byNumber.size(), storeTermVector, storePositionWithTermVector,
                                 storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    byNumber.add(fi);
    byName.put(name, fi);
    return fi;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-Examples/src/com/opengamma/examples/loader/ExampleViewsPopulator;doRun();;@Override
  protected void doRun() {
    storeViewDefinition(getEquityViewDefinition(ExampleEquityPortfolioLoader.PORTFOLIO_NAME));
    storeViewDefinition(getMultiCurrencySwapViewDeprecatedDefinition(MULTI_CURRENCY_SWAP_PORTFOLIO_NAME));
    storeViewDefinition(getMultiCurrencySwapViewDefinition(MULTI_CURRENCY_SWAP_PORTFOLIO_NAME));
    storeViewDefinition(getAUDSwapView1Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getAUDSwapView2Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getAUDSwapView3Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getSwaptionParityViewDefinition(SWAPTION_PORTFOLIO_NAME));
    storeViewDefinition(getSABRExtrapolationViewDefinition(MIXED_CMS_PORTFOLIO_NAME));
//    storeViewDefinition(getFXLocalVolatilityViewDefinition(VANILLA_FX_OPTION_PORTFOLIO_NAME));
  };@Override
  protected void doRun() {
    storeViewDefinition(getEquityViewDefinition(ExampleEquityPortfolioLoader.PORTFOLIO_NAME));
    storeViewDefinition(getMultiCurrencySwapViewDeprecatedDefinition(MULTI_CURRENCY_SWAP_PORTFOLIO_NAME));
    storeViewDefinition(getMultiCurrencySwapViewDefinition(MULTI_CURRENCY_SWAP_PORTFOLIO_NAME));
    storeViewDefinition(getAUDSwapView1Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getAUDSwapView2Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getAUDSwapView3Definition(AUD_SWAP_PORFOLIO_NAME));
    storeViewDefinition(getSwaptionParityViewDefinition(SWAPTION_PORTFOLIO_NAME));
    storeViewDefinition(getSABRExtrapolationViewDefinition(MIXED_CMS_PORTFOLIO_NAME));
    //    storeViewDefinition(getFXLocalVolatilityViewDefinition(VANILLA_FX_OPTION_PORTFOLIO_NAME));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-Examples/src/com/opengamma/examples/loader/ExampleViewsPopulator;getEquityViewDefinition(String);;private ViewDefinition getEquityViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition(portfolioName + " View", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxFullCalculationPeriod(30000L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMaxDeltaCalculationPeriod(30000L);

    final ViewCalculationConfiguration defaultCalc = new ViewCalculationConfiguration(viewDefinition, DEFAULT_CALC_CONFIG);
    addValueRequirements(defaultCalc, EquitySecurity.SECURITY_TYPE, 
        new String[] {ValueRequirementNames.FAIR_VALUE, ValueRequirementNames.CAPM_BETA, ValueRequirementNames.HISTORICAL_VAR,
          ValueRequirementNames.SHARPE_RATIO, ValueRequirementNames.TREYNOR_RATIO, ValueRequirementNames.JENSENS_ALPHA, 
          ValueRequirementNames.TOTAL_RISK_ALPHA });
    defaultCalc.addPortfolioRequirement(EquitySecurity.SECURITY_TYPE, ValueRequirementNames.PNL, ValueProperties.with(ValuePropertyNames.CURRENCY, Currency.USD.getCode()).get());
    viewDefinition.addViewCalculationConfiguration(defaultCalc);
    return viewDefinition;
  };private ViewDefinition getEquityViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition(portfolioName + " View", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxFullCalculationPeriod(30000L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMaxDeltaCalculationPeriod(30000L);

    final ViewCalculationConfiguration defaultCalc = new ViewCalculationConfiguration(viewDefinition, DEFAULT_CALC_CONFIG);
    addValueRequirements(defaultCalc, EquitySecurity.SECURITY_TYPE,
        new String[] {ValueRequirementNames.FAIR_VALUE, ValueRequirementNames.CAPM_BETA, ValueRequirementNames.HISTORICAL_VAR,
            ValueRequirementNames.SHARPE_RATIO, ValueRequirementNames.TREYNOR_RATIO, ValueRequirementNames.JENSENS_ALPHA,
            ValueRequirementNames.TOTAL_RISK_ALPHA });
    defaultCalc.addPortfolioRequirement(EquitySecurity.SECURITY_TYPE, ValueRequirementNames.PNL, ValueProperties.with(ValuePropertyNames.CURRENCY, Currency.USD.getCode()).get());
    viewDefinition.addViewCalculationConfiguration(defaultCalc);
    return viewDefinition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-Examples/src/com/opengamma/examples/loader/ExampleViewsPopulator;getSABRExtrapolationViewDefinition(String);;private ViewDefinition getSABRExtrapolationViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition("Mixed CM", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxDeltaCalculationPeriod(500L);
    viewDefinition.setMaxFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    final String curveConfig = "DefaultTwoCurveUSDConfig";
    final ViewCalculationConfiguration noExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "No Extrapolation");
    final ViewCalculationConfiguration rightExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "Right Extrapolation");
    final String[] securityTypes = new String[] {CapFloorCMSSpreadSecurity.SECURITY_TYPE, CapFloorSecurity.SECURITY_TYPE, SwapSecurity.SECURITY_TYPE};
    for (final String securityType : securityTypes) {
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
    }
    viewDefinition.addViewCalculationConfiguration(noExtrapolationConfig);
    viewDefinition.addViewCalculationConfiguration(rightExtrapolationConfig);
    return viewDefinition;
  };private ViewDefinition getSABRExtrapolationViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition("Mixed CM", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxDeltaCalculationPeriod(500L);
    viewDefinition.setMaxFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    final String curveConfig = "DefaultTwoCurveUSDConfig";
    final ViewCalculationConfiguration noExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "No Extrapolation");
    final ViewCalculationConfiguration rightExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "Right Extrapolation");
    final String[] securityTypes = new String[] {CapFloorCMSSpreadSecurity.SECURITY_TYPE, CapFloorSecurity.SECURITY_TYPE, SwapSecurity.SECURITY_TYPE };
    for (final String securityType : securityTypes) {
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
    }
    viewDefinition.addViewCalculationConfiguration(noExtrapolationConfig);
    viewDefinition.addViewCalculationConfiguration(rightExtrapolationConfig);
    return viewDefinition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-MasterDB/tests/unit/com/opengamma/masterdb/batch/DbBatchWriterTest;getComputationTargetBySpec();;@Test
  public void getComputationTargetBySpec() {
    final UniqueId uniqueId = UniqueId.of("foo", "bar");

    _batchMaster.getDbConnector().getTransactionTemplate().execute(new TransactionCallback<Void>() {
      @Override
      public Void doInTransaction(TransactionStatus status) {
        HbComputationTargetSpecification portfolio = _batchWriter.getOrCreateComputationTargetInTransaction(
          new ComputationTargetSpecification(ComputationTargetType.PORTFOLIO_NODE, uniqueId));


        assertNotNull(portfolio);
        assertEquals(ComputationTargetType.PORTFOLIO_NODE, portfolio.getType());
        assertEquals(uniqueId, portfolio.getUniqueId());

        HbComputationTargetSpecification position = _batchWriter.getComputationTargetIntransaction(
          new ComputationTargetSpecification(ComputationTargetType.POSITION, uniqueId));
        assertNull(position);

        HbComputationTargetSpecification security = _batchWriter.getComputationTargetIntransaction(
          new ComputationTargetSpecification(ComputationTargetType.SECURITY, uniqueId));
        assertNull(security);

        HbComputationTargetSpecification primitive = _batchWriter.getComputationTargetIntransaction(
          new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, uniqueId));
        assertNull(primitive);


        return null;
      }
    });


  };@Test
  public void getComputationTargetBySpec() {
    final UniqueId uniqueId = UniqueId.of("foo", "bar");

    _batchMaster.getDbConnector().getTransactionTemplate().execute(new TransactionCallback<Void>() {
      @Override
      public Void doInTransaction(TransactionStatus status) {
        HbComputationTargetSpecification portfolio = _batchWriter.getOrCreateComputationTargetInTransaction(
          new ComputationTargetSpecification(ComputationTargetType.PORTFOLIO_NODE, uniqueId));


        assertNotNull(portfolio);
        assertEquals(ComputationTargetType.PORTFOLIO_NODE, portfolio.getType());
        assertEquals(uniqueId, portfolio.getUniqueId());

        HbComputationTargetSpecification position = _batchWriter.getComputationTargetIntransaction(
          new ComputationTargetSpecification(ComputationTargetType.POSITION, uniqueId));
        assertNull(position);

        HbComputationTargetSpecification security = _batchWriter.getComputationTargetIntransaction(
          new ComputationTargetSpecification(ComputationTargetType.SECURITY, uniqueId));
        assertNull(security);

        HbComputationTargetSpecification primitive = _batchWriter.getComputationTargetIntransaction(
            new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, uniqueId));
        assertNull(primitive);


        return null;
      }
    });


  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-MasterDB/tests/unit/com/opengamma/masterdb/batch/DbBatchWriterTest;getComputationTarget();;@Test
  public void getComputationTarget() {
    final UniqueId uniqueId = UniqueId.of("foo", "bar", "1");

    final SimpleSecurity mockSecurity = new SimpleSecurity("option");
    mockSecurity.setUniqueId(uniqueId);
    mockSecurity.setName("myOption");

    //Batch batch = new Batch(_batchId, _cycleInfo);
    _batchMaster.getDbConnector().getTransactionTemplate().execute(new TransactionCallback<Void>() {
      @Override
      public Void doInTransaction(TransactionStatus status) {
        HbComputationTargetSpecification security = _batchWriter.getOrCreateComputationTargetInTransaction(
          new ComputationTargetSpecification(ComputationTargetType.SECURITY, uniqueId));

        assertEquals(ComputationTargetType.SECURITY, security.getType());

        HbComputationTargetSpecification primitive = _batchWriter.getOrCreateComputationTargetInTransaction(
          new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, uniqueId));

        assertEquals(ComputationTargetType.PRIMITIVE, primitive.getType());
        return null;
      }
    });


  };@Test
  public void getComputationTarget() {
    final UniqueId uniqueId = UniqueId.of("foo", "bar", "1");

    final SimpleSecurity mockSecurity = new SimpleSecurity("option");
    mockSecurity.setUniqueId(uniqueId);
    mockSecurity.setName("myOption");

    //Batch batch = new Batch(_batchId, _cycleInfo);
    _batchMaster.getDbConnector().getTransactionTemplate().execute(new TransactionCallback<Void>() {
      @Override
      public Void doInTransaction(TransactionStatus status) {
        HbComputationTargetSpecification security = _batchWriter.getOrCreateComputationTargetInTransaction(
          new ComputationTargetSpecification(ComputationTargetType.SECURITY, uniqueId));

        assertEquals(ComputationTargetType.SECURITY, security.getType());

        HbComputationTargetSpecification primitive = _batchWriter.getOrCreateComputationTargetInTransaction(
            new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, uniqueId));

        assertEquals(ComputationTargetType.PRIMITIVE, primitive.getType());
        return null;
      }
    });


  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_383fe_713d3/rev_383fe-713d3;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/loader/ExampleViewsPopulator;getEquityOptionViewDefinition(String);;private ViewDefinition getEquityOptionViewDefinition(String portfolioName) {
    UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    ViewDefinition equityViewDefinition = new ViewDefinition(portfolioName + " View", portfolioId, UserPrincipal.getTestUser());
    equityViewDefinition.setDefaultCurrency(Currency.USD);
    equityViewDefinition.setMaxFullCalculationPeriod(30000L);
    equityViewDefinition.setMinFullCalculationPeriod(500L);
    equityViewDefinition.setMinDeltaCalculationPeriod(500L);
    equityViewDefinition.setMaxDeltaCalculationPeriod(30000L);
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquitySecurity.SECURITY_TYPE, ValueRequirementNames.FAIR_VALUE, ValueProperties.none());
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquityOptionSecurity.SECURITY_TYPE, ValueRequirementNames.FAIR_VALUE, ValueProperties.none());    
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquityOptionSecurity.SECURITY_TYPE, ValueRequirementNames.HISTORICAL_VAR, ValueProperties.none());        
    
    return equityViewDefinition;
  };private ViewDefinition getEquityOptionViewDefinition(String portfolioName) {
    UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    ViewDefinition equityViewDefinition = new ViewDefinition(portfolioName + " View", portfolioId, UserPrincipal.getTestUser());
    equityViewDefinition.setDefaultCurrency(Currency.USD);
    equityViewDefinition.setMaxFullCalculationPeriod(30000L);
    equityViewDefinition.setMinFullCalculationPeriod(500L);
    equityViewDefinition.setMinDeltaCalculationPeriod(500L);
    equityViewDefinition.setMaxDeltaCalculationPeriod(30000L);
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquitySecurity.SECURITY_TYPE, ValueRequirementNames.FAIR_VALUE, ValueProperties.none());
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquityOptionSecurity.SECURITY_TYPE, ValueRequirementNames.FAIR_VALUE, ValueProperties.none());
    equityViewDefinition.addPortfolioRequirement(DEFAULT_CALC_CONFIG, EquityOptionSecurity.SECURITY_TYPE, ValueRequirementNames.HISTORICAL_VAR, ValueProperties.none());

    return equityViewDefinition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_0573e_3e8e8/rev_0573e-3e8e8;/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ImportsResolver;addBoundToReceiver(Collection<DeclarationDescriptor>,DeclarationDescriptor);;@NotNull
        public static Collection<DeclarationDescriptor> addBoundToReceiver(@NotNull Collection<DeclarationDescriptor> descriptors, @NotNull final DeclarationDescriptor receiver) {
            return Collections2.transform(descriptors, DescriptorUtils.getAddBoundToReceiverFunction(receiver));
        };@NotNull
        public static Collection<DeclarationDescriptor> addBoundToReceiver(@NotNull Collection<DeclarationDescriptor> descriptors,
                                                                           @NotNull final DeclarationDescriptor receiver) {
            return Collections2.transform(descriptors, DescriptorUtils.getAddBoundToReceiverFunction(receiver));
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_dropwizard/rev_602fc_28ee2/rev_602fc-28ee2;/dropwizard-testing/src/test/java/com/yammer/dropwizard/testing/tests/junit/DropwizardServiceRuleTest;canGetExpectedResourceOverHttp();;@Test
    public void canGetExpectedResourceOverHttp() {
        final String content = new Client().resource("http://localhost:" +
                                                             RULE.getLocalPort()
                                                             +"/test").get(String.class);

        assertThat(content, is("Yes, it's here"));
    };@Test
    public void canGetExpectedResourceOverHttp() {
        final String content = new Client().resource("http://localhost:" +
                RULE.getLocalPort()
                + "/test").get(String.class);

        assertThat(content, is("Yes, it's here"));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd;/compiler/backend/src/org/jetbrains/jet/codegen/GenerationUtils;compileFileGetGenerationState(JetFile);;public static GenerationState compileFileGetGenerationState(JetFile psiFile) {
        final AnalyzeExhaust analyzeExhaust = AnalyzerFacadeForJVM.analyzeOneFileWithJavaIntegrationAndCheckForErrors(psiFile, JetControlFlowDataTraceFactory.EMPTY);
        GenerationState state = new GenerationState(psiFile.getProject(), ClassBuilderFactories.binaries(false), analyzeExhaust, Collections.singletonList(psiFile));
        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);
        return state;
    };public static GenerationState compileFileGetGenerationState(JetFile psiFile) {
        final AnalyzeExhaust analyzeExhaust = AnalyzerFacadeForJVM.analyzeOneFileWithJavaIntegrationAndCheckForErrors(psiFile, JetControlFlowDataTraceFactory.EMPTY);
        GenerationState state = new GenerationState(psiFile.getProject(), ClassBuilderFactories.binaries(false),
                                                    analyzeExhaust, Collections.singletonList(psiFile));
        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);
        return state;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_852b2_767db/rev_852b2-767db;/src/com/opengamma/financial/analytics/ircurve/InterpolatedYieldAndDiscountCurveDefinition;hashCode();;@Override
  public int hashCode() {
    int prime = 37;
    int result = 1;
    result = (result * prime) + _currency.hashCode();
    if (_name != null) {
      result = (result * prime) + _name.hashCode(); 
    }
    if (_interpolatorName != null) {
      result = (result * prime) + _interpolatorName.hashCode(); 
    }
    for (FixedIncomeStrip strip : _strips) {
      result = (result * prime) + strip.hashCode();
    }
    return result;
  };@Override
  public int hashCode() {
    int prime = 37;
    int result = 1;
    result = (result * prime) + _currency.hashCode();
    if (_name != null) {
      result = (result * prime) + _name.hashCode();
    }
    if (_interpolatorName != null) {
      result = (result * prime) + _interpolatorName.hashCode();
    }
    for (FixedIncomeStrip strip : _strips) {
      result = (result * prime) + strip.hashCode();
    }
    return result;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5893f_b2042/rev_5893f-b2042;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;getSingleCurveResult(Map<ExternalId,Double>,FixedIncomeStripIdentifierAndMaturityBuilder,ZonedDateTime,HistoricalTimeSeriesSource);;@SuppressWarnings("synthetic-access")
    private Set<ComputedValue> getSingleCurveResult(final Map<ExternalId, Double> marketDataMap, final FixedIncomeStripIdentifierAndMaturityBuilder builder, final ZonedDateTime now,
        final HistoricalTimeSeriesSource dataSource) {
      // TODO going to arbitrarily use funding curve - will give the same result as forward curve
      final InterpolatedYieldCurveSpecificationWithSecurities specificationWithSecurities = builder.resolveToSecurity(_fundingCurveSpecification, marketDataMap);
      final List<InstrumentDerivative> derivatives = new ArrayList<InstrumentDerivative>();
      final Set<FixedIncomeStrip> strips = _fundingCurveDefinition.getStrips();
      final int n = strips.size();
      final double[] initialRatesGuess = new double[n];
      final double[] nodeTimes = new double[n];
      final double[] marketValues = new double[n];
      int i = 0;
      for (final FixedIncomeStripWithSecurity strip : specificationWithSecurities.getStrips()) {
        final Double marketValue = marketDataMap.get(strip.getSecurityIdentifier());
        if (marketValue == null) {
          throw new NullPointerException("Could not get market data for " + strip);
        }
        InstrumentDerivative derivative;
        final FinancialSecurity financialSecurity = (FinancialSecurity) strip.getSecurity();
        final String[] curveNames = FixedIncomeInstrumentCurveExposureHelper
            .getCurveNamesForFundingCurveInstrument(strip.getInstrumentType(), _fundingCurveDefinitionName, _forwardCurveDefinitionName);
        final InstrumentDefinition<?> definition = _securityConverter.visit(financialSecurity);
        derivative = _definitionConverter.convert(financialSecurity, definition, now, curveNames, dataSource);
        if (derivative == null) {
          throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
        }
        if (_calculationType.equals(PRESENT_VALUE_STRING)) {
          marketValues[i] = 0;
        } else {
          marketValues[i] = marketValue;
        }
        derivatives.add(derivative);
        initialRatesGuess[i] = 0.01;
        nodeTimes[i] = LAST_DATE_CALCULATOR.visit(derivative);
        i++;
      }
      ParallelArrayBinarySort.parallelBinarySort(nodeTimes, initialRatesGuess);
      final LinkedHashMap<String, double[]> curveKnots = new LinkedHashMap<String, double[]>();
      curveKnots.put(_fundingCurveDefinitionName, nodeTimes);
      final LinkedHashMap<String, double[]> curveNodes = new LinkedHashMap<String, double[]>();
      final LinkedHashMap<String, Interpolator1D> interpolators = new LinkedHashMap<String, Interpolator1D>();
      curveNodes.put(_fundingCurveDefinitionName, nodeTimes);
      interpolators.put(_fundingCurveDefinitionName, _fundingInterpolator);
      // TODO have use finite difference or not as an input [FIN-147]

      final MultipleYieldCurveFinderDataBundle data = new MultipleYieldCurveFinderDataBundle(derivatives, marketValues, null, curveNodes, interpolators, false);
      final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderFunction(data, _calculator);
      final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderJacobian(data, _sensitivityCalculator);
      NewtonVectorRootFinder rootFinder;
      double[] yields = null;
      try {
        // TODO have the decomposition as an optional input [FIN-146]
        rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.LU_COMMONS_NAME));
        final DoubleMatrix1D result = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess));

        yields = result.getData();
      } catch (final Exception eLU) {
        try {
          s_logger.warn("Could not find root using LU decomposition and present value method for curve " + _fundingCurveDefinitionName + "; trying SV. Error was: " + eLU.getMessage());
          rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
          yields = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess)).getData();
        } catch (final Exception eSV) {
          s_logger.warn("Could not find root using SV decomposition and present value method for curve " + _fundingCurveDefinitionName + ". Error was: " + eSV.getMessage());
          throw new OpenGammaRuntimeException(eSV.getMessage());
        }
      }

      final YieldAndDiscountCurve fundingCurve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, _fundingInterpolator));
      final YieldAndDiscountCurve forwardCurve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, _fundingInterpolator));
      final DoubleMatrix2D jacobianMatrix = jacobianCalculator.evaluate(new DoubleMatrix1D(yields));
      final Set<ComputedValue> result = Sets.newHashSet(new ComputedValue(_fundingCurveResult, fundingCurve), new ComputedValue(_forwardCurveResult, forwardCurve), new ComputedValue(_jacobianResult,
          jacobianMatrix.getData()), new ComputedValue(_fundingCurveSpecResult, specificationWithSecurities), new ComputedValue(_forwardCurveSpecResult, specificationWithSecurities));
      if (_calculationType.equals(PRESENT_VALUE_STRING)) {
        if (_couponSensitivityCalculator == null) {
          throw new OpenGammaRuntimeException("Should never happen - coupon sensitivity calculator was null but requested calculation method was present value");
        }
        final double[] couponSensitivities = new double[derivatives.size()];
        int ii = 0;
        final String[] curveNames = new String[] {_forwardCurveDefinitionName, _fundingCurveDefinitionName};
        final YieldAndDiscountCurve[] curves = new YieldAndDiscountCurve[] {forwardCurve, fundingCurve};
        final YieldCurveBundle curveBundle = new YieldCurveBundle(curveNames, curves);
        for (final InstrumentDerivative derivative : derivatives) {
          couponSensitivities[ii++] = _couponSensitivityCalculator.visit(derivative, curveBundle);
        }
        final ComputedValue couponSensitivitiesValue = new ComputedValue(_couponSensitivityResult, new DoubleMatrix1D(couponSensitivities));
        result.add(couponSensitivitiesValue);
      }
      return result;
    };@SuppressWarnings("synthetic-access")
    private Set<ComputedValue> getSingleCurveResult(final Map<ExternalId, Double> marketDataMap, final FixedIncomeStripIdentifierAndMaturityBuilder builder, final ZonedDateTime now,
        final HistoricalTimeSeriesSource dataSource) {
      // TODO going to arbitrarily use funding curve - will give the same result as forward curve
      final InterpolatedYieldCurveSpecificationWithSecurities specificationWithSecurities = builder.resolveToSecurity(_fundingCurveSpecification, marketDataMap);
      final List<InstrumentDerivative> derivatives = new ArrayList<InstrumentDerivative>();
      final Set<FixedIncomeStrip> strips = _fundingCurveDefinition.getStrips();
      final int n = strips.size();
      final double[] initialRatesGuess = new double[n];
      final double[] nodeTimes = new double[n];
      final double[] marketValues = new double[n];
      int i = 0;
      for (final FixedIncomeStripWithSecurity strip : specificationWithSecurities.getStrips()) {
        final Double marketValue = marketDataMap.get(strip.getSecurityIdentifier());
        if (marketValue == null) {
          throw new NullPointerException("Could not get market data for " + strip);
        }
        InstrumentDerivative derivative;
        final FinancialSecurity financialSecurity = (FinancialSecurity) strip.getSecurity();
        final String[] curveNames = FixedIncomeInstrumentCurveExposureHelper
            .getCurveNamesForFundingCurveInstrument(strip.getInstrumentType(), _fundingCurveDefinitionName, _forwardCurveDefinitionName);
        final InstrumentDefinition<?> definition = _securityConverter.visit(financialSecurity);
        derivative = _definitionConverter.convert(financialSecurity, definition, now, curveNames, dataSource);
        if (derivative == null) {
          throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
        }
        if (_calculationType.equals(PRESENT_VALUE_STRING)) {
          marketValues[i] = 0;
        } else {
          marketValues[i] = marketValue;
        }
        derivatives.add(derivative);
        initialRatesGuess[i] = 0.01;
        nodeTimes[i] = LAST_DATE_CALCULATOR.visit(derivative);
        i++;
      }
      ParallelArrayBinarySort.parallelBinarySort(nodeTimes, initialRatesGuess);
      final LinkedHashMap<String, double[]> curveKnots = new LinkedHashMap<String, double[]>();
      curveKnots.put(_fundingCurveDefinitionName, nodeTimes);
      final LinkedHashMap<String, double[]> curveNodes = new LinkedHashMap<String, double[]>();
      final LinkedHashMap<String, Interpolator1D> interpolators = new LinkedHashMap<String, Interpolator1D>();
      curveNodes.put(_fundingCurveDefinitionName, nodeTimes);
      interpolators.put(_fundingCurveDefinitionName, _fundingInterpolator);
      // TODO have use finite difference or not as an input [FIN-147]

      final MultipleYieldCurveFinderDataBundle data = new MultipleYieldCurveFinderDataBundle(derivatives, marketValues, null, curveNodes, interpolators, false);
      final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderFunction(data, _calculator);
      final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderJacobian(data, _sensitivityCalculator);
      NewtonVectorRootFinder rootFinder;
      double[] yields = null;
      try {
        // TODO have the decomposition as an optional input [FIN-146]
        rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.LU_COMMONS_NAME));
        final DoubleMatrix1D result = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess));

        yields = result.getData();
      } catch (final Exception eLU) {
        try {
          s_logger.warn("Could not find root using LU decomposition and present value method for curve " + _fundingCurveDefinitionName + "; trying SV. Error was: " + eLU.getMessage());
          rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
          yields = rootFinder.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initialRatesGuess)).getData();
        } catch (final Exception eSV) {
          s_logger.warn("Could not find root using SV decomposition and present value method for curve " + _fundingCurveDefinitionName + ". Error was: " + eSV.getMessage());
          throw new OpenGammaRuntimeException(eSV.getMessage());
        }
      }

      final YieldAndDiscountCurve fundingCurve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, _fundingInterpolator));
      final YieldAndDiscountCurve forwardCurve = new YieldCurve(InterpolatedDoublesCurve.from(nodeTimes, yields, _fundingInterpolator));
      final DoubleMatrix2D jacobianMatrix = jacobianCalculator.evaluate(new DoubleMatrix1D(yields));
      final Set<ComputedValue> result = Sets.newHashSet(new ComputedValue(_fundingCurveResult, fundingCurve), new ComputedValue(_forwardCurveResult, forwardCurve), new ComputedValue(_jacobianResult,
          jacobianMatrix.getData()), new ComputedValue(_fundingCurveSpecResult, specificationWithSecurities), new ComputedValue(_forwardCurveSpecResult, specificationWithSecurities));
      if (_calculationType.equals(PRESENT_VALUE_STRING)) {
        if (_couponSensitivityCalculator == null) {
          throw new OpenGammaRuntimeException("Should never happen - coupon sensitivity calculator was null but requested calculation method was present value");
        }
        final double[] couponSensitivities = new double[derivatives.size()];
        int ii = 0;
        final String[] curveNames = new String[] {_forwardCurveDefinitionName, _fundingCurveDefinitionName };
        final YieldAndDiscountCurve[] curves = new YieldAndDiscountCurve[] {forwardCurve, fundingCurve };
        final YieldCurveBundle curveBundle = new YieldCurveBundle(curveNames, curves);
        for (final InstrumentDerivative derivative : derivatives) {
          couponSensitivities[ii++] = _couponSensitivityCalculator.visit(derivative, curveBundle);
        }
        final ComputedValue couponSensitivitiesValue = new ComputedValue(_couponSensitivityResult, new DoubleMatrix1D(couponSensitivities));
        result.add(couponSensitivitiesValue);
      }
      return result;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5893f_b2042/rev_5893f-b2042;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;getPriority();;public int getPriority() {
    if (isSecondary()) {
      return -1;
    } 
    return 0;
  };public int getPriority() {
    if (isSecondary()) {
      return -1;
    }
    return 0;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7105a_603f9/rev_7105a-603f9;/src/java/org/apache/cassandra/thrift/ThriftValidation;validateColumnParent(String,ColumnParent);;static void validateColumnParent(String tablename, ColumnParent column_parent) throws InvalidRequestException
    {
        validateTable(tablename);
        ColumnFamilyType cfType = validateColumnFamily(tablename, column_parent.column_family);
        if (cfType == ColumnFamilyType.Standard)
        {
            if (column_parent.super_column != null)
            {
                throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
            }
        }
        if (column_parent.super_column != null)
        {
            validateColumnNames(tablename, column_parent.column_family, null, Arrays.asList(column_parent.super_column));
        }
    };static void validateColumnParent(String tablename, ColumnParent column_parent) throws InvalidRequestException
    {
        validateTable(tablename);
        ColumnFamilyType cfType = validateColumnFamily(tablename, column_parent.column_family);
        if (cfType == ColumnFamilyType.Standard)
        {
            if (column_parent.super_column != null)
            {
                throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
            }
        }

        if (column_parent.super_column != null)
        {
            validateColumnNames(tablename, column_parent.column_family, null, Arrays.asList(column_parent.super_column));
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/volatility/local/old/ForexLocalVolatilityPDEPresentValueFunctionOld;getPriceRequirement(ComputationTarget,String,String,String,String,String,String,String,String,String,String,String,String,String,String,String,String,String);;private ValueRequirement getPriceRequirement(final ComputationTarget target, final String surfaceName, final String surfaceType, final String xAxis, final String yAxis,
      final String yAxisType, final String forwardCurveCalculationMethod, final String h, final String forwardCurveName,  final String theta, final String timeSteps,
      final String spaceSteps, final String timeGridBunching, final String spaceGridBunching, final String maxMoneyness, final String pdeDirection,
      final String strikeInterpolatorName, final String timeInterpolatorName) {
    final ValueProperties properties = getPriceProperties(surfaceName, surfaceType, xAxis, yAxis, yAxisType, forwardCurveCalculationMethod, h, forwardCurveName, theta,
        timeSteps, spaceSteps, timeGridBunching, spaceGridBunching, maxMoneyness, pdeDirection, strikeInterpolatorName, timeInterpolatorName);
    return new ValueRequirement(ValueRequirementNames.PRESENT_VALUE, target.toSpecification(), properties);
  };private ValueRequirement getPriceRequirement(final ComputationTarget target, final String surfaceName, final String surfaceType, final String xAxis, final String yAxis,
      final String yAxisType, final String forwardCurveCalculationMethod, final String h, final String forwardCurveName, final String theta, final String timeSteps,
      final String spaceSteps, final String timeGridBunching, final String spaceGridBunching, final String maxMoneyness, final String pdeDirection,
      final String strikeInterpolatorName, final String timeInterpolatorName) {
    final ValueProperties properties = getPriceProperties(surfaceName, surfaceType, xAxis, yAxis, yAxisType, forwardCurveCalculationMethod, h, forwardCurveName, theta,
        timeSteps, spaceSteps, timeGridBunching, spaceGridBunching, maxMoneyness, pdeDirection, strikeInterpolatorName, timeInterpolatorName);
    return new ValueRequirement(ValueRequirementNames.PRESENT_VALUE, target.toSpecification(), properties);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_43116_04478/rev_43116-04478;/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;getLimit();;public int getLimit() 
    {
        return limit;
    };public int getLimit()
    {
        return limit;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_43116_04478/rev_43116-04478;/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;setConnectionInformation();;private void setConnectionInformation() throws IOException
    {
        if (System.getenv(PIG_RPC_PORT) != null)
            ConfigHelper.setRpcPort(conf, System.getenv(PIG_RPC_PORT));
        else if (ConfigHelper.getRpcPort(conf) == 0) 
            throw new IOException("PIG_RPC_PORT environment variable not set");
        if (System.getenv(PIG_INITIAL_ADDRESS) != null)
            ConfigHelper.setInitialAddress(conf, System.getenv(PIG_INITIAL_ADDRESS));
        else if (ConfigHelper.getInitialAddress(conf) == null) 
            throw new IOException("PIG_INITIAL_ADDRESS environment variable not set");
        if (System.getenv(PIG_PARTITIONER) != null)
            ConfigHelper.setPartitioner(conf, System.getenv(PIG_PARTITIONER));
        else if (ConfigHelper.getPartitioner(conf) == null) 
            throw new IOException("PIG_PARTITIONER environment variable not set");
        if (System.getenv(PIG_ALLOW_DELETES) != null)
            allow_deletes = Boolean.valueOf(System.getenv(PIG_ALLOW_DELETES));
    };private void setConnectionInformation() throws IOException
    {
        if (System.getenv(PIG_RPC_PORT) != null)
            ConfigHelper.setRpcPort(conf, System.getenv(PIG_RPC_PORT));
        else if (ConfigHelper.getRpcPort(conf) == 0)
            throw new IOException("PIG_RPC_PORT environment variable not set");
        if (System.getenv(PIG_INITIAL_ADDRESS) != null)
            ConfigHelper.setInitialAddress(conf, System.getenv(PIG_INITIAL_ADDRESS));
        else if (ConfigHelper.getInitialAddress(conf) == null)
            throw new IOException("PIG_INITIAL_ADDRESS environment variable not set");
        if (System.getenv(PIG_PARTITIONER) != null)
            ConfigHelper.setPartitioner(conf, System.getenv(PIG_PARTITIONER));
        else if (ConfigHelper.getPartitioner(conf) == null)
            throw new IOException("PIG_PARTITIONER environment variable not set");
        if (System.getenv(PIG_ALLOW_DELETES) != null)
            allow_deletes = Boolean.valueOf(System.getenv(PIG_ALLOW_DELETES));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_43496_9bd38/rev_43496-9bd38;/src/java/org/apache/cassandra/cql3/Lists;bind(List<ByteBuffer>);;public Value bind(List<ByteBuffer> values) throws InvalidRequestException
        {
            ByteBuffer value = values.get(bindIndex);
            return value == null ? null : Value.fromSerialized(value, (ListType)receiver.type);

        };public Value bind(List<ByteBuffer> values) throws InvalidRequestException
        {
            ByteBuffer value = values.get(bindIndex);
            return value == null ? null : Value.fromSerialized(value, (ListType)receiver.type);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_77912_4d6b4/rev_77912-4d6b4;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeMarketDataFunction;buildMarketDataMap(FunctionInputs);;private VolatilityCubeData buildMarketDataMap(final FunctionInputs inputs) {
      final HashMap<VolatilityPoint, Double> dataPoints = new HashMap<VolatilityPoint, Double>();
      final HashMap<VolatilityPoint, ExternalId> dataIds = new HashMap<VolatilityPoint, ExternalId>();
      final HashMap<VolatilityPoint, Double> relativeStrikes = new HashMap<VolatilityPoint, Double>();
      final HashMap<Pair<Tenor, Tenor>, Double> strikes = new HashMap<Pair<Tenor, Tenor>, Double>();

      final HashMap<UniqueId, Double> otherData = new HashMap<UniqueId, Double>();

      for (final ComputedValue value : inputs.getAllValues()) {
        if (!(value.getValue() instanceof Double)) {
          continue;
        }
        final Double dValue = (Double) value.getValue();
        final VolatilityPoint volatilityPoint = getVolatilityPoint(value.getSpecification());
        final Pair<Tenor, Tenor> strikePoint = getStrikePoint(value.getSpecification());
        if (volatilityPoint == null && strikePoint == null) {
          otherData.put(value.getSpecification().getTargetSpecification().getUniqueId(), dValue);
        } else if (volatilityPoint != null && strikePoint == null) {
          if (volatilityPoint.getRelativeStrike() > -50) {
            final Double previous = dataPoints.put(volatilityPoint, dValue);
            final ExternalId previousId = dataIds.put(volatilityPoint, value.getSpecification().getTargetSpecification().getIdentifier());
            final Double previousRelativeStrike = relativeStrikes.put(volatilityPoint, volatilityPoint.getRelativeStrike()); 
            if (previous != null && previous > dValue) {
              //TODO: this is a hack because we don't understand which tickers are for straddles, so we presume that the straddle has lower vol
              dataPoints.put(volatilityPoint, previous);
              dataIds.put(volatilityPoint, previousId);
              relativeStrikes.put(volatilityPoint, previousRelativeStrike);
            }
          }
        } else if (volatilityPoint == null && strikePoint != null) {
          final Double previous = strikes.put(strikePoint, dValue);
          if (previous != null) {
            throw new OpenGammaRuntimeException("Got two values for strike ");
          }
        } else {
          throw new OpenGammaRuntimeException("Instrument is both a volatility and a strike");
        }
      }

      final VolatilityCubeData volatilityCubeData = new VolatilityCubeData();
      volatilityCubeData.setDataPoints(dataPoints);
      final SnapshotDataBundle bundle = new SnapshotDataBundle();
      bundle.setDataPoints(otherData);
      volatilityCubeData.setOtherData(bundle);
      volatilityCubeData.setDataIds(dataIds);
      volatilityCubeData.setRelativeStrikes(relativeStrikes);
      volatilityCubeData.setATMStrikes(strikes);
      return volatilityCubeData;
    };private VolatilityCubeData buildMarketDataMap(final FunctionInputs inputs) {
      final HashMap<VolatilityPoint, Double> dataPoints = new HashMap<VolatilityPoint, Double>();
      final HashMap<VolatilityPoint, ExternalId> dataIds = new HashMap<VolatilityPoint, ExternalId>();
      final HashMap<VolatilityPoint, Double> relativeStrikes = new HashMap<VolatilityPoint, Double>();
      final HashMap<Pair<Tenor, Tenor>, Double> strikes = new HashMap<Pair<Tenor, Tenor>, Double>();

      final HashMap<UniqueId, Double> otherData = new HashMap<UniqueId, Double>();

      for (final ComputedValue value : inputs.getAllValues()) {
        if (!(value.getValue() instanceof Double)) {
          continue;
        }
        final Double dValue = (Double) value.getValue();
        final VolatilityPoint volatilityPoint = getVolatilityPoint(value.getSpecification());
        final Pair<Tenor, Tenor> strikePoint = getStrikePoint(value.getSpecification());
        if (volatilityPoint == null && strikePoint == null) {
          otherData.put(value.getSpecification().getTargetSpecification().getUniqueId(), dValue);
        } else if (volatilityPoint != null && strikePoint == null) {
          if (volatilityPoint.getRelativeStrike() > -50) {
            final Double previous = dataPoints.put(volatilityPoint, dValue);
            final ExternalId previousId = dataIds.put(volatilityPoint, value.getSpecification().getTargetSpecification().getIdentifier());
            final Double previousRelativeStrike = relativeStrikes.put(volatilityPoint, volatilityPoint.getRelativeStrike());
            if (previous != null && previous > dValue) {
              //TODO: this is a hack because we don't understand which tickers are for straddles, so we presume that the straddle has lower vol
              dataPoints.put(volatilityPoint, previous);
              dataIds.put(volatilityPoint, previousId);
              relativeStrikes.put(volatilityPoint, previousRelativeStrike);
            }
          }
        } else if (volatilityPoint == null && strikePoint != null) {
          final Double previous = strikes.put(strikePoint, dValue);
          if (previous != null) {
            throw new OpenGammaRuntimeException("Got two values for strike ");
          }
        } else {
          throw new OpenGammaRuntimeException("Instrument is both a volatility and a strike");
        }
      }

      final VolatilityCubeData volatilityCubeData = new VolatilityCubeData();
      volatilityCubeData.setDataPoints(dataPoints);
      final SnapshotDataBundle bundle = new SnapshotDataBundle();
      bundle.setDataPoints(otherData);
      volatilityCubeData.setOtherData(bundle);
      volatilityCubeData.setDataIds(dataIds);
      volatilityCubeData.setRelativeStrikes(relativeStrikes);
      volatilityCubeData.setATMStrikes(strikes);
      return volatilityCubeData;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_77912_4d6b4/rev_77912-4d6b4;/projects/OG-Examples/src/main/java/com/opengamma/examples/loader/ExampleViewsPopulator;getSABRExtrapolationViewDefinition(String);;private ViewDefinition getSABRExtrapolationViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition("Mixed CM", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxDeltaCalculationPeriod(500L);
    viewDefinition.setMaxFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    final String curveConfig = "DefaultTwoCurveUSDConfig";
    final ViewCalculationConfiguration noExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "No Extrapolation");
    final ViewCalculationConfiguration rightExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "Right Extrapolation");
    final String[] securityTypes = new String[] {CapFloorCMSSpreadSecurity.SECURITY_TYPE, CapFloorSecurity.SECURITY_TYPE, SwapSecurity.SECURITY_TYPE};
    for (final String securityType : securityTypes) {
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
    }
    viewDefinition.addViewCalculationConfiguration(noExtrapolationConfig);
    viewDefinition.addViewCalculationConfiguration(rightExtrapolationConfig);
    return viewDefinition;
  };private ViewDefinition getSABRExtrapolationViewDefinition(final String portfolioName) {
    final UniqueId portfolioId = getPortfolioId(portfolioName).toLatest();
    final ViewDefinition viewDefinition = new ViewDefinition("Mixed CM", portfolioId, UserPrincipal.getTestUser());
    viewDefinition.setDefaultCurrency(Currency.USD);
    viewDefinition.setMaxDeltaCalculationPeriod(500L);
    viewDefinition.setMaxFullCalculationPeriod(500L);
    viewDefinition.setMinDeltaCalculationPeriod(500L);
    viewDefinition.setMinFullCalculationPeriod(500L);
    final String curveConfig = "DefaultTwoCurveUSDConfig";
    final ViewCalculationConfiguration noExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "No Extrapolation");
    final ViewCalculationConfiguration rightExtrapolationConfig = new ViewCalculationConfiguration(viewDefinition, "Right Extrapolation");
    final String[] securityTypes = new String[] {CapFloorCMSSpreadSecurity.SECURITY_TYPE, CapFloorSecurity.SECURITY_TYPE, SwapSecurity.SECURITY_TYPE };
    for (final String securityType : securityTypes) {
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      noExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_NO_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_ALPHA_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_NU_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, PRESENT_VALUE_SABR_RHO_SENSITIVITY,
          ValueProperties.with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Discounting").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
      rightExtrapolationConfig.addPortfolioRequirement(securityType, YIELD_CURVE_NODE_SENSITIVITIES,
          ValueProperties.with(CURVE, "Forward3M").with(CURVE_CALCULATION_CONFIG, curveConfig).with(CALCULATION_METHOD, SABRFunction.SABR_RIGHT_EXTRAPOLATION).get());
    }
    viewDefinition.addViewCalculationConfiguration(noExtrapolationConfig);
    viewDefinition.addViewCalculationConfiguration(rightExtrapolationConfig);
    return viewDefinition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_79650_980ea/rev_79650-980ea;/projects/OG-Analytics/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;updateInstruments(MultipleYieldCurveFinderDataBundle,List<InterestRateDerivative>);;protected static MultipleYieldCurveFinderDataBundle updateInstruments(final MultipleYieldCurveFinderDataBundle old, final List<InterestRateDerivative> instruments) {
    return new MultipleYieldCurveFinderDataBundle(instruments, old.getKnownCurves(), old.getUnknownCurveNodePoints(), old.getUnknownCurveInterpolators(), old
        .getUnknownCurveNodeSensitivityCalculators());
  };protected static MultipleYieldCurveFinderDataBundle updateInstruments(final MultipleYieldCurveFinderDataBundle old, final List<InterestRateDerivative> instruments) {
    return new MultipleYieldCurveFinderDataBundle(instruments, old.getKnownCurves(), old.getUnknownCurveNodePoints(), old.getUnknownCurveInterpolators(),
        old.getUnknownCurveNodeSensitivityCalculators());
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_90164_4b76d/rev_90164-4b76d;/projects/OG-Engine/src/com/opengamma/engine/function/resolver/ApplyToSubtree;accept(DependencyNode);;@Override
  public boolean accept(DependencyNode node) {
    while (node != null) {
      if (node.getComputationTarget().toSpecification().equals(_subtreeRoot)) {
        return true;
      }
            
      node = node.getDependentNode();
    }
    
    return false;
  };@Override
  public boolean accept(DependencyNode node) {
    while (node != null) {
      if (node.getComputationTarget().toSpecification().equals(_subtreeRoot)) {
        return true;
      }
      node = node.getDependentNode();
    }
    return false;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a8b14_08bc5/rev_a8b14-08bc5;/projects/OG-MasterDB/src/com/opengamma/masterdb/batch/AbstractBatchResultWriter;getValue(String,String,ValueProperties,ValueProperties,ComputationTargetSpecification);;public RiskValue getValue(String calcConfName, String valueName, ValueProperties requirement, ValueProperties specification, ComputationTargetSpecification ct) {
    Integer calcConfId = getCalculationConfigurationId(calcConfName);
    Integer valueId = getValueNameId(valueName);
    Integer computationTargetId = getComputationTargetId(ct);
    Integer valueRequirementId = getValueRequirementId(requirement);
    Integer valueSpecificationId = getValueSpecificationId(specification);
    
    MapSqlParameterSource params = new MapSqlParameterSource();
    params.addValue("calculation_configuration_id", calcConfId);
    params.addValue("value_name_id", valueId);
    params.addValue("computation_target_id", computationTargetId);
    params.addValue("value_requirement_id", valueRequirementId);
    params.addValue("value_specification_id", valueSpecificationId);
    
    try {
      return getJdbcTemplate().queryForObject(RiskValue.sqlGet(), RiskValue.ROW_MAPPER, params);
    } catch (IncorrectResultSizeDataAccessException e) {
      return null;
    }
  };public RiskValue getValue(String calcConfName, String valueName, ValueProperties requirement,
      ValueProperties specification, ComputationTargetSpecification ct) {
    Integer calcConfId = getCalculationConfigurationId(calcConfName);
    Integer valueId = getValueNameId(valueName);
    Integer computationTargetId = getComputationTargetId(ct);
    Integer valueRequirementId = getValueRequirementId(requirement);
    Integer valueSpecificationId = getValueSpecificationId(specification);
    
    MapSqlParameterSource params = new MapSqlParameterSource();
    params.addValue("calculation_configuration_id", calcConfId);
    params.addValue("value_name_id", valueId);
    params.addValue("computation_target_id", computationTargetId);
    params.addValue("value_requirement_id", valueRequirementId);
    params.addValue("value_specification_id", valueSpecificationId);
    
    try {
      return getJdbcTemplate().queryForObject(RiskValue.sqlGet(), RiskValue.ROW_MAPPER, params);
    } catch (IncorrectResultSizeDataAccessException e) {
      return null;
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_rxjava/rev_a7254_0d420/rev_a7254-0d420;/rxjava-core/src/main/java/rx/operators/OperationTake;testTakeWhile2();;@Test
        public void testTakeWhile2() {
            Observable<String> w = Observable.toObservable("one", "two", "three");
            Observable<String> take = Observable.create(takeWhileWithIndex(w, new Func2<String, Integer, Boolean>() {
                @Override
                public Boolean call(String input, Integer index) {
                    return index < 2;
                }
            }));

            @SuppressWarnings("unchecked")
            Observer<String> aObserver = mock(Observer.class);
            take.subscribe(aObserver);
            verify(aObserver, times(1)).onNext("one");
            verify(aObserver, times(1)).onNext("two");
            verify(aObserver, never()).onNext("three");
            verify(aObserver, never()).onError(any(Exception.class));
            verify(aObserver, times(1)).onCompleted();
        };@Test
        public void testTakeWhile2() {
            Observable<String> w = Observable.toObservable("one", "two", "three");
            Observable<String> take = Observable.create(takeWhileWithIndex(w, new Func2<String, Integer, Boolean>()
            {
                @Override
                public Boolean call(String input, Integer index)
                {
                    return index < 2;
                }
            }));

            @SuppressWarnings("unchecked")
            Observer<String> aObserver = mock(Observer.class);
            take.subscribe(aObserver);
            verify(aObserver, times(1)).onNext("one");
            verify(aObserver, times(1)).onNext("two");
            verify(aObserver, never()).onNext("three");
            verify(aObserver, never()).onError(any(Exception.class));
            verify(aObserver, times(1)).onCompleted();
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a8551_a1d41/rev_a8551-a1d41;/projects/OG-Util/src/com/opengamma/component/CommandMonitor;run();;@Override
  public void run() {
    while(true) {
      byte[] buffer = new byte[COMMAND_LENGTH];
      DatagramPacket packet = new DatagramPacket(buffer,buffer.length);
      try {
      _socket.receive(packet);
      } catch (IOException e) {
        s_logger.warn("Error while receiving command packet");
        continue;
      }
      String received = new String(packet.getData(), 0, packet.getLength());

      if(!received.matches("secret:"+_secret+"\\s+command:\\w+\\s*")) {
        s_logger.debug("Malformed command or wrong secret");
        continue;
      }

      String command=received.replaceAll("secret:"+_secret+"\\s+command:(\\w+)\\s*","$1");
      s_logger.debug("Received command \"{}\"", command);

      if(command.equals("stop")) {
        /* What do we do if the repo isn't running? */
        if(_repo.isRunning()) {
          _repo.stop();
        }
      } else if(command.equals("exit")) {
        if(_repo.isRunning()) {
          _repo.stop();
        }
        System.exit(0);
      } else {
        s_logger.debug("Unknown command \"{}\"", command);
      }
    }
  };@Override
  public void run() {
    while (true) {
      byte[] buffer = new byte[COMMAND_LENGTH];
      DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
      try {
        _socket.receive(packet);
      } catch (IOException e) {
        s_logger.warn("Error while receiving command packet");
        continue;
      }
      String received = new String(packet.getData(), 0, packet.getLength());

      if (!received.matches("secret:" + _secret + "\\s+command:\\w+\\s*")) {
        s_logger.debug("Malformed command or wrong secret");
        continue;
      }

      String command = received.replaceAll("secret:" + _secret + "\\s+command:(\\w+)\\s*", "$1");
      s_logger.debug("Received command \"{}\"", command);

      if (command.equals("stop")) {
        /* What do we do if the repo isn't running? */
        if (_repo.isRunning()) {
          _repo.stop();
        }
      } else if (command.equals("exit")) {
        if (_repo.isRunning()) {
          _repo.stop();
        }
        System.exit(0);
      } else {
        s_logger.debug("Unknown command \"{}\"", command);
      }
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_a9352_c2561/rev_a9352-c2561;/core/src/main/java/com/orientechnologies/orient/core/index/OIndexMultiValues;getEntriesMajor(Object,boolean,boolean,IndexEntriesResultListener);;public void getEntriesMajor(Object iRangeFrom, final boolean isInclusive, boolean ascOrder, final IndexEntriesResultListener entriesResultListener) {
    checkForRebuild();

    iRangeFrom = getCollatingValue(iRangeFrom);

    acquireSharedLock();
    try {
      indexEngine.getEntriesMajor(iRangeFrom, isInclusive, ascOrder, MultiValuesTransformer.INSTANCE, new OIndexEngine.EntriesResultListener() {
          @Override
          public boolean addResult(ODocument entry) {
            return entriesResultListener.addResult(entry);
          }
        }
      );
    } finally {
      releaseSharedLock();
    }
  };public void getEntriesMajor(Object iRangeFrom, final boolean isInclusive, boolean ascOrder,
      final IndexEntriesResultListener entriesResultListener) {
    checkForRebuild();

    iRangeFrom = getCollatingValue(iRangeFrom);

    acquireSharedLock();
    try {
      indexEngine.getEntriesMajor(iRangeFrom, isInclusive, ascOrder, MultiValuesTransformer.INSTANCE,
          new OIndexEngine.EntriesResultListener() {
            @Override
            public boolean addResult(ODocument entry) {
              return entriesResultListener.addResult(entry);
            }
          });
    } finally {
      releaseSharedLock();
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_a9352_c2561/rev_a9352-c2561;/core/src/main/java/com/orientechnologies/orient/core/index/OIndexMultiValues;getEntriesMinor(Object,boolean,boolean,IndexEntriesResultListener);;public void getEntriesMinor(Object iRangeTo, boolean isInclusive, boolean ascOrder, final IndexEntriesResultListener entriesResultListener) {
    checkForRebuild();

    iRangeTo = getCollatingValue(iRangeTo);

    acquireSharedLock();
    try {
      indexEngine.getEntriesMinor(iRangeTo, isInclusive, ascOrder, MultiValuesTransformer.INSTANCE, new OIndexEngine.EntriesResultListener() {
          @Override
          public boolean addResult(ODocument entry) {
            return entriesResultListener.addResult(entry);
          }
        }
      );
    } finally {
      releaseSharedLock();
    }
  };public void getEntriesMinor(Object iRangeTo, boolean isInclusive, boolean ascOrder,
      final IndexEntriesResultListener entriesResultListener) {
    checkForRebuild();

    iRangeTo = getCollatingValue(iRangeTo);

    acquireSharedLock();
    try {
      indexEngine.getEntriesMinor(iRangeTo, isInclusive, ascOrder, MultiValuesTransformer.INSTANCE,
          new OIndexEngine.EntriesResultListener() {
            @Override
            public boolean addResult(ODocument entry) {
              return entriesResultListener.addResult(entry);
            }
          });
    } finally {
      releaseSharedLock();
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_a9352_c2561/rev_a9352-c2561;/core/src/main/java/com/orientechnologies/orient/core/index/OIndexMultiValues;getEntriesBetween(Object,Object,boolean,boolean,IndexEntriesResultListener);;public void getEntriesBetween(Object iRangeFrom, Object iRangeTo, boolean inclusive, boolean ascOrder, final IndexEntriesResultListener indexEntriesResultListener) {
    checkForRebuild();

    iRangeFrom = getCollatingValue(iRangeFrom);
    iRangeTo = getCollatingValue(iRangeTo);

    final OType[] types = getDefinition().getTypes();
    if (types.length == 1) {
      iRangeFrom = OType.convert(iRangeFrom, types[0].getDefaultJavaType());
      iRangeTo = OType.convert(iRangeTo, types[0].getDefaultJavaType());
    }

    acquireSharedLock();
    try {
      indexEngine.getEntriesBetween(iRangeFrom, iRangeTo, inclusive, ascOrder, MultiValuesTransformer.INSTANCE, new OIndexEngine.EntriesResultListener() {
          @Override
          public boolean addResult(ODocument entry) {
            return indexEntriesResultListener.addResult(entry);
          }
        }
      );
    } finally {
      releaseSharedLock();
    }

  };public void getEntriesBetween(Object iRangeFrom, Object iRangeTo, boolean inclusive, boolean ascOrder,
      final IndexEntriesResultListener indexEntriesResultListener) {
    checkForRebuild();

    iRangeFrom = getCollatingValue(iRangeFrom);
    iRangeTo = getCollatingValue(iRangeTo);

    final OType[] types = getDefinition().getTypes();
    if (types.length == 1) {
      iRangeFrom = OType.convert(iRangeFrom, types[0].getDefaultJavaType());
      iRangeTo = OType.convert(iRangeTo, types[0].getDefaultJavaType());
    }

    acquireSharedLock();
    try {
      indexEngine.getEntriesBetween(iRangeFrom, iRangeTo, inclusive, ascOrder, MultiValuesTransformer.INSTANCE,
          new OIndexEngine.EntriesResultListener() {
            @Override
            public boolean addResult(ODocument entry) {
              return indexEntriesResultListener.addResult(entry);
            }
          });
    } finally {
      releaseSharedLock();
    }

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_a9352_c2561/rev_a9352-c2561;/core/src/main/java/com/orientechnologies/orient/core/index/OIndexMultiValues;valuesIterator();;public Iterator<OIdentifiable> valuesIterator() {
    checkForRebuild();
    acquireSharedLock();
    try {

      return new OSharedResourceIterator<OIdentifiable>(this, new OMultiCollectionIterator<OIdentifiable>(indexEngine.valuesIterator()));

    } finally {
      releaseSharedLock();
    }
  };public Iterator<OIdentifiable> valuesIterator() {
    checkForRebuild();
    acquireSharedLock();
    try {

      return new OSharedResourceIterator<OIdentifiable>(this, new OMultiCollectionIterator<OIdentifiable>(
          indexEngine.valuesIterator()));

    } finally {
      releaseSharedLock();
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b70bb_daa2e/rev_b70bb-daa2e;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/bond/BondFunction;getComputedValues(FunctionExecutionContext,CurrencyUnit,Security,BondDefinition,Object,LocalDate,String);;protected abstract Set<ComputedValue> getComputedValues(FunctionExecutionContext context, CurrencyUnit currency, Security security, BondDefinition bond, Object value, LocalDate now,
      String yieldCurveName);;protected abstract Set<ComputedValue> getComputedValues(FunctionExecutionContext context, CurrencyUnit currency,
      Security security, BondDefinition bond, Object value, LocalDate now, String yieldCurveName);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_ba864_d4f7c/rev_ba864-d4f7c;/lucene/src/java/org/apache/lucene/index/SegmentMerger;merge(boolean);;final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {

    this.mergeDocStores = mergeDocStores;
    
    // NOTE: it's important to add calls to
    // checkAbort.work(...) if you make any changes to this
    // method that will spend alot of time.  The frequency
    // of this check impacts how long
    // IndexWriter.close(false) takes to actually stop the
    // threads.

    mergedDocs = mergeFields();
    mergeTerms();
    mergeNorms();

    if (mergeDocStores && fieldInfos.hasVectors())
      mergeVectors();

    return mergedDocs;
  };final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {

    this.mergeDocStores = mergeDocStores;
    
    // NOTE: it's important to add calls to
    // checkAbort.work(...) if you make any changes to this
    // method that will spend alot of time.  The frequency
    // of this check impacts how long
    // IndexWriter.close(false) takes to actually stop the
    // threads.

    mergedDocs = mergeFields();
    mergeTerms();
    mergeNorms();

    if (mergeDocStores && fieldInfos.hasVectors())
      mergeVectors();
    return mergedDocs;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_bfaf6_386ae/rev_bfaf6-386ae;/tightdb-java-core/src/main/java/com/tightdb/ColumnType;getColumnTypeForIndex(int);;public static ColumnType getColumnTypeForIndex(int index){
		ColumnType[] columnTypes = values();
		for(int i=0; i<columnTypes.length; i++){
			if(columnTypes[i].index == index)
				return columnTypes[i];
		}
		return null;
	};public static ColumnType getColumnTypeForIndex(int index) {
		ColumnType[] columnTypes = values();
		for (int i=0; i<columnTypes.length; i++) {
			if (columnTypes[i].index == index)
				return columnTypes[i];
		}
		return null;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ThirtyEThreeSixtyISDA;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    throw new NotImplementedException("Need to know whether the second date is the maturity");
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    throw new NotImplementedException("Need to know whether the second date is the maturity");
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ThirtyEThreeSixtyISDA;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int,boolean);;public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear, final boolean isMaturity) {
    return coupon * getDayCountFraction(previousCouponDate, date, isMaturity);
  };public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear,
      final boolean isMaturity) {
    return coupon * getDayCountFraction(previousCouponDate, date, isMaturity);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualThreeSixtyFive;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualThreeSixtyFiveLong;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    testDates(previousCouponDate, date, nextCouponDate);
    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    double daysPerYear;
    if (paymentsPerYear == 1) {
      if (next.isLeapYear()) {
        final LocalDate feb29 = LocalDate.of(next.getYear(), 2, 29);
        if (!next.isBefore(feb29) && previous.isBefore(feb29)) {
          daysPerYear = 366;
        } else {
          daysPerYear = 365;
        }
      } else if (previous.isLeapYear()) {
        final LocalDate feb29 = LocalDate.of(previous.getYear(), 2, 29);
        if (!next.isBefore(feb29) && previous.isBefore(feb29)) {
          daysPerYear = 366;
        } else {
          daysPerYear = 365;
        }
      } else {
        daysPerYear = 365;
      }
    } else {
      daysPerYear = next.isLeapYear() ? 366 : 365;
    }
    final long firstJulianDate = previous.toModifiedJulianDays();
    final long secondJulianDate = date.toLocalDate().toModifiedJulianDays();
    return coupon * (secondJulianDate - firstJulianDate) / daysPerYear;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    testDates(previousCouponDate, date, nextCouponDate);
    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    double daysPerYear;
    if (paymentsPerYear == 1) {
      if (next.isLeapYear()) {
        final LocalDate feb29 = LocalDate.of(next.getYear(), 2, 29);
        if (!next.isBefore(feb29) && previous.isBefore(feb29)) {
          daysPerYear = 366;
        } else {
          daysPerYear = 365;
        }
      } else if (previous.isLeapYear()) {
        final LocalDate feb29 = LocalDate.of(previous.getYear(), 2, 29);
        if (!next.isBefore(feb29) && previous.isBefore(feb29)) {
          daysPerYear = 366;
        } else {
          daysPerYear = 365;
        }
      } else {
        daysPerYear = 365;
      }
    } else {
      daysPerYear = next.isLeapYear() ? 366 : 365;
    }
    final long firstJulianDate = previous.toModifiedJulianDays();
    final long secondJulianDate = date.toLocalDate().toModifiedJulianDays();
    return coupon * (secondJulianDate - firstJulianDate) / daysPerYear;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualISDA;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/OneOneDayCount;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return coupon / paymentsPerYear;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return coupon / paymentsPerYear;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualThreeSixty;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return getDayCountFraction(previousCouponDate, date) * coupon;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualICMA;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return getAccruedInterest(previousCouponDate, date, nextCouponDate, coupon, paymentsPerYear, StubType.NONE);
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return getAccruedInterest(previousCouponDate, date, nextCouponDate, coupon, paymentsPerYear, StubType.NONE);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualICMA;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int,StubType);;public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear, final StubType stubType) {
    testDates(previousCouponDate, date, nextCouponDate);
    Validate.notNull(stubType, "stub type");
    
    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    long daysBetween, daysBetweenCoupons;
    final long previousCouponDateJulian = previous.toModifiedJulianDays();
    final long nextCouponDateJulian = next.toModifiedJulianDays();
    final long dateJulian = date.toLocalDate().toModifiedJulianDays();
    final int months = 12 / paymentsPerYear;
    switch (stubType) {
      case NONE: {
        daysBetween = dateJulian - previousCouponDateJulian;
        daysBetweenCoupons = next.toModifiedJulianDays() - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case SHORT_START: {
        final LocalDate notionalStart = getEOMAdjustedDate(next, next.minusMonths(months));
        daysBetweenCoupons = nextCouponDateJulian - notionalStart.toLocalDate().toModifiedJulianDays();
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_START: {
        long firstNotionalJulian = getEOMAdjustedDate(next, next.minusMonths(months * 2)).toModifiedJulianDays();
        long secondNotionalJulian = getEOMAdjustedDate(next, next.minusMonths(months)).toModifiedJulianDays();
        long daysBetweenStub = secondNotionalJulian - previousCouponDateJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        if (dateJulian > secondNotionalJulian) {
          daysBetween = dateJulian - secondNotionalJulian;
          return coupon * (daysBetweenStub / daysBetweenTwoNotionalCoupons + 1) / paymentsPerYear;
        }
        daysBetween = dateJulian - firstNotionalJulian;
        return coupon * (daysBetween / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      case SHORT_END: {
        final LocalDate notionalEnd = getEOMAdjustedDate(previous, previous.plusMonths(months));
        daysBetweenCoupons = notionalEnd.toModifiedJulianDays() - previousCouponDateJulian;
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_END: {
        long firstNotionalJulian = getEOMAdjustedDate(previous, previous.plusMonths(months)).toModifiedJulianDays();
        long secondNotionalJulian = getEOMAdjustedDate(previous, previous.plusMonths(2 * months)).toModifiedJulianDays();
        final long daysBetweenPreviousAndFirstNotional = firstNotionalJulian - previousCouponDateJulian;
        if (dateJulian < firstNotionalJulian) {
          daysBetween = dateJulian - previousCouponDateJulian;
          return coupon * daysBetween / daysBetweenPreviousAndFirstNotional / paymentsPerYear;
        }
        long daysBetweenStub = dateJulian - firstNotionalJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        return coupon * (1 + daysBetweenStub / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      default:
        throw new IllegalArgumentException("Cannot handle stub type " + stubType);
    }
  };public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear,
      final StubType stubType) {
    testDates(previousCouponDate, date, nextCouponDate);
    Validate.notNull(stubType, "stub type");

    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    long daysBetween, daysBetweenCoupons;
    final long previousCouponDateJulian = previous.toModifiedJulianDays();
    final long nextCouponDateJulian = next.toModifiedJulianDays();
    final long dateJulian = date.toLocalDate().toModifiedJulianDays();
    final int months = 12 / paymentsPerYear;
    switch (stubType) {
      case NONE: {
        daysBetween = dateJulian - previousCouponDateJulian;
        daysBetweenCoupons = next.toModifiedJulianDays() - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case SHORT_START: {
        final LocalDate notionalStart = getEOMAdjustedDate(next, next.minusMonths(months));
        daysBetweenCoupons = nextCouponDateJulian - notionalStart.toLocalDate().toModifiedJulianDays();
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_START: {
        long firstNotionalJulian = getEOMAdjustedDate(next, next.minusMonths(months * 2)).toModifiedJulianDays();
        long secondNotionalJulian = getEOMAdjustedDate(next, next.minusMonths(months)).toModifiedJulianDays();
        long daysBetweenStub = secondNotionalJulian - previousCouponDateJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        if (dateJulian > secondNotionalJulian) {
          daysBetween = dateJulian - secondNotionalJulian;
          return coupon * (daysBetweenStub / daysBetweenTwoNotionalCoupons + 1) / paymentsPerYear;
        }
        daysBetween = dateJulian - firstNotionalJulian;
        return coupon * (daysBetween / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      case SHORT_END: {
        final LocalDate notionalEnd = getEOMAdjustedDate(previous, previous.plusMonths(months));
        daysBetweenCoupons = notionalEnd.toModifiedJulianDays() - previousCouponDateJulian;
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_END: {
        long firstNotionalJulian = getEOMAdjustedDate(previous, previous.plusMonths(months)).toModifiedJulianDays();
        long secondNotionalJulian = getEOMAdjustedDate(previous, previous.plusMonths(2 * months)).toModifiedJulianDays();
        final long daysBetweenPreviousAndFirstNotional = firstNotionalJulian - previousCouponDateJulian;
        if (dateJulian < firstNotionalJulian) {
          daysBetween = dateJulian - previousCouponDateJulian;
          return coupon * daysBetween / daysBetweenPreviousAndFirstNotional / paymentsPerYear;
        }
        long daysBetweenStub = dateJulian - firstNotionalJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        return coupon * (1 + daysBetweenStub / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      default:
        throw new IllegalArgumentException("Cannot handle stub type " + stubType);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualAFB;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return coupon * getDayCountFraction(previousCouponDate, date);
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return coupon * getDayCountFraction(previousCouponDate, date);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualTypeDayCount;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public abstract double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear);;@Override
  public abstract double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualICMANormal;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return getAccruedInterest(previousCouponDate, date, nextCouponDate, coupon, paymentsPerYear, StubType.NONE);
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return getAccruedInterest(previousCouponDate, date, nextCouponDate, coupon, paymentsPerYear, StubType.NONE);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/ActualActualICMANormal;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int,StubType);;public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear, final StubType stubType) {
    testDates(previousCouponDate, date, nextCouponDate);
    Validate.notNull(stubType, "stub type");
    
    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    long daysBetween, daysBetweenCoupons;
    final long previousCouponDateJulian = previous.toModifiedJulianDays();
    final long nextCouponDateJulian = next.toModifiedJulianDays();
    final long dateJulian = date.toLocalDate().toModifiedJulianDays();
    final int months = 12 / paymentsPerYear;
    switch (stubType) {
      case NONE: {
        daysBetween = dateJulian - previousCouponDateJulian;
        daysBetweenCoupons = next.toModifiedJulianDays() - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case SHORT_START: {
        final LocalDate notionalStart = next.minusMonths(months);
        daysBetweenCoupons = nextCouponDateJulian - notionalStart.toLocalDate().toModifiedJulianDays();
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_START: {
        long firstNotionalJulian = next.minusMonths(months * 2).toModifiedJulianDays();
        long secondNotionalJulian = next.minusMonths(months).toModifiedJulianDays();
        long daysBetweenStub = secondNotionalJulian - previousCouponDateJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        if (dateJulian > secondNotionalJulian) {
          daysBetween = dateJulian - secondNotionalJulian;
          return coupon * (daysBetweenStub / daysBetweenTwoNotionalCoupons + 1) / paymentsPerYear;
        }
        daysBetween = dateJulian - firstNotionalJulian;
        return coupon * (daysBetween / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      case SHORT_END: {
        final LocalDate notionalEnd = previous.plusMonths(months);
        daysBetweenCoupons = notionalEnd.toModifiedJulianDays() - previousCouponDateJulian;
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_END: {
        long firstNotionalJulian = previous.plusMonths(months).toModifiedJulianDays();
        long secondNotionalJulian = previous.plusMonths(2 * months).toModifiedJulianDays();
        final long daysBetweenPreviousAndFirstNotional = firstNotionalJulian - previousCouponDateJulian;
        if (dateJulian < firstNotionalJulian) {
          daysBetween = dateJulian - previousCouponDateJulian;
          return coupon * daysBetween / daysBetweenPreviousAndFirstNotional / paymentsPerYear;
        }
        long daysBetweenStub = dateJulian - firstNotionalJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        return coupon * (1 + daysBetweenStub / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      default:
        throw new IllegalArgumentException("Cannot handle stub type " + stubType);
    }
  };public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear,
      final StubType stubType) {
    testDates(previousCouponDate, date, nextCouponDate);
    Validate.notNull(stubType, "stub type");

    final LocalDate previous = previousCouponDate.toLocalDate();
    final LocalDate next = nextCouponDate.toLocalDate();
    long daysBetween, daysBetweenCoupons;
    final long previousCouponDateJulian = previous.toModifiedJulianDays();
    final long nextCouponDateJulian = next.toModifiedJulianDays();
    final long dateJulian = date.toLocalDate().toModifiedJulianDays();
    final int months = 12 / paymentsPerYear;
    switch (stubType) {
      case NONE: {
        daysBetween = dateJulian - previousCouponDateJulian;
        daysBetweenCoupons = next.toModifiedJulianDays() - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case SHORT_START: {
        final LocalDate notionalStart = next.minusMonths(months);
        daysBetweenCoupons = nextCouponDateJulian - notionalStart.toLocalDate().toModifiedJulianDays();
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_START: {
        long firstNotionalJulian = next.minusMonths(months * 2).toModifiedJulianDays();
        long secondNotionalJulian = next.minusMonths(months).toModifiedJulianDays();
        long daysBetweenStub = secondNotionalJulian - previousCouponDateJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        if (dateJulian > secondNotionalJulian) {
          daysBetween = dateJulian - secondNotionalJulian;
          return coupon * (daysBetweenStub / daysBetweenTwoNotionalCoupons + 1) / paymentsPerYear;
        }
        daysBetween = dateJulian - firstNotionalJulian;
        return coupon * (daysBetween / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      case SHORT_END: {
        final LocalDate notionalEnd = previous.plusMonths(months);
        daysBetweenCoupons = notionalEnd.toModifiedJulianDays() - previousCouponDateJulian;
        daysBetween = dateJulian - previousCouponDateJulian;
        return coupon * daysBetween / daysBetweenCoupons / paymentsPerYear;
      }
      case LONG_END: {
        long firstNotionalJulian = previous.plusMonths(months).toModifiedJulianDays();
        long secondNotionalJulian = previous.plusMonths(2 * months).toModifiedJulianDays();
        final long daysBetweenPreviousAndFirstNotional = firstNotionalJulian - previousCouponDateJulian;
        if (dateJulian < firstNotionalJulian) {
          daysBetween = dateJulian - previousCouponDateJulian;
          return coupon * daysBetween / daysBetweenPreviousAndFirstNotional / paymentsPerYear;
        }
        long daysBetweenStub = dateJulian - firstNotionalJulian;
        double daysBetweenTwoNotionalCoupons = secondNotionalJulian - firstNotionalJulian;
        return coupon * (1 + daysBetweenStub / daysBetweenTwoNotionalCoupons) / paymentsPerYear;
      }
      default:
        throw new IllegalArgumentException("Cannot handle stub type " + stubType);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c0fe8_af2fe/rev_c0fe8-af2fe;/projects/OG-Analytics/src/com/opengamma/financial/convention/daycount/FlatDayCount;getAccruedInterest(ZonedDateTime,ZonedDateTime,ZonedDateTime,double,int);;@Override
  public double getAccruedInterest(
      final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate,
      final double coupon, final int paymentsPerYear) {
    return 0;
  };@Override
  public double getAccruedInterest(final ZonedDateTime previousCouponDate, final ZonedDateTime date, final ZonedDateTime nextCouponDate, final double coupon, final int paymentsPerYear) {
    return 0;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2c78_b77c7/rev_c2c78-b77c7;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/CurveDefinitionAndSpecifications;buildForwardCurve(Currency,Tenor[],Tenor,int,Tenor[]);;public static YieldCurveDefinition buildForwardCurve(Currency ccy, Tenor[] liborStrips, Tenor futureStartTenor, int numQuarterlyFutures, Tenor[] swaps) {
    final Collection<FixedIncomeStrip> strips = new ArrayList<FixedIncomeStrip>();
    for (Tenor liborTenor : liborStrips) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.LIBOR, liborTenor, "DEFAULT"));
    }
    if (futureStartTenor != null) {
      for (int i=1; i <= numQuarterlyFutures; i++) {
        strips.add(new FixedIncomeStrip(StripInstrumentType.FUTURE, futureStartTenor, i, "DEFAULT"));
      }
    }
    for (Tenor tenorSwapTenor : swaps) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.SWAP, tenorSwapTenor, "DEFAULT"));
    }
    final YieldCurveDefinition definition = new YieldCurveDefinition(ccy, "FORWARD", Interpolator1DFactory.DOUBLE_QUADRATIC, strips);
    return definition;
  };public static YieldCurveDefinition buildForwardCurve(Currency ccy, Tenor[] liborStrips, Tenor futureStartTenor, int numQuarterlyFutures, Tenor[] swaps) {
    final Collection<FixedIncomeStrip> strips = new ArrayList<FixedIncomeStrip>();
    for (Tenor liborTenor : liborStrips) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.LIBOR, liborTenor, "DEFAULT"));
    }
    if (futureStartTenor != null) {
      for (int i = 1; i <= numQuarterlyFutures; i++) {
        strips.add(new FixedIncomeStrip(StripInstrumentType.FUTURE, futureStartTenor, i, "DEFAULT"));
      }
    }
    for (Tenor tenorSwapTenor : swaps) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.SWAP, tenorSwapTenor, "DEFAULT"));
    }
    final YieldCurveDefinition definition = new YieldCurveDefinition(ccy, "FORWARD", Interpolator1DFactory.DOUBLE_QUADRATIC, strips);
    return definition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2c78_b77c7/rev_c2c78-b77c7;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/CurveDefinitionAndSpecifications;buildSingleCurve(Currency,Tenor[],Tenor,int,Tenor[]);;public static YieldCurveDefinition buildSingleCurve(Currency ccy, Tenor[] liborStrips, Tenor futureStartTenor, int numQuarterlyFutures, Tenor[] swaps) {
    final Collection<FixedIncomeStrip> strips = new ArrayList<FixedIncomeStrip>();
    for (Tenor liborTenor : liborStrips) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.LIBOR, liborTenor, "DEFAULT"));
    }
    if (futureStartTenor != null) {
      for (int i=1; i <= numQuarterlyFutures; i++) {
        strips.add(new FixedIncomeStrip(StripInstrumentType.FUTURE, futureStartTenor, i, "DEFAULT"));
      }
    }
    for (Tenor tenorSwapTenor : swaps) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.SWAP, tenorSwapTenor, "DEFAULT"));
    }
    final YieldCurveDefinition definition = new YieldCurveDefinition(ccy, "SINGLE", Interpolator1DFactory.DOUBLE_QUADRATIC, strips);
    return definition;
  };public static YieldCurveDefinition buildSingleCurve(Currency ccy, Tenor[] liborStrips, Tenor futureStartTenor, int numQuarterlyFutures, Tenor[] swaps) {
    final Collection<FixedIncomeStrip> strips = new ArrayList<FixedIncomeStrip>();
    for (Tenor liborTenor : liborStrips) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.LIBOR, liborTenor, "DEFAULT"));
    }
    if (futureStartTenor != null) {
      for (int i = 1; i <= numQuarterlyFutures; i++) {
        strips.add(new FixedIncomeStrip(StripInstrumentType.FUTURE, futureStartTenor, i, "DEFAULT"));
      }
    }
    for (Tenor tenorSwapTenor : swaps) {
      strips.add(new FixedIncomeStrip(StripInstrumentType.SWAP, tenorSwapTenor, "DEFAULT"));
    }
    final YieldCurveDefinition definition = new YieldCurveDefinition(ccy, "SINGLE", Interpolator1DFactory.DOUBLE_QUADRATIC, strips);
    return definition;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c9abb_03167/rev_c9abb-03167;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/pnl/SecurityPriceSeriesFunction;getRequirements(FunctionCompilationContext,ComputationTarget);;@Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target) {
    return Collections.<ValueRequirement> emptySet();
  };@Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target) {
    return Collections.<ValueRequirement>emptySet();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c9abb_03167/rev_c9abb-03167;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/pnl/OptionGreekUnderlyingPriceSeriesFunction;getRequirements(FunctionCompilationContext,ComputationTarget);;@Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target) {
    return Collections.<ValueRequirement> emptySet();
  };@Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target) {
    return Collections.<ValueRequirement>emptySet();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c9cef_79f38/rev_c9cef-79f38;/test/unit/org/apache/cassandra/pig/ThriftColumnFamilyTest;testCassandraStorageCompositeKeyCF();;@Test
    public void testCassandraStorageCompositeKeyCF() throws IOException, ClassNotFoundException, TException, TimedOutException, NotFoundException, InvalidRequestException, NoSuchFieldException, UnavailableException, IllegalAccessException, InstantiationException, AuthenticationException, AuthorizationException
    {
        //Test CompositeKey
        pig.registerQuery("compokeys = load 'cassandra://thriftKs/CompoKey?" + defaultParameters + "' using CassandraStorage();");
        pig.registerQuery("compokeys = filter compokeys by key.$1 == 40;");
        //((clock,40),{(6,coffee...)})
        Iterator<Tuple> it = pig.openIterator("compokeys");
        if (it.hasNext()) {
            Tuple t = it.next();
            Tuple key = (Tuple) t.get(0); 
            Assert.assertEquals(key.get(0), "clock");
            Assert.assertEquals(key.get(1), 40L);
            DataBag columns = (DataBag) t.get(1);
            Iterator<Tuple> iter = columns.iterator();
            if (iter.hasNext())
            {
                Tuple t1 = iter.next();
                Assert.assertEquals(t1.get(0), 6L);
                Assert.assertEquals(t1.get(1), "coffee...");
            }
        }
        pig.setBatchOn();
        pig.registerQuery("compo_key_rows = LOAD 'cassandra://thriftKs/CompoKey?" + defaultParameters + "' using CassandraStorage();");
        pig.registerQuery("STORE compo_key_rows INTO 'cassandra://thriftKs/CompoKeyCopy?" + defaultParameters + "' using CassandraStorage();");
        pig.executeBatch();
        pig.registerQuery("compo_key_copy_rows = LOAD 'cassandra://thriftKs/CompoKeyCopy?" + defaultParameters + "' using CassandraStorage();");
        //((clock,10),{(1,z)})
        //((clock,20),{(1,zzzz)})
        //((clock,30),{(2,daddy?)})
        //((clock,40),{(6,coffee...)})
        it = pig.openIterator("compo_key_copy_rows");
        int count = 0;
        while (it.hasNext()) {
            Tuple t = it.next();
            count ++;
            if (count == 1)
            {
                Tuple key = (Tuple) t.get(0); 
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 10L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 1L);
                    Assert.assertEquals(t1.get(1), "z");
                }
            }
            else if (count == 2)
            {
                Tuple key = (Tuple) t.get(0); 
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 20L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 1L);
                    Assert.assertEquals(t1.get(1), "zzzz");
                }
            }
            else if (count == 3)
            {
                Tuple key = (Tuple) t.get(0); 
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 30L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 2L);
                    Assert.assertEquals(t1.get(1), "daddy?");
                }
            }
            else if (count == 4)
            {
                Tuple key = (Tuple) t.get(0); 
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 40L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 6L);
                    Assert.assertEquals(t1.get(1), "coffee...");
                }
            }
        }
        Assert.assertEquals(count, 4);
    };@Test
    public void testCassandraStorageCompositeKeyCF() throws IOException, ClassNotFoundException, TException, TimedOutException, NotFoundException, InvalidRequestException, NoSuchFieldException, UnavailableException, IllegalAccessException, InstantiationException, AuthenticationException, AuthorizationException
    {
        //Test CompositeKey
        pig.registerQuery("compokeys = load 'cassandra://thriftKs/CompoKey?" + defaultParameters + "' using CassandraStorage();");
        pig.registerQuery("compokeys = filter compokeys by key.$1 == 40;");
        //((clock,40),{(6,coffee...)})
        Iterator<Tuple> it = pig.openIterator("compokeys");
        if (it.hasNext()) {
            Tuple t = it.next();
            Tuple key = (Tuple) t.get(0);
            Assert.assertEquals(key.get(0), "clock");
            Assert.assertEquals(key.get(1), 40L);
            DataBag columns = (DataBag) t.get(1);
            Iterator<Tuple> iter = columns.iterator();
            if (iter.hasNext())
            {
                Tuple t1 = iter.next();
                Assert.assertEquals(t1.get(0), 6L);
                Assert.assertEquals(t1.get(1), "coffee...");
            }
        }
        pig.setBatchOn();
        pig.registerQuery("compo_key_rows = LOAD 'cassandra://thriftKs/CompoKey?" + defaultParameters + "' using CassandraStorage();");
        pig.registerQuery("STORE compo_key_rows INTO 'cassandra://thriftKs/CompoKeyCopy?" + defaultParameters + "' using CassandraStorage();");
        pig.executeBatch();
        pig.registerQuery("compo_key_copy_rows = LOAD 'cassandra://thriftKs/CompoKeyCopy?" + defaultParameters + "' using CassandraStorage();");
        //((clock,10),{(1,z)})
        //((clock,20),{(1,zzzz)})
        //((clock,30),{(2,daddy?)})
        //((clock,40),{(6,coffee...)})
        it = pig.openIterator("compo_key_copy_rows");
        int count = 0;
        while (it.hasNext()) {
            Tuple t = it.next();
            count ++;
            if (count == 1)
            {
                Tuple key = (Tuple) t.get(0);
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 10L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 1L);
                    Assert.assertEquals(t1.get(1), "z");
                }
            }
            else if (count == 2)
            {
                Tuple key = (Tuple) t.get(0);
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 20L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 1L);
                    Assert.assertEquals(t1.get(1), "zzzz");
                }
            }
            else if (count == 3)
            {
                Tuple key = (Tuple) t.get(0);
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 30L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 2L);
                    Assert.assertEquals(t1.get(1), "daddy?");
                }
            }
            else if (count == 4)
            {
                Tuple key = (Tuple) t.get(0);
                Assert.assertEquals(key.get(0), "clock");
                Assert.assertEquals(key.get(1), 40L);
                DataBag columns = (DataBag) t.get(1);
                Iterator<Tuple> iter = columns.iterator();
                if (iter.hasNext())
                {
                    Tuple t1 = iter.next();
                    Assert.assertEquals(t1.get(0), 6L);
                    Assert.assertEquals(t1.get(1), "coffee...");
                }
            }
        }
        Assert.assertEquals(count, 4);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;setupExtrapolator();;protected void setupExtrapolator() {
    SINGLE_CURVE_INSTRUMENTS = new ArrayList<InterestRateDerivative>();
    DOUBLE_CURVE_INSTRUMENTS = new ArrayList<InterestRateDerivative>();
    EXTRAPOLATOR = CombinedInterpolatorExtrapolatorFactory.getInterpolator(_interolatorName, LINEAR_EXTRAPOLATOR,
        FLAT_EXTRAPOLATOR);
    EXTRAPOLATOR_WITH_SENSITIVITY = CombinedInterpolatorExtrapolatorNodeSensitivityCalculatorFactory
        .getSensitivityCalculator(_interolatorName, LINEAR_EXTRAPOLATOR, FLAT_EXTRAPOLATOR, false);
    EXTRAPOLATOR_WITH_FD_SENSITIVITY = CombinedInterpolatorExtrapolatorNodeSensitivityCalculatorFactory
        .getSensitivityCalculator(_interolatorName, LINEAR_EXTRAPOLATOR, FLAT_EXTRAPOLATOR, true);

  };protected void setupExtrapolator() {
    SINGLE_CURVE_INSTRUMENTS = new ArrayList<InterestRateDerivative>();
    DOUBLE_CURVE_INSTRUMENTS = new ArrayList<InterestRateDerivative>();
    EXTRAPOLATOR = CombinedInterpolatorExtrapolatorFactory.getInterpolator(_interolatorName, LINEAR_EXTRAPOLATOR, FLAT_EXTRAPOLATOR);
    EXTRAPOLATOR_WITH_SENSITIVITY = CombinedInterpolatorExtrapolatorNodeSensitivityCalculatorFactory.getSensitivityCalculator(_interolatorName, LINEAR_EXTRAPOLATOR, FLAT_EXTRAPOLATOR, false);
    EXTRAPOLATOR_WITH_FD_SENSITIVITY = CombinedInterpolatorExtrapolatorNodeSensitivityCalculatorFactory.getSensitivityCalculator(_interolatorName, LINEAR_EXTRAPOLATOR, FLAT_EXTRAPOLATOR, true);

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;getSingleYieldCurveFinderDataBundle(List<InterestRateDerivative>,Interpolator1D<?extendsInterpolator1DDataBundle>,Interpolator1DNodeSensitivityCalculator<?extendsInterpolator1DDataBundle>);;protected MultipleYieldCurveFinderDataBundle getSingleYieldCurveFinderDataBundle(
      List<InterestRateDerivative> instruments, final Interpolator1D<? extends Interpolator1DDataBundle> extrapolator,
      final Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle> extrapolatorWithSense) {

    LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>> unknownCurveInterpolators = new LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>>();
    LinkedHashMap<String, double[]> unknownCurveNodes = new LinkedHashMap<String, double[]>();
    LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>> unknownCurveNodeSensitivityCalculators = new LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>>();

    unknownCurveInterpolators.put(_curve1Name, extrapolator);
    unknownCurveNodes.put(_curve1Name, _curve1Knots);
    unknownCurveNodeSensitivityCalculators.put(_curve1Name, extrapolatorWithSense);
    return new MultipleYieldCurveFinderDataBundle(instruments, null, unknownCurveNodes, unknownCurveInterpolators,
        unknownCurveNodeSensitivityCalculators);
  };protected MultipleYieldCurveFinderDataBundle getSingleYieldCurveFinderDataBundle(List<InterestRateDerivative> instruments, final Interpolator1D<? extends Interpolator1DDataBundle> extrapolator,
      final Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle> extrapolatorWithSense) {

    LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>> unknownCurveInterpolators = new LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>>();
    LinkedHashMap<String, double[]> unknownCurveNodes = new LinkedHashMap<String, double[]>();
    LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>> unknownCurveNodeSensitivityCalculators = 
      new LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>>();

    unknownCurveInterpolators.put(_curve1Name, extrapolator);
    unknownCurveNodes.put(_curve1Name, _curve1Knots);
    unknownCurveNodeSensitivityCalculators.put(_curve1Name, extrapolatorWithSense);
    return new MultipleYieldCurveFinderDataBundle(instruments, null, unknownCurveNodes, unknownCurveInterpolators, unknownCurveNodeSensitivityCalculators);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;getDoubleYieldCurveFinderDataBundle(List<InterestRateDerivative>,Interpolator1D<?extendsInterpolator1DDataBundle>,Interpolator1DNodeSensitivityCalculator<?extendsInterpolator1DDataBundle>);;protected MultipleYieldCurveFinderDataBundle getDoubleYieldCurveFinderDataBundle(
      List<InterestRateDerivative> instruments, final Interpolator1D<? extends Interpolator1DDataBundle> extrapolator,
      final Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle> extrapolatorWithSense) {

    LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>> unknownCurveInterpolators = new LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>>();
    LinkedHashMap<String, double[]> unknownCurveNodes = new LinkedHashMap<String, double[]>();
    LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>> unknownCurveNodeSensitivityCalculators = new LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>>();

    unknownCurveInterpolators.put(_curve1Name, extrapolator);
    unknownCurveInterpolators.put(_curve2Name, extrapolator);
    unknownCurveNodes.put(_curve1Name, _curve1Knots);
    unknownCurveNodes.put(_curve2Name, _curve2Knots);
    unknownCurveNodeSensitivityCalculators.put(_curve1Name, extrapolatorWithSense);
    unknownCurveNodeSensitivityCalculators.put(_curve2Name, extrapolatorWithSense);
    return new MultipleYieldCurveFinderDataBundle(instruments, null, unknownCurveNodes, unknownCurveInterpolators,
        unknownCurveNodeSensitivityCalculators);
  };protected MultipleYieldCurveFinderDataBundle getDoubleYieldCurveFinderDataBundle(List<InterestRateDerivative> instruments, final Interpolator1D<? extends Interpolator1DDataBundle> extrapolator,
      final Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle> extrapolatorWithSense) {

    LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>> unknownCurveInterpolators = new LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>>();
    LinkedHashMap<String, double[]> unknownCurveNodes = new LinkedHashMap<String, double[]>();
    LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>> unknownCurveNodeSensitivityCalculators = 
      new LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>>();

    unknownCurveInterpolators.put(_curve1Name, extrapolator);
    unknownCurveInterpolators.put(_curve2Name, extrapolator);
    unknownCurveNodes.put(_curve1Name, _curve1Knots);
    unknownCurveNodes.put(_curve2Name, _curve2Knots);
    unknownCurveNodeSensitivityCalculators.put(_curve1Name, extrapolatorWithSense);
    unknownCurveNodeSensitivityCalculators.put(_curve2Name, extrapolatorWithSense);
    return new MultipleYieldCurveFinderDataBundle(instruments, null, unknownCurveNodes, unknownCurveInterpolators, unknownCurveNodeSensitivityCalculators);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;setupSingleCurveFinder();;protected void setupSingleCurveFinder() {

    MultipleYieldCurveFinderDataBundle data = getSingleYieldCurveFinderDataBundle(SINGLE_CURVE_INSTRUMENTS,
        EXTRAPOLATOR, EXTRAPOLATOR_WITH_SENSITIVITY);
    SINGLE_CURVE_FINDER = new MultipleYieldCurveFinderFunction(data, _marketValueCalculator);
    SINGLE_CURVE_JACOBIAN = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);

    data = getSingleYieldCurveFinderDataBundle(SINGLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_FD_SENSITIVITY);
    SINGLE_CURVE_JACOBIAN_WITH_FD_INTERPOLATOR_SENSITIVITY = new MultipleYieldCurveFinderJacobian(data,
        _marketValueSensitivityCalculator);
  };protected void setupSingleCurveFinder() {

    MultipleYieldCurveFinderDataBundle data = getSingleYieldCurveFinderDataBundle(SINGLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_SENSITIVITY);
    SINGLE_CURVE_FINDER = new MultipleYieldCurveFinderFunction(data, _marketValueCalculator);
    SINGLE_CURVE_JACOBIAN = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);

    data = getSingleYieldCurveFinderDataBundle(SINGLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_FD_SENSITIVITY);
    SINGLE_CURVE_JACOBIAN_WITH_FD_INTERPOLATOR_SENSITIVITY = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;setupDoubleCurveFinder();;protected void setupDoubleCurveFinder() {

    MultipleYieldCurveFinderDataBundle data = getDoubleYieldCurveFinderDataBundle(DOUBLE_CURVE_INSTRUMENTS,
        EXTRAPOLATOR, EXTRAPOLATOR_WITH_SENSITIVITY);
    DOUBLE_CURVE_FINDER = new MultipleYieldCurveFinderFunction(data, _marketValueCalculator);
    DOUBLE_CURVE_JACOBIAN = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);

    data = getDoubleYieldCurveFinderDataBundle(DOUBLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_FD_SENSITIVITY);
    DOUBLE_CURVE_JACOBIAN_WITH_FD_INTERPOLATOR_SENSITIVITY = new MultipleYieldCurveFinderJacobian(data,
        _marketValueSensitivityCalculator);
  };protected void setupDoubleCurveFinder() {

    MultipleYieldCurveFinderDataBundle data = getDoubleYieldCurveFinderDataBundle(DOUBLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_SENSITIVITY);
    DOUBLE_CURVE_FINDER = new MultipleYieldCurveFinderFunction(data, _marketValueCalculator);
    DOUBLE_CURVE_JACOBIAN = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);

    data = getDoubleYieldCurveFinderDataBundle(DOUBLE_CURVE_INSTRUMENTS, EXTRAPOLATOR, EXTRAPOLATOR_WITH_FD_SENSITIVITY);
    DOUBLE_CURVE_JACOBIAN_WITH_FD_INTERPOLATOR_SENSITIVITY = new MultipleYieldCurveFinderJacobian(data, _marketValueSensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;doTestForSingleCurve(NewtonVectorRootFinder,Function1D<DoubleMatrix1D,DoubleMatrix1D>,Function1D<DoubleMatrix1D,DoubleMatrix2D>);;private void doTestForSingleCurve(final NewtonVectorRootFinder rootFinder,
      final Function1D<DoubleMatrix1D, DoubleMatrix1D> f, final Function1D<DoubleMatrix1D, DoubleMatrix2D> j) {
    final DoubleMatrix1D yieldCurveNodes = rootFinder.getRoot(f, j, _startPosition);
    final DoubleMatrix1D modelMarketValueDiff = f.evaluate(yieldCurveNodes);

    for (int i = 0; i < modelMarketValueDiff.getNumberOfElements(); i++) {
      assertEquals(0.0, modelMarketValueDiff.getEntry(i), EPS);
    }
  };private void doTestForSingleCurve(final NewtonVectorRootFinder rootFinder, final Function1D<DoubleMatrix1D, DoubleMatrix1D> f, final Function1D<DoubleMatrix1D, DoubleMatrix2D> j) {
    final DoubleMatrix1D yieldCurveNodes = rootFinder.getRoot(f, j, _startPosition);
    final DoubleMatrix1D modelMarketValueDiff = f.evaluate(yieldCurveNodes);

    for (int i = 0; i < modelMarketValueDiff.getNumberOfElements(); i++) {
      assertEquals(0.0, modelMarketValueDiff.getEntry(i), EPS);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;upDateInstruments(MultipleYieldCurveFinderDataBundle,List<InterestRateDerivative>);;protected static MultipleYieldCurveFinderDataBundle upDateInstruments(MultipleYieldCurveFinderDataBundle old,
      final List<InterestRateDerivative> instruments) {
    return new MultipleYieldCurveFinderDataBundle(instruments, old.getKnownCurves(), old.getUnknownCurveNodePoints(),
        old.getUnknownCurveInterpolators(), old.getUnknownCurveNodeSensitivityCalculators());
  };protected static MultipleYieldCurveFinderDataBundle upDateInstruments(MultipleYieldCurveFinderDataBundle old, final List<InterestRateDerivative> instruments) {
    return new MultipleYieldCurveFinderDataBundle(instruments, old.getKnownCurves(), old.getUnknownCurveNodePoints(), old.getUnknownCurveInterpolators(), old
        .getUnknownCurveNodeSensitivityCalculators());
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingSetup;setParSwapRate(FixedFloatSwap,double);;protected static FixedFloatSwap setParSwapRate(FixedFloatSwap swap, double rate) {
    VariableAnnuity floatingLeg = swap.getFloatingLeg();
    ConstantCouponAnnuity fixedLeg = swap.getFixedLeg();
    ConstantCouponAnnuity newLeg = new ConstantCouponAnnuity(fixedLeg.getPaymentTimes(), fixedLeg.getNotional(), rate,
        fixedLeg.getYearFractions(), fixedLeg.getFundingCurveName());
    return new FixedFloatSwap(newLeg, floatingLeg);
  };protected static FixedFloatSwap setParSwapRate(FixedFloatSwap swap, double rate) {
    VariableAnnuity floatingLeg = swap.getFloatingLeg();
    ConstantCouponAnnuity fixedLeg = swap.getFixedLeg();
    ConstantCouponAnnuity newLeg = new ConstantCouponAnnuity(fixedLeg.getPaymentTimes(), fixedLeg.getNotional(), rate, fixedLeg.getYearFractions(), fixedLeg.getFundingCurveName());
    return new FixedFloatSwap(newLeg, floatingLeg);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_c8657_99a84/rev_c8657-99a84;/src/main/java/org/junit/experimental/interceptor/ExpectedException;expect(Matcher<?>);;public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher = matcher;
		else
			fMatcher = both(fMatcher).and(matches(matcher));
	};public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher= matcher;
		else
			fMatcher= both(fMatcher).and(matches(matcher));
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_c8657_99a84/rev_c8657-99a84;/src/main/java/org/junit/experimental/interceptor/TestName;starting(FrameworkMethod);;@Override
	public void starting(FrameworkMethod method) {
		fName = method.getName();
	};@Override
	public void starting(FrameworkMethod method) {
		fName= method.getName();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae;/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat;throwException(VProto.Error);;public void throwException(VProto.Error error) {
            throw errorMapper.getError((short) error.getErrorCode(), error.getErrorMessage());
    };public void throwException(VProto.Error error) {
        throw errorMapper.getError((short) error.getErrorCode(), error.getErrorMessage());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_d12db_2926c/rev_d12db-2926c;/src/main/java/com/tightdb/example/FailureExample;main(String[]);;public static void main(String[] args) {
		Group group = new Group();
		EmployeeTable employees = new EmployeeTable(group);

		employees.add("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(), "extra");

		employees.at(0).phones.get();

		try {
			group.writeToFile("employees.tdb");
		} catch (IOException e) {
			throw new RuntimeException("Couldn't save the data!", e);
		}

		employees.clear();

	};public static void main(String[] args) {
		Group group = new Group();
		EmployeeTable employees = new EmployeeTable(group);
		
		employees.add("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(), "extra");

		employees.at(0).phones.get();

		try {
			group.writeToFile("employees.tdb");
		} catch (IOException e) {
			throw new RuntimeException("Couldn't save the data!", e);
		}
				
		employees.clear();

	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d24d7_eaf20/rev_d24d7-eaf20;/src/java/org/apache/cassandra/thrift/ThriftValidation;validateColumnParent(String,ColumnParent);;static void validateColumnParent(String tablename, ColumnParent column_parent) throws InvalidRequestException
    {
        validateTable(tablename);
        ColumnFamilyType cfType = validateColumnFamily(tablename, column_parent.column_family);
        if (cfType == ColumnFamilyType.Standard)
        {
            if (column_parent.super_column != null)
            {
                throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
            }
        }
        if (column_parent.super_column != null)
        {
            validateColumnNames(tablename, column_parent.column_family, null, Arrays.asList(column_parent.super_column));
        }
    };static void validateColumnParent(String tablename, ColumnParent column_parent) throws InvalidRequestException
    {
        validateTable(tablename);
        ColumnFamilyType cfType = validateColumnFamily(tablename, column_parent.column_family);
        if (cfType == ColumnFamilyType.Standard)
        {
            if (column_parent.super_column != null)
            {
                throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
            }
        }

        if (column_parent.super_column != null)
        {
            validateColumnNames(tablename, column_parent.column_family, null, Arrays.asList(column_parent.super_column));
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_d97f3_f27f8/rev_d97f3-f27f8;/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest;pipeline();;@Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    };@Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/ComputationTargetSpecification;toString();;@Override
  public String toString() {
    return new StrBuilder()
      .append("CTSpec[")
      .append(getType())
      .append(", ")
      .append(getUniqueId())
      .append(']')
      .toString();
  };@Override
  public String toString() {
    return new StrBuilder()
        .append("CTSpec[")
        .append(getType())
        .append(", ")
        .append(getUniqueId())
        .append(']')
        .toString();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/test/MockFunction;getMockFunction(String,ComputationTarget,Object,ValueRequirement);;public static MockFunction getMockFunction(String uniqueId, ComputationTarget target, Object output, ValueRequirement input) {
    MockFunction fn = getMockFunction(uniqueId, target, output);

    fn.addRequirement(input);
    return fn;
  };public static MockFunction getMockFunction(String uniqueId, ComputationTarget target, Object output, ValueRequirement input) {
    MockFunction fn = getMockFunction(uniqueId, target, output);
    fn.addRequirement(input);
    return fn;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/test/MockFunction;getMockFunction(String,ComputationTarget,Object,MockFunction);;public static MockFunction getMockFunction(String uniqueId, ComputationTarget target, Object output, MockFunction inputFunction) {
    MockFunction fn = getMockFunction(uniqueId, target, output);

    for (ValueSpecification resultSpec : inputFunction.getResultSpecs()) {
      fn.addRequirement(resultSpec.toRequirementSpecification());
    }
    return fn;
  };public static MockFunction getMockFunction(String uniqueId, ComputationTarget target, Object output, MockFunction inputFunction) {
    MockFunction fn = getMockFunction(uniqueId, target, output);
    for (ValueSpecification resultSpec : inputFunction.getResultSpecs()) {
      fn.addRequirement(resultSpec.toRequirementSpecification());
    }
    return fn;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/test/PrimitiveTestFunction;getRequirements(FunctionCompilationContext,ComputationTarget,ValueRequirement);;@Override
  public Set<ValueRequirement> getRequirements(FunctionCompilationContext context, ComputationTarget target, final ValueRequirement desiredValue) {
    ValueRequirement requirement = new ValueRequirement(_requirementName, 
        ComputationTargetType.PRIMITIVE, 
        UniqueId.of("foo", "bar"));
    return Collections.singleton(requirement);
  };@Override
  public Set<ValueRequirement> getRequirements(FunctionCompilationContext context, ComputationTarget target, final ValueRequirement desiredValue) {
    ValueRequirement requirement = new ValueRequirement(_requirementName, 
        ComputationTargetType.PRIMITIVE,
        UniqueId.of("foo", "bar"));
    return Collections.singleton(requirement);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/value/ComputedValue;hashCode();;@Override
  public int hashCode() {
    int result = _specification.hashCode();
    result = 31 * result + (_value != null ? _value.hashCode() : 0);
    result = 31 * result + (_result != null ? _result.hashCode() : 0);
    result = 31 * result + (_exceptionClass != null ? _exceptionClass.hashCode() : 0);
    result = 31 * result + (_exceptionMsg != null ? _exceptionMsg.hashCode() : 0);
    result = 31 * result + (_stackTrace != null ? _stackTrace.hashCode() : 0);
    result = 31 * result + (_missingInputs != null ? _missingInputs.hashCode() : 0);
    result = 31 * result + (_originalRequirements != null? _originalRequirements.hashCode() : 0);
    return result;
  };@Override
  public int hashCode() {
    int result = _specification.hashCode();
    result = 31 * result + (_value != null ? _value.hashCode() : 0);
    result = 31 * result + (_result != null ? _result.hashCode() : 0);
    result = 31 * result + (_exceptionClass != null ? _exceptionClass.hashCode() : 0);
    result = 31 * result + (_exceptionMsg != null ? _exceptionMsg.hashCode() : 0);
    result = 31 * result + (_stackTrace != null ? _stackTrace.hashCode() : 0);
    result = 31 * result + (_missingInputs != null ? _missingInputs.hashCode() : 0);
    result = 31 * result + (_originalRequirements != null ? _originalRequirements.hashCode() : 0);
    return result;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/depgraph/DependencyGraph;getExecutionOrder();;public List<DependencyNode> getExecutionOrder() {
    ArrayList<DependencyNode> executionOrder = new ArrayList<DependencyNode>();
    HashSet<DependencyNode> alreadyEvaluated = new HashSet<DependencyNode>();

    for (DependencyNode root : getRootNodes()) {
      getExecutionOrder(root, executionOrder, alreadyEvaluated);
    }

    return executionOrder;
  };public List<DependencyNode> getExecutionOrder() {
    ArrayList<DependencyNode> executionOrder = new ArrayList<DependencyNode>();
    HashSet<DependencyNode> alreadyEvaluated = new HashSet<DependencyNode>();
    for (DependencyNode root : getRootNodes()) {
      getExecutionOrder(root, executionOrder, alreadyEvaluated);
    }
    return executionOrder;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/src/com/opengamma/engine/depgraph/DependencyGraph;getExecutionOrder(DependencyNode,List<DependencyNode>,Set<DependencyNode>);;private void getExecutionOrder(DependencyNode currentNode, List<DependencyNode> executionOrder, Set<DependencyNode> alreadyEvaluated) {
    if (!containsNode(currentNode)) { // this check is necessary because of sub-graphing
      return;
    }

    for (DependencyNode child : currentNode.getInputNodes()) {
      getExecutionOrder(child, executionOrder, alreadyEvaluated);
    }

    if (!alreadyEvaluated.contains(currentNode)) {
      executionOrder.add(currentNode);
      alreadyEvaluated.add(currentNode);
    }
  };private void getExecutionOrder(DependencyNode currentNode, List<DependencyNode> executionOrder, Set<DependencyNode> alreadyEvaluated) {
    if (!containsNode(currentNode)) { // this check is necessary because of sub-graphing
      return;
    }
    for (DependencyNode child : currentNode.getInputNodes()) {
      getExecutionOrder(child, executionOrder, alreadyEvaluated);
    }
    if (!alreadyEvaluated.contains(currentNode)) {
      executionOrder.add(currentNode);
      alreadyEvaluated.add(currentNode);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/value/ValueRequirementTest;test_fudgeEncoding();;public void test_fudgeEncoding() {
    FudgeContext context = OpenGammaFudgeContext.getInstance();
    FudgeSerializer serializationContext = new FudgeSerializer(context);
    FudgeDeserializer deserializationContext = new FudgeDeserializer(context);
    ValueRequirement test = new ValueRequirement("DATA", ComputationTargetType.PRIMITIVE, USD);
    MutableFudgeMsg inMsg = serializationContext.objectToFudgeMsg(test);
    assertNotNull(inMsg);
    assertEquals(3, inMsg.getNumFields());
    FudgeMsg outMsg = context.deserialize(context.toByteArray(inMsg)).getMessage();
    ValueRequirement decoded = deserializationContext.fudgeMsgToObject(ValueRequirement.class, outMsg);
    assertEquals(test, decoded);
    test = new ValueRequirement("DATA", ComputationTargetType.PRIMITIVE, USD, ValueProperties.with(ValuePropertyNames.FUNCTION, "Foo").get ());
    inMsg = serializationContext.objectToFudgeMsg(test);
    assertNotNull(inMsg);
    assertEquals(4, inMsg.getNumFields());
    outMsg = context.deserialize(context.toByteArray(inMsg)).getMessage();
    decoded = deserializationContext.fudgeMsgToObject(ValueRequirement.class, outMsg);
    assertEquals(test, decoded);
  };public void test_fudgeEncoding() {
    FudgeContext context = OpenGammaFudgeContext.getInstance();
    FudgeSerializer serializationContext = new FudgeSerializer(context);
    FudgeDeserializer deserializationContext = new FudgeDeserializer(context);
    ValueRequirement test = new ValueRequirement("DATA", ComputationTargetType.PRIMITIVE, USD);
    MutableFudgeMsg inMsg = serializationContext.objectToFudgeMsg(test);
    assertNotNull(inMsg);
    assertEquals(3, inMsg.getNumFields());
    FudgeMsg outMsg = context.deserialize(context.toByteArray(inMsg)).getMessage();
    ValueRequirement decoded = deserializationContext.fudgeMsgToObject(ValueRequirement.class, outMsg);
    assertEquals(test, decoded);
    test = new ValueRequirement("DATA", ComputationTargetType.PRIMITIVE, USD, ValueProperties.with(ValuePropertyNames.FUNCTION, "Foo").get());
    inMsg = serializationContext.objectToFudgeMsg(test);
    assertNotNull(inMsg);
    assertEquals(4, inMsg.getNumFields());
    outMsg = context.deserialize(context.toByteArray(inMsg)).getMessage();
    decoded = deserializationContext.fudgeMsgToObject(ValueRequirement.class, outMsg);
    assertEquals(test, decoded);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/depgraph/DepGraphTestHelper;getSpecification1Bar();;public ValueSpecification getSpecification1Bar () {
    return _spec1Bar;
  };public ValueSpecification getSpecification1Bar() {
    return _spec1Bar;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/depgraph/DepGraphTestHelper;getValue1Bar();;public ComputedValue getValue1Bar () {
    return _value1Bar;
  };public ComputedValue getValue1Bar() {
    return _value1Bar;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/DefaultViewComputationCacheTest;testPutValuesPrivate();;@Test
  public void testPutValuesPrivate() {
    assertPutValues (0, CacheSelectHint.allPrivate (), CacheSelectHint.allShared ());
  };@Test
  public void testPutValuesPrivate() {
    assertPutValues(0, CacheSelectHint.allPrivate(), CacheSelectHint.allShared());
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/DefaultViewComputationCacheTest;testPutValuesShared();;@Test
  public void testPutValuesShared() {
    assertPutValues (1, CacheSelectHint.allShared (), CacheSelectHint.allPrivate ());
  };@Test
  public void testPutValuesShared() {
    assertPutValues(1, CacheSelectHint.allShared(), CacheSelectHint.allPrivate());
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/RemoteCacheRequestResponseTest;singleThreadPutLoad();;@Test
  public void singleThreadPutLoad() throws InterruptedException {
    InMemoryViewComputationCacheSource cache = new InMemoryViewComputationCacheSource(s_fudgeContext);
    ViewComputationCacheServer server = new ViewComputationCacheServer(cache);
    DirectFudgeConnection conduit = new DirectFudgeConnection (cache.getFudgeContext ());
    conduit.connectEnd2  (server);
    RemoteCacheClient client = new RemoteCacheClient(conduit.getEnd1());
    FudgeMessageStore dataStore = new RemoteFudgeMessageStore(client, new ViewComputationCacheKey(UniqueId.of("Test", "ViewCycle1"), "Config1"));

    // Single value
    final MutableFudgeMsg inputValue1 = s_fudgeContext.newMessage();
    for (int i = 0; i < 32; i++) {
      inputValue1.add(i, Integer.toString(i));
    }
    long identifier1 = 1L;
    dataStore.put(identifier1, inputValue1);

    FudgeMsg outputValue = dataStore.get(identifier1);
    assertNotNull(outputValue);
    assertEquals(inputValue1.getAllFields(), outputValue.getAllFields());

    outputValue = dataStore.get(identifier1 + 1);
    assertNull(outputValue);

    outputValue = dataStore.get(identifier1);
    assertNotNull(outputValue);
    assertEquals(inputValue1.getAllFields(), outputValue.getAllFields());

    // Multiple value
    final MutableFudgeMsg inputValue2 = s_fudgeContext.newMessage();
    for (int i = 32; i < 64; i++) {
      inputValue2.add(i, Integer.toString(i));
    }
    final Map<Long, FudgeMsg> inputMap = new HashMap<Long, FudgeMsg>();
    identifier1++;
    long identifier2 = identifier1 + 1;
    inputMap.put(identifier1, inputValue1);
    inputMap.put(identifier2, inputValue2);
    dataStore.put(inputMap);

    final Map<Long, FudgeMsg> outputMap = dataStore.get(Arrays.asList(identifier1, identifier2));
    assertEquals(2, outputMap.size());
    assertEquals(inputValue1.getAllFields(), outputMap.get(identifier1).getAllFields());
    assertEquals(inputValue2.getAllFields(), outputMap.get(identifier2).getAllFields());
  };@Test
  public void singleThreadPutLoad() throws InterruptedException {
    InMemoryViewComputationCacheSource cache = new InMemoryViewComputationCacheSource(s_fudgeContext);
    ViewComputationCacheServer server = new ViewComputationCacheServer(cache);
    DirectFudgeConnection conduit = new DirectFudgeConnection(cache.getFudgeContext());
    conduit.connectEnd2(server);
    RemoteCacheClient client = new RemoteCacheClient(conduit.getEnd1());
    FudgeMessageStore dataStore = new RemoteFudgeMessageStore(client, new ViewComputationCacheKey(UniqueId.of("Test", "ViewCycle1"), "Config1"));

    // Single value
    final MutableFudgeMsg inputValue1 = s_fudgeContext.newMessage();
    for (int i = 0; i < 32; i++) {
      inputValue1.add(i, Integer.toString(i));
    }
    long identifier1 = 1L;
    dataStore.put(identifier1, inputValue1);

    FudgeMsg outputValue = dataStore.get(identifier1);
    assertNotNull(outputValue);
    assertEquals(inputValue1.getAllFields(), outputValue.getAllFields());

    outputValue = dataStore.get(identifier1 + 1);
    assertNull(outputValue);

    outputValue = dataStore.get(identifier1);
    assertNotNull(outputValue);
    assertEquals(inputValue1.getAllFields(), outputValue.getAllFields());

    // Multiple value
    final MutableFudgeMsg inputValue2 = s_fudgeContext.newMessage();
    for (int i = 32; i < 64; i++) {
      inputValue2.add(i, Integer.toString(i));
    }
    final Map<Long, FudgeMsg> inputMap = new HashMap<Long, FudgeMsg>();
    identifier1++;
    long identifier2 = identifier1 + 1;
    inputMap.put(identifier1, inputValue1);
    inputMap.put(identifier2, inputValue2);
    dataStore.put(inputMap);

    final Map<Long, FudgeMsg> outputMap = dataStore.get(Arrays.asList(identifier1, identifier2));
    assertEquals(2, outputMap.size());
    assertEquals(inputValue1.getAllFields(), outputMap.get(identifier1).getAllFields());
    assertEquals(inputValue2.getAllFields(), outputMap.get(identifier2).getAllFields());
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/RemoteCacheRequestResponseTest;singleThreadPutLoadPurgeLoad();;@Test(timeOut = 10000l)
  public void singleThreadPutLoadPurgeLoad() throws InterruptedException {
    InMemoryViewComputationCacheSource cache = new InMemoryViewComputationCacheSource(s_fudgeContext);
    ViewComputationCacheServer server = new ViewComputationCacheServer(cache);
    DirectFudgeConnection conduit = new DirectFudgeConnection (cache.getFudgeContext ());
    conduit.connectEnd2 (server);
    RemoteCacheClient client = new RemoteCacheClient(conduit.getEnd1());
    FudgeMessageStore dataStore = new RemoteFudgeMessageStore(client, new ViewComputationCacheKey(
        UniqueId.of("Test", "ViewCycle1"), "Config1"));
    final MutableFudgeMsg inputValue = s_fudgeContext.newMessage();
    for (int i = 0; i < 32; i++) {
      inputValue.add(i, Integer.toString(i));
    }
    final long identifier = 1L;
    dataStore.put(identifier, inputValue);

    FudgeMsg outputValue = dataStore.get(identifier);
    assertNotNull(outputValue);
    assertEquals(inputValue.getAllFields(), outputValue.getAllFields());

    dataStore.delete();

    outputValue = dataStore.get(identifier);
    assertNull(outputValue);
  };@Test(timeOut = 10000l)
  public void singleThreadPutLoadPurgeLoad() throws InterruptedException {
    InMemoryViewComputationCacheSource cache = new InMemoryViewComputationCacheSource(s_fudgeContext);
    ViewComputationCacheServer server = new ViewComputationCacheServer(cache);
    DirectFudgeConnection conduit = new DirectFudgeConnection(cache.getFudgeContext());
    conduit.connectEnd2(server);
    RemoteCacheClient client = new RemoteCacheClient(conduit.getEnd1());
    FudgeMessageStore dataStore = new RemoteFudgeMessageStore(client, new ViewComputationCacheKey(
        UniqueId.of("Test", "ViewCycle1"), "Config1"));
    final MutableFudgeMsg inputValue = s_fudgeContext.newMessage();
    for (int i = 0; i < 32; i++) {
      inputValue.add(i, Integer.toString(i));
    }
    final long identifier = 1L;
    dataStore.put(identifier, inputValue);

    FudgeMsg outputValue = dataStore.get(identifier);
    assertNotNull(outputValue);
    assertEquals(inputValue.getAllFields(), outputValue.getAllFields());

    dataStore.delete();

    outputValue = dataStore.get(identifier);
    assertNull(outputValue);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;simpleOperation();;@Test
  public void simpleOperation() throws IOException {
    File dbDir = createDbDir("simpleOperation");
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    
    Map<String, Long> identifiers = new HashMap<String, Long>();
    LongSet seenIdentifiers = new LongOpenHashSet();
    for (int i = 0; i < 10; i++) {
      String valueName = "value-" + i;
      ValueSpecification valueSpec = getValueSpec(valueName);
      long identifier = idSource.getIdentifier(valueSpec);
      assertFalse(seenIdentifiers.contains(identifier));
      seenIdentifiers.add (identifier);
      identifiers.put(valueName, identifier);
    }
    
    for (int j = 0; j < 5; j++) {
      Long2ObjectMap<ValueSpecification> valueSpecs = idSource.getValueSpecifications(seenIdentifiers);
      assertEquals (seenIdentifiers.size (), valueSpecs.size ());
      for (int i = 0; i < 10; i++) {
        String valueName = "value-" + i;
        ValueSpecification valueSpec = getValueSpec(valueName);
        long identifier = idSource.getIdentifier(valueSpec);
        long existingIdentifier = identifiers.get(valueName);
        assertEquals(identifier, existingIdentifier);
        assertEquals(valueSpec, idSource.getValueSpecification(identifier));
        assertEquals (valueSpec, valueSpecs.get (identifier));
      }
    }
    
    idSource.stop();
    
    dbEnvironment.close();
  };@Test
  public void simpleOperation() throws IOException {
    File dbDir = createDbDir("simpleOperation");
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();

    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();

    Map<String, Long> identifiers = new HashMap<String, Long>();
    LongSet seenIdentifiers = new LongOpenHashSet();
    for (int i = 0; i < 10; i++) {
      String valueName = "value-" + i;
      ValueSpecification valueSpec = getValueSpec(valueName);
      long identifier = idSource.getIdentifier(valueSpec);
      assertFalse(seenIdentifiers.contains(identifier));
      seenIdentifiers.add(identifier);
      identifiers.put(valueName, identifier);
    }

    for (int j = 0; j < 5; j++) {
      Long2ObjectMap<ValueSpecification> valueSpecs = idSource.getValueSpecifications(seenIdentifiers);
      assertEquals(seenIdentifiers.size(), valueSpecs.size());
      for (int i = 0; i < 10; i++) {
        String valueName = "value-" + i;
        ValueSpecification valueSpec = getValueSpec(valueName);
        long identifier = idSource.getIdentifier(valueSpec);
        long existingIdentifier = identifiers.get(valueName);
        assertEquals(identifier, existingIdentifier);
        assertEquals(valueSpec, idSource.getValueSpecification(identifier));
        assertEquals(valueSpec, valueSpecs.get(identifier));
      }
    }

    idSource.stop();

    dbEnvironment.close();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;reloadPreservesMaxValue();;@Test
  public void reloadPreservesMaxValue() throws IOException {
    File dbDir = createDbDir("reloadPreservesMaxValue");
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    String valueName = "value-5";
    ValueSpecification valueSpec = getValueSpec(valueName);
    long initialIdentifier = idSource.getIdentifier(valueSpec);
    
    // Cycle everything to simulate a clean shutdown and restart.
    idSource.stop();
    dbEnvironment.close();
    dbEnvironment = createDbEnvironment(dbDir);
    idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    
    // Check we get the same thing back.
    valueName = "value-5";
    valueSpec = getValueSpec(valueName);
    long identifier = idSource.getIdentifier(valueSpec);
    assertEquals(initialIdentifier, identifier);
    
    // Check that the next one is the previous max + 1
    valueName = "value-99999";
    valueSpec = getValueSpec(valueName);
    identifier = idSource.getIdentifier(valueSpec);
    assertEquals(initialIdentifier + 1, identifier);
  };@Test
  public void reloadPreservesMaxValue() throws IOException {
    File dbDir = createDbDir("reloadPreservesMaxValue");
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();

    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    String valueName = "value-5";
    ValueSpecification valueSpec = getValueSpec(valueName);
    long initialIdentifier = idSource.getIdentifier(valueSpec);

    // Cycle everything to simulate a clean shutdown and restart.
    idSource.stop();
    dbEnvironment.close();
    dbEnvironment = createDbEnvironment(dbDir);
    idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();

    // Check we get the same thing back.
    valueName = "value-5";
    valueSpec = getValueSpec(valueName);
    long identifier = idSource.getIdentifier(valueSpec);
    assertEquals(initialIdentifier, identifier);

    // Check that the next one is the previous max + 1
    valueName = "value-99999";
    valueSpec = getValueSpec(valueName);
    identifier = idSource.getIdentifier(valueSpec);
    assertEquals(initialIdentifier + 1, identifier);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;putPerformanceTestImpl(boolean);;private void putPerformanceTestImpl(final boolean bulkOperation) {
    final int numRequirementNames = 100;
    final int numIdentifiers = 100;
    final long numSpecifications = ((long) numRequirementNames) * ((long) numIdentifiers);
    File dbDir = createDbDir("putPerformanceTest" + bulkOperation);
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    
    OperationTimer timer = new OperationTimer(s_logger, "Put performance test with {} elements", numSpecifications);
    
    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }
    
    idSource.stop();
    long numMillis = timer.finished();
    
    double msPerPut = ((double) numMillis) / ((double) numSpecifications);
    double putsPerSecond = 1000.0 / msPerPut;
    
    s_logger.info("Split time was {}ms/put, {}puts/sec", msPerPut, putsPerSecond);
    
    dbEnvironment.close();
  };private void putPerformanceTestImpl(final boolean bulkOperation) {
    final int numRequirementNames = 100;
    final int numIdentifiers = 100;
    final long numSpecifications = ((long) numRequirementNames) * ((long) numIdentifiers);
    File dbDir = createDbDir("putPerformanceTest" + bulkOperation);
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();

    OperationTimer timer = new OperationTimer(s_logger, "Put performance test with {} elements", numSpecifications);

    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }

    idSource.stop();
    long numMillis = timer.finished();

    double msPerPut = ((double) numMillis) / ((double) numSpecifications);
    double putsPerSecond = 1000.0 / msPerPut;

    s_logger.info("Split time was {}ms/put, {}puts/sec", msPerPut, putsPerSecond);

    dbEnvironment.close();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;getPerformanceTestImpl(boolean);;private void getPerformanceTestImpl(final boolean bulkOperation) {
    final int numRequirementNames = 100;
    final int numIdentifiers = 100;
    final long numSpecifications = ((long) numRequirementNames) * ((long) numIdentifiers);
    File dbDir = createDbDir("getPerformanceTest" + bulkOperation);
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();
    
    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }
    
    OperationTimer timer = new OperationTimer(s_logger, "Get performance test with {} elements", numSpecifications);
    
    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }
    
    long numMillis = timer.finished();
    idSource.stop();
    
    double msPerPut = ((double) numMillis) / ((double) numSpecifications);
    double putsPerSecond = 1000.0 / msPerPut;
    
    s_logger.info("Split time was {}ms/get, {}gets/sec", msPerPut, putsPerSecond);
    
    dbEnvironment.close();
  };private void getPerformanceTestImpl(final boolean bulkOperation) {
    final int numRequirementNames = 100;
    final int numIdentifiers = 100;
    final long numSpecifications = ((long) numRequirementNames) * ((long) numIdentifiers);
    File dbDir = createDbDir("getPerformanceTest" + bulkOperation);
    Environment dbEnvironment = createDbEnvironment(dbDir);
    FudgeContext fudgeContext = OpenGammaFudgeContext.getInstance();
    BerkeleyDBIdentifierMap idSource = new BerkeleyDBIdentifierMap(dbEnvironment, fudgeContext);
    idSource.start();

    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }

    OperationTimer timer = new OperationTimer(s_logger, "Get performance test with {} elements", numSpecifications);

    if (bulkOperation) {
      bulkOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    } else {
      singleOperationGetIdentifier(numRequirementNames, numIdentifiers, idSource);
    }

    long numMillis = timer.finished();
    idSource.stop();

    double msPerPut = ((double) numMillis) / ((double) numSpecifications);
    double putsPerSecond = 1000.0 / msPerPut;

    s_logger.info("Split time was {}ms/get, {}gets/sec", msPerPut, putsPerSecond);

    dbEnvironment.close();
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;putPerformanceTest();;@Test
  public void putPerformanceTest () {
    putPerformanceTestImpl(false);
  };@Test
  public void putPerformanceTest() {
    putPerformanceTestImpl(false);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;bulkPutPerformanceTest();;@Test
  public void bulkPutPerformanceTest () {
    putPerformanceTestImpl(true);
  };@Test
  public void bulkPutPerformanceTest() {
    putPerformanceTestImpl(true);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;getPerformanceTest();;@Test
  public void getPerformanceTest () {
    getPerformanceTestImpl(false);
  };@Test
  public void getPerformanceTest() {
    getPerformanceTestImpl(false);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d456e_40daf/rev_d456e-40daf;/projects/OG-Engine/tests/unit/com/opengamma/engine/view/cache/BerkeleyDBValueSpecificationIdentifierSourceTest;bulkGetPerformanceTest();;@Test
  public void bulkGetPerformanceTest () {
    getPerformanceTestImpl(true);
  };@Test
  public void bulkGetPerformanceTest() {
    getPerformanceTestImpl(true);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dc09e_54b67/rev_dc09e-54b67;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Period,int);;@Override
  public synchronized UniqueIdentifier addConventionBundle(final IdentifierBundle bundle, final String name, final DayCount dayCount, final BusinessDayConvention businessDayConvention,
      final Period period, final int settlementDays) {
    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, period, settlementDays);
    return add(bundle, convention);
  };@Override
  public synchronized UniqueIdentifier addConventionBundle(final IdentifierBundle bundle, final String name,
      final DayCount dayCount, final BusinessDayConvention businessDayConvention,
      final Period period, final int settlementDays) {
    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention,
        period, settlementDays);
    return add(bundle, convention);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dc917_de8c9/rev_dc917-de8c9;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/option/black/FXOptionBlackRhoFunction;getResultProperties(ComputationTarget);;private ValueProperties.Builder getResultProperties(final ComputationTarget target) {
    return createValueProperties()
        .with(ValuePropertyNames.CALCULATION_METHOD, FXOptionBlackFunction.BLACK_METHOD)
        .withAny(FXOptionBlackFunction.PUT_CURVE)
        .withAny(FXOptionBlackFunction.PUT_CURVE_CALC_CONFIG)
        .withAny(FXOptionBlackFunction.CALL_CURVE)
        .withAny(FXOptionBlackFunction.CALL_CURVE_CALC_CONFIG)
        .withAny(ValuePropertyNames.SURFACE)
        .withAny(InterpolatedDataProperties.X_INTERPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME)
        .withAny(ValuePropertyNames.CURRENCY);
//        .with(ValuePropertyNames.CURRENCY, FXOptionBlackSingleValuedFunction.getResultCurrency(target));
  };private ValueProperties.Builder getResultProperties(final ComputationTarget target) {
    return createValueProperties()
        .with(ValuePropertyNames.CALCULATION_METHOD, FXOptionBlackFunction.BLACK_METHOD)
        .withAny(FXOptionBlackFunction.PUT_CURVE)
        .withAny(FXOptionBlackFunction.PUT_CURVE_CALC_CONFIG)
        .withAny(FXOptionBlackFunction.CALL_CURVE)
        .withAny(FXOptionBlackFunction.CALL_CURVE_CALC_CONFIG)
        .withAny(ValuePropertyNames.SURFACE)
        .withAny(InterpolatedDataProperties.X_INTERPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME)
        .withAny(ValuePropertyNames.CURRENCY);
    //        .with(ValuePropertyNames.CURRENCY, FXOptionBlackSingleValuedFunction.getResultCurrency(target));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dc917_de8c9/rev_dc917-de8c9;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/option/black/FXOptionBlackPhiFunction;getResultProperties(ComputationTarget);;private ValueProperties.Builder getResultProperties(final ComputationTarget target) {
    return createValueProperties()
        .with(ValuePropertyNames.CALCULATION_METHOD, FXOptionBlackFunction.BLACK_METHOD)
        .withAny(FXOptionBlackFunction.PUT_CURVE)
        .withAny(FXOptionBlackFunction.PUT_CURVE_CALC_CONFIG)
        .withAny(FXOptionBlackFunction.CALL_CURVE)
        .withAny(FXOptionBlackFunction.CALL_CURVE_CALC_CONFIG)
        .withAny(ValuePropertyNames.SURFACE)
        .withAny(InterpolatedDataProperties.X_INTERPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME)
        .withAny(ValuePropertyNames.CURRENCY);
//        .with(ValuePropertyNames.CURRENCY, FXOptionBlackSingleValuedFunction.getResultCurrency(target));
  };private ValueProperties.Builder getResultProperties(final ComputationTarget target) {
    return createValueProperties()
        .with(ValuePropertyNames.CALCULATION_METHOD, FXOptionBlackFunction.BLACK_METHOD)
        .withAny(FXOptionBlackFunction.PUT_CURVE)
        .withAny(FXOptionBlackFunction.PUT_CURVE_CALC_CONFIG)
        .withAny(FXOptionBlackFunction.CALL_CURVE)
        .withAny(FXOptionBlackFunction.CALL_CURVE_CALC_CONFIG)
        .withAny(ValuePropertyNames.SURFACE)
        .withAny(InterpolatedDataProperties.X_INTERPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME)
        .withAny(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME)
        .withAny(ValuePropertyNames.CURRENCY);
    //        .with(ValuePropertyNames.CURRENCY, FXOptionBlackSingleValuedFunction.getResultCurrency(target));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_de039_08b30/rev_de039-08b30;/src/java/org/apache/cassandra/service/AntiEntropyService;makeVerb(TreeRequest,int);;static Message makeVerb(TreeRequest request, int version)
        {
            try
            {
            	FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
                DataOutputStream dos = new DataOutputStream(bos);
                SERIALIZER.serialize(request, dos, version);
                return new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.TREE_REQUEST, bos.toByteArray(), version);
            }
            catch(IOException e)
            {
                throw new RuntimeException(e);
            }
        };static Message makeVerb(TreeRequest request, int version)
        {
            try
            {
                FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
                DataOutputStream dos = new DataOutputStream(bos);
                SERIALIZER.serialize(request, dos, version);
                return new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.TREE_REQUEST, bos.toByteArray(), version);
            }
            catch(IOException e)
            {
                throw new RuntimeException(e);
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_de039_08b30/rev_de039-08b30;/src/java/org/apache/cassandra/service/AntiEntropyService;makeVerb(InetAddress,Validator);;static Message makeVerb(InetAddress local, Validator validator)
        {
            try
            {
            	FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
                DataOutputStream dos = new DataOutputStream(bos);
                SERIALIZER.serialize(validator, dos, Gossiper.instance.getVersion(validator.request.endpoint));
                return new Message(local,
                                   StorageService.Verb.TREE_RESPONSE,
                                   bos.toByteArray(),
                                   Gossiper.instance.getVersion(validator.request.endpoint));
            }
            catch(IOException e)
            {
                throw new RuntimeException(e);
            }
        };static Message makeVerb(InetAddress local, Validator validator)
        {
            try
            {
                FastByteArrayOutputStream bos = new FastByteArrayOutputStream();
                DataOutputStream dos = new DataOutputStream(bos);
                SERIALIZER.serialize(validator, dos, Gossiper.instance.getVersion(validator.request.endpoint));
                return new Message(local,
                                   StorageService.Verb.TREE_RESPONSE,
                                   bos.toByteArray(),
                                   Gossiper.instance.getVersion(validator.request.endpoint));
            }
            catch(IOException e)
            {
                throw new RuntimeException(e);
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e48b2_c98ed/rev_e48b2-c98ed;/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;objToBB(Object);;private ByteBuffer objToBB(Object o)
    {
        if (o == null)
            return (ByteBuffer)o;
        if (o instanceof java.lang.String)
            return ByteBuffer.wrap(new DataByteArray((String)o).get());
        if (o instanceof Integer)
            return Int32Type.instance.decompose((Integer)o);
        if (o instanceof Long)
            return LongType.instance.decompose((Long)o);
        if (o instanceof Float)
            return FloatType.instance.decompose((Float)o);
        if (o instanceof Double)
            return DoubleType.instance.decompose((Double)o);
        if (o instanceof UUID)
            return ByteBuffer.wrap(UUIDGen.decompose((UUID) o));
        return ByteBuffer.wrap(((DataByteArray) o).get());
    };private ByteBuffer objToBB(Object o)
    {
        if (o == null)
            return (ByteBuffer)o;
        if (o instanceof java.lang.String)
            return ByteBuffer.wrap(new DataByteArray((String)o).get());
        if (o instanceof Integer)
            return Int32Type.instance.decompose((Integer)o);
        if (o instanceof Long)
            return LongType.instance.decompose((Long)o);
        if (o instanceof Float)
            return FloatType.instance.decompose((Float)o);
        if (o instanceof Double)
            return DoubleType.instance.decompose((Double)o);
        if (o instanceof UUID)
            return ByteBuffer.wrap(UUIDGen.decompose((UUID) o));

        return ByteBuffer.wrap(((DataByteArray) o).get());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e2516_ae451/rev_e2516-ae451;/projects/OG-Analytics/src/com/opengamma/financial/model/finiteDifference/OperatorSplittingFiniteDifference2D;solve(ConvectionDiffusion2DPDEDataBundle,int,int,int,double,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,Cube<Double,Double,Double,Double>);;public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;
    double dtdxdy = dt / dy / dx;

    double[][] v = new double[xSteps + 1][ySteps + 1];
    double[][] vStar = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];
    final double[] vx = new double[xSteps + 1];
    final double[] vy = new double[ySteps + 1];
    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, e, f, aa, bb, cc;

    for (int n = 0; n < tSteps; n++) {
      // t += dt / 2;

      // stag 1 x terms and the cross
      for (int j = 1; j < ySteps; j++) {

        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);
          e = pdeData.getE(t, x[i], y[j]);
          // aa = (dtdx2 * a - 0.5 * dtdx * b);
          // bb = 1 - (2 * dtdx2 * a - dt * c);
          // cc = (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = v[i][j];
          q[i] -= (1 - THETA) * (dtdx2 * a * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]) + 0.5 * dtdx * b * (v[i + 1][j] - v[i - 1][j]) + 0.5 * dt * c * v[i][j]);
          q[i] -= dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]) + 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]) + 0.5 * dt * c * v[i][j];
          q[i] -= 0.25 * dtdxdy * e * (v[i + 1][j + 1] + v[i - 1][j - 1] - v[i + 1][j - 1] - v[i - 1][j + 1]);

          // should we resample a,b & c at t+dt/2?
          mx[i][i - 1] = THETA * (dtdx2 * a - dtdx * b);
          mx[i][i] = 1 + THETA * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = THETA * (dtdx2 * a + dtdx * b);
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // final DoubleMatrix2D mM = new DoubleMatrix2D(mx);
        // final DecompositionResult res = DCOMP.evaluate(mM);
        // double[] vNew = res.solve(q);
        // for (int i = 0; i <= xSteps; i++) {
        // v[i][j] = vNew[i];
        // }

        for (int i = 0; i <= xSteps; i++) {
          vx[i] = v[i][j];
        }
        // SOR
        final double omega = 1.0;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        while (errorSqr / (scale + 1e-10) > 1e-18) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) {// mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vx[k];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vx[l] += correction;
            scale += vx[l] * vx[l];
          }
        }
        for (int i = 0; i <= xSteps; i++) {
          vStar[i][j] = vx[i];
        }
      }
      // copy the boundary points from the previous level
      for (int i = 0; i <= xSteps; i++) {
        vStar[i][0] = v[i][0];
        vStar[i][ySteps] = v[i][ySteps];
      }

      // stag 2 y terms
      for (int i = 1; i < xSteps; i++) {

        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          r[j] = vStar[i][j];
          r[j] += THETA * (dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]) + 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]) + 0.5 * dt * c * v[i][j]);

          my[j][j - 1] = THETA * (dtdy2 * d - dtdy * f);
          my[j][j] = 1 + THETA * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = THETA * (dtdy2 * d + dtdx * f);
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // final DoubleMatrix2D mM = new DoubleMatrix2D(mx);
        // final DecompositionResult res = DCOMP.evaluate(mM);
        // double[] vNew = res.solve(r);
        // for (int j = 0; j <= ySteps; j++) {
        // v[i][j] = vNew[j];
        // }

        //
        // SOR
        final double omega = 1.0;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        while (errorSqr / (scale + 1e-10) > 1e-18) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
        }
      }

      // still have to handle the i = 0 and i = xSteps boundary
      for (int j = 0; j <= ySteps; j++) {

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];// TODO this should be vold
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

    } // time loop
    return v;

  };public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;
    double dtdxdy = dt / dy / dx;

    double[][] v = new double[xSteps + 1][ySteps + 1];
    double[][] vStar = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];
    final double[] vx = new double[xSteps + 1];
    final double[] vy = new double[ySteps + 1];
    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, e, f, aa, bb, cc;

    for (int n = 0; n < tSteps; n++) {
      // t += dt / 2;

      // stag 1 x terms and the cross
      for (int j = 1; j < ySteps; j++) {

        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);
          e = pdeData.getE(t, x[i], y[j]);
          // aa = (dtdx2 * a - 0.5 * dtdx * b);
          // bb = 1 - (2 * dtdx2 * a - dt * c);
          // cc = (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = v[i][j];
          q[i] -= (1 - THETA) * (dtdx2 * a * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]) + 0.5 * dtdx * b * (v[i + 1][j] - v[i - 1][j]) + 0.5 * dt * c * v[i][j]);
          q[i] -= dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]) + 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]) + 0.5 * dt * c * v[i][j];
          q[i] -= 0.25 * dtdxdy * e * (v[i + 1][j + 1] + v[i - 1][j - 1] - v[i + 1][j - 1] - v[i - 1][j + 1]);

          // should we resample a,b & c at t+dt/2?
          mx[i][i - 1] = THETA * (dtdx2 * a - dtdx * b);
          mx[i][i] = 1 + THETA * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = THETA * (dtdx2 * a + dtdx * b);
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // final DoubleMatrix2D mM = new DoubleMatrix2D(mx);
        // final DecompositionResult res = DCOMP.evaluate(mM);
        // double[] vNew = res.solve(q);
        // for (int i = 0; i <= xSteps; i++) {
        // v[i][j] = vNew[i];
        // }

        for (int i = 0; i <= xSteps; i++) {
          vx[i] = v[i][j];
        }
        // SOR
        final double omega = 1.0;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        while (errorSqr / (scale + 1e-10) > 1e-18) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) { // mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vx[k];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vx[l] += correction;
            scale += vx[l] * vx[l];
          }
        }
        for (int i = 0; i <= xSteps; i++) {
          vStar[i][j] = vx[i];
        }
      }
      // copy the boundary points from the previous level
      for (int i = 0; i <= xSteps; i++) {
        vStar[i][0] = v[i][0];
        vStar[i][ySteps] = v[i][ySteps];
      }

      // stag 2 y terms
      for (int i = 1; i < xSteps; i++) {

        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          r[j] = vStar[i][j];
          r[j] += THETA * (dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]) + 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]) + 0.5 * dt * c * v[i][j]);

          my[j][j - 1] = THETA * (dtdy2 * d - dtdy * f);
          my[j][j] = 1 + THETA * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = THETA * (dtdy2 * d + dtdx * f);
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // final DoubleMatrix2D mM = new DoubleMatrix2D(mx);
        // final DecompositionResult res = DCOMP.evaluate(mM);
        // double[] vNew = res.solve(r);
        // for (int j = 0; j <= ySteps; j++) {
        // v[i][j] = vNew[j];
        // }

        //
        // SOR
        final double omega = 1.0;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        while (errorSqr / (scale + 1e-10) > 1e-18) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
        }
      }

      // still have to handle the i = 0 and i = xSteps boundary
      for (int j = 0; j <= ySteps; j++) {

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j]; // TODO this should be vold
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

    } // time loop
    return v;

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e2516_ae451/rev_e2516-ae451;/projects/OG-Analytics/src/com/opengamma/financial/model/finiteDifference/PeacemanRachfordFiniteDifference2Db;solve(ConvectionDiffusion2DPDEDataBundle,int,int,int,double,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,Cube<Double,Double,Double,Double>);;public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];
    double[][] vt = new double[xSteps + 1][ySteps + 1];

    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t, tStar;
    double a, b, c, d, f;

    for (int n = 0; n < tSteps; n++) {

      t = n * dt;
      tStar = t + 0.25 * dt;

      // stag 1 Explicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vt[i][j] -= 0.5 * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          vt[i][j] -= 0.25 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
        }

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, tStar, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, tStar, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, tStar, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, tStar, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, tStar, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, tStar, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      // stag 2 - Implicit in x
      t += 0.5 * dt;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = 0.5 * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + 0.5 * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = 0.5 * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vt[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < SOR_MAX) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) {// mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vt[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vt[l][j] += correction;
            scale += vt[l][j] * vt[l][j];
          }
          count++;
        }
        Validate.isTrue(count < SOR_MAX, "SOR exceeded max interations");
      }

      // stag 3 explicit in x
      tStar = t + 0.25 * dt;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          v[i][j] = (1 - 0.25 * c) * vt[i][j];
          v[i][j] -= 0.5 * dtdx2 * a * (vt[i + 1][j] + vt[i - 1][j] - 2 * vt[i][j]);
          v[i][j] -= 0.25 * dtdx * b * (vt[i + 1][j] - vt[i - 1][j]);
        }

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, tStar, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[k][j];
        }
        sum += xLowerBoundary.getConstant(pdeData, tStar, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, tStar, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, tStar, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, tStar, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, tStar, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

      // stag 4 - implicit in y
      t = (n + 1) * dt;
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          my[j][j - 1] = 0.5 * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + 0.5 * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = 0.5 * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = v[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < SOR_MAX) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < SOR_MAX, "SOR exceeded max interations");
      }

    } // time loop
    return v;

  };public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];
    double[][] vt = new double[xSteps + 1][ySteps + 1];

    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t, tStar;
    double a, b, c, d, f;

    for (int n = 0; n < tSteps; n++) {

      t = n * dt;
      tStar = t + 0.25 * dt;

      // stag 1 Explicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vt[i][j] -= 0.5 * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          vt[i][j] -= 0.25 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
        }

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, tStar, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, tStar, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, tStar, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, tStar, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, tStar, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, tStar, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      // stag 2 - Implicit in x
      t += 0.5 * dt;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = 0.5 * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + 0.5 * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = 0.5 * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vt[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < SOR_MAX) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) { // mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vt[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vt[l][j] += correction;
            scale += vt[l][j] * vt[l][j];
          }
          count++;
        }
        Validate.isTrue(count < SOR_MAX, "SOR exceeded max interations");
      }

      // stag 3 explicit in x
      tStar = t + 0.25 * dt;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          v[i][j] = (1 - 0.25 * c) * vt[i][j];
          v[i][j] -= 0.5 * dtdx2 * a * (vt[i + 1][j] + vt[i - 1][j] - 2 * vt[i][j]);
          v[i][j] -= 0.25 * dtdx * b * (vt[i + 1][j] - vt[i - 1][j]);
        }

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, tStar, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[k][j];
        }
        sum += xLowerBoundary.getConstant(pdeData, tStar, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, tStar, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, tStar, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, tStar, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, tStar, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

      // stag 4 - implicit in y
      t = (n + 1) * dt;
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          my[j][j - 1] = 0.5 * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + 0.5 * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = 0.5 * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = v[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * vt[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < SOR_MAX) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < SOR_MAX, "SOR exceeded max interations");
      }

    } // time loop
    return v;

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e2516_ae451/rev_e2516-ae451;/projects/OG-Analytics/src/com/opengamma/financial/model/finiteDifference/CraigSneydFiniteDifference2D;solve(ConvectionDiffusion2DPDEDataBundle,int,int,int,double,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,Cube<Double,Double,Double,Double>);;public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;
    double dtdxdy = dt / dx / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];

    double[][] vt = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, e, f;

    for (int n = 0; n < tSteps; n++) {

      // stag 1 full Explicit
      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          e = pdeData.getE(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] = (1 - dt * (1 - 0.5 * THETA) * c) * v[i][j];
          vt[i][j] -= dtdx2 * a * (1 - THETA) * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]);
          vt[i][j] -= 0.5 * dtdx * b * (1 - THETA) * (v[i + 1][j] - v[i - 1][j]);
          vt[i][j] -= dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          // upwind
          // if (f > 0) {
          // vt[i][j] -= dtdy * f * (v[i][j] - v[i][j - 1]);
          // } else if (f < 0) {
          // vt[i][j] -= dtdy * f * (v[i][j + 1] - v[i][j]);
          // }
          vt[i][j] -= 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
          vt[i][j] -= 0.25 * dtdxdy * e * (v[i + 1][j + 1] + v[i - 1][j - 1] - v[i + 1][j - 1] - v[i - 1][j + 1]);
        }
      }

      // copy up the boundary from previous full time step - could also apply the y and x boundary conditions here
      // although it is not clear what time we are at
      // for (int i = 0; i <= xSteps; i++) {
      // vt[i][0] = v[i][0];
      // v[i][ySteps] = v[i][ySteps];
      // }
      // for (int j = 1; j < ySteps; j++) {
      // vt[0][j] = v[0][j];
      // vt[xSteps][j] = v[xSteps][j];
      // }

      for (int i = 0; i <= xSteps; i++) {
        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      for (int j = 1; j < ySteps; j++) {
        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[k][j];
        }
        vt[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[xSteps - k][j];
        }
        vt[xSteps][j] = sum / temp[0];
      }

      // stag 2 implicit in x
      t += dt / 2;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = THETA * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + THETA * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = THETA * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vt[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) {// mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vt[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vt[l][j] += correction;
            scale += vt[l][j] * vt[l][j];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // stag 3 explicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] += THETA * 0.5 * dt * c * v[i][j];
          vt[i][j] += THETA * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);

          // upwind
          // if (f > 0) {
          // vt[i][j] += THETA * dtdx * f * (v[i][j] - v[i][j - 1]);
          // } else if (f < 0) {
          // vt[i][j] += THETA * dtdx * f * (v[i][j + 1] - v[i][j]);
          // }
          vt[i][j] += THETA * 0.5 * dtdx * f * (v[i][j + 1] - v[i][j - 1]);
        }

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      // The y = 0 and y = yStep boundary values are assumed the same as the previous sub-step
      // Again we could apply the y boundary conditions here

      // stag 4 implicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          // upwind
          // if (f > 0) {
          // my[j][j - 1] = THETA * (dtdy2 * d - dtdy * f);
          // my[j][j] = 1 + THETA * (-2 * dtdy2 * d + dtdy * f + 0.5 * dt * c);
          // my[j][j + 1] = THETA * (dtdy2 * d);
          // } else if (f < 0) {
          // my[j][j - 1] = THETA * (dtdy2 * d);
          // my[j][j] = 1 + THETA * (-2 * dtdy2 * d - dtdy * f + 0.5 * dt * c);
          // my[j][j + 1] = THETA * (dtdy2 * d + dtdy * f);
          // }
          my[j][j - 1] = THETA * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + THETA * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = THETA * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = vt[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

    } // time loop
    return v;

  };public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;
    double dtdxdy = dt / dx / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];

    double[][] vt = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, e, f;

    for (int n = 0; n < tSteps; n++) {

      // stag 1 full Explicit
      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          e = pdeData.getE(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] = (1 - dt * (1 - 0.5 * THETA) * c) * v[i][j];
          vt[i][j] -= dtdx2 * a * (1 - THETA) * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]);
          vt[i][j] -= 0.5 * dtdx * b * (1 - THETA) * (v[i + 1][j] - v[i - 1][j]);
          vt[i][j] -= dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          // upwind
          // if (f > 0) {
          // vt[i][j] -= dtdy * f * (v[i][j] - v[i][j - 1]);
          // } else if (f < 0) {
          // vt[i][j] -= dtdy * f * (v[i][j + 1] - v[i][j]);
          // }
          vt[i][j] -= 0.5 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
          vt[i][j] -= 0.25 * dtdxdy * e * (v[i + 1][j + 1] + v[i - 1][j - 1] - v[i + 1][j - 1] - v[i - 1][j + 1]);
        }
      }

      // copy up the boundary from previous full time step - could also apply the y and x boundary conditions here
      // although it is not clear what time we are at
      // for (int i = 0; i <= xSteps; i++) {
      // vt[i][0] = v[i][0];
      // v[i][ySteps] = v[i][ySteps];
      // }
      // for (int j = 1; j < ySteps; j++) {
      // vt[0][j] = v[0][j];
      // vt[xSteps][j] = v[xSteps][j];
      // }

      for (int i = 0; i <= xSteps; i++) {
        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      for (int j = 1; j < ySteps; j++) {
        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[k][j];
        }
        vt[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[xSteps - k][j];
        }
        vt[xSteps][j] = sum / temp[0];
      }

      // stag 2 implicit in x
      t += dt / 2;
      for (int j = 0; j <= ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = THETA * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + THETA * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = THETA * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vt[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) { // mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * vt[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            vt[l][j] += correction;
            scale += vt[l][j] * vt[l][j];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // stag 3 explicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vt[i][j] += THETA * 0.5 * dt * c * v[i][j];
          vt[i][j] += THETA * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);

          // upwind
          // if (f > 0) {
          // vt[i][j] += THETA * dtdx * f * (v[i][j] - v[i][j - 1]);
          // } else if (f < 0) {
          // vt[i][j] += THETA * dtdx * f * (v[i][j + 1] - v[i][j]);
          // }
          vt[i][j] += THETA * 0.5 * dtdx * f * (v[i][j + 1] - v[i][j - 1]);
        }

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][k];
        }
        vt[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * vt[i][ySteps - k];
        }
        vt[i][ySteps] = sum / temp[0];
      }

      // The y = 0 and y = yStep boundary values are assumed the same as the previous sub-step
      // Again we could apply the y boundary conditions here

      // stag 4 implicit in y
      for (int i = 0; i <= xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          // upwind
          // if (f > 0) {
          // my[j][j - 1] = THETA * (dtdy2 * d - dtdy * f);
          // my[j][j] = 1 + THETA * (-2 * dtdy2 * d + dtdy * f + 0.5 * dt * c);
          // my[j][j + 1] = THETA * (dtdy2 * d);
          // } else if (f < 0) {
          // my[j][j - 1] = THETA * (dtdy2 * d);
          // my[j][j] = 1 + THETA * (-2 * dtdy2 * d - dtdy * f + 0.5 * dt * c);
          // my[j][j + 1] = THETA * (dtdy2 * d + dtdy * f);
          // }
          my[j][j - 1] = THETA * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + THETA * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = THETA * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = vt[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

    } // time loop
    return v;

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e2516_ae451/rev_e2516-ae451;/projects/OG-Analytics/src/com/opengamma/financial/model/finiteDifference/PeacemanRachfordFiniteDifference2D;solve(ConvectionDiffusion2DPDEDataBundle,int,int,int,double,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,BoundaryCondition2D,Cube<Double,Double,Double,Double>);;public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];

    double[][] vRight = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, f;

    for (int n = 0; n < tSteps; n++) {
      // t += dt / 2;

      // stag 1 Explicit in y, implicit in x
      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vRight[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vRight[i][j] -= 0.5 * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          vRight[i][j] -= 0.25 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
        }
      }

      t += dt / 2;

      for (int j = 1; j < ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = 0.5 * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + 0.5 * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = 0.5 * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vRight[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) {// mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * v[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[l][j] += correction;
            scale += v[l][j] * v[l][j];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // get the y = 0 and y = yStep boundaries
      for (int i = 0; i <= xSteps; i++) {

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];// TODO this should be vold
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[i][k];
        }
        v[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[i][ySteps - k];
        }
        v[i][ySteps] = sum / temp[0];
      }

      // // copy the boundary points from the previous level
      // for (int i = 0; i <= xSteps; i++) {
      // vStar[i][0] = v[i][0];
      // vStar[i][ySteps] = v[i][ySteps];
      // }

      // stag 2 explicit in x, implicit in y
      for (int j = 1; j < ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          vRight[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vRight[i][j] -= 0.5 * dtdx2 * a * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]);
          vRight[i][j] -= 0.25 * dtdx * b * (v[i + 1][j] - v[i - 1][j]);
        }
      }

      t += dt / 2;

      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          my[j][j - 1] = 0.5 * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + 0.5 * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = 0.5 * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = vRight[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // still have to handle the i = 0 and i = xSteps boundary
      for (int j = 0; j <= ySteps; j++) {

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];// TODO this should be vold
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

    } // time loop
    return v;

  };public double[][] solve(ConvectionDiffusion2DPDEDataBundle pdeData, final int tSteps, final int xSteps, final int ySteps, final double tMax, BoundaryCondition2D xLowerBoundary,
      BoundaryCondition2D xUpperBoundary, BoundaryCondition2D yLowerBoundary, BoundaryCondition2D yUpperBoundary, final Cube<Double, Double, Double, Double> freeBoundary) {

    double dt = tMax / (tSteps);
    double dx = (xUpperBoundary.getLevel() - xLowerBoundary.getLevel()) / (xSteps);
    double dy = (yUpperBoundary.getLevel() - yLowerBoundary.getLevel()) / (ySteps);
    double dtdx2 = dt / dx / dx;
    double dtdx = dt / dx;
    double dtdy2 = dt / dy / dy;
    double dtdy = dt / dy;

    double[][] v = new double[xSteps + 1][ySteps + 1];

    double[][] vRight = new double[xSteps + 1][ySteps + 1];
    double[] x = new double[xSteps + 1];
    double[] y = new double[ySteps + 1];

    final double[] q = new double[xSteps + 1];
    final double[] r = new double[ySteps + 1];
    final double[][] mx = new double[xSteps + 1][xSteps + 1];
    final double[][] my = new double[ySteps + 1][ySteps + 1];

    double currentX = 0;
    double currentY = 0;

    for (int j = 0; j <= ySteps; j++) {
      currentY = yLowerBoundary.getLevel() + j * dy;
      y[j] = currentY;
    }
    for (int i = 0; i <= xSteps; i++) {
      currentX = xLowerBoundary.getLevel() + i * dx;
      x[i] = currentX;
      for (int j = 0; j <= ySteps; j++) {
        v[i][j] = pdeData.getInitialValue(x[i], y[j]);
      }
    }

    double t = 0.0;
    double a, b, c, d, f;

    for (int n = 0; n < tSteps; n++) {
      // t += dt / 2;

      // stag 1 Explicit in y, implicit in x
      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {
          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          vRight[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vRight[i][j] -= 0.5 * dtdy2 * d * (v[i][j + 1] + v[i][j - 1] - 2 * v[i][j]);
          vRight[i][j] -= 0.25 * dtdy * f * (v[i][j + 1] - v[i][j - 1]);
        }
      }

      t += dt / 2;

      for (int j = 1; j < ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {
          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          mx[i][i - 1] = 0.5 * (dtdx2 * a - 0.5 * dtdx * b);
          mx[i][i] = 1 + 0.5 * (-2 * dtdx2 * a + 0.5 * dt * c);
          mx[i][i + 1] = 0.5 * (dtdx2 * a + 0.5 * dtdx * b);

          q[i] = vRight[i][j];
        }

        double[] temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[0][k] = temp[k];
        }
        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 0; k < temp.length; k++) {
          mx[xSteps][xSteps - k] = temp[k];
        }

        temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j];
        }
        q[0] = sum + xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        q[xSteps] = sum + xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int min, max;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          for (int l = 0; l <= xSteps; l++) {
            min = (l == xSteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? xSteps : Math.min(xSteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= xSteps; k++) {
            for (int k = min; k <= max; k++) { // mx is tri-diagonal so only need 3 steps here
              sum += mx[l][k] * v[k][j];
            }
            double correction = omega / mx[l][l] * (q[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[l][j] += correction;
            scale += v[l][j] * v[l][j];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // get the y = 0 and y = yStep boundaries
      for (int i = 0; i <= xSteps; i++) {

        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k]; // TODO this should be vold
        }
        sum += yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[i][k];
        }
        v[i][0] = sum / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        sum += yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[i][ySteps - k];
        }
        v[i][ySteps] = sum / temp[0];
      }

      // // copy the boundary points from the previous level
      // for (int i = 0; i <= xSteps; i++) {
      // vStar[i][0] = v[i][0];
      // vStar[i][ySteps] = v[i][ySteps];
      // }

      // stag 2 explicit in x, implicit in y
      for (int j = 1; j < ySteps; j++) {
        for (int i = 1; i < xSteps; i++) {

          a = pdeData.getA(t, x[i], y[j]);
          b = pdeData.getB(t, x[i], y[j]);
          c = pdeData.getC(t, x[i], y[j]);

          vRight[i][j] = (1 - 0.25 * dt * c) * v[i][j];
          vRight[i][j] -= 0.5 * dtdx2 * a * (v[i + 1][j] + v[i - 1][j] - 2 * v[i][j]);
          vRight[i][j] -= 0.25 * dtdx * b * (v[i + 1][j] - v[i - 1][j]);
        }
      }

      t += dt / 2;

      for (int i = 1; i < xSteps; i++) {
        for (int j = 1; j < ySteps; j++) {

          c = pdeData.getC(t, x[i], y[j]);
          d = pdeData.getD(t, x[i], y[j]);
          f = pdeData.getF(t, x[i], y[j]);

          my[j][j - 1] = 0.5 * (dtdy2 * d - 0.5 * dtdy * f);
          my[j][j] = 1 + 0.5 * (-2 * dtdy2 * d + 0.5 * dt * c);
          my[j][j + 1] = 0.5 * (dtdy2 * d + 0.5 * dtdy * f);

          r[j] = vRight[i][j];
        }

        double[] temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[0][k] = temp[k];
        }
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t, x[i]);
        for (int k = 0; k < temp.length; k++) {
          my[ySteps][ySteps - k] = temp[k];
        }

        temp = yLowerBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][k];
        }
        r[0] = sum + yLowerBoundary.getConstant(pdeData, t, x[i], dy);

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t, x[i]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[i][ySteps - k];
        }
        r[ySteps] = sum + yUpperBoundary.getConstant(pdeData, t, x[i], dy);

        // SOR
        final double omega = 1.5;
        double scale = 1.0;
        double errorSqr = Double.POSITIVE_INFINITY;
        int count = 0;
        while (errorSqr / (scale + 1e-10) > 1e-18 && count < 1000) {
          errorSqr = 0.0;
          scale = 0.0;
          int min, max;
          for (int l = 0; l <= ySteps; l++) {
            min = (l == ySteps ? 0 : Math.max(0, l - 1));
            max = (l == 0 ? ySteps : Math.min(ySteps, l + 1));
            sum = 0;
            // for (int k = 0; k <= ySteps; k++) {
            for (int k = min; k <= max; k++) {
              sum += my[l][k] * v[i][k];
            }
            double correction = omega / my[l][l] * (r[l] - sum);
            // if (freeBoundary != null) {
            // correction = Math.max(correction, freeBoundary.getZValue(t, x[j]) - f[j]);
            // }
            errorSqr += correction * correction;
            v[i][l] += correction;
            scale += v[i][l] * v[i][l];
          }
          count++;
        }
        Validate.isTrue(count < 1000, "SOR exceeded max interations");
      }

      // still have to handle the i = 0 and i = xSteps boundary
      for (int j = 0; j <= ySteps; j++) {

        double[] temp = xLowerBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        double sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[k][j]; // TODO this should be vold
        }
        sum += xLowerBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xLowerBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[k][j];
        }
        v[0][j] = sum / temp[0];

        temp = xUpperBoundary.getRightMatrixCondition(pdeData, t, y[j]);
        sum = 0;
        for (int k = 0; k < temp.length; k++) {
          sum += temp[k] * v[xSteps - k][j];
        }
        sum += xUpperBoundary.getConstant(pdeData, t, y[j], dx);

        temp = xUpperBoundary.getLeftMatrixCondition(pdeData, t, y[j]);
        for (int k = 1; k < temp.length; k++) {
          sum -= temp[k] * v[xSteps - k][j];
        }
        v[xSteps][j] = sum / temp[0];
      }

    } // time loop
    return v;

  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentDefinitionYieldCurveSensitivitiesTest;makeSwapDefinition(ZonedDateTime,double,double,String,String);;@SuppressWarnings("unchecked")
  private static Swap<?, ?> makeSwapDefinition(final ZonedDateTime maturity, final double rate, final double notional, final String fundingCurveName,
      final String forwardCurveName) {
    return new SwapFixedIborDefinition(AnnuityCouponFixedDefinition.from(CCY, DateUtils.getUTCDate(2011, 1, 3), maturity, SimpleFrequency.SEMI_ANNUAL, CALENDAR,
        DAY_COUNT, BUSINESS_DAY, false, notional, rate, true), AnnuityCouponIborDefinition.from(DateUtils.getUTCDate(2011, 1, 3), maturity, notional, IBOR, false))
        .toDerivative(NOW, new DoubleTimeSeries[] {new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {SWAP_FIXING_DATE}, new double[] {rate})},
            fundingCurveName, forwardCurveName);
  };@SuppressWarnings("unchecked")
  private static Swap<?, ?> makeSwapDefinition(final ZonedDateTime maturity, final double rate, final double notional, final String fundingCurveName,
      final String forwardCurveName) {
    return new SwapFixedIborDefinition(AnnuityCouponFixedDefinition.from(CCY, DateUtils.getUTCDate(2011, 1, 3), maturity, SimpleFrequency.SEMI_ANNUAL, CALENDAR,
        DAY_COUNT, BUSINESS_DAY, false, notional, rate, true), AnnuityCouponIborDefinition.from(DateUtils.getUTCDate(2011, 1, 3), maturity, notional, IBOR, false))
        .toDerivative(NOW, new DoubleTimeSeries[] {new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {SWAP_FIXING_DATE }, new double[] {rate }) },
            fundingCurveName, forwardCurveName);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentSingleCurveSensitivityCalculatorTest;testBumpedData();;@Test
  public void testBumpedData() {
    final double notional = 10394850;
    final double eps = 1e-3;
    final InstrumentDerivative libor = makeSingleCurrencyIRD("libor", 1.5, FRQ, CURVE_NAME, CURVE_NAME, 0.04, notional);
    testBumpedDataParRateMethod(libor, eps);
    testBumpedDataPVMethod(libor, eps);
    InstrumentDerivative swap = makeSingleCurrencyIRD("swap", 13,FRQ, CURVE_NAME, CURVE_NAME, 0.048, notional);
    testBumpedDataParRateMethod(swap, eps);
    testBumpedDataPVMethod(swap, eps);
    final InstrumentDerivative fra = makeSingleCurrencyIRD("fra", 0.6666, FRQ,CURVE_NAME, CURVE_NAME, 0.02, notional);
    testBumpedDataParRateMethod(fra, eps);
    testBumpedDataPVMethod(fra, eps);
    final InstrumentDerivative future = makeSingleCurrencyIRD("fra", 2,FRQ, CURVE_NAME, CURVE_NAME, 0.03, notional);
    testBumpedDataParRateMethod(future, eps);
    testBumpedDataPVMethod(future, eps);
    swap = makeSingleCurrencyIRD("swap", 19,FRQ, CURVE_NAME, CURVE_NAME, 0.05, notional);
    testBumpedDataParRateMethod(swap, eps);
    testBumpedDataPVMethod(swap, eps);
  };@Test
  public void testBumpedData() {
    final double notional = 10394850;
    final double eps = 1e-3;
    final InstrumentDerivative libor = makeSingleCurrencyIRD("libor", 1.5, FRQ, CURVE_NAME, CURVE_NAME, 0.04, notional);
    testBumpedDataParRateMethod(libor, eps);
    testBumpedDataPVMethod(libor, eps);
    InstrumentDerivative swap = makeSingleCurrencyIRD("swap", 13, FRQ, CURVE_NAME, CURVE_NAME, 0.048, notional);
    testBumpedDataParRateMethod(swap, eps);
    testBumpedDataPVMethod(swap, eps);
    final InstrumentDerivative fra = makeSingleCurrencyIRD("fra", 0.6666, FRQ, CURVE_NAME, CURVE_NAME, 0.02, notional);
    testBumpedDataParRateMethod(fra, eps);
    testBumpedDataPVMethod(fra, eps);
    final InstrumentDerivative future = makeSingleCurrencyIRD("fra", 2, FRQ, CURVE_NAME, CURVE_NAME, 0.03, notional);
    testBumpedDataParRateMethod(future, eps);
    testBumpedDataPVMethod(future, eps);
    swap = makeSingleCurrencyIRD("swap", 19, FRQ, CURVE_NAME, CURVE_NAME, 0.05, notional);
    testBumpedDataParRateMethod(swap, eps);
    testBumpedDataPVMethod(swap, eps);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/InstrumentSingleCurveSensitivityCalculatorTest;getSingleCurveSetup(InstrumentDerivativeVisitor<YieldCurveBundle,Double>,InstrumentDerivativeVisitor<YieldCurveBundle,Map<String,List<DoublesPair>>>,Map<String,double[]>,Map<String,double[]>,boolean);;private static YieldCurveFittingTestDataBundle getSingleCurveSetup(final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator,
      final Map<String, double[]> maturities, final Map<String, double[]> marketRates, final boolean isPV) {
    final List<String> curveNames = new ArrayList<String>();
    curveNames.add(CURVE_NAME);
    int nNodes = 0;
    for (final double[] temp : maturities.values()) {
      nNodes += temp.length;
    }
    final double[] temp = new double[nNodes];
    int index = 0;
    for (final double[] times : maturities.values()) {
      for (final double t : times) {
        temp[index++] = t;
      }
    }
    Arrays.sort(temp);
    final List<double[]> curveKnots = new ArrayList<double[]>();
    curveKnots.add(temp);
    // now get market prices
    final double[] marketValues = new double[nNodes];
    final List<InstrumentDerivative> instruments = new ArrayList<InstrumentDerivative>();
    InstrumentDerivative ird;
    index = 0;
    for (final String name : maturities.keySet()) {
      final double[] times = maturities.get(name);
      final double[] rates = marketRates.get(name);
      Validate.isTrue(times.length == rates.length);
      for (int i = 0; i < times.length; i++) {
        ird = makeSingleCurrencyIRD(name, times[i],FRQ, CURVE_NAME, CURVE_NAME, rates[i], 1);
        instruments.add(ird);
        if (isPV) {
          marketValues[index] = 0;
        } else {
          marketValues[index] = rates[i];
        }
        index++;
      }
    }
    final double[] rates = new double[nNodes];
    for (int i = 0; i < nNodes; i++) {
      rates[i] = 0.04;
    }
    rates[0] = 0.02;
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);
    final YieldCurveFittingTestDataBundle data = getYieldCurveFittingTestDataBundle(instruments, null, curveNames, curveKnots, INTERPOLATOR,
        calculator, sensitivityCalculator, marketValues, startPosition, null, false, FX_MATRIX);
    return data;
  };private static YieldCurveFittingTestDataBundle getSingleCurveSetup(final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator,
      final Map<String, double[]> maturities, final Map<String, double[]> marketRates, final boolean isPV) {
    final List<String> curveNames = new ArrayList<String>();
    curveNames.add(CURVE_NAME);
    int nNodes = 0;
    for (final double[] temp : maturities.values()) {
      nNodes += temp.length;
    }
    final double[] temp = new double[nNodes];
    int index = 0;
    for (final double[] times : maturities.values()) {
      for (final double t : times) {
        temp[index++] = t;
      }
    }
    Arrays.sort(temp);
    final List<double[]> curveKnots = new ArrayList<double[]>();
    curveKnots.add(temp);
    // now get market prices
    final double[] marketValues = new double[nNodes];
    final List<InstrumentDerivative> instruments = new ArrayList<InstrumentDerivative>();
    InstrumentDerivative ird;
    index = 0;
    for (final String name : maturities.keySet()) {
      final double[] times = maturities.get(name);
      final double[] rates = marketRates.get(name);
      Validate.isTrue(times.length == rates.length);
      for (int i = 0; i < times.length; i++) {
        ird = makeSingleCurrencyIRD(name, times[i], FRQ, CURVE_NAME, CURVE_NAME, rates[i], 1);
        instruments.add(ird);
        if (isPV) {
          marketValues[index] = 0;
        } else {
          marketValues[index] = rates[i];
        }
        index++;
      }
    }
    final double[] rates = new double[nNodes];
    for (int i = 0; i < nNodes; i++) {
      rates[i] = 0.04;
    }
    rates[0] = 0.02;
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);
    final YieldCurveFittingTestDataBundle data = getYieldCurveFittingTestDataBundle(instruments, null, curveNames, curveKnots, INTERPOLATOR,
        calculator, sensitivityCalculator, marketValues, startPosition, null, false, FX_MATRIX);
    return data;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/curve/CurveConstructionSpreadTest;makeCurvesFromDefinitions(InstrumentDefinition<?>[][][],GeneratorYDCurve[][],String[][],YieldCurveBundle,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,Double>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,InterestRateCurveSensitivity>,boolean,int);;private static Pair<YieldCurveBundle, CurveBuildingBlockBundle> makeCurvesFromDefinitions(final InstrumentDefinition<?>[][][] definitions, GeneratorYDCurve[][] curveGenerators, String[][] curveNames,
      YieldCurveBundle knownData, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, boolean withToday, int block) {
    int nbUnits = curveGenerators.length;
    double[][] parametersGuess = new double[nbUnits][];
    GeneratorYDCurve[][] generatorFinal = new GeneratorYDCurve[nbUnits][];
    InstrumentDerivative[][][] instruments = new InstrumentDerivative[nbUnits][][];
    for (int loopunit = 0; loopunit < nbUnits; loopunit++) {
      generatorFinal[loopunit] = new GeneratorYDCurve[curveGenerators[loopunit].length];
      int nbInsUnit = 0;
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        nbInsUnit += definitions[loopunit][loopcurve].length;
      }
      parametersGuess[loopunit] = new double[nbInsUnit];
      int startCurve = 0; // First parameter index of the curve in the unit. 
      instruments[loopunit] = convert(curveNames, definitions[loopunit], loopunit, withToday, block);
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        generatorFinal[loopunit][loopcurve] = curveGenerators[loopunit][loopcurve].finalGenerator(instruments[loopunit][loopcurve]);
        double[] guessCurve = generatorFinal[loopunit][loopcurve].initialGuess(initialGuess(definitions[loopunit][loopcurve]));
        System.arraycopy(guessCurve, 0, parametersGuess[loopunit], startCurve, instruments[loopunit][loopcurve].length);
        startCurve += instruments[loopunit][loopcurve].length;
      }
      if ((block == 7) && (loopunit == 1)) {
        parametersGuess[loopunit] = new double[] {0.012, -0.003, 0.018, 1.60, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      }
    }
    return CURVE_BUILDING_FUNCTION.makeCurvesFromDerivatives(instruments, generatorFinal, curveNames, parametersGuess, knownData, calculator, sensitivityCalculator);
  };private static Pair<YieldCurveBundle, CurveBuildingBlockBundle> makeCurvesFromDefinitions(final InstrumentDefinition<?>[][][] definitions, GeneratorYDCurve[][] curveGenerators,
      String[][] curveNames, YieldCurveBundle knownData, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, boolean withToday, int block) {
    int nbUnits = curveGenerators.length;
    double[][] parametersGuess = new double[nbUnits][];
    GeneratorYDCurve[][] generatorFinal = new GeneratorYDCurve[nbUnits][];
    InstrumentDerivative[][][] instruments = new InstrumentDerivative[nbUnits][][];
    for (int loopunit = 0; loopunit < nbUnits; loopunit++) {
      generatorFinal[loopunit] = new GeneratorYDCurve[curveGenerators[loopunit].length];
      int nbInsUnit = 0;
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        nbInsUnit += definitions[loopunit][loopcurve].length;
      }
      parametersGuess[loopunit] = new double[nbInsUnit];
      int startCurve = 0; // First parameter index of the curve in the unit. 
      instruments[loopunit] = convert(curveNames, definitions[loopunit], loopunit, withToday, block);
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        generatorFinal[loopunit][loopcurve] = curveGenerators[loopunit][loopcurve].finalGenerator(instruments[loopunit][loopcurve]);
        double[] guessCurve = generatorFinal[loopunit][loopcurve].initialGuess(initialGuess(definitions[loopunit][loopcurve]));
        System.arraycopy(guessCurve, 0, parametersGuess[loopunit], startCurve, instruments[loopunit][loopcurve].length);
        startCurve += instruments[loopunit][loopcurve].length;
      }
      if ((block == 7) && (loopunit == 1)) {
        parametersGuess[loopunit] = new double[] {0.012, -0.003, 0.018, 1.60, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      }
    }
    return CURVE_BUILDING_FUNCTION.makeCurvesFromDerivatives(instruments, generatorFinal, curveNames, parametersGuess, knownData, calculator, sensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/curve/CurveConstructionBillBondTest;makeCurvesFromDefinitions(InstrumentDefinition<?>[][][],GeneratorYDCurve[][],String[][],YieldCurveBundle,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,Double>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,InterestRateCurveSensitivity>,boolean);;private static Pair<YieldCurveBundle, CurveBuildingBlockBundle> makeCurvesFromDefinitions(final InstrumentDefinition<?>[][][] definitions, GeneratorYDCurve[][] curveGenerators, String[][] curveNames,
      YieldCurveBundle knownData, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, boolean withToday) {
    int nbUnits = curveGenerators.length;
    double[][] parametersGuess = new double[nbUnits][];
    GeneratorYDCurve[][] generatorFinal = new GeneratorYDCurve[nbUnits][];
    InstrumentDerivative[][][] instruments = new InstrumentDerivative[nbUnits][][];
    for (int loopunit = 0; loopunit < nbUnits; loopunit++) {
      generatorFinal[loopunit] = new GeneratorYDCurve[curveGenerators[loopunit].length];
      int nbInsUnit = 0;
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        nbInsUnit += definitions[loopunit][loopcurve].length;
      }
      parametersGuess[loopunit] = new double[nbInsUnit];
      int startCurve = 0; // First parameter index of the curve in the unit. 
      instruments[loopunit] = convert(curveNames, definitions[loopunit], loopunit, withToday);
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        generatorFinal[loopunit][loopcurve] = curveGenerators[loopunit][loopcurve].finalGenerator(instruments[loopunit][loopcurve]);
        double[] guessCurve = generatorFinal[loopunit][loopcurve].initialGuess(rate(definitions[loopunit][loopcurve]));
        System.arraycopy(guessCurve, 0, parametersGuess[loopunit], startCurve, instruments[loopunit][loopcurve].length);
        startCurve += instruments[loopunit][loopcurve].length;
      }
    }
    return CURVE_BUILDING_FUNCTION.makeCurvesFromDerivatives(instruments, generatorFinal, curveNames, parametersGuess, knownData, calculator, sensitivityCalculator);
  };private static Pair<YieldCurveBundle, CurveBuildingBlockBundle> makeCurvesFromDefinitions(final InstrumentDefinition<?>[][][] definitions, GeneratorYDCurve[][] curveGenerators,
      String[][] curveNames, YieldCurveBundle knownData, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, boolean withToday) {
    int nbUnits = curveGenerators.length;
    double[][] parametersGuess = new double[nbUnits][];
    GeneratorYDCurve[][] generatorFinal = new GeneratorYDCurve[nbUnits][];
    InstrumentDerivative[][][] instruments = new InstrumentDerivative[nbUnits][][];
    for (int loopunit = 0; loopunit < nbUnits; loopunit++) {
      generatorFinal[loopunit] = new GeneratorYDCurve[curveGenerators[loopunit].length];
      int nbInsUnit = 0;
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        nbInsUnit += definitions[loopunit][loopcurve].length;
      }
      parametersGuess[loopunit] = new double[nbInsUnit];
      int startCurve = 0; // First parameter index of the curve in the unit. 
      instruments[loopunit] = convert(curveNames, definitions[loopunit], loopunit, withToday);
      for (int loopcurve = 0; loopcurve < curveGenerators[loopunit].length; loopcurve++) {
        generatorFinal[loopunit][loopcurve] = curveGenerators[loopunit][loopcurve].finalGenerator(instruments[loopunit][loopcurve]);
        double[] guessCurve = generatorFinal[loopunit][loopcurve].initialGuess(rate(definitions[loopunit][loopcurve]));
        System.arraycopy(guessCurve, 0, parametersGuess[loopunit], startCurve, instruments[loopunit][loopcurve].length);
        startCurve += instruments[loopunit][loopcurve].length;
      }
    }
    return CURVE_BUILDING_FUNCTION.makeCurvesFromDerivatives(instruments, generatorFinal, curveNames, parametersGuess, knownData, calculator, sensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/curve/YieldCurveConstructionGeneratorTwoCurrenciesXCcyData;makeCurves(List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,Double>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,InterestRateCurveSensitivity>,boolean,boolean);;@SuppressWarnings({"unchecked" })
  /**
   * The returned pair contains 1) the yield curve bundle and 2) the inverse Jacobian (derivative of the curve parameters with respect to the market quotes).
   */
  public static Pair<YieldCurveBundle, DoubleMatrix2D> makeCurves(final List<InstrumentDefinition<?>> dsc1Definitions, final List<InstrumentDefinition<?>> fwd1Definitions,
      final List<InstrumentDefinition<?>> dsc2Definitions, final List<InstrumentDefinition<?>> fwd2Definitions, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, final boolean withToday, final boolean isPV) {
    final int nbDsc1 = dsc1Definitions.size();
    final int nbFwd1 = fwd1Definitions.size();
    final int nbDsc2 = dsc2Definitions.size();
    final int nbFwd2 = fwd2Definitions.size();
    final InstrumentDerivative[] instruments = new InstrumentDerivative[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    final double[] dsc1Node = new double[nbDsc1];
    final double[] fwd1Node = new double[nbFwd1];
    final double[] dsc2Node = new double[nbDsc2];
    final double[] fwd2Node = new double[nbFwd2];
    final double[] initGuess = new double[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    int i = 0;
    for (final InstrumentDefinition<?> instrument : dsc1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedONDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_DSC_1};
        ird = ((SwapFixedONDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_OIS_USD_WITH_TODAY : TS_FIXED_OIS_USD_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i] = initialGuess(instrument);
      dsc1Node[i++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j = 0;
    for (final InstrumentDefinition<?> instrument : fwd1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_USD3M_WITH_TODAY : TS_FIXED_IBOR_USD3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      fwd1Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }
    j = 0;
    for (final InstrumentDefinition<?> instrument : dsc2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapXCcyIborIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2, CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapXCcyIborIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EURUSD3M_WITH_TODAY : TS_FIXED_IBOR_EURUSD3M_WITHOUT_TODAY, curveNames);
      } else {
        if (instrument instanceof CashDefinition) {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2};
          ird = instrument.toDerivative(NOW, curveNames);
        } else {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_DSC_1};
          ird = instrument.toDerivative(NOW, curveNames);
        }
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      dsc2Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }
    j = 0;
    for (final InstrumentDefinition<?> instrument : fwd2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EUR3M_WITH_TODAY : TS_FIXED_IBOR_EUR3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_2};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      fwd2Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }

    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final YieldCurveBundle knowData = new YieldCurveBundle(FX_MATRIX, CCY_MAP);
    final MultipleYieldCurveFinderGeneratorDataBundle data = new MultipleYieldCurveFinderGeneratorDataBundle(instruments, knowData, curveGenerators);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderGeneratorFunction(calculator, data);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data);
    final double[] parameters = ROOT_FINDER.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initGuess)).getData();
    final YieldCurveBundle newCurves = data.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters));
    final YieldCurveBundle bundle = knowData.copy();
    bundle.addAll(newCurves);
    final DoubleMatrix2D inverseJacobian;
    if (isPV) {
      final DoubleMatrix2D jacobianPV = jacobianCalculator.evaluate(new DoubleMatrix1D(parameters));
      final DoubleMatrix2D inverseJacobianPV = MATRIX_ALGEBRA.getInverse(jacobianPV);
      final double[][] inverseJacobianPVArray = inverseJacobianPV.getData();
      final int dim = inverseJacobianPV.getNumberOfColumns();
      final double[] pvmqs = new double[dim];
      // Implementation note: pvmqs: Present Value Sensitivity with respect to Market Quote. 
      //   To be coherent, the pv calculator should provide a pv in the first currency of FX swaps and XCcy swaps.
      i = 0;
      for (final InstrumentDerivative ird : instruments) {
        pvmqs[i++] = PVBP_CALCULATOR.visit(ird, bundle);
      }
      double[][] inverseJacobianArray = new double[dim][dim];
      for (int loopi = 0; loopi < dim; loopi++) {
        for (int loopj = 0; loopj < dim; loopj++) {
          inverseJacobianArray[loopi][loopj] = -inverseJacobianPVArray[loopi][loopj] * pvmqs[loopj];
        }
      }
      inverseJacobian = new DoubleMatrix2D(inverseJacobianArray);
    } else {
      final DoubleMatrix2D jacobian = jacobianCalculator.evaluate(new DoubleMatrix1D(parameters));
      inverseJacobian = MATRIX_ALGEBRA.getInverse(jacobian);
    }
    return new ObjectsPair<YieldCurveBundle, DoubleMatrix2D>(bundle, inverseJacobian);
  };@SuppressWarnings({"unchecked"})
  /**
   * The returned pair contains 1) the yield curve bundle and 2) the inverse Jacobian (derivative of the curve parameters with respect to the market quotes).
   */
  public static Pair<YieldCurveBundle, DoubleMatrix2D> makeCurves(final List<InstrumentDefinition<?>> dsc1Definitions, final List<InstrumentDefinition<?>> fwd1Definitions,
      final List<InstrumentDefinition<?>> dsc2Definitions, final List<InstrumentDefinition<?>> fwd2Definitions, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, final boolean withToday, final boolean isPV) {
    final int nbDsc1 = dsc1Definitions.size();
    final int nbFwd1 = fwd1Definitions.size();
    final int nbDsc2 = dsc2Definitions.size();
    final int nbFwd2 = fwd2Definitions.size();
    final InstrumentDerivative[] instruments = new InstrumentDerivative[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    final double[] dsc1Node = new double[nbDsc1];
    final double[] fwd1Node = new double[nbFwd1];
    final double[] dsc2Node = new double[nbDsc2];
    final double[] fwd2Node = new double[nbFwd2];
    final double[] initGuess = new double[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    int i = 0;
    for (final InstrumentDefinition<?> instrument : dsc1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedONDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_DSC_1};
        ird = ((SwapFixedONDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_OIS_USD_WITH_TODAY : TS_FIXED_OIS_USD_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i] = initialGuess(instrument);
      dsc1Node[i++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j = 0;
    for (final InstrumentDefinition<?> instrument : fwd1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_USD3M_WITH_TODAY : TS_FIXED_IBOR_USD3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      fwd1Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }
    j = 0;
    for (final InstrumentDefinition<?> instrument : dsc2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapXCcyIborIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2, CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapXCcyIborIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EURUSD3M_WITH_TODAY : TS_FIXED_IBOR_EURUSD3M_WITHOUT_TODAY, curveNames);
      } else {
        if (instrument instanceof CashDefinition) {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2};
          ird = instrument.toDerivative(NOW, curveNames);
        } else {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_DSC_1};
          ird = instrument.toDerivative(NOW, curveNames);
        }
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      dsc2Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }
    j = 0;
    for (final InstrumentDefinition<?> instrument : fwd2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EUR3M_WITH_TODAY : TS_FIXED_IBOR_EUR3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_2};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments[i] = ird;
      initGuess[i++] = initialGuess(instrument);
      fwd2Node[j++] = MATURITY_CALCULATOR.visit(ird);
    }

    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGenerators.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final YieldCurveBundle knowData = new YieldCurveBundle(FX_MATRIX, CCY_MAP);
    final MultipleYieldCurveFinderGeneratorDataBundle data = new MultipleYieldCurveFinderGeneratorDataBundle(instruments, knowData, curveGenerators);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator = new MultipleYieldCurveFinderGeneratorFunction(calculator, data);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data);
    final double[] parameters = ROOT_FINDER.getRoot(curveCalculator, jacobianCalculator, new DoubleMatrix1D(initGuess)).getData();
    final YieldCurveBundle newCurves = data.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters));
    final YieldCurveBundle bundle = knowData.copy();
    bundle.addAll(newCurves);
    final DoubleMatrix2D inverseJacobian;
    if (isPV) {
      final DoubleMatrix2D jacobianPV = jacobianCalculator.evaluate(new DoubleMatrix1D(parameters));
      final DoubleMatrix2D inverseJacobianPV = MATRIX_ALGEBRA.getInverse(jacobianPV);
      final double[][] inverseJacobianPVArray = inverseJacobianPV.getData();
      final int dim = inverseJacobianPV.getNumberOfColumns();
      final double[] pvmqs = new double[dim];
      // Implementation note: pvmqs: Present Value Sensitivity with respect to Market Quote. 
      //   To be coherent, the pv calculator should provide a pv in the first currency of FX swaps and XCcy swaps.
      i = 0;
      for (final InstrumentDerivative ird : instruments) {
        pvmqs[i++] = PVBP_CALCULATOR.visit(ird, bundle);
      }
      double[][] inverseJacobianArray = new double[dim][dim];
      for (int loopi = 0; loopi < dim; loopi++) {
        for (int loopj = 0; loopj < dim; loopj++) {
          inverseJacobianArray[loopi][loopj] = -inverseJacobianPVArray[loopi][loopj] * pvmqs[loopj];
        }
      }
      inverseJacobian = new DoubleMatrix2D(inverseJacobianArray);
    } else {
      final DoubleMatrix2D jacobian = jacobianCalculator.evaluate(new DoubleMatrix1D(parameters));
      inverseJacobian = MATRIX_ALGEBRA.getInverse(jacobian);
    }
    return new ObjectsPair<YieldCurveBundle, DoubleMatrix2D>(bundle, inverseJacobian);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/curve/YieldCurveConstructionGeneratorTwoCurrenciesXCcyData;makeCurves2Blocks(List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,List<InstrumentDefinition<?>>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,Double>,AbstractInstrumentDerivativeVisitor<YieldCurveBundle,InterestRateCurveSensitivity>,boolean,boolean);;@SuppressWarnings({"unchecked" })
  /**
   * Build the curves and returns a pair containing 
   * 1) the yield curve bundle (4 curves) and 
   * 2) the inverse Jacobian (derivative of the curve parameters with respect to the market quotes) for the full bundle.
   * The curves are build in two blocks: first USD and then EUR. 
   */
  public static Pair<YieldCurveBundle, DoubleMatrix2D> makeCurves2Blocks(final List<InstrumentDefinition<?>> dsc1Definitions, final List<InstrumentDefinition<?>> fwd1Definitions,
      final List<InstrumentDefinition<?>> dsc2Definitions, final List<InstrumentDefinition<?>> fwd2Definitions, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, final boolean withToday, final boolean isPV) {

    // First block
    final int nbDsc1 = dsc1Definitions.size();
    final int nbFwd1 = fwd1Definitions.size();
    final InstrumentDerivative[] instruments1 = new InstrumentDerivative[nbDsc1 + nbFwd1];
    final double[] dsc1Node = new double[nbDsc1];
    final double[] fwd1Node = new double[nbFwd1];
    final double[] initGuess1 = new double[nbDsc1 + nbFwd1];
    int i1 = 0;
    for (final InstrumentDefinition<?> instrument : dsc1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedONDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_DSC_1};
        ird = ((SwapFixedONDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_OIS_USD_WITH_TODAY : TS_FIXED_OIS_USD_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments1[i1] = ird;
      initGuess1[i1] = initialGuess(instrument);
      dsc1Node[i1++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j1 = 0;
    for (final InstrumentDefinition<?> instrument : fwd1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_USD3M_WITH_TODAY : TS_FIXED_IBOR_USD3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments1[i1] = ird;
      initGuess1[i1++] = initialGuess(instrument);
      fwd1Node[j1++] = MATURITY_CALCULATOR.visit(ird);
    }
    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators1 = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators1.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGenerators1.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    final YieldCurveBundle knowData = new YieldCurveBundle(FX_MATRIX, CCY_MAP);
    final MultipleYieldCurveFinderGeneratorDataBundle data1 = new MultipleYieldCurveFinderGeneratorDataBundle(instruments1, knowData, curveGenerators1);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator1 = new MultipleYieldCurveFinderGeneratorFunction(calculator, data1);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator1 = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data1);
    final double[] parameters1 = ROOT_FINDER.getRoot(curveCalculator1, jacobianCalculator1, new DoubleMatrix1D(initGuess1)).getData();
    final YieldCurveBundle newCurves = data1.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters1));
    final YieldCurveBundle bundle1 = knowData.copy();
    bundle1.addAll(newCurves);

    // Second block
    final int nbDsc2 = dsc2Definitions.size();
    final int nbFwd2 = fwd2Definitions.size();
    final InstrumentDerivative[] instruments2 = new InstrumentDerivative[nbDsc2 + nbFwd2];
    final double[] dsc2Node = new double[nbDsc2];
    final double[] fwd2Node = new double[nbFwd2];
    final double[] initGuess2 = new double[nbDsc2 + nbFwd2];
    int i2 = 0;
    for (final InstrumentDefinition<?> instrument : dsc2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapXCcyIborIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2, CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapXCcyIborIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EURUSD3M_WITH_TODAY : TS_FIXED_IBOR_EURUSD3M_WITHOUT_TODAY, curveNames);
      } else {
        if (instrument instanceof CashDefinition) {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2};
          ird = instrument.toDerivative(NOW, curveNames);
        } else {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_DSC_1};
          ird = instrument.toDerivative(NOW, curveNames);
        }
      }
      instruments2[i2] = ird;
      initGuess2[i2] = initialGuess(instrument);
      dsc2Node[i2++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j2 = 0;
    for (final InstrumentDefinition<?> instrument : fwd2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EUR3M_WITH_TODAY : TS_FIXED_IBOR_EUR3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_2};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments2[i2] = ird;
      initGuess2[i2++] = initialGuess(instrument);
      fwd2Node[j2++] = MATURITY_CALCULATOR.visit(ird);
    }

    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators2 = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators2.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGenerators2.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final MultipleYieldCurveFinderGeneratorDataBundle data2 = new MultipleYieldCurveFinderGeneratorDataBundle(instruments2, bundle1, curveGenerators2);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator2 = new MultipleYieldCurveFinderGeneratorFunction(calculator, data2);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator2 = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data2);
    final double[] parameters2 = ROOT_FINDER.getRoot(curveCalculator2, jacobianCalculator2, new DoubleMatrix1D(initGuess2)).getData();
    final YieldCurveBundle newCurves2 = data2.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters2));
    final YieldCurveBundle bundle2 = bundle1.copy();
    bundle2.addAll(newCurves2);

    final InstrumentDerivative[] instrumentsT = new InstrumentDerivative[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    System.arraycopy(instruments1, 0, instrumentsT, 0, nbDsc1 + nbFwd1);
    System.arraycopy(instruments2, 0, instrumentsT, nbDsc1 + nbFwd1, nbDsc2 + nbFwd2);
    final LinkedHashMap<String, GeneratorYDCurve> curveGeneratorsT = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGeneratorsT.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final MultipleYieldCurveFinderGeneratorDataBundle dataT = new MultipleYieldCurveFinderGeneratorDataBundle(instrumentsT, knowData, curveGeneratorsT);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculatorT = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), dataT);
    final double[] parametersT = new double[parameters1.length + parameters2.length];
    System.arraycopy(parameters1, 0, parametersT, 0, parameters1.length);
    System.arraycopy(parameters2, 0, parametersT, parameters1.length, parameters2.length);
    final DoubleMatrix2D inverseJacobian;
    if (isPV) {
      final DoubleMatrix2D jacobianPV = jacobianCalculatorT.evaluate(new DoubleMatrix1D(parametersT));
      final DoubleMatrix2D inverseJacobianPV = MATRIX_ALGEBRA.getInverse(jacobianPV);
      final double[][] inverseJacobianPVArray = inverseJacobianPV.getData();
      final int dim = inverseJacobianPV.getNumberOfColumns();
      final double[] pvmqs = new double[dim];
      // Implementation note: pvmqs: Present Value Sensitivity with respect to Market Quote. 
      //   To be coherent, the pv calculator should provide a pv in the first currency of FX swaps and XCcy swaps.
      int i = 0;
      for (final InstrumentDerivative ird : instrumentsT) {
        pvmqs[i++] = PVBP_CALCULATOR.visit(ird, bundle2);
      }
      double[][] inverseJacobianArray = new double[dim][dim];
      for (int loopi = 0; loopi < dim; loopi++) {
        for (int loopj = 0; loopj < dim; loopj++) {
          inverseJacobianArray[loopi][loopj] = -inverseJacobianPVArray[loopi][loopj] * pvmqs[loopj];
        }
      }
      inverseJacobian = new DoubleMatrix2D(inverseJacobianArray);
    } else {
      final DoubleMatrix2D jacobian = jacobianCalculatorT.evaluate(new DoubleMatrix1D(parametersT));
      inverseJacobian = MATRIX_ALGEBRA.getInverse(jacobian);
    }
    return new ObjectsPair<YieldCurveBundle, DoubleMatrix2D>(bundle2, inverseJacobian);
  };@SuppressWarnings({"unchecked"})
  /**
   * Build the curves and returns a pair containing 
   * 1) the yield curve bundle (4 curves) and 
   * 2) the inverse Jacobian (derivative of the curve parameters with respect to the market quotes) for the full bundle.
   * The curves are build in two blocks: first USD and then EUR. 
   */
  public static Pair<YieldCurveBundle, DoubleMatrix2D> makeCurves2Blocks(final List<InstrumentDefinition<?>> dsc1Definitions, final List<InstrumentDefinition<?>> fwd1Definitions,
      final List<InstrumentDefinition<?>> dsc2Definitions, final List<InstrumentDefinition<?>> fwd2Definitions, final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator,
      final AbstractInstrumentDerivativeVisitor<YieldCurveBundle, InterestRateCurveSensitivity> sensitivityCalculator, final boolean withToday, final boolean isPV) {

    // First block
    final int nbDsc1 = dsc1Definitions.size();
    final int nbFwd1 = fwd1Definitions.size();
    final InstrumentDerivative[] instruments1 = new InstrumentDerivative[nbDsc1 + nbFwd1];
    final double[] dsc1Node = new double[nbDsc1];
    final double[] fwd1Node = new double[nbFwd1];
    final double[] initGuess1 = new double[nbDsc1 + nbFwd1];
    int i1 = 0;
    for (final InstrumentDefinition<?> instrument : dsc1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedONDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_DSC_1};
        ird = ((SwapFixedONDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_OIS_USD_WITH_TODAY : TS_FIXED_OIS_USD_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments1[i1] = ird;
      initGuess1[i1] = initialGuess(instrument);
      dsc1Node[i1++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j1 = 0;
    for (final InstrumentDefinition<?> instrument : fwd1Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_USD3M_WITH_TODAY : TS_FIXED_IBOR_USD3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_1};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments1[i1] = ird;
      initGuess1[i1++] = initialGuess(instrument);
      fwd1Node[j1++] = MATURITY_CALCULATOR.visit(ird);
    }
    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators1 = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators1.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGenerators1.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    final YieldCurveBundle knowData = new YieldCurveBundle(FX_MATRIX, CCY_MAP);
    final MultipleYieldCurveFinderGeneratorDataBundle data1 = new MultipleYieldCurveFinderGeneratorDataBundle(instruments1, knowData, curveGenerators1);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator1 = new MultipleYieldCurveFinderGeneratorFunction(calculator, data1);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator1 = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data1);
    final double[] parameters1 = ROOT_FINDER.getRoot(curveCalculator1, jacobianCalculator1, new DoubleMatrix1D(initGuess1)).getData();
    final YieldCurveBundle newCurves = data1.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters1));
    final YieldCurveBundle bundle1 = knowData.copy();
    bundle1.addAll(newCurves);

    // Second block
    final int nbDsc2 = dsc2Definitions.size();
    final int nbFwd2 = fwd2Definitions.size();
    final InstrumentDerivative[] instruments2 = new InstrumentDerivative[nbDsc2 + nbFwd2];
    final double[] dsc2Node = new double[nbDsc2];
    final double[] fwd2Node = new double[nbFwd2];
    final double[] initGuess2 = new double[nbDsc2 + nbFwd2];
    int i2 = 0;
    for (final InstrumentDefinition<?> instrument : dsc2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapXCcyIborIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2, CURVE_NAME_DSC_1, CURVE_NAME_FWD_1};
        ird = ((SwapXCcyIborIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EURUSD3M_WITH_TODAY : TS_FIXED_IBOR_EURUSD3M_WITHOUT_TODAY, curveNames);
      } else {
        if (instrument instanceof CashDefinition) {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2};
          ird = instrument.toDerivative(NOW, curveNames);
        } else {
          final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_DSC_1};
          ird = instrument.toDerivative(NOW, curveNames);
        }
      }
      instruments2[i2] = ird;
      initGuess2[i2] = initialGuess(instrument);
      dsc2Node[i2++] = MATURITY_CALCULATOR.visit(ird);
    }
    int j2 = 0;
    for (final InstrumentDefinition<?> instrument : fwd2Definitions) {
      InstrumentDerivative ird;
      if (instrument instanceof SwapFixedIborDefinition) {
        final String[] curveNames = new String[] {CURVE_NAME_DSC_2, CURVE_NAME_FWD_2};
        ird = ((SwapFixedIborDefinition) instrument).toDerivative(NOW, withToday ? TS_FIXED_IBOR_EUR3M_WITH_TODAY : TS_FIXED_IBOR_EUR3M_WITHOUT_TODAY, curveNames);
      } else {
        final String[] curveNames = new String[] {CURVE_NAME_FWD_2};
        ird = instrument.toDerivative(NOW, curveNames);
      }
      instruments2[i2] = ird;
      initGuess2[i2++] = initialGuess(instrument);
      fwd2Node[j2++] = MATURITY_CALCULATOR.visit(ird);
    }

    final LinkedHashMap<String, GeneratorYDCurve> curveGenerators2 = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGenerators2.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGenerators2.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final MultipleYieldCurveFinderGeneratorDataBundle data2 = new MultipleYieldCurveFinderGeneratorDataBundle(instruments2, bundle1, curveGenerators2);
    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveCalculator2 = new MultipleYieldCurveFinderGeneratorFunction(calculator, data2);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculator2 = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), data2);
    final double[] parameters2 = ROOT_FINDER.getRoot(curveCalculator2, jacobianCalculator2, new DoubleMatrix1D(initGuess2)).getData();
    final YieldCurveBundle newCurves2 = data2.getBuildingFunction().evaluate(new DoubleMatrix1D(parameters2));
    final YieldCurveBundle bundle2 = bundle1.copy();
    bundle2.addAll(newCurves2);

    final InstrumentDerivative[] instrumentsT = new InstrumentDerivative[nbDsc1 + nbFwd1 + nbDsc2 + nbFwd2];
    System.arraycopy(instruments1, 0, instrumentsT, 0, nbDsc1 + nbFwd1);
    System.arraycopy(instruments2, 0, instrumentsT, nbDsc1 + nbFwd1, nbDsc2 + nbFwd2);
    final LinkedHashMap<String, GeneratorYDCurve> curveGeneratorsT = new LinkedHashMap<String, GeneratorYDCurve>();
    curveGeneratorsT.put(CURVE_NAME_DSC_1, new GeneratorCurveYieldInterpolatedNode(dsc1Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_FWD_1, new GeneratorCurveYieldInterpolatedNode(fwd1Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_DSC_2, new GeneratorCurveYieldInterpolatedNode(dsc2Node, INTERPOLATOR));
    curveGeneratorsT.put(CURVE_NAME_FWD_2, new GeneratorCurveYieldInterpolatedNode(fwd2Node, INTERPOLATOR));
    final MultipleYieldCurveFinderGeneratorDataBundle dataT = new MultipleYieldCurveFinderGeneratorDataBundle(instrumentsT, knowData, curveGeneratorsT);
    final Function1D<DoubleMatrix1D, DoubleMatrix2D> jacobianCalculatorT = new MultipleYieldCurveFinderGeneratorJacobian(new ParameterSensitivityCalculator(sensitivityCalculator), dataT);
    final double[] parametersT = new double[parameters1.length + parameters2.length];
    System.arraycopy(parameters1, 0, parametersT, 0, parameters1.length);
    System.arraycopy(parameters2, 0, parametersT, parameters1.length, parameters2.length);
    final DoubleMatrix2D inverseJacobian;
    if (isPV) {
      final DoubleMatrix2D jacobianPV = jacobianCalculatorT.evaluate(new DoubleMatrix1D(parametersT));
      final DoubleMatrix2D inverseJacobianPV = MATRIX_ALGEBRA.getInverse(jacobianPV);
      final double[][] inverseJacobianPVArray = inverseJacobianPV.getData();
      final int dim = inverseJacobianPV.getNumberOfColumns();
      final double[] pvmqs = new double[dim];
      // Implementation note: pvmqs: Present Value Sensitivity with respect to Market Quote. 
      //   To be coherent, the pv calculator should provide a pv in the first currency of FX swaps and XCcy swaps.
      int i = 0;
      for (final InstrumentDerivative ird : instrumentsT) {
        pvmqs[i++] = PVBP_CALCULATOR.visit(ird, bundle2);
      }
      double[][] inverseJacobianArray = new double[dim][dim];
      for (int loopi = 0; loopi < dim; loopi++) {
        for (int loopj = 0; loopj < dim; loopj++) {
          inverseJacobianArray[loopi][loopj] = -inverseJacobianPVArray[loopi][loopj] * pvmqs[loopj];
        }
      }
      inverseJacobian = new DoubleMatrix2D(inverseJacobianArray);
    } else {
      final DoubleMatrix2D jacobian = jacobianCalculatorT.evaluate(new DoubleMatrix1D(parametersT));
      inverseJacobian = MATRIX_ALGEBRA.getInverse(jacobian);
    }
    return new ObjectsPair<YieldCurveBundle, DoubleMatrix2D>(bundle2, inverseJacobian);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/rootfinding/YieldCurveFittingFromSwapsTest;getSingleCurveSetup();;protected YieldCurveFittingTestDataBundle getSingleCurveSetup() {

    final List<String> curveNames = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    final int[] payments = new int[] { 1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("single curve");
    curveKnots.add(new double[] { 0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] { 0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    // final InterestRateDerivativeVisitor<YieldCurveBundle, Double> calculator
    // = ParRateCalculator.getInstance();
    // final InterestRateDerivativeVisitor<YieldCurveBundle, Map<String,
    // List<DoublesPair>>> sensitivityCalculator =
    // ParRateCurveSensitivityCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    return getSwapOnlySetup(payments, curveNames, null, curveKnots, yields, startPosition, interpolatorName, calculator, sensitivityCalculator);
  };protected YieldCurveFittingTestDataBundle getSingleCurveSetup() {

    final List<String> curveNames = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    final int[] payments = new int[] {1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("single curve");
    curveKnots.add(new double[] {0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] {0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    // final InterestRateDerivativeVisitor<YieldCurveBundle, Double> calculator
    // = ParRateCalculator.getInstance();
    // final InterestRateDerivativeVisitor<YieldCurveBundle, Map<String,
    // List<DoublesPair>>> sensitivityCalculator =
    // ParRateCurveSensitivityCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    return getSwapOnlySetup(payments, curveNames, null, curveKnots, yields, startPosition, interpolatorName, calculator, sensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/rootfinding/YieldCurveFittingFromSwapsTest;getDoubleCurveSetup();;protected YieldCurveFittingTestDataBundle getDoubleCurveSetup() {

    final List<String> curveNames = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    final int[] payments = new int[] { 1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    curveKnots.add(new double[] { 1, 2, 5, 10, 20, 31 });
    curveKnots.add(new double[] { 0.5, 1, 2, 5, 10, 20, 31 });
    yields.add(new double[] { 0.021, 0.036, 0.06, 0.054, 0.049, 0.044 });
    yields.add(new double[] { 0.01, 0.02, 0.035, 0.06, 0.055, 0.05, 0.045 });

    final double[] rates = new double[payments.length];
    int count = 0;
    for (final double[] trueYields : yields) {
      for (final double temp : trueYields) {
        rates[count++] = temp + 0.02;
      }
    }

    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = ParRateCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = ParRateCurveSensitivityCalculator.getInstance();
    return getSwapOnlySetup(payments, curveNames, null, curveKnots, yields, startPosition, interpolatorName, calculator, sensitivityCalculator);
  };protected YieldCurveFittingTestDataBundle getDoubleCurveSetup() {

    final List<String> curveNames = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    final int[] payments = new int[] {1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    curveKnots.add(new double[] {1, 2, 5, 10, 20, 31 });
    curveKnots.add(new double[] {0.5, 1, 2, 5, 10, 20, 31 });
    yields.add(new double[] {0.021, 0.036, 0.06, 0.054, 0.049, 0.044 });
    yields.add(new double[] {0.01, 0.02, 0.035, 0.06, 0.055, 0.05, 0.045 });

    final double[] rates = new double[payments.length];
    int count = 0;
    for (final double[] trueYields : yields) {
      for (final double temp : trueYields) {
        rates[count++] = temp + 0.02;
      }
    }

    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = ParRateCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = ParRateCurveSensitivityCalculator.getInstance();
    return getSwapOnlySetup(payments, curveNames, null, curveKnots, yields, startPosition, interpolatorName, calculator, sensitivityCalculator);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/rootfinding/YieldCurveFittingFromSwapsTest;testForwardCurveOnly();;@Test
  public void testForwardCurveOnly() {

    final List<String> curveNames = new ArrayList<String>();
    final List<String> knownCurves = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.DOUBLE_QUADRATIC;
    final int[] payments = new int[] { 1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    knownCurves.add("funding");
    curveKnots.add(new double[] { 1, 5, 10, 20, 30 });
    curveKnots.add(new double[] { 0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] { 0.02, 0.04, 0.05, 0.05, 0.05 });
    yields.add(new double[] { 0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }

    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    final YieldCurveFittingTestDataBundle data = getSwapOnlySetup(payments, curveNames, knownCurves, curveKnots, yields, startPosition, interpolatorName, calculator,
        sensitivityCalculator);

    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, data, "Fit Forward curve only. Rootfinder: Broyden");
  };@Test
  public void testForwardCurveOnly() {

    final List<String> curveNames = new ArrayList<String>();
    final List<String> knownCurves = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.DOUBLE_QUADRATIC;
    final int[] payments = new int[] {1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    knownCurves.add("funding");
    curveKnots.add(new double[] {1, 5, 10, 20, 30 });
    curveKnots.add(new double[] {0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] {0.02, 0.04, 0.05, 0.05, 0.05 });
    yields.add(new double[] {0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }

    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    final YieldCurveFittingTestDataBundle data = getSwapOnlySetup(payments, curveNames, knownCurves, curveKnots, yields, startPosition, interpolatorName, calculator,
        sensitivityCalculator);

    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, data, "Fit Forward curve only. Rootfinder: Broyden");
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/rootfinding/YieldCurveFittingFromSwapsTest;testFundingCurveOnly();;@Test
  public void testFundingCurveOnly() {

    final List<String> curveNames = new ArrayList<String>();
    final List<String> knownCurves = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.DOUBLE_QUADRATIC;
    final int[] payments = new int[] { 1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    knownCurves.add("Libor");
    curveKnots.add(new double[] { 0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    curveKnots.add(new double[] { 0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] { 0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });
    yields.add(new double[] { 0.015, 0.0155, 0.025, 0.032, 0.042, 0.052, 0.0521, 0.0491, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    final YieldCurveFittingTestDataBundle data = getSwapOnlySetup(payments, curveNames, knownCurves, curveKnots, yields, startPosition, interpolatorName, calculator,
        sensitivityCalculator);

    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, data, "Fit Funding curve only. Rootfinder: Broyden");
  };@Test
  public void testFundingCurveOnly() {

    final List<String> curveNames = new ArrayList<String>();
    final List<String> knownCurves = new ArrayList<String>();
    final List<double[]> curveKnots = new ArrayList<double[]>();
    final List<double[]> yields = new ArrayList<double[]>();

    final String interpolatorName = Interpolator1DFactory.DOUBLE_QUADRATIC;
    final int[] payments = new int[] {1, 2, 3, 4, 6, 8, 10, 14, 20, 30, 40, 50, 60 };
    curveNames.add("funding");
    curveNames.add("Libor");
    knownCurves.add("Libor");
    curveKnots.add(new double[] {0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    curveKnots.add(new double[] {0.5, 1.00, 1.5, 2.005555556, 3.002777778, 4, 5, 7.008333333, 10, 15, 20.00277778, 25.00555556, 30.00555556 });
    yields.add(new double[] {0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.052, 0.049, 0.045, 0.044, 0.043, 0.041, 0.04 });
    yields.add(new double[] {0.015, 0.0155, 0.025, 0.032, 0.042, 0.052, 0.0521, 0.0491, 0.045, 0.044, 0.043, 0.041, 0.04 });

    final int n = payments.length;
    final double[] rates = new double[n];
    for (int i = 0; i < n; i++) {
      rates[i] = 0.05;
    }
    final DoubleMatrix1D startPosition = new DoubleMatrix1D(rates);

    final InstrumentDerivativeVisitor<YieldCurveBundle, Double> calculator = PresentValueCalculator.getInstance();
    final InstrumentDerivativeVisitor<YieldCurveBundle, Map<String, List<DoublesPair>>> sensitivityCalculator = PresentValueCurveSensitivityCalculator.getInstance();

    final YieldCurveFittingTestDataBundle data = getSwapOnlySetup(payments, curveNames, knownCurves, curveKnots, yields, startPosition, interpolatorName, calculator,
        sensitivityCalculator);

    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, data, "Fit Funding curve only. Rootfinder: Broyden");
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea573_5f3c0/rev_ea573-5f3c0;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/rootfinding/YieldCurveFittingSetup;makeSinglePaymentOISSwap(double,String,String,double,double);;protected static SwapFixedCoupon<CouponOIS> makeSinglePaymentOISSwap(final double time, final String fundingCurveName, final String indexCurveName, final double rate, final double notional) {

    final CouponOIS oisCoupon = new CouponOIS(DUMMY_CUR, time, fundingCurveName, time, notional, DUMMY_OIS_INDEX, 0, time, time, notional, indexCurveName);

    final CouponFixed fixedCoupon = new CouponFixed(DUMMY_CUR, time, fundingCurveName, time, -notional, rate);

    final AnnuityCouponFixed fixedLeg = new AnnuityCouponFixed(new CouponFixed[] {fixedCoupon});
    return new SwapFixedCoupon<CouponOIS>(fixedLeg, new Annuity<CouponOIS>(new CouponOIS[] {oisCoupon}));
  };protected static SwapFixedCoupon<CouponOIS> makeSinglePaymentOISSwap(final double time, final String fundingCurveName, final String indexCurveName, final double rate, final double notional) {

    final CouponOIS oisCoupon = new CouponOIS(DUMMY_CUR, time, fundingCurveName, time, notional, DUMMY_OIS_INDEX, 0, time, time, notional, indexCurveName);

    final CouponFixed fixedCoupon = new CouponFixed(DUMMY_CUR, time, fundingCurveName, time, -notional, rate);

    final AnnuityCouponFixed fixedLeg = new AnnuityCouponFixed(new CouponFixed[] {fixedCoupon });
    return new SwapFixedCoupon<CouponOIS>(fixedLeg, new Annuity<CouponOIS>(new CouponOIS[] {oisCoupon }));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/forex/option/black/FXOptionBlackFunction;buildMarketBundle(ZonedDateTime,FunctionInputs,ComputationTarget,Set<ValueRequirement>);;protected ForexOptionDataBundle<?> buildMarketBundle(ZonedDateTime now, final FunctionInputs inputs, final ComputationTarget target, final Set<ValueRequirement> desiredValues) {

    final FinancialSecurity security = (FinancialSecurity) target.getSecurity();
    final Currency putCurrency = security.accept(ForexVisitors.getPutCurrencyVisitor());
    final Currency callCurrency = security.accept(ForexVisitors.getCallCurrencyVisitor());
    if (now.isAfter(security.accept(ForexVisitors.getExpiryVisitor()))) {
      throw new OpenGammaRuntimeException("FX option " + putCurrency.getCode() + "/" + callCurrency + " has expired");
    }
    final ValueRequirement desiredValue = desiredValues.iterator().next();
    final String putCurveName = desiredValue.getConstraint(PUT_CURVE);
    final String callCurveName = desiredValue.getConstraint(CALL_CURVE);
    final String surfaceName = desiredValue.getConstraint(ValuePropertyNames.SURFACE);
    final String putCurveConfig = desiredValue.getConstraint(PUT_CURVE_CALC_CONFIG);
    final String callCurveConfig = desiredValue.getConstraint(CALL_CURVE_CALC_CONFIG);
    final String interpolatorName = desiredValue.getConstraint(InterpolatedDataProperties.X_INTERPOLATOR_NAME);
    final String leftExtrapolatorName = desiredValue.getConstraint(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME);
    final String rightExtrapolatorName = desiredValue.getConstraint(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME);
    final Object baseQuotePairsObject = inputs.getValue(ValueRequirementNames.CURRENCY_PAIRS);
    if (baseQuotePairsObject == null) {
      throw new OpenGammaRuntimeException("Could not get base/quote pair data");
    }
    final CurrencyPairs baseQuotePairs = (CurrencyPairs) baseQuotePairsObject;
    final String fullPutCurveName = putCurveName + "_" + putCurrency.getCode();
    final String fullCallCurveName = callCurveName + "_" + callCurrency.getCode();
    final YieldAndDiscountCurve putFundingCurve = getCurve(inputs, putCurrency, putCurveName, putCurveConfig);
    final YieldAndDiscountCurve callFundingCurve = getCurve(inputs, callCurrency, callCurveName, callCurveConfig);
    final YieldAndDiscountCurve[] curves;
    final Map<String, Currency> curveCurrency = new HashMap<String, Currency>();
    curveCurrency.put(fullPutCurveName, putCurrency);
    curveCurrency.put(fullCallCurveName, callCurrency);
    final String[] allCurveNames;
    final Currency ccy1;
    final Currency ccy2;
    final Object spotObject = inputs.getValue(ValueRequirementNames.SPOT_RATE);
    if (spotObject == null) {
      throw new OpenGammaRuntimeException("Could not get spot requirement");
    }
    final double spot = (Double) spotObject;
    final CurrencyPair baseQuotePair = baseQuotePairs.getCurrencyPair(putCurrency, callCurrency);
    if (baseQuotePair == null) {
      throw new OpenGammaRuntimeException("Could not get base/quote pair for currency pair (" + putCurrency + ", " + callCurrency + ")");
    }
    if (baseQuotePair.getBase().equals(putCurrency)) { // To get Base/quote in market standard order.
      ccy1 = putCurrency;
      ccy2 = callCurrency;
      curves = new YieldAndDiscountCurve[] {putFundingCurve, callFundingCurve};
      allCurveNames = new String[] {fullPutCurveName, fullCallCurveName};
    } else {
      curves = new YieldAndDiscountCurve[] {callFundingCurve, putFundingCurve};
      allCurveNames = new String[] {fullCallCurveName, fullPutCurveName};
      ccy1 = callCurrency;
      ccy2 = putCurrency;
    }
    final YieldCurveBundle yieldCurves = new YieldCurveBundle(allCurveNames, curves);
    final ValueRequirement fxVolatilitySurfaceRequirement = getSurfaceRequirement(surfaceName, putCurrency, callCurrency, interpolatorName, leftExtrapolatorName, rightExtrapolatorName);
    final Object volatilitySurfaceObject = inputs.getValue(fxVolatilitySurfaceRequirement);
    if (volatilitySurfaceObject == null) {
      throw new OpenGammaRuntimeException("Could not get " + fxVolatilitySurfaceRequirement);
    }
    final FXMatrix fxMatrix = new FXMatrix(ccy1, ccy2, spot);
    final YieldCurveBundle curvesWithFX = new YieldCurveBundle(fxMatrix, curveCurrency, yieldCurves.getCurvesMap());
    final ObjectsPair<Currency, Currency> currencyPair = Pair.of(ccy1, ccy2);
    if (volatilitySurfaceObject instanceof SmileDeltaTermStructureParametersStrikeInterpolation) {
      final SmileDeltaTermStructureParametersStrikeInterpolation smiles = (SmileDeltaTermStructureParametersStrikeInterpolation) volatilitySurfaceObject;
      final SmileDeltaTermStructureDataBundle smileBundle = new SmileDeltaTermStructureDataBundle(curvesWithFX, smiles, currencyPair);
      return smileBundle;
    }
    final BlackForexTermStructureParameters termStructure = (BlackForexTermStructureParameters) volatilitySurfaceObject;
    final YieldCurveWithBlackForexTermStructureBundle flatData = new YieldCurveWithBlackForexTermStructureBundle(curvesWithFX, termStructure, currencyPair);
    return flatData;
  };protected ForexOptionDataBundle<?> buildMarketBundle(ZonedDateTime now, final FunctionInputs inputs, final ComputationTarget target, final Set<ValueRequirement> desiredValues) {

    final FinancialSecurity security = (FinancialSecurity) target.getSecurity();
    final Currency putCurrency = security.accept(ForexVisitors.getPutCurrencyVisitor());
    final Currency callCurrency = security.accept(ForexVisitors.getCallCurrencyVisitor());
    if (now.isAfter(security.accept(ForexVisitors.getExpiryVisitor()))) {
      throw new OpenGammaRuntimeException("FX option " + putCurrency.getCode() + "/" + callCurrency + " has expired");
    }
    final ValueRequirement desiredValue = desiredValues.iterator().next();
    final String putCurveName = desiredValue.getConstraint(PUT_CURVE);
    final String callCurveName = desiredValue.getConstraint(CALL_CURVE);
    final String surfaceName = desiredValue.getConstraint(ValuePropertyNames.SURFACE);
    final String putCurveConfig = desiredValue.getConstraint(PUT_CURVE_CALC_CONFIG);
    final String callCurveConfig = desiredValue.getConstraint(CALL_CURVE_CALC_CONFIG);
    final String interpolatorName = desiredValue.getConstraint(InterpolatedDataProperties.X_INTERPOLATOR_NAME);
    final String leftExtrapolatorName = desiredValue.getConstraint(InterpolatedDataProperties.LEFT_X_EXTRAPOLATOR_NAME);
    final String rightExtrapolatorName = desiredValue.getConstraint(InterpolatedDataProperties.RIGHT_X_EXTRAPOLATOR_NAME);
    final Object baseQuotePairsObject = inputs.getValue(ValueRequirementNames.CURRENCY_PAIRS);
    if (baseQuotePairsObject == null) {
      throw new OpenGammaRuntimeException("Could not get base/quote pair data");
    }
    final CurrencyPairs baseQuotePairs = (CurrencyPairs) baseQuotePairsObject;
    final String fullPutCurveName = putCurveName + "_" + putCurrency.getCode();
    final String fullCallCurveName = callCurveName + "_" + callCurrency.getCode();
    final YieldAndDiscountCurve putFundingCurve = getCurve(inputs, putCurrency, putCurveName, putCurveConfig);
    final YieldAndDiscountCurve callFundingCurve = getCurve(inputs, callCurrency, callCurveName, callCurveConfig);
    final YieldAndDiscountCurve[] curves;
    final Map<String, Currency> curveCurrency = new HashMap<String, Currency>();
    curveCurrency.put(fullPutCurveName, putCurrency);
    curveCurrency.put(fullCallCurveName, callCurrency);
    final String[] allCurveNames;
    final Currency ccy1;
    final Currency ccy2;
    final Object spotObject = inputs.getValue(ValueRequirementNames.SPOT_RATE);
    if (spotObject == null) {
      throw new OpenGammaRuntimeException("Could not get spot requirement");
    }
    final double spot = (Double) spotObject;
    final CurrencyPair baseQuotePair = baseQuotePairs.getCurrencyPair(putCurrency, callCurrency);
    if (baseQuotePair == null) {
      throw new OpenGammaRuntimeException("Could not get base/quote pair for currency pair (" + putCurrency + ", " + callCurrency + ")");
    }
    if (baseQuotePair.getBase().equals(putCurrency)) { // To get Base/quote in market standard order.
      ccy1 = putCurrency;
      ccy2 = callCurrency;
      curves = new YieldAndDiscountCurve[] {putFundingCurve, callFundingCurve };
      allCurveNames = new String[] {fullPutCurveName, fullCallCurveName };
    } else {
      curves = new YieldAndDiscountCurve[] {callFundingCurve, putFundingCurve };
      allCurveNames = new String[] {fullCallCurveName, fullPutCurveName };
      ccy1 = callCurrency;
      ccy2 = putCurrency;
    }
    final YieldCurveBundle yieldCurves = new YieldCurveBundle(allCurveNames, curves);
    final ValueRequirement fxVolatilitySurfaceRequirement = getSurfaceRequirement(surfaceName, putCurrency, callCurrency, interpolatorName, leftExtrapolatorName, rightExtrapolatorName);
    final Object volatilitySurfaceObject = inputs.getValue(fxVolatilitySurfaceRequirement);
    if (volatilitySurfaceObject == null) {
      throw new OpenGammaRuntimeException("Could not get " + fxVolatilitySurfaceRequirement);
    }
    final FXMatrix fxMatrix = new FXMatrix(ccy1, ccy2, spot);
    final YieldCurveBundle curvesWithFX = new YieldCurveBundle(fxMatrix, curveCurrency, yieldCurves.getCurvesMap());
    final ObjectsPair<Currency, Currency> currencyPair = Pair.of(ccy1, ccy2);
    if (volatilitySurfaceObject instanceof SmileDeltaTermStructureParametersStrikeInterpolation) {
      final SmileDeltaTermStructureParametersStrikeInterpolation smiles = (SmileDeltaTermStructureParametersStrikeInterpolation) volatilitySurfaceObject;
      final SmileDeltaTermStructureDataBundle smileBundle = new SmileDeltaTermStructureDataBundle(curvesWithFX, smiles, currencyPair);
      return smileBundle;
    }
    final BlackForexTermStructureParameters termStructure = (BlackForexTermStructureParameters) volatilitySurfaceObject;
    final YieldCurveWithBlackForexTermStructureBundle flatData = new YieldCurveWithBlackForexTermStructureBundle(curvesWithFX, termStructure, currencyPair);
    return flatData;
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ec428_07d48/rev_ec428-07d48;/projects/OG-Web/src/main/java/com/opengamma/web/spring/DemoStandardFunctionConfiguration;addLocalVolatilityDefaultProperties(List<FunctionConfiguration>);;private static void addLocalVolatilityDefaultProperties(final List<FunctionConfiguration> functionConfigs) {
    // Interpolator properties. There are three types: SABR, MIXED_LOGNORMAL, SPLINE.
    final List<String> commonBlackSurfaceInterpolatorProperties = Arrays.asList(
        BlackVolatilitySurfacePropertyNamesAndValues.LOG_TIME,
        BlackVolatilitySurfacePropertyNamesAndValues.LOG_Y, 
        BlackVolatilitySurfacePropertyNamesAndValues.INTEGRATED_VARIANCE, 
        Interpolator1DFactory.DOUBLE_QUADRATIC,
        Interpolator1DFactory.LINEAR_EXTRAPOLATOR, 
        Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    final List<String> mixedLogNormalProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    mixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> sabrProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    sabrProperties.add(VolatilityFunctionFactory.HAGAN);
    sabrProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    sabrProperties.add("false");
    sabrProperties.add("0.5");
    final List<String> splineProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    splineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    splineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    splineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // Equity default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    splineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalInterpolatorDefaults.class.getName(), mixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSABRInterpolatorDefaults.class.getName(), sabrProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorDefaults.class.getName(), splineProperties));

    // commonForexBLACKSurfaceProperties
    final List<String> commonForexBlackSurfaceProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    commonForexBlackSurfaceProperties.add("FUNDING-FUNDING");
    commonForexBlackSurfaceProperties.add(ForwardCurveValuePropertyNames.PROPERTY_YIELD_CURVE_IMPLIED_METHOD);
    commonForexBlackSurfaceProperties.add("DEFAULT");
    final List<String> forexBlackSurfaceMixedLogNormalProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    forexBlackSurfaceMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    // forexBlackSurface[Interpr]Properties  ( depend on commonForexBlackSurfaceProperties)
    final List<String> forexBlackSurfaceSABRProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    forexBlackSurfaceSABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexBlackSurfaceSABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexBlackSurfaceSABRProperties.add("false");
    forexBlackSurfaceSABRProperties.add("0.5");
    // BlackSurface with Spline Interpolation and  ShiftedLogNormalTailExtrapolation
    final List<String> blackSurfaceSplineProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // Spline default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    blackSurfaceSplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    // commonForexLOCALSurfaceProperties
    final List<String> commonForexLocalSurfaceProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    commonForexLocalSurfaceProperties.add("1e-3"); // "SurfaceDerivativeEPS" shift used for FD derivative approximations
    final List<String> forexLocalSurfaceMixedLogNormalProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexLocalSurfaceSABRProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceSABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexLocalSurfaceSABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexLocalSurfaceSABRProperties.add("false");
    forexLocalSurfaceSABRProperties.add("0.5");
    final List<String> forexLocalSurfaceSplineProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // FX default is:  Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexLocalSurfaceSplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    final List<String> commonForexBackwardPDEProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    commonForexBackwardPDEProperties.add("0.5");
    commonForexBackwardPDEProperties.add("100");
    commonForexBackwardPDEProperties.add("100");
    commonForexBackwardPDEProperties.add("5.0");
    commonForexBackwardPDEProperties.add("0.05");
    commonForexBackwardPDEProperties.add("3.5");
    commonForexBackwardPDEProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    commonForexBackwardPDEProperties.add("FUNDING");
    final List<String> forexBackwardPDEMixedLogNormalProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDEMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexBackwardPDESABRProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDESABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexBackwardPDESABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexBackwardPDESABRProperties.add("false");
    forexBackwardPDESABRProperties.add("0.5");
    final List<String> forexBackwardPDESplineProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // backwardPDE default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexBackwardPDESplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);
    final List<String> commonForexForwardPDEProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    commonForexForwardPDEProperties.add("0.5");
    commonForexForwardPDEProperties.add("100");
    commonForexForwardPDEProperties.add("100");
    commonForexForwardPDEProperties.add("5.0");
    commonForexForwardPDEProperties.add("0.05");
    commonForexForwardPDEProperties.add("1.5");
    commonForexForwardPDEProperties.add("1.0");
    commonForexForwardPDEProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    commonForexForwardPDEProperties.add("FUNDING");
    final List<String> forexForwardPDEMixedLogNormalProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDEMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexForwardPDESABRProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDESABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexForwardPDESABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexForwardPDESABRProperties.add("false");
    forexForwardPDESABRProperties.add("0.5");
    final List<String> forexForwardPDESplineProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // forwardPDE default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexForwardPDESplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalDefaults.class.getName(), forexBlackSurfaceMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSABRDefaults.class.getName(), forexBlackSurfaceSABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSplineDefaults.class.getName(), blackSurfaceSplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceMixedLogNormalDefaults.class.getName(), forexLocalSurfaceMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceSABRDefaults.class.getName(), forexLocalSurfaceSABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceSplineDefaults.class.getName(), forexLocalSurfaceSplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDEMixedLogNormalDefaults.class.getName(), forexBackwardPDEMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDESABRDefaults.class.getName(), forexBackwardPDESABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDESplineDefaults.class.getName(), forexBackwardPDESplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDEMixedLogNormalDefaults.class.getName(), forexForwardPDEMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDESABRDefaults.class.getName(), forexForwardPDESABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDESplineDefaults.class.getName(), forexForwardPDESplineProperties));
  };private static void addLocalVolatilityDefaultProperties(final List<FunctionConfiguration> functionConfigs) {
    // Interpolator properties. There are three types: SABR, MIXED_LOGNORMAL, SPLINE.
    final List<String> commonBlackSurfaceInterpolatorProperties = Arrays.asList(
        BlackVolatilitySurfacePropertyNamesAndValues.LOG_TIME,
        BlackVolatilitySurfacePropertyNamesAndValues.LOG_Y,
        BlackVolatilitySurfacePropertyNamesAndValues.INTEGRATED_VARIANCE,
        Interpolator1DFactory.DOUBLE_QUADRATIC,
        Interpolator1DFactory.LINEAR_EXTRAPOLATOR,
        Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    final List<String> mixedLogNormalProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    mixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> sabrProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    sabrProperties.add(VolatilityFunctionFactory.HAGAN);
    sabrProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    sabrProperties.add("false");
    sabrProperties.add("0.5");
    final List<String> splineProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    splineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    splineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    splineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // Equity default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    splineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalInterpolatorDefaults.class.getName(), mixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSABRInterpolatorDefaults.class.getName(), sabrProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSplineInterpolatorDefaults.class.getName(), splineProperties));

    // commonForexBLACKSurfaceProperties
    final List<String> commonForexBlackSurfaceProperties = new ArrayList<String>(commonBlackSurfaceInterpolatorProperties);
    commonForexBlackSurfaceProperties.add("FUNDING-FUNDING");
    commonForexBlackSurfaceProperties.add(ForwardCurveValuePropertyNames.PROPERTY_YIELD_CURVE_IMPLIED_METHOD);
    commonForexBlackSurfaceProperties.add("DEFAULT");
    final List<String> forexBlackSurfaceMixedLogNormalProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    forexBlackSurfaceMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    // forexBlackSurface[Interpr]Properties  ( depend on commonForexBlackSurfaceProperties)
    final List<String> forexBlackSurfaceSABRProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    forexBlackSurfaceSABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexBlackSurfaceSABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexBlackSurfaceSABRProperties.add("false");
    forexBlackSurfaceSABRProperties.add("0.5");
    // BlackSurface with Spline Interpolation and  ShiftedLogNormalTailExtrapolation
    final List<String> blackSurfaceSplineProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    blackSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // Spline default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    blackSurfaceSplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    // commonForexLOCALSurfaceProperties
    final List<String> commonForexLocalSurfaceProperties = new ArrayList<String>(commonForexBlackSurfaceProperties);
    commonForexLocalSurfaceProperties.add("1e-3"); // "SurfaceDerivativeEPS" shift used for FD derivative approximations
    final List<String> forexLocalSurfaceMixedLogNormalProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexLocalSurfaceSABRProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceSABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexLocalSurfaceSABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexLocalSurfaceSABRProperties.add("false");
    forexLocalSurfaceSABRProperties.add("0.5");
    final List<String> forexLocalSurfaceSplineProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexLocalSurfaceSplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // FX default is:  Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexLocalSurfaceSplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    final List<String> commonForexBackwardPDEProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    commonForexBackwardPDEProperties.add("0.5");
    commonForexBackwardPDEProperties.add("100");
    commonForexBackwardPDEProperties.add("100");
    commonForexBackwardPDEProperties.add("5.0");
    commonForexBackwardPDEProperties.add("0.05");
    commonForexBackwardPDEProperties.add("3.5");
    commonForexBackwardPDEProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    commonForexBackwardPDEProperties.add("FUNDING");
    final List<String> forexBackwardPDEMixedLogNormalProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDEMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexBackwardPDESABRProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDESABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexBackwardPDESABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexBackwardPDESABRProperties.add("false");
    forexBackwardPDESABRProperties.add("0.5");
    final List<String> forexBackwardPDESplineProperties = new ArrayList<String>(commonForexBackwardPDEProperties);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexBackwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // backwardPDE default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexBackwardPDESplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);
    final List<String> commonForexForwardPDEProperties = new ArrayList<String>(commonForexLocalSurfaceProperties);
    commonForexForwardPDEProperties.add("0.5");
    commonForexForwardPDEProperties.add("100");
    commonForexForwardPDEProperties.add("100");
    commonForexForwardPDEProperties.add("5.0");
    commonForexForwardPDEProperties.add("0.05");
    commonForexForwardPDEProperties.add("1.5");
    commonForexForwardPDEProperties.add("1.0");
    commonForexForwardPDEProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    commonForexForwardPDEProperties.add("FUNDING");
    final List<String> forexForwardPDEMixedLogNormalProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDEMixedLogNormalProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    final List<String> forexForwardPDESABRProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDESABRProperties.add(VolatilityFunctionFactory.HAGAN);
    forexForwardPDESABRProperties.add(WeightingFunctionFactory.SINE_WEIGHTING_FUNCTION_NAME);
    forexForwardPDESABRProperties.add("false");
    forexForwardPDESABRProperties.add("0.5");
    final List<String> forexForwardPDESplineProperties = new ArrayList<String>(commonForexForwardPDEProperties);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.DOUBLE_QUADRATIC);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    forexForwardPDESplineProperties.add(Interpolator1DFactory.LINEAR_EXTRAPOLATOR);
    // forwardPDE default is: Quiet - if ShiftedLogNormalTailExtrapolationFitter fails on boundary, try on next strike in interior of domain
    forexForwardPDESplineProperties.add(BlackVolatilitySurfacePropertyNamesAndValues.QUIET_SPLINE_EXTRAPOLATOR_FAILURE);

    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceMixedLogNormalDefaults.class.getName(), forexBlackSurfaceMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSABRDefaults.class.getName(), forexBlackSurfaceSABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BlackVolatilitySurfaceSplineDefaults.class.getName(), blackSurfaceSplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceMixedLogNormalDefaults.class.getName(), forexLocalSurfaceMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceSABRDefaults.class.getName(), forexLocalSurfaceSABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(LocalVolatilitySurfaceSplineDefaults.class.getName(), forexLocalSurfaceSplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDEMixedLogNormalDefaults.class.getName(), forexBackwardPDEMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDESABRDefaults.class.getName(), forexBackwardPDESABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(BackwardPDESplineDefaults.class.getName(), forexBackwardPDESplineProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDEMixedLogNormalDefaults.class.getName(), forexForwardPDEMixedLogNormalProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDESABRDefaults.class.getName(), forexForwardPDESABRProperties));
    functionConfigs.add(new ParameterizedFunctionConfiguration(ForwardPDESplineDefaults.class.getName(), forexForwardPDESplineProperties));
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac;/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat;encodeFilter(VoldemortFilter);;private VAdminProto.VoldemortFilter encodeFilter(VoldemortFilter filter) throws IOException {
        Class<?> cl = filter.getClass();
        byte[] classBytes = networkClassLoader.dumpClass(cl);
        return VAdminProto.VoldemortFilter.newBuilder()
                                          .setName(cl.getName())
                                          .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                                          .build();
    };private VAdminProto.VoldemortFilter encodeFilter(VoldemortFilter filter) throws IOException {

        Class<?> cl = filter.getClass();
        byte[] classBytes = networkClassLoader.dumpClass(cl);
        return VAdminProto.VoldemortFilter.newBuilder()
                                          .setName(cl.getName())
                                          .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                                          .build();
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver;createMachineDetailsForTemplate(CloudTemplate);;protected MachineDetails createMachineDetailsForTemplate(final CloudTemplate template) {

		final MachineDetails md = new MachineDetails();
		md.setAgentRunning(false);
		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);

		md.setRemoteUsername(template.getUsername());
		md.setRemotePassword(template.getPassword());

		md.setRemoteExecutionMode(template.getRemoteExecution());
		md.setFileTransferMode(template.getFileTransfer());
		md.setScriptLangeuage(template.getScriptLanguage());
		return md;

	};protected MachineDetails createMachineDetailsForTemplate(final CloudTemplate template) {

		final MachineDetails md = new MachineDetails();
		md.setAgentRunning(false);
		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);

		md.setRemoteUsername(template.getUsername());
		md.setRemotePassword(template.getPassword());

		md.setRemoteExecutionMode(template.getRemoteExecution());
		md.setFileTransferMode(template.getFileTransfer());
		md.setScriptLangeuage(template.getScriptLanguage());
		return md;

	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver;createServer(String,long,CloudTemplate);;protected abstract MachineDetails createServer(String serverName, long endTime,
			CloudTemplate template) throws CloudProvisioningException, TimeoutException;;protected abstract MachineDetails createServer(String serverName, long endTime,
			CloudTemplate template) throws CloudProvisioningException, TimeoutException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver;handleEC2WindowsCredentials(long,NodeMetadata,MachineDetails,CloudTemplate);;private void handleEC2WindowsCredentials(final long end,
			final NodeMetadata node, final MachineDetails machineDetails,
			final CloudTemplate cloudTemplate) throws FileNotFoundException,
			InterruptedException, TimeoutException, CloudProvisioningException {
		File pemFile = null;

		if (this.management) {
			final File localDirectory = new File(cloudTemplate.getAbsoluteUploadDir());

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		} else {
			final String localDirectoryName = cloudTemplate.getLocalDirectory();
			logger.fine("local dir name is: " + localDirectoryName);
			final File localDirectory = new File(localDirectoryName);

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		}

		if (!pemFile.exists()) {
			logger.severe("Could not find pem file: " + pemFile);
			throw new FileNotFoundException("Could not find key file: "
					+ pemFile);
		}

		String password;
		if (cloudTemplate.getPassword() == null) {
			// get the password using Amazon API
			this.publishEvent("waiting_for_ec2_windows_password", node.getId());

			final LoginCredentials credentials = new EC2WindowsPasswordHandler()
					.getPassword(node, this.deployer.getContext(), end, pemFile);
			password = credentials.getPassword();

			this.publishEvent("ec2_windows_password_retrieved", node.getId());

		} else {
			password = cloudTemplate.getPassword();
		}

		String username = cloudTemplate.getUsername();

		if (username == null) {
			username = DEFAULT_EC2_WINDOWS_USERNAME;
		}
		machineDetails.setRemoteUsername(username);
		machineDetails.setRemotePassword(password);
		machineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());
		machineDetails.setRemoteExecutionMode(cloudTemplate
				.getRemoteExecution());
	};private void handleEC2WindowsCredentials(final long end,
			final NodeMetadata node, final MachineDetails machineDetails,
			final CloudTemplate cloudTemplate) throws FileNotFoundException,
			InterruptedException, TimeoutException, CloudProvisioningException {
		File pemFile = null;

		if (this.management) {
			final File localDirectory = new File(cloudTemplate.getAbsoluteUploadDir());

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		} else {
			final String localDirectoryName = cloudTemplate.getLocalDirectory();
			logger.fine("local dir name is: " + localDirectoryName);
			final File localDirectory = new File(localDirectoryName);

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		}

		if (!pemFile.exists()) {
			logger.severe("Could not find pem file: " + pemFile);
			throw new FileNotFoundException("Could not find key file: "
					+ pemFile);
		}

		String password;
		if (cloudTemplate.getPassword() == null) {
			// get the password using Amazon API
			this.publishEvent("waiting_for_ec2_windows_password", node.getId());

			final LoginCredentials credentials = new EC2WindowsPasswordHandler()
					.getPassword(node, this.deployer.getContext(), end, pemFile);
			password = credentials.getPassword();

			this.publishEvent("ec2_windows_password_retrieved", node.getId());

		} else {
			password = cloudTemplate.getPassword();
		}

		String username = cloudTemplate.getUsername();

		if (username == null) {
			username = DEFAULT_EC2_WINDOWS_USERNAME;
		}
		machineDetails.setRemoteUsername(username);
		machineDetails.setRemotePassword(password);
		machineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());
		machineDetails.setRemoteExecutionMode(cloudTemplate
				.getRemoteExecution());
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver;createMachineUsername(NodeMetadata,CloudTemplate);;private String createMachineUsername(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getUsername() != null) {
			return template.getUsername();
		}

		// Check if node returned a username
		if (node.getCredentials() != null) {
			final String serverIdentity = node.getCredentials().identity;
			if (serverIdentity != null) {
				return serverIdentity;
			}
		}

		return null;
	};private String createMachineUsername(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getUsername() != null) {
			return template.getUsername();
		}

		// Check if node returned a username
		if (node.getCredentials() != null) {
			final String serverIdentity = node.getCredentials().identity;
			if (serverIdentity != null) {
				return serverIdentity;
			}
		}

		return null;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver;createMachinePassword(NodeMetadata,CloudTemplate);;private String createMachinePassword(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getPassword() != null) {
			return template.getPassword();
		}

		// Check if node returned a username - some clouds support this
		// (Rackspace, for instance)
		if (node.getCredentials() != null
				&& node.getCredentials().getOptionalPassword() != null) {
			if (node.getCredentials().getOptionalPassword().isPresent()) {
				return node.getCredentials().getPassword();
			}
		}

		return null;
	};private String createMachinePassword(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getPassword() != null) {
			return template.getPassword();
		}

		// Check if node returned a username - some clouds support this
		// (Rackspace, for instance)
		if (node.getCredentials() != null
				&& node.getCredentials().getOptionalPassword() != null) {
			if (node.getCredentials().getOptionalPassword().isPresent()) {
				return node.getCredentials().getPassword();
			}
		}

		return null;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/RSCloudDriver;newServer(String,long,CloudTemplate);;private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final MachineDetails md = createServer(
				token, serverTemplate);

		try {
			// wait until complete
			waitForServerToReachStatus(
					md, endTime, md.getMachineId(), token, "ACTIVE");

			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			return md;
		} catch (final Exception e) {
			logger.log(
					Level.WARNING, "server: " + md.getMachineId() + " failed to start up correctly. "
							+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(
						md.getMachineId(), token, endTime);
			} catch (final Exception e2) {
				logger.log(
						Level.WARNING,
						"Error while shutting down failed machine: " + md.getMachineId()
								+ ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	};private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final MachineDetails md = createServer(
				token, serverTemplate);

		try {
			// wait until complete
			waitForServerToReachStatus(
					md, endTime, md.getMachineId(), token, "ACTIVE");

			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			return md;
		} catch (final Exception e) {
			logger.log(
					Level.WARNING, "server: " + md.getMachineId() + " failed to start up correctly. "
							+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(
						md.getMachineId(), token, endTime);
			} catch (final Exception e2) {
				logger.log(
						Level.WARNING,
						"Error while shutting down failed machine: " + md.getMachineId()
								+ ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/RSCloudDriver;createServer(String,CloudTemplate);;private MachineDetails createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageId\":" + serverTemplate.getImageId()
						+ ",\"flavorId\":" + serverTemplate.getHardwareId() + "}}";

		String serverBootResponse = null;
		try {
			serverBootResponse = service.path(
					this.pathPrefix + "servers")
					.header(
							"Content-Type", "application/json").header(
							"X-Auth-Token", token).accept(
							MediaType.APPLICATION_XML).post(
							String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate(
					"/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate(
					"/server/@id", doc);
			final String rootPassword = xpath.evaluate(
					"/server/@adminPass", doc);
			MachineDetails md = new MachineDetails();
			md.setMachineId(serverId);
			md.setRemoteUsername(serverTemplate.getUsername());
			md.setRemotePassword(rootPassword);
			return md;
		} catch (XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	};private MachineDetails createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageId\":" + serverTemplate.getImageId()
						+ ",\"flavorId\":" + serverTemplate.getHardwareId() + "}}";

		String serverBootResponse = null;
		try {
			serverBootResponse = service.path(
					this.pathPrefix + "servers")
					.header(
							"Content-Type", "application/json").header(
							"X-Auth-Token", token).accept(
							MediaType.APPLICATION_XML).post(
							String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate(
					"/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate(
					"/server/@id", doc);
			final String rootPassword = xpath.evaluate(
					"/server/@adminPass", doc);
			MachineDetails md = new MachineDetails();
			md.setMachineId(serverId);
			md.setRemoteUsername(serverTemplate.getUsername());
			md.setRemotePassword(rootPassword);
			return md;
		} catch (XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/DynamicByonProvisioningDriver;createServer(String,long,CloudTemplate);;@Override
	protected MachineDetails createServer(String serverName, long endTime, CloudTemplate template) 
			throws CloudProvisioningException, TimeoutException {
		
		String ip;
		synchronized (mutex) {
			ip = managementMachines.removeFirst();
		}

		MachineDetails machine = createMachine(serverName, template, ip);

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}
		logger.info("Successfully started machine [" + ip + "]");
		
		return machine;
	};@Override
	protected MachineDetails createServer(String serverName, long endTime, CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		String ip;
		synchronized (mutex) {
			ip = managementMachines.removeFirst();
		}

		MachineDetails machine = createMachine(serverName, template, ip);

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}
		logger.info("Successfully started machine [" + ip + "]");

		return machine;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver;addTemplatesToDeployer(ByonDeployer,Map<String,CloudTemplate>);;@SuppressWarnings("unchecked")
	private void addTemplatesToDeployer(final ByonDeployer deployer, final Map<String, CloudTemplate> templatesMap)
			throws Exception {
		logger.info("addTempaltesToDeployer - adding the following tempaltes to the deployer: "
				+ templatesMap.keySet());

		List<Map<String, String>> nodesList = null;
		for (final String templateName : templatesMap.keySet()) {
			final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
			if (customSettings != null) {
				final List<Map<Object, Object>> originalNodesList =
						(List<Map<Object, Object>>) customSettings.get(CLOUD_NODES_LIST);

				nodesList = convertToStringMap(originalNodesList);

			}
			if (nodesList == null) {
				publishEvent(CloudifyErrorMessages.MISSING_NODES_LIST.getName(), templateName);
				throw new CloudProvisioningException(
						"Failed to create BYON cloud deployer, invalid configuration for tempalte "
								+ templateName + " - missing nodes list.");
			}
			deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
		}
	};@SuppressWarnings("unchecked")
	private void addTemplatesToDeployer(final ByonDeployer deployer, final Map<String, CloudTemplate> templatesMap)
			throws Exception {
		logger.info("addTempaltesToDeployer - adding the following tempaltes to the deployer: "
				+ templatesMap.keySet());

		List<Map<String, String>> nodesList = null;
		for (final String templateName : templatesMap.keySet()) {
			final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
			if (customSettings != null) {
				final List<Map<Object, Object>> originalNodesList =
						(List<Map<Object, Object>>) customSettings.get(CLOUD_NODES_LIST);

				nodesList = convertToStringMap(originalNodesList);

			}
			if (nodesList == null) {
				publishEvent(CloudifyErrorMessages.MISSING_NODES_LIST.getName(), templateName);
				throw new CloudProvisioningException(
						"Failed to create BYON cloud deployer, invalid configuration for tempalte "
								+ templateName + " - missing nodes list.");
			}
			deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
		}
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver;createServer(String,long,CloudTemplate);;@Override
	protected MachineDetails createServer(final String serverName, final long endTime, final CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		final CustomNode node;
		final MachineDetails machineDetails;
		logger.info("Cloudify Deployer is creating a machine named: " + serverName + ". This may take a few minutes");
		node = deployer.createServer(cloudTemplateName, serverName);

		machineDetails = createMachineDetailsFromNode(node);

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine.
		try {
			handleServerCredentials(machineDetails, template);
		} catch (final CloudProvisioningException e) {
			try {
				deployer.invalidateServer(cloudTemplateName, node);
			} catch (final CloudProvisioningException ie) {
				logger.log(Level.SEVERE, "Failed to mark machine [" + machineDetails.getPublicAddress() + "/"
						+ machineDetails.getPrivateAddress() + "] as Invalid.", ie);
			}
			throw new CloudProvisioningException(e);
		}

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}

		logger.info("Machine successfully allocated");
		return machineDetails;
	};@Override
	protected MachineDetails createServer(final String serverName, final long endTime, final CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		final CustomNode node;
		final MachineDetails machineDetails;
		logger.info("Cloudify Deployer is creating a machine named: " + serverName + ". This may take a few minutes");
		node = deployer.createServer(cloudTemplateName, serverName);

		machineDetails = createMachineDetailsFromNode(node);

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine.
		try {
			handleServerCredentials(machineDetails, template);
		} catch (final CloudProvisioningException e) {
			try {
				deployer.invalidateServer(cloudTemplateName, node);
			} catch (final CloudProvisioningException ie) {
				logger.log(Level.SEVERE, "Failed to mark machine [" + machineDetails.getPublicAddress() + "/"
						+ machineDetails.getPrivateAddress() + "] as Invalid.", ie);
			}
			throw new CloudProvisioningException(e);
		}

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}

		logger.info("Machine successfully allocated");
		return machineDetails;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper;createInstallationDetails(int,MachineDetails[],CloudTemplate,String,String);;private InstallationDetails[] createInstallationDetails(final int numOfManagementMachines,
			final MachineDetails[] machineDetails, final CloudTemplate template, final String securityProfile,
			final String keystorePassword) throws FileNotFoundException {
		final InstallationDetails[] details = new InstallationDetails[numOfManagementMachines];

		final GSAReservationId reservationId = null;
		final String managementAuthGroups = null;

		for (int i = 0; i < details.length; i++) {
			final ExactZonesConfig zones = new ExactZonesConfigurer().addZone(
					MANAGEMENT_GSA_ZONE).create();
			details[i] = Utils.createInstallationDetails(machineDetails[i], cloud, template, zones, null, null, true,
					this.cloudFile, reservationId, cloud.getConfiguration().getManagementMachineTemplate(),
					securityProfile, keystorePassword, managementAuthGroups);
		}

		return details;
	};private InstallationDetails[] createInstallationDetails(final int numOfManagementMachines,
			final MachineDetails[] machineDetails, final CloudTemplate template, final String securityProfile,
			final String keystorePassword) throws FileNotFoundException {
		final InstallationDetails[] details = new InstallationDetails[numOfManagementMachines];

		final GSAReservationId reservationId = null;
		final String managementAuthGroups = null;

		for (int i = 0; i < details.length; i++) {
			final ExactZonesConfig zones = new ExactZonesConfigurer().addZone(
					MANAGEMENT_GSA_ZONE).create();
			details[i] = Utils.createInstallationDetails(machineDetails[i], cloud, template, zones, null, null, true,
					this.cloudFile, reservationId, cloud.getConfiguration().getManagementMachineTemplate(),
					securityProfile, keystorePassword, managementAuthGroups);
		}

		return details;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;calculateExternalProcessMemory(Cloud,CloudTemplate);;private long calculateExternalProcessMemory(final Cloud cloud,
			final CloudTemplate template) throws DSLException {
		// TODO remove hardcoded number
		logger.info("Calculating external proc mem for template: " + template);
		final int machineMemoryMB = template.getMachineMemoryMB();
		final int reservedMemoryCapacityPerMachineInMB = cloud.getProvider()
				.getReservedMemoryCapacityPerMachineInMB();
		final int safteyMargin = 100; // get rid of this constant. see
		// CLOUDIFY-297
		final long cloudExternalProcessMemoryInMB = machineMemoryMB
				- reservedMemoryCapacityPerMachineInMB - safteyMargin;
		if (cloudExternalProcessMemoryInMB <= 0) {
			throw new DSLException("Cloud template machineMemoryMB ("
					+ machineMemoryMB + "MB) must be bigger than "
					+ "reservedMemoryCapacityPerMachineInMB+" + safteyMargin
					+ " ("
					+ (reservedMemoryCapacityPerMachineInMB + safteyMargin)
					+ ")");
		}
		logger.fine("template.machineMemoryMB = "
				+ template.getMachineMemoryMB() + "MB\n"
				+ "cloud.provider.reservedMemoryCapacityPerMachineInMB = "
				+ reservedMemoryCapacityPerMachineInMB + "MB\n"
				+ "cloudExternalProcessMemoryInMB = "
				+ cloudExternalProcessMemoryInMB + "MB"
				+ "cloudExternalProcessMemoryInMB = cloud.machineMemoryMB - "
				+ "cloud.reservedMemoryCapacityPerMachineInMB" + " = "
				+ cloudExternalProcessMemoryInMB);
		return cloudExternalProcessMemoryInMB;
	};private long calculateExternalProcessMemory(final Cloud cloud,
			final CloudTemplate template) throws DSLException {
		// TODO remove hardcoded number
		logger.info("Calculating external proc mem for template: " + template);
		final int machineMemoryMB = template.getMachineMemoryMB();
		final int reservedMemoryCapacityPerMachineInMB = cloud.getProvider()
				.getReservedMemoryCapacityPerMachineInMB();
		final int safteyMargin = 100; // get rid of this constant. see
		// CLOUDIFY-297
		final long cloudExternalProcessMemoryInMB = machineMemoryMB
				- reservedMemoryCapacityPerMachineInMB - safteyMargin;
		if (cloudExternalProcessMemoryInMB <= 0) {
			throw new DSLException("Cloud template machineMemoryMB ("
					+ machineMemoryMB + "MB) must be bigger than "
					+ "reservedMemoryCapacityPerMachineInMB+" + safteyMargin
					+ " ("
					+ (reservedMemoryCapacityPerMachineInMB + safteyMargin)
					+ ")");
		}
		logger.fine("template.machineMemoryMB = "
				+ template.getMachineMemoryMB() + "MB\n"
				+ "cloud.provider.reservedMemoryCapacityPerMachineInMB = "
				+ reservedMemoryCapacityPerMachineInMB + "MB\n"
				+ "cloudExternalProcessMemoryInMB = "
				+ cloudExternalProcessMemoryInMB + "MB"
				+ "cloudExternalProcessMemoryInMB = cloud.machineMemoryMB - "
				+ "cloud.reservedMemoryCapacityPerMachineInMB" + " = "
				+ cloudExternalProcessMemoryInMB);
		return cloudExternalProcessMemoryInMB;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;validateAndPrepareStatefulSla(String,Sla,Cloud,CloudTemplate);;private void validateAndPrepareStatefulSla(final String serviceName,
			final Sla sla, final Cloud cloud, final CloudTemplate template)
					throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMaxMemoryCapacity() != null
				&& sla.getMemoryCapacity() != null
				&& sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			throw new DSLException(
					"Max memory capacity is smaller than the memory capacity."
							+ sla.getMaxMemoryCapacity() + " < "
							+ sla.getMemoryCapacity());
		}

		final int minimumNumberOfContainers = sla.getHighlyAvailable() ? 2 : 1;
		final int minMemoryInMB = minimumNumberOfContainers
				* sla.getMemoryCapacityPerContainer();

		if (sla.getMemoryCapacity() == null
				|| sla.getMemoryCapacity() < minMemoryInMB) {

			logger.info("Setting memoryCapacity for service " + serviceName
					+ " to minimum " + minMemoryInMB + "MB");
			sla.setMemoryCapacity(minMemoryInMB);
		}

		if (sla.getMaxMemoryCapacity() == null
				|| sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			logger.info("Setting maxMemoryCapacity for service " + serviceName
					+ " to memoryCapacity " + sla.getMemoryCapacity() + "MB");
			sla.setMaxMemoryCapacity(sla.getMemoryCapacity());
		}
	};private void validateAndPrepareStatefulSla(final String serviceName,
			final Sla sla, final Cloud cloud, final CloudTemplate template)
			throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMaxMemoryCapacity() != null
				&& sla.getMemoryCapacity() != null
				&& sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			throw new DSLException(
					"Max memory capacity is smaller than the memory capacity."
							+ sla.getMaxMemoryCapacity() + " < "
							+ sla.getMemoryCapacity());
		}

		final int minimumNumberOfContainers = sla.getHighlyAvailable() ? 2 : 1;
		final int minMemoryInMB = minimumNumberOfContainers
				* sla.getMemoryCapacityPerContainer();

		if (sla.getMemoryCapacity() == null
				|| sla.getMemoryCapacity() < minMemoryInMB) {

			logger.info("Setting memoryCapacity for service " + serviceName
					+ " to minimum " + minMemoryInMB + "MB");
			sla.setMemoryCapacity(minMemoryInMB);
		}

		if (sla.getMaxMemoryCapacity() == null
				|| sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			logger.info("Setting maxMemoryCapacity for service " + serviceName
					+ " to memoryCapacity " + sla.getMemoryCapacity() + "MB");
			sla.setMaxMemoryCapacity(sla.getMemoryCapacity());
		}
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;validateAndPrepareStatelessSla(Sla,Cloud,CloudTemplate);;private void validateAndPrepareStatelessSla(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
					throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMemoryCapacity() != null) {
			throw new DSLException(
					"memoryCapacity SLA is not supported in this service");
		}

		if (sla.getMaxMemoryCapacity() != null) {
			throw new DSLException(
					"maxMemoryCapacity SLA is not supported in this service");
		}

	};private void validateAndPrepareStatelessSla(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
			throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMemoryCapacity() != null) {
			throw new DSLException(
					"memoryCapacity SLA is not supported in this service");
		}

		if (sla.getMaxMemoryCapacity() != null) {
			throw new DSLException(
					"maxMemoryCapacity SLA is not supported in this service");
		}

	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController;validateMemoryCapacityPerContainer(Sla,Cloud,CloudTemplate);;private void validateMemoryCapacityPerContainer(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
					throws DSLException {
		if (cloud == null) {
			// No cloud, must specify memory capacity per container explicitly
			if (sla.getMemoryCapacityPerContainer() == null) {
				throw new DSLException(
						"Cannot determine memoryCapacityPerContainer SLA");
			}
		} else {
			// Assuming one container per machine then container memory =
			// machine memory
			final int availableMemoryOnMachine = (int) calculateExternalProcessMemory(
					cloud, template);
			if (sla.getMemoryCapacityPerContainer() != null
					&& sla.getMemoryCapacityPerContainer() > availableMemoryOnMachine) {
				throw new DSLException(
						"memoryCapacityPerContainer SLA is larger than available memory on machine\n"
								+ sla.getMemoryCapacityPerContainer() + " > "
								+ availableMemoryOnMachine);
			}

			if (sla.getMemoryCapacityPerContainer() == null) {
				sla.setMemoryCapacityPerContainer(availableMemoryOnMachine);
			}
		}
	};private void validateMemoryCapacityPerContainer(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
			throws DSLException {
		if (cloud == null) {
			// No cloud, must specify memory capacity per container explicitly
			if (sla.getMemoryCapacityPerContainer() == null) {
				throw new DSLException(
						"Cannot determine memoryCapacityPerContainer SLA");
			}
		} else {
			// Assuming one container per machine then container memory =
			// machine memory
			final int availableMemoryOnMachine = (int) calculateExternalProcessMemory(
					cloud, template);
			if (sla.getMemoryCapacityPerContainer() != null
					&& sla.getMemoryCapacityPerContainer() > availableMemoryOnMachine) {
				throw new DSLException(
						"memoryCapacityPerContainer SLA is larger than available memory on machine\n"
								+ sla.getMemoryCapacityPerContainer() + " > "
								+ availableMemoryOnMachine);
			}

			if (sla.getMemoryCapacityPerContainer() == null) {
				sla.setMemoryCapacityPerContainer(availableMemoryOnMachine);
			}
		}
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_bukkit/revisions/rev_f46d9_61bea/rev_f46d9-61bea;/src/org/bukkit/event/block/BlockFromToEvent;getFromBlock();;public Block getFromBlock() {
    	return from; 
    };public Block getFromBlock() {
        return from; 
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_bukkit/revisions/rev_f46d9_61bea/rev_f46d9-61bea;/src/org/bukkit/event/block/BlockCanBuildEvent;isBuildable();;public boolean isBuildable() {
		return buildable;
	};public boolean isBuildable() {
        return buildable;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_bukkit/revisions/rev_f46d9_61bea/rev_f46d9-61bea;/src/org/bukkit/event/block/BlockCanBuildEvent;setBuildable(boolean);;public void setBuildable(boolean cancel) {
		this.buildable = cancel;
	};public void setBuildable(boolean cancel) {
        this.buildable = cancel;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_bukkit/revisions/rev_f46d9_61bea/rev_f46d9-61bea;/src/org/bukkit/event/block/BlockCanBuildEvent;getMaterial();;public Material getMaterial() {
		return Material.getMaterial(material);
	};public Material getMaterial() {
        return Material.getMaterial(material);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_bukkit/revisions/rev_f46d9_61bea/rev_f46d9-61bea;/src/org/bukkit/event/block/BlockCanBuildEvent;getMaterialID();;public int getMaterialID() {
		return material;
	};public int getMaterialID() {
        return material;
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_f2594_95779/rev_f2594-95779;/src/main/java/org/junit/experimental/ParallelComputer;getRunner(RunnerBuilder,Class<?>);;@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
	};@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_fc594_19fc1/rev_fc594-19fc1;/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler;discoverClusterNodesAndSlots(Jedis);;private void discoverClusterNodesAndSlots(Jedis jedis) {
	String localNodes = jedis.clusterNodes();
	for (String nodeInfo : localNodes.split("\n")) {
	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));

	    HostAndPort targetNode = clusterNodeInfo.getNode();
	    setNodeIfNotExist(targetNode);
	    assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
	}
    };private void discoverClusterNodesAndSlots(Jedis jedis) {
        String localNodes = jedis.clusterNodes();
        for (String nodeInfo : localNodes.split("\n")) {
            ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
                    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
                    jedis.getClient().getPort()));

            HostAndPort targetNode = clusterNodeInfo.getNode();
            setNodeIfNotExist(targetNode);
            assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_ff2ff_b7371/rev_ff2ff-b7371;/src/main/java/org/junit/experimental/ParallelComputer;getRunner(RunnerBuilder,Class<?>);;@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
	};@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_ff519_092e3/rev_ff519-092e3;/subprojects/core/src/main/groovy/org/gradle/api/tasks/bundling/Tar;getCompressor();;public ArchiveOutputStreamFactory getCompressor() {
            switch(compression) {
                case BZIP2: return Bzip2Archiver.getCompressor();
                case GZIP:  return GzipArchiver.getCompressor();
                default:    return new SimpleCompressor();
            }
        };public ArchiveOutputStreamFactory getCompressor() {
            switch (compression) {
                case BZIP2:
                    return Bzip2Archiver.getCompressor();
                case GZIP:
                    return GzipArchiver.getCompressor();
                default:
                    return new SimpleCompressor();
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ffc73_e99c0/rev_ffc73-e99c0;/projects/OG-Financial/src/com/opengamma/financial/analytics/swap/FixedFloatSwapSecurityToSwapConverter;getFloatLeg(FloatingInterestRateLeg,ZonedDateTime,ZonedDateTime,ZonedDateTime,String,String,Calendar,double,int);;public GenericAnnuity<Payment> getFloatLeg(final FloatingInterestRateLeg floatLeg, final ZonedDateTime now, final ZonedDateTime effectiveDate, final ZonedDateTime maturityDate,
      final String fundingCurveName, final String liborCurveName, final Calendar calendar, final double initialRate, final int settlementDays) {
    final ZonedDateTime[] unadjustedDates = ScheduleCalculator.getUnadjustedDateSchedule(effectiveDate, maturityDate, floatLeg.getFrequency());
    final ZonedDateTime[] adjustedDates = ScheduleCalculator.getAdjustedDateSchedule(unadjustedDates, floatLeg.getBusinessDayConvention(), calendar, 0);
    final ZonedDateTime[] resetDates = ScheduleCalculator.getAdjustedResetDateSchedule(effectiveDate, unadjustedDates, floatLeg.getBusinessDayConvention(), calendar, settlementDays); //TODO should settlement days be negative?
    final ZonedDateTime[] maturityDates = ScheduleCalculator.getAdjustedMaturityDateSchedule(effectiveDate, unadjustedDates, floatLeg.getBusinessDayConvention(), calendar, floatLeg.getFrequency());

    double[] paymentTimes = ScheduleCalculator.getTimes(adjustedDates, DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] resetTimes = ScheduleCalculator.getTimes(resetDates, DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] maturityTimes = ScheduleCalculator.getTimes(maturityDates, DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] yearFractions = ScheduleCalculator.getYearFractions(adjustedDates, floatLeg.getDayCount(), effectiveDate);
    final double notional = ((InterestRateNotional) floatLeg.getNotional()).getAmount();
    final double spread = floatLeg.getSpread();

    final int n = ScheduleCalculator.numberOfNegativeValues(paymentTimes);
    if (n >= paymentTimes.length) {
      //all payments are in the past - return a dummy annuity with zero notional a one payment (of zero) at zero and zero spread 
      //TODO may want to handle this case differently 
      return new GenericAnnuity<Payment>(new Payment[] {new PaymentFixed(0, 0, fundingCurveName)});
    }

    if (n > 0) {
      paymentTimes = ScheduleCalculator.removeFirstNValues(paymentTimes, n);
      resetTimes = ScheduleCalculator.removeFirstNValues(resetTimes, n);
      maturityTimes = ScheduleCalculator.removeFirstNValues(maturityTimes, n);
      yearFractions = ScheduleCalculator.removeFirstNValues(yearFractions, n);
    }
    final double[] spreads = new double[paymentTimes.length];
    Arrays.fill(spreads, spread);

    final Payment[] payments = new Payment[paymentTimes.length];
    for (int i = 0; i < payments.length; i++) {
      if (resetTimes[i] < 0.0) {
        payments[i] = new CouponFixed(paymentTimes[i], fundingCurveName, yearFractions[i], notional, initialRate);
      } else {
        payments[i] = new CouponIbor(paymentTimes[i], fundingCurveName, yearFractions[i], notional, resetTimes[i], resetTimes[i], maturityTimes[i], yearFractions[i], spreads[i], liborCurveName);
      }
    }

    //TODO need to handle paymentYearFraction differently from forwardYearFraction 
    return new GenericAnnuity<Payment>(payments);
  };public GenericAnnuity<Payment> getFloatLeg(final FloatingInterestRateLeg floatLeg, final ZonedDateTime now,
      final ZonedDateTime effectiveDate, final ZonedDateTime maturityDate, final String fundingCurveName,
      final String liborCurveName, final Calendar calendar, final double initialRate, final int settlementDays) {
    final ZonedDateTime[] unadjustedDates = ScheduleCalculator.getUnadjustedDateSchedule(effectiveDate, maturityDate,
        floatLeg.getFrequency());
    final ZonedDateTime[] adjustedDates = ScheduleCalculator.getAdjustedDateSchedule(unadjustedDates,
        floatLeg.getBusinessDayConvention(), calendar, 0);
    final ZonedDateTime[] resetDates = ScheduleCalculator.getAdjustedResetDateSchedule(effectiveDate, unadjustedDates,
        floatLeg.getBusinessDayConvention(), calendar, settlementDays); //TODO should settlement days be negative?
    final ZonedDateTime[] maturityDates = ScheduleCalculator.getAdjustedMaturityDateSchedule(effectiveDate,
        unadjustedDates, floatLeg.getBusinessDayConvention(), calendar, floatLeg.getFrequency());

    double[] paymentTimes = ScheduleCalculator.getTimes(adjustedDates,
        DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] resetTimes = ScheduleCalculator.getTimes(resetDates,
        DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] maturityTimes = ScheduleCalculator.getTimes(maturityDates,
        DayCountFactory.INSTANCE.getDayCount("Actual/Actual"), now);
    double[] yearFractions = ScheduleCalculator.getYearFractions(adjustedDates, floatLeg.getDayCount(), effectiveDate);
    final double notional = ((InterestRateNotional) floatLeg.getNotional()).getAmount();
    final double spread = floatLeg.getSpread();

    final int n = ScheduleCalculator.numberOfNegativeValues(paymentTimes);
    if (n >= paymentTimes.length) {
      //all payments are in the past - return a dummy annuity with zero notional a one payment (of zero) at zero and zero spread 
      //TODO may want to handle this case differently 
      return new GenericAnnuity<Payment>(new Payment[] {new PaymentFixed(0, 0, fundingCurveName)});
    }

    if (n > 0) {
      paymentTimes = ScheduleCalculator.removeFirstNValues(paymentTimes, n);
      resetTimes = ScheduleCalculator.removeFirstNValues(resetTimes, n);
      maturityTimes = ScheduleCalculator.removeFirstNValues(maturityTimes, n);
      yearFractions = ScheduleCalculator.removeFirstNValues(yearFractions, n);
    }
    final double[] spreads = new double[paymentTimes.length];
    Arrays.fill(spreads, spread);

    final Payment[] payments = new Payment[paymentTimes.length];
    for (int i = 0; i < payments.length; i++) {
      if (resetTimes[i] < 0.0) {
        payments[i] = new CouponFixed(paymentTimes[i], fundingCurveName, yearFractions[i], notional, initialRate);
      } else {
        payments[i] = new CouponIbor(paymentTimes[i], fundingCurveName, yearFractions[i], notional, resetTimes[i],
            resetTimes[i], maturityTimes[i], yearFractions[i], spreads[i], liborCurveName);
      }
    }

    //TODO need to handle paymentYearFraction differently from forwardYearFraction 
    return new GenericAnnuity<Payment>(payments);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_0c32e_3e3bb/rev_0c32e-3e3bb;/lucene/src/java/org/apache/lucene/index/FieldInfos;addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean);;synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,
      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,
      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {
    if (globalFieldNumbers == null) {
      throw new IllegalStateException("FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos");
    }
    assert segmentCodecsBuilder != null : "SegmentCodecsBuilder is set to null but FieldInfos is not read-only";
    FieldInfo fi = fieldInfo(name);
    if (fi == null) {
      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);
      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    } else {
      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    }
    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {
      segmentCodecsBuilder.tryAddAndSet(fi);
    }
    return fi;
  };synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,
                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,
                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {
    if (globalFieldNumbers == null) {
      throw new IllegalStateException("FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos");
    }
    assert segmentCodecsBuilder != null : "SegmentCodecsBuilder is set to null but FieldInfos is not read-only";
    FieldInfo fi = fieldInfo(name);
    if (fi == null) {
      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);
      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    } else {
      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
    }
    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {
      segmentCodecsBuilder.tryAddAndSet(fi);
    }
    return fi;
  }
