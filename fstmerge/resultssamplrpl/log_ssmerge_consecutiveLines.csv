revision;file;methodsignature;leftbody;basebody;rightbody
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0d241_1c2a6/rev_0d241-1c2a6;/src/java/org/apache/cassandra/thrift/ThriftValidation;validateKeyRange(CFMetaData,ByteBuffer,KeyRange);                if (p.preservesOrder())
                    throw new InvalidRequestException("start key must sort before (or equal to) finish key in your partitioner!");
                else
                    throw new InvalidRequestException("start key's md5 sorts after end key's md5.  this is not allowed; you probably should not specify end key at all, under RandomPartitioner");;                if (p instanceof RandomPartitioner)
                    throw new InvalidRequestException("start key's md5 sorts after end key's md5.  this is not allowed; you probably should not specify end key at all, under RandomPartitioner");
                else
                    throw new InvalidRequestException("start key must sort before (or equal to) finish key in your partitioner!");;                if (p instanceof RandomPartitioner)
                    throw new org.apache.cassandra.exceptions.InvalidRequestException("start key's md5 sorts after end key's md5.  this is not allowed; you probably should not specify end key at all, under RandomPartitioner");
                else
                    throw new org.apache.cassandra.exceptions.InvalidRequestException("start key must sort before (or equal to) finish key in your partitioner!");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0d441_780cc/rev_0d441-780cc;/src/java/org/apache/cassandra/db/RowMutation;deserializeFixingTimestamps(DataInput,int);                if (cfOld.isMarkedForDelete())
                    cf.delete(cfOld.getLocalDeletionTime(), cfOld.getMarkedForDeleteAt() > now ? now : cfOld.getMarkedForDeleteAt());;                if (cf.isMarkedForDelete())
                    cf.delete(cf.getLocalDeletionTime(), cf.getMarkedForDeleteAt() > now ? now : cf.getMarkedForDeleteAt());;                if (cf.isMarkedForDelete())
                {
                    DeletionTime delTime = cf.deletionInfo().getTopLevelDeletion();
                    cf.delete(new DeletionInfo(delTime.markedForDeleteAt > now ? now : delTime.markedForDeleteAt,
                                               delTime.localDeletionTime));
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0d805_3d5a5/rev_0d805-3d5a5;/src/java/org/apache/cassandra/db/DataTracker;replace(Collection<SSTableReader>,Iterable<SSTableReader>);        addNewSSTablesSize(replacements);
        removeOldSSTablesSize(oldSSTables);

        cfstore.updateCacheSizes();;        addNewSSTablesSize(replacements);
        removeOldSSTablesSize(oldSSTables);

        notifySSTablesChanged(replacements, oldSSTables);
        cfstore.updateCacheSizes();;        postReplace(oldSSTables, replacements);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0e18f_ab31b/rev_0e18f-ab31b;/src/java/org/apache/cassandra/service/StorageProxy;writeHintForMutation(RowMutation,int,InetAddress);        mutation.toHint(ttl, hostId).apply();
        StorageMetrics.totalHints.inc();;        mutation.toHint(ttl, hostId).apply();
        totalHints.incrementAndGet();;        HintedHandOffManager.instance.hintFor(mutation, ttl, hostId).apply();
        totalHints.incrementAndGet();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_0ffdc_39cee/rev_0ffdc-39cee;/projects/OG-Web/src/com/opengamma/web/json/CurveSpecificationBuilderConfigurationJSONBuilder;fromJSON(String);    CurveSpecificationBuilderConfiguration result = null;
    
    try {
      JSONObject configJSON = new JSONObject(json);
      
      Map<Tenor, CurveInstrumentProvider> cashInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("cashInstrumentProviders"));
      
      Map<Tenor, CurveInstrumentProvider> fra3MInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> fra6MInstrumentProviders = null;
      JSONArray oldFRAArray = configJSON.optJSONArray("fraInstrumentProviders");
      JSONArray fra3MArray = configJSON.optJSONArray("fra3MInstrumentProviders");
      JSONArray fra6MArray = configJSON.optJSONArray("fra6MInstrumentProviders");
      if (oldFRAArray != null) {
        if (fra3MArray != null || fra6MArray != null) {
          throw new OpenGammaRuntimeException("Have JSON array with the old FRA field but at least one of the new FRA fields (3m or 6m)");
        }
        // Treat all old FRAs as 3M (e.g. 1M x 4M)
        s_logger.warn("Curve specification uses a FRA strip that does not contain information about its tenor: assuming that it is 3m.");
        fra3MInstrumentProviders = processCurveInstrumentProvider(oldFRAArray);
      } else {
        fra3MInstrumentProviders = processCurveInstrumentProvider(fra3MArray);
        fra6MInstrumentProviders = processCurveInstrumentProvider(fra6MArray);
      }
      
      Map<Tenor, CurveInstrumentProvider> futureInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("futureInstrumentProviders"));
      
      Map<Tenor, CurveInstrumentProvider> liborInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> euriborInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> cdorInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> ciborInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> stiborInstrumentProviders = null;
      JSONArray oldRateArray = configJSON.optJSONArray("rateInstrumentProviders");
      JSONArray liborArray = configJSON.optJSONArray("liborInstrumentProviders");
      JSONArray euriborArray = configJSON.optJSONArray("euriborInstrumentProviders");
      JSONArray cdorArray = configJSON.optJSONArray("cdorInstrumentProviders");
      JSONArray ciborArray = configJSON.optJSONArray("ciborInstrumentProviders");
      JSONArray stiborArray = configJSON.optJSONArray("stiborInstrumentProviders");
      if (oldRateArray != null) {
        if (liborArray != null || euriborArray != null) {
          throw new OpenGammaRuntimeException("Have JSON array with the old rate field but at least one of the new *ibor fields (libor, euribor or CDOR");
        }
        // Treat all old rates as libor
        s_logger.warn("Curve specification uses a RATE strip: assuming that it is a libor rate.");
        liborInstrumentProviders = processCurveInstrumentProvider(oldRateArray);
      } else {
        liborInstrumentProviders = processCurveInstrumentProvider(liborArray);
        euriborInstrumentProviders = processCurveInstrumentProvider(euriborArray);
        cdorInstrumentProviders = processCurveInstrumentProvider(cdorArray);
        ciborInstrumentProviders = processCurveInstrumentProvider(ciborArray);
        stiborInstrumentProviders = processCurveInstrumentProvider(stiborArray);
      }
      
      Map<Tenor, CurveInstrumentProvider> swap3MInstrumentProviders = null;
      Map<Tenor, CurveInstrumentProvider> swap6MInstrumentProviders = null;
      JSONArray oldSwapArray = configJSON.optJSONArray("swapInstrumentProviders");
      JSONArray swap3MArray = configJSON.optJSONArray("swap3MInstrumentProviders");
      JSONArray swap6MArray = configJSON.optJSONArray("swap6MInstrumentProviders");
      if (oldSwapArray != null) {
        if (swap3MArray != null || swap6MArray != null) {
          throw new OpenGammaRuntimeException("Have JSON array with the old swap field but at least one of the new swap fields (3m or 6m)");
        }
        // Treat all old swaps as if the floating leg was reset quarterly
        s_logger.warn("Curve specification uses a SWAP strip that does not contain information about its floating leg reset tenor: assuming that it is 3m.");
        swap3MInstrumentProviders = processCurveInstrumentProvider(oldSwapArray);
      } else {
        swap3MInstrumentProviders = processCurveInstrumentProvider(swap3MArray);
        swap6MInstrumentProviders = processCurveInstrumentProvider(swap6MArray);
      }
      
      Map<Tenor, CurveInstrumentProvider> basisSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("basisSwapInstrumentProviders"));
      
      Map<Tenor, CurveInstrumentProvider> tenorSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("tenorSwapInstrumentProviders"));
      
      Map<Tenor, CurveInstrumentProvider> oisSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("oisSwapInstrumentProviders"));

      result = new CurveSpecificationBuilderConfiguration(cashInstrumentProviders, 
                                                          fra3MInstrumentProviders, 
                                                          fra6MInstrumentProviders, 
                                                          liborInstrumentProviders, 
                                                          euriborInstrumentProviders,
                                                          cdorInstrumentProviders,
                                                          ciborInstrumentProviders,
                                                          stiborInstrumentProviders,
                                                          futureInstrumentProviders, 
                                                          swap6MInstrumentProviders, 
                                                          swap3MInstrumentProviders, 
                                                          basisSwapInstrumentProviders, 
                                                          tenorSwapInstrumentProviders,
                                                          oisSwapInstrumentProviders);
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("Unable to create CurveSpecificationBuilderConfiguration", ex);
    }
    return result;;    CurveSpecificationBuilderConfiguration result = null;
    try {
      JSONObject configJSON = new JSONObject(json);
      
      Map<Tenor, CurveInstrumentProvider> cashInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("cashInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> fraInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("fraInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> futureInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("futureInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> rateInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("rateInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> swapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("swapInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> basisSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("basisSwapInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> tenorSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("tenorSwapInstrumentProviders"));
      Map<Tenor, CurveInstrumentProvider> oisSwapInstrumentProviders = processCurveInstrumentProvider(configJSON.optJSONArray("oisSwapInstrumentProviders"));

      result = new CurveSpecificationBuilderConfiguration(cashInstrumentProviders, 
                                                          fraInstrumentProviders, 
                                                          rateInstrumentProviders, 
                                                          futureInstrumentProviders, 
                                                          swapInstrumentProviders, 
                                                          basisSwapInstrumentProviders, 
                                                          tenorSwapInstrumentProviders,
                                                          oisSwapInstrumentProviders);
      
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("Unable to create CurveSpecificationBuilderConfiguration", ex);
    }
    return result;;    return fromJSON(CurveSpecificationBuilderConfiguration.class, json);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_0ffdc_39cee/rev_0ffdc-39cee;/projects/OG-Web/src/com/opengamma/web/json/CurveSpecificationBuilderConfigurationJSONBuilder;toJSON(CurveSpecificationBuilderConfiguration);    JSONObject message = new JSONObject();
    try {
      SortedSet<Tenor> allTenors = new TreeSet<Tenor>();
      message.put(String.valueOf(0), CurveSpecificationBuilderConfiguration.class.getName());

      if (object.getCashInstrumentProviders() != null) {
        List<JSONObject> cashInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getCashInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException("tenor is null");
          }
          JSONObject cashInstrumentProvidersMessage = new JSONObject();
          cashInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          cashInstrumentProviders.add(cashInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getCashInstrumentProviders().keySet());
        message.put("cashInstrumentProviders", cashInstrumentProviders);
      } else {
        s_logger.debug("No cash instrument providers");
      }
      
      if (object.getFra3MInstrumentProviders() != null) {
        List<JSONObject> fraInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getFra3MInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject fraInstrumentProvidersMessage = new JSONObject();
          fraInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          fraInstrumentProviders.add(fraInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getFra3MInstrumentProviders().keySet());
        message.put("fra3MInstrumentProviders", fraInstrumentProviders);
      } else {
        s_logger.debug("No FRA 3M instrument providers");
      }
      
      if (object.getFra6MInstrumentProviders() != null) {
        List<JSONObject> fraInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getFra6MInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject fraInstrumentProvidersMessage = new JSONObject();
          fraInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          fraInstrumentProviders.add(fraInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getFra6MInstrumentProviders().keySet());
        message.put("fra6MInstrumentProviders", fraInstrumentProviders);
      } else {
        s_logger.debug("No FRA 6M instrument providers");
      }

      if (object.getFutureInstrumentProviders() != null) {
        List<JSONObject> futureInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getFutureInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject futureInstrumentProvidersMessage = new JSONObject();
          futureInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          futureInstrumentProviders.add(futureInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getFutureInstrumentProviders().keySet());
        message.put("futureInstrumentProviders", futureInstrumentProviders);
      } else {
        s_logger.debug("No future instrument providers");
      }
      
      if (object.getLiborInstrumentProviders() != null) {
        List<JSONObject> liborInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getLiborInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject liborInstrumentProvidersMessage = new JSONObject();
          liborInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          liborInstrumentProviders.add(liborInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getLiborInstrumentProviders().keySet());
        message.put("liborInstrumentProviders", liborInstrumentProviders);
      } else {
        s_logger.debug("No libor instrument providers");
      }

      if (object.getEuriborInstrumentProviders() != null) {
        List<JSONObject> euriborInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getEuriborInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject euriborInstrumentProvidersMessage = new JSONObject();
          euriborInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          euriborInstrumentProviders.add(euriborInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getEuriborInstrumentProviders().keySet());
        message.put("euriborInstrumentProviders", euriborInstrumentProviders);
      } else {
        s_logger.debug("No euribor instrument providers");
      }
      
      if (object.getCDORInstrumentProviders() != null) {
        List<JSONObject> cdorInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getCDORInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject cdorInstrumentProvidersMessage = new JSONObject();
          cdorInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          cdorInstrumentProviders.add(cdorInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getCDORInstrumentProviders().keySet());
        message.put("cdorInstrumentProviders", cdorInstrumentProviders);
      } else {
        s_logger.debug("No CDOR instrument providers");
      }

      if (object.getCiborInstrumentProviders() != null) {
        List<JSONObject> ciborInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getCiborInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject ciborInstrumentProvidersMessage = new JSONObject();
          ciborInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          ciborInstrumentProviders.add(ciborInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getCiborInstrumentProviders().keySet());
        message.put("ciborInstrumentProviders", ciborInstrumentProviders);
      } else {
        s_logger.debug("No cibor instrument providers");
      }

      if (object.getStiborInstrumentProviders() != null) {
        List<JSONObject> stiborInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getStiborInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject stiborInstrumentProvidersMessage = new JSONObject();
          stiborInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          stiborInstrumentProviders.add(stiborInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getEuriborInstrumentProviders().keySet());
        message.put("stiborInstrumentProviders", stiborInstrumentProviders);
      } else {
        s_logger.debug("No stibor instrument providers");
      }
      
      if (object.getSwap3MInstrumentProviders() != null) {
        List<JSONObject> swapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getSwap3MInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject swapInstrumentProvidersMessage = new JSONObject();
          swapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          swapInstrumentProviders.add(swapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getSwap3MInstrumentProviders().keySet());
        message.put("swap3MInstrumentProviders", swapInstrumentProviders);
      } else {
        s_logger.debug("No swap 3M instrument providers");
      }

      if (object.getSwap6MInstrumentProviders() != null) {
        List<JSONObject> swapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getSwap6MInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject swapInstrumentProvidersMessage = new JSONObject();
          swapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          swapInstrumentProviders.add(swapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getSwap6MInstrumentProviders().keySet());
        message.put("swap6MInstrumentProviders", swapInstrumentProviders);
      } else {
        s_logger.debug("No swap 6M instrument providers");
      }

      if (object.getBasisSwapInstrumentProviders() != null) {
        List<JSONObject> basisSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getBasisSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject basisSwapInstrumentProvidersMessage = new JSONObject();
          basisSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          basisSwapInstrumentProviders.add(basisSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getBasisSwapInstrumentProviders().keySet());
        message.put("basisSwapInstrumentProviders", basisSwapInstrumentProviders);
      } else {
        s_logger.debug("No basis swap instrument providers");
      }

      if (object.getTenorSwapInstrumentProviders() != null) {
        List<JSONObject> tenorSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getTenorSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject tenorSwapInstrumentProvidersMessage = new JSONObject();
          tenorSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          tenorSwapInstrumentProviders.add(tenorSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getTenorSwapInstrumentProviders().keySet());
        message.put("tenorSwapInstrumentProviders", tenorSwapInstrumentProviders);
      } else {
        s_logger.debug("No tenor swap instrument providers");
      }
      
      if (object.getOISSwapInstrumentProviders() != null) {
        List<JSONObject> oisSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getOISSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject oisSwapInstrumentProvidersMessage = new JSONObject();
          oisSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          oisSwapInstrumentProviders.add(oisSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getOISSwapInstrumentProviders().keySet());
        message.put("oisSwapInstrumentProviders", oisSwapInstrumentProviders);
      } else {
        s_logger.debug("No OIS swap instrument providers");
      }
      
      String[] periods = new String[allTenors.size()];
      Iterator<Tenor> iterator = allTenors.iterator();
      for (int i = 0; i < allTenors.size(); i++) {
        periods[i] = iterator.next().getPeriod().toString();
      }
      message.put("tenors", new JSONArray(periods));
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("unable to convert CurveSpecificationBuilderConfiguration to JSON", ex);
    }
        
    return message.toString();;    JSONObject message = new JSONObject();
    try {
      SortedSet<Tenor> allTenors = new TreeSet<Tenor>();
      message.put(String.valueOf(0), CurveSpecificationBuilderConfiguration.class.getName());

      if (object.getCashInstrumentProviders() != null) {
        List<JSONObject> cashInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getCashInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException("tenor is null");
          }
          JSONObject cashInstrumentProvidersMessage = new JSONObject();
          cashInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          cashInstrumentProviders.add(cashInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getCashInstrumentProviders().keySet());
        message.put("cashInstrumentProviders", cashInstrumentProviders);
      } else {
        s_logger.debug("No cash instrument providers");
      }
      
      if (object.getFraInstrumentProviders() != null) {
        List<JSONObject> fraInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getFraInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject fraInstrumentProvidersMessage = new JSONObject();
          fraInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          fraInstrumentProviders.add(fraInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getFraInstrumentProviders().keySet());
        message.put("fraInstrumentProviders", fraInstrumentProviders);
      } else {
        s_logger.debug("No FRA instrument providers");
      }
      
      if (object.getFutureInstrumentProviders() != null) {
        List<JSONObject> futureInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getFutureInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject futureInstrumentProvidersMessage = new JSONObject();
          futureInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          futureInstrumentProviders.add(futureInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getFutureInstrumentProviders().keySet());
        message.put("futureInstrumentProviders", futureInstrumentProviders);
      } else {
        s_logger.debug("No future instrument providers");
      }
      
      if (object.getRateInstrumentProviders() != null) {
        List<JSONObject> rateInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getRateInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject rateInstrumentProvidersMessage = new JSONObject();
          rateInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          rateInstrumentProviders.add(rateInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getRateInstrumentProviders().keySet());
        message.put("rateInstrumentProviders", rateInstrumentProviders);
      } else {
        s_logger.debug("No rate instrument providers");
      }

      if (object.getSwapInstrumentProviders() != null) {
        List<JSONObject> swapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject swapInstrumentProvidersMessage = new JSONObject();
          swapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          swapInstrumentProviders.add(swapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getSwapInstrumentProviders().keySet());
        message.put("swapInstrumentProviders", swapInstrumentProviders);
      } else {
        s_logger.debug("No swap instrument providers");
      }

      if (object.getBasisSwapInstrumentProviders() != null) {
        List<JSONObject> basisSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getBasisSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject basisSwapInstrumentProvidersMessage = new JSONObject();
          basisSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          basisSwapInstrumentProviders.add(basisSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getBasisSwapInstrumentProviders().keySet());
        message.put("basisSwapInstrumentProviders", basisSwapInstrumentProviders);
      } else {
        s_logger.debug("No basis swap instrument providers");
      }

      if (object.getTenorSwapInstrumentProviders() != null) {
        List<JSONObject> tenorSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getTenorSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject tenorSwapInstrumentProvidersMessage = new JSONObject();
          tenorSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          tenorSwapInstrumentProviders.add(tenorSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getTenorSwapInstrumentProviders().keySet());
        message.put("tenorSwapInstrumentProviders", tenorSwapInstrumentProviders);
      } else {
        s_logger.debug("No tenor swap instrument providers");
      }
      
      if (object.getOISSwapInstrumentProviders() != null) {
        List<JSONObject> oisSwapInstrumentProviders = Lists.newArrayList();
        for (Entry<Tenor, CurveInstrumentProvider> entry : object.getOISSwapInstrumentProviders().entrySet()) {
          if (entry.getKey().getPeriod().toString() == null) {
            throw new OpenGammaRuntimeException(" tenor is null");
          }
          JSONObject oisSwapInstrumentProvidersMessage = new JSONObject();
          oisSwapInstrumentProvidersMessage.put(entry.getKey().getPeriod().toString(), toJSONObject(entry.getValue()));
          oisSwapInstrumentProviders.add(oisSwapInstrumentProvidersMessage);
        }
        allTenors.addAll(object.getOISSwapInstrumentProviders().keySet());
        message.put("oisSwapInstrumentProviders", oisSwapInstrumentProviders);
      } else {
        s_logger.debug("No OIS swap instrument providers");
      }
      
      String[] periods = new String[allTenors.size()];
      Iterator<Tenor> iterator = allTenors.iterator();
      for (int i = 0; i < allTenors.size(); i++) {
        periods[i] = iterator.next().getPeriod().toString();
      }
      message.put("tenors", new JSONArray(periods));
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("unable to convert CurveSpecificationBuilderConfiguration to JSON", ex);
    }
        
    return message.toString();;    return toJSON(object, CurveSpecificationBuilderConfiguration.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/KeyBasedReconConfig;batchRecon(List<ReconJob>,long);                    jsonWriter.array();
                    jsonWriter.object();;                jsonWriter.object();
                jsonWriter.key("query");
                    jsonWriter.array();
                    jsonWriter.object();;                jsonWriter.array();
                jsonWriter.object();
                
                    jsonWriter.key("id"); jsonWriter.value(null);
                    jsonWriter.key("name"); jsonWriter.value(null);
                    jsonWriter.key("guid"); jsonWriter.value(null);
                    jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/KeyBasedReconConfig;batchRecon(List<ReconJob>,long);                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();;                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();
                jsonWriter.endObject();;                            
                        jsonWriter.endObject();
                        jsonWriter.endArray();
                    
                jsonWriter.endObject();
                jsonWriter.endArray();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/KeyBasedReconConfig;batchRecon(List<ReconJob>,long);            sb.append(s_mqlreadService);
            sb.append("query=");;            sb.append(s_mqlreadService);
            sb.append("?query=");;            sb.append(getMqlreadService());
            sb.append("&query=");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/GuidBasedReconConfig;batchRecon(List<ReconJob>,long);            sb.append(s_mqlreadService);
            sb.append("query=");;            sb.append(s_mqlreadService);
            sb.append("?query=");;            sb.append(getMqlreadService());
            sb.append("&query=");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/IdBasedReconConfig;batchRecon(List<ReconJob>,long);                    jsonWriter.array();
                    jsonWriter.object();;                jsonWriter.object();
                jsonWriter.key("query");
                    jsonWriter.array();
                    jsonWriter.object();;                jsonWriter.array();
                jsonWriter.object();
                
                    jsonWriter.key("id"); jsonWriter.value(null);
                    jsonWriter.key("name"); jsonWriter.value(null);
                    jsonWriter.key("guid"); jsonWriter.value(null);
                    jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                    
                    jsonWriter.key("id|=");
                        jsonWriter.array();
                        for (ReconJob job : jobs) {
                            jsonWriter.value(((IdBasedReconJob) job).id);
                        }
                        jsonWriter.endArray();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/IdBasedReconConfig;batchRecon(List<ReconJob>,long);                        jsonWriter.key("id"); jsonWriter.value(null);
                        jsonWriter.key("name"); jsonWriter.value(null);
                        jsonWriter.key("guid"); jsonWriter.value(null);
                        jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                        
                        jsonWriter.key("id|=");
                            jsonWriter.array();
                            for (ReconJob job : jobs) {
                                jsonWriter.value(((IdBasedReconJob) job).id);
                            }
                            jsonWriter.endArray();
                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();;                        jsonWriter.key("id"); jsonWriter.value(null);
                        jsonWriter.key("name"); jsonWriter.value(null);
                        jsonWriter.key("guid"); jsonWriter.value(null);
                        jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                        
                        jsonWriter.key("id|=");
                            jsonWriter.array();
                            for (ReconJob job : jobs) {
                                jsonWriter.value(((IdBasedReconJob) job).id);
                            }
                            jsonWriter.endArray();
                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();
                jsonWriter.endObject();;                jsonWriter.endObject();
                jsonWriter.endArray();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_01de9_fef77/rev_01de9-fef77;/extensions/freebase/src/com/google/refine/freebase/model/recon/IdBasedReconConfig;batchRecon(List<ReconJob>,long);            sb.append(s_mqlreadService);
            sb.append("query=");;            sb.append(s_mqlreadService);
            sb.append("?query=");;            sb.append(getMqlreadService());
            sb.append("&query=");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4;/src/java/voldemort/store/rebalancing/RedirectingStore;getVersions(ByteArray);        if(stealInfo != null) {
            List<Versioned<byte[]>> proxyValues = proxyGetAndLocalPut(key, stealInfo.getDonorId());
            if(isReadOnly)
                return StoreUtils.getVersions(proxyValues);
        };        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId());;        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId(), null);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1a2f2_a3bc4/rev_1a2f2-a3bc4;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/curve/ForwardCurveTest;testShift();      final double t = EXPIRIES[i];
      assertEquals("time " + i, (SPOT + shift) * Math.exp(DRIFT * t), shiftedCurve.getForward(t), 1e-9);;      double t = EXPIRIES[i];
      assertEquals("time " + i, (SPOT + shift) * Math.exp(DRIFT * t), shifedCurve.getForward(t), 1e-9);;      double t = EXPIRIES[i];
      assertEquals("time " + i, SPOT*(1 + shift)* Math.exp(DRIFT * t), shifedCurve.getForward(t), 1e-9);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1a2f2_a3bc4/rev_1a2f2-a3bc4;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/curve/ForwardCurveTest;testShift();      final double t = EXPIRIES[i];
      assertEquals("time " + i, (SPOT + shift) * Math.exp(DRIFT * t), func.evaluate(t), 1e-9);;      double t = EXPIRIES[i];
      assertEquals("time " + i, (SPOT + shift) * Math.exp(DRIFT * t), func.evaluate(t), 1e-9);;      double t = EXPIRIES[i];
      assertEquals("time " + i, SPOT*(1 + shift) * Math.exp(DRIFT * t), func.evaluate(t), 1e-9);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1a3d2_a7021/rev_1a3d2-a7021;/src/com/opengamma/financial/security/db/EquityOptionSecurityBeanOperation;createBean(HibernateSecurityMasterSession,EquityOptionSecurity);    final EquityOptionSecurityBean equityOption = new EquityOptionSecurityBean();
    equityOption.setEquityOptionType(EquityOptionType.identify (security));
    equityOption.setOptionType(security.getOptionType ());
    equityOption.setStrike(security.getStrike ());
    equityOption.setExpiry(new Date (security.getExpiry ().toInstant ().toEpochMillisLong ()));
    equityOption.setUnderlyingIdentityKey(security.getUnderlyingIdentityKey ());
    equityOption.setCurrency(secMasterSession.getOrCreateCurrencyBean (security.getCurrency ().getISOCode ()));
    equityOption.setExchange(secMasterSession.getOrCreateExchangeBean (security.getExchange (), ""));
    return equityOption;;    final EquityOptionSecurityBean equityOption = new EquityOptionSecurityBean();
    equityOption.setEquityOptionType(EquityOptionType.identify (security));
    equityOption.setOptionType(security.getOptionType ());
    equityOption.setStrike(security.getStrike ());
    equityOption.setExpiry(new Date (security.getExpiry ().toInstant ().toEpochMillis ()));
    equityOption.setUnderlyingIdentityKey(security.getUnderlyingIdentityKey ());
    equityOption.setCurrency(secMasterSession.getOrCreateCurrencyBean (security.getCurrency ().getISOCode ()));
    equityOption.setExchange(secMasterSession.getOrCreateExchangeBean (security.getExchange (), ""));
    return equityOption;;    return security.accept (new EquityOptionSecurityVisitor<EquityOptionSecurityBean> () {
      
      private EquityOptionSecurityBean createBasicBean (final EquityOptionSecurity security) {
        final EquityOptionSecurityBean equityOption = new EquityOptionSecurityBean();
        equityOption.setEquityOptionType(EquityOptionType.identify (security));
        equityOption.setOptionType(security.getOptionType ());
        equityOption.setStrike(security.getStrike ());
        equityOption.setExpiry(new Date (security.getExpiry ().toInstant ().toEpochMillis ()));
        equityOption.setUnderlyingIdentityKey(security.getUnderlyingIdentityKey ());
        equityOption.setCurrency(secMasterSession.getOrCreateCurrencyBean (security.getCurrency ().getISOCode ()));
        equityOption.setExchange(secMasterSession.getOrCreateExchangeBean (security.getExchange (), ""));
        return equityOption;
      }

      @Override
      public EquityOptionSecurityBean visitAmericanVanillaEquityOptionSecurity(
          AmericanVanillaEquityOptionSecurity security) {
        return createBasicBean (security);
      }

      @Override
      public EquityOptionSecurityBean visitEuropeanVanillaEquityOptionSecurity(
          EuropeanVanillaEquityOptionSecurity security) {
        return createBasicBean (security);
      }

      @Override
      public EquityOptionSecurityBean visitPoweredEquityOptionSecurity(
          PoweredEquityOptionSecurity security) {
        final EquityOptionSecurityBean equityOption = createBasicBean (security);
        equityOption.setPower (security.getPower ());
        return equityOption;
      }
      
    });
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_1a66e_08cc8/rev_1a66e-08cc8;/src/java/org/apache/cassandra/io/compress/CompressionParameters;CompressionParameters(ICompressor,Integer,Map<String,String>);        this.crcCheckChance = otherOptions.get(CRC_CHECK_CHANCE) == null
                              ? DEFAULT_CRC_CHECK_CHANCE
                              : parseCrcCheckChance(otherOptions.get(CRC_CHECK_CHANCE));;        String chance = otherOptions.get(CRC_CHECK_CHANCE);
        this.crcChance = (chance == null) ? DEFAULT_CRC_CHECK_CHANCE : Double.parseDouble(chance);;        String chance = otherOptions.get(CRC_CHECK_CHANCE);
        otherOptions.remove(CRC_CHECK_CHANCE);
        this.crcChance = (chance == null) ? DEFAULT_CRC_CHECK_CHANCE : Double.parseDouble(chance);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1ab7c_a9aaf/rev_1ab7c-a9aaf;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/timeseries/HistoricalValuationFunction;getRequirements(FunctionCompilationContext,ComputationTarget,ValueRequirement);    
    String startDateConstraint = null;
    String includeStartConstraint = null;
    String endDateConstraint = null;
    String includeEndConstraint = null;
    String periodConstraint = null; 
    
    if (!constraints.isEmpty()) {
      for (String constraintName : constraints.getProperties()) {
        Set<String> constraintValues = constraints.getValues(constraintName);
        if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.START_DATE_PROPERTY)) {
          startDateConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.END_DATE_PROPERTY)) {
          endDateConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.INCLUDE_START_PROPERTY)) {
          includeStartConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.INCLUDE_END_PROPERTY)) {
          includeEndConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(ValuePropertyNames.SAMPLING_PERIOD)) {
          periodConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (!ValuePropertyNames.FUNCTION.equals(constraintName) && !constraints.isOptional(constraintName)) {
          // getResults uses ValueProperties.all() so have to filter out invalid constraints here
          return null;;    
    String startDateConstraint = null;
    String includeStartConstraint = null;
    String endDateConstraint = null;
    String includeEndConstraint = null;
    String periodConstraint = null; 
    
    if (!constraints.isEmpty()) {
      for (String constraintName : constraints.getProperties()) {
        Set<String> constraintValues = constraints.getValues(constraintName);
        if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.START_DATE_PROPERTY)) {
          startDateConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.END_DATE_PROPERTY)) {
          endDateConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.INCLUDE_START_PROPERTY)) {
          includeStartConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(HistoricalTimeSeriesFunctionUtils.INCLUDE_END_PROPERTY)) {
          includeEndConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (constraintName.equals(PERIOD)) {
          periodConstraint = Iterables.getOnlyElement(constraintValues);
        } else if (!ValuePropertyNames.FUNCTION.equals(constraintName) && !constraints.isOptional(constraintName)) {
          // getResults uses ValueProperties.all() so have to filter out invalid constraints here
          return null;;    String startDateConstraint = anyConstraintOrNull(constraints, HistoricalTimeSeriesFunctionUtils.START_DATE_PROPERTY);
    String includeStartConstraintString = anyConstraintOrNull(constraints, HistoricalTimeSeriesFunctionUtils.INCLUDE_START_PROPERTY);
    boolean includeStartConstraint = true;
    String endDateConstraint = anyConstraintOrNull(constraints, HistoricalTimeSeriesFunctionUtils.END_DATE_PROPERTY);
    String includeEndConstraintString = anyConstraintOrNull(constraints, HistoricalTimeSeriesFunctionUtils.INCLUDE_END_PROPERTY);
    boolean includeEndConstraint = false;
    if (includeStartConstraintString != null) {
      includeStartConstraint = HistoricalTimeSeriesFunctionUtils.YES_VALUE.equals(includeStartConstraintString);
    }
    if (includeEndConstraintString != null) {
      includeEndConstraint = HistoricalTimeSeriesFunctionUtils.NO_VALUE.equals(includeEndConstraintString);
    }
    if (endDateConstraint == null) {
      endDateConstraint = DateConstraint.VALUATION_TIME.toString();
    }
    if (startDateConstraint == null) {
      if (includeEndConstraint) {
        if (includeStartConstraint) {
          startDateConstraint = endDateConstraint;
        } else {
          startDateConstraint = DateConstraint.parse(endDateConstraint).minus(Period.ofDays(1)).toString();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1b06f_da004/rev_1b06f-da004;/projects/OG-Financial/src/com/opengamma/financial/convention/AUConventions;addFixedIncomeInstrumentConventions(ConventionBundleMaster);    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_SWAP")), "AUD_SWAP", act365, modified, semiAnnual, 0, au, act365,
        modified, semiAnnual, 0, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD Bank Bill 6m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_3M_SWAP")), "AUD_3M_SWAP", act365, modified, quarterly, 0, au,
        act365, modified, quarterly, 0, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD Bank Bill 3m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_6M_SWAP")), "AUD_6M_SWAP", act365, modified, semiAnnual, 0, au,
        act365, modified, semiAnnual, 0, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD Bank Bill 6m"), au, true);;    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_SWAP")), "AUD_SWAP", act365, modified, semiAnnual, 1, au, act365,
        modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 6m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_3M_SWAP")), "AUD_3M_SWAP", act365, modified, quarterly, 1, au,
        act365, modified, quarterly, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 3m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_6M_SWAP")), "AUD_6M_SWAP", act365, modified, semiAnnual, 1, au,
        act365, modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 6m"), au, true);;    final DayCount swapFixedDayCount = act365;
    final BusinessDayConvention swapFixedBusinessDay = modified;
    final Frequency swapFixedPaymentFrequency = semiAnnual;
    final DayCount swapFloatDayCount = act365;
    final BusinessDayConvention swapFloatBusinessDay = modified;
    final Frequency swapFloatPaymentFrequency = semiAnnual;

    for (final int i : new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }) {
      final String bbgOISId = "ADSO" + MONTH_NAMES[i - 1] + " Curncy";
      final String ogOISName = "AUD OIS " + i + "m";
      final Frequency frequency = PeriodFrequency.of(Period.ofMonths(i));
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          swapFixedDayCount, swapFixedBusinessDay, frequency, 2, au, swapFloatDayCount, swapFloatBusinessDay, frequency,
          1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "RBA OVERNIGHT CASH RATE"), au, true); //TODO need BBSW rate
    }
    for (int i = 1; i <= 30; i++) {
      final String bbgSwapId = "ADSW" + i + " Curncy";
      final String ogSwapName = "AUD SWAP " + i + "y";
      final String bbgOISId = "ADSO" + i + " Curncy";
      final String ogOISName = "AUD OIS " + i + "y";
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogSwapName)), ogSwapName,
          swapFixedDayCount, swapFixedBusinessDay, swapFixedPaymentFrequency, 2, au, swapFloatDayCount, swapFloatBusinessDay, swapFloatPaymentFrequency,
          1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 6m"), au, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          swapFixedDayCount, swapFixedBusinessDay, annual, 2, au, swapFloatDayCount, swapFloatBusinessDay, annual,
          1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "RBA OVERNIGHT CASH RATE"), au, true);
    }

    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_SWAP")), "AUD_SWAP", act365, modified, semiAnnual, 1, au, act365,
        modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 6m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_3M_SWAP")), "AUD_3M_SWAP", act365, modified, quarterly, 1, au,
        act365, modified, quarterly, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 3m"), au, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD_6M_SWAP")), "AUD_6M_SWAP", act365, modified, semiAnnual, 1, au,
        act365, modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "AUD LIBOR 6m"), au, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_1c7b3_cbf83/rev_1c7b3-cbf83;/js/js.tests/test/org/jetbrains/k2js/test/semantics/StdLibTestToJSTest;testGenerateTestCase();        generateJavaScriptFiles(EcmaVersion.all(),
                                "libraries/stdlib/test",
                                "dom/DomTest.kt",
                                "js/MapTest.kt",
                                "js/JsDomTest.kt",
                                "iterators/FunctionIteratorTest.kt",
                                "iterators/IteratorsTest.kt",
                                "GetOrElseTest.kt",
                                "ListTest.kt",
                                "SetTest.kt",
                                "StringTest.kt");;        generateJavaScriptFiles(EcmaVersion.all(),
                                "libraries/stdlib/test",
                                //"dom/DomTest.kt",
                                "js/MapTest.kt",
                                "ListTest.kt",
                                "StringTest.kt");;        performStdLibTest(EcmaVersion.all(),
                          "libraries/stdlib/test",
                          //"dom/DomTest.kt",
                          //"js/MapTest.kt",
                          "ListTest.kt",
                          "StringTest.kt");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_1c794_d216b/rev_1c794-d216b;/src/java/org/apache/cassandra/db/RowMutation;hintFor(RowMutation,UUID);        QueryPath path = new QueryPath(SystemTable.HINTS_CF, null, HintedHandOffManager.comparator.decompose(hintId, MessagingService.current_version));
        rm.add(path, ByteBuffer.wrap(FBUtilities.serialize(mutation, serializer, MessagingService.current_version)), System.currentTimeMillis(), ttl);;        QueryPath path = new QueryPath(SystemTable.HINTS_CF, null, HintedHandOffManager.comparator.decompose(hintId, MessagingService.current_version));
        rm.add(path, ByteBuffer.wrap(mutation.getSerializedBuffer(MessagingService.current_version)), System.currentTimeMillis(), ttl);;        ByteBuffer name = HintedHandOffManager.comparator.decompose(hintId, MessagingService.current_version);
        ByteBuffer value = ByteBuffer.wrap(mutation.getSerializedBuffer(MessagingService.current_version));
        rm.add(SystemTable.HINTS_CF, name, value, System.currentTimeMillis(), ttl);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_1cbbb_18913/rev_1cbbb-18913;/src/java/org/apache/cassandra/thrift/CassandraServer;get_count(ByteBuffer,ColumnParent,SlicePredicate,ConsistencyLevel);            predicate.slice_range.count = Math.min(pageSize, Math.max(2, remaining)); // fetch at least two columns
            columns = get_slice(key, column_parent, predicate, consistency_level);
            if (columns.isEmpty())
                break;

            ByteBuffer firstName = getName(columns.get(0));
            int newColumns = pages == 0 || !firstName.equals(predicate.slice_range.start) ? columns.size() : columns.size() - 1;
            totalCount += newColumns;
            // if we over-counted, just return original limit
            if (totalCount > requestedCount)
                return requestedCount;
            remaining -= newColumns;
            pages++;
            // We're done if either:
            //   - We've querying the number of columns requested by the user
            //   - last fetched page only contains the column we already fetched
            if (remaining == 0 || ((columns.size() == 1) && (firstName.equals(predicate.slice_range.start))))
                break;
            else
                predicate.slice_range.start = getName(columns.get(columns.size() - 1));;            predicate.slice_range.count = Math.min(pageSize, Math.max(2, remaining)); // fetch at least two columns
            columns = get_slice(key, column_parent, predicate, consistency_level);
            if (columns.isEmpty())
                break;

            ByteBuffer firstName = getName(columns.get(0));
            int newColumns = pages == 0 || !firstName.equals(predicate.slice_range.start) ? columns.size() : columns.size() - 1;
            totalCount += newColumns;
            // if we over-counted, just return original limit
            if (totalCount > requestedCount)
                return requestedCount;
            remaining -= newColumns;
            pages++;
            // We're done if either:
            //   - We've querying the number of columns requested by the user
            //   - The last page wasn't full
            if (remaining == 0 || columns.size() < predicate.slice_range.count)
                break;
            else
                predicate.slice_range.start = getName(columns.get(columns.size() - 1));;            Tracing.instance().stopSession();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_1cf98_20150/rev_1cf98-20150;/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow;getReduced();                IColumn reduced = purged.iterator().next();
                container = emptyColumnFamily.cloneMeShallow();;                IColumn reduced = purged.iterator().next();
                container.clear();;                Column reduced = purged.iterator().next();
                container.clear();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_1e5f8_22a9a/rev_1e5f8-22a9a;/extensions/gdata/src/com/google/refine/extension/gdata/GDataImporter;setProgress(ImportingJob,String,int);static private void setProgress(ImportingJob job, String fileSource, int percent) {
        job.setProgress(percent, "Reading " + fileSource);;static private void setProgress(ImportingJob job, String fileSource, int percent) {
        JSONObject progress = JSONUtilities.getObject(job.config, "progress");
        if (progress == null) {
            progress = new JSONObject();
            JSONUtilities.safePut(job.config, "progress", progress);
        }
        JSONUtilities.safePut(progress, "message", "Reading " + fileSource);
        JSONUtilities.safePut(progress, "percent", percent);;static void setProgress(ImportingJob job, String fileSource, int percent) {
        JSONObject progress = JSONUtilities.getObject(job.config, "progress");
        if (progress == null) {
            progress = new JSONObject();
            JSONUtilities.safePut(job.config, "progress", progress);
        }
        JSONUtilities.safePut(progress, "message", "Reading " + fileSource);
        JSONUtilities.safePut(progress, "percent", percent);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_1e5f9_a143d/rev_1e5f9-a143d;/src/java/org/apache/cassandra/service/StorageService;joinTokenRing();            SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap
            setToken(token);
        };        } 

        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap
        setToken(token);;        } 

        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap
        setToken(token);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1f0cd_02503/rev_1f0cd-02503;/projects/OG-Language/Client/src/com/opengamma/language/view/Loader;assertPropertiesSet();    ArgumentChecker.notNull(getJmsConnector(), "jmsConnector");
    ArgumentChecker.notNull(getScheduler(), "scheduler");;    ArgumentChecker.notNull(getConnectionFactory(), "connectionFactory");
    ArgumentChecker.notNull(getScheduler(), "scheduler");;    ArgumentChecker.notNull(getConnectionFactory(), "connectionFactory");
    ArgumentChecker.notNull(getHousekeepingScheduler(), "housekeepingScheduler");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_1f1d0_54c90/rev_1f1d0-54c90;/test/integration/voldemort/socketpool/SimpleSocketPoolTest;testSocketPoolLimitSomeTimeout();        SocketServer server = new SocketServer(7666,
                                               50,
                                               50,
                                               1000,
                                               new SocketRequestHandlerFactory(null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null),
                                               "test");;        SocketServer server = new SocketServer(7666,
                                               50,
                                               50,
                                               1000,
                                               new SocketRequestHandlerFactory(null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null),
                                               "test");;        AbstractSocketService server = ServerTestUtils.getSocketService(useNio,
                                                                        new SocketRequestHandlerFactory(null,
                                                                                                        null,
                                                                                                        null,
                                                                                                        null,
                                                                                                        null),
                                                                        7666,
                                                                        50,
                                                                        50,
                                                                        1000);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_1f4c6_23c62/rev_1f4c6-23c62;/lucene/src/java/org/apache/lucene/index/IndexWriter;addIndexes(IndexReader);        ;        info.setUseCompoundFile(true);
        ;        info.setUseCompoundFile(true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_1f21e_61f4d/rev_1f21e-61f4d;/src/java/voldemort/store/readonly/ReadOnlyStorageEngine;get(ByteArray);        byte[] keyMd5 = ByteUtils.md5(key.get());
        try {
            fileModificationLock.readLock().lock();
            int chunk = fileSet.getChunkForKey(keyMd5);
            int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                                  keyMd5,
                                                  fileSet.getIndexFileSize(chunk));
            if(location >= 0) {
                byte[] value = readValue(chunk, location);
                return Collections.singletonList(Versioned.value(value));
            } else {
                return Collections.emptyList();
            }
        } finally {
            fileModificationLock.readLock().unlock();;        byte[] keyMd5 = ByteUtils.md5(key.get());
        int chunk = fileSet.getChunkForKey(keyMd5);
        int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                              keyMd5,
                                              fileSet.getIndexFileSize(chunk));
        if(location >= 0) {
            byte[] value = readValue(chunk, location);
            return Collections.singletonList(Versioned.value(value));
        } else {
            return Collections.emptyList();;        int chunk = fileSet.getChunkForKey(key.get());
        int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                              ByteUtils.md5(key.get()),
                                              fileSet.getIndexFileSize(chunk));
        if(location >= 0) {
            byte[] value = readValue(chunk, location);
            return Collections.singletonList(Versioned.value(value));
        } else {
            return Collections.emptyList();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_2a0ec_8147c/rev_2a0ec-8147c;/tests/unit/com/opengamma/engine/view/cache/RemoteCacheRequestResponseTest;singleThreadSpecLookupDifferentIdentifierValues();    final ValueSpecification[] valueSpec = new ValueSpecification[10];
    for (int i = 0; i < valueSpec.length; i++) {
      valueSpec[i] = new ValueSpecification(new ValueRequirement("Test Value", new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, UniqueIdentifier.of("Kirk", "Value" + i))));
    }
    // Make single value calls
    s_logger.debug ("Begin single value lookup");
    final BitSet seenIds = new BitSet();
    for(int i = 0; i < valueSpec.length; i++) {
      long id = identifierMap.getIdentifier(valueSpec[i]);;    BitSet seenIds = new BitSet();
    for(int i = 0; i < 10; i++) {
      ValueSpecification valueSpec = new ValueSpecification(new ValueRequirement("Test Value", new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, UniqueIdentifier.of("Kirk", "Value" + i))));
      long id = identifierMap.getIdentifier(valueSpec);;    BitSet seenIds = new BitSet();
    for(int i = 0; i < 10; i++) {
      ValueSpecification valueSpec = new ValueSpecification(
          new ValueRequirement("Test Value", new ComputationTargetSpecification(ComputationTargetType.PRIMITIVE, UniqueIdentifier.of("Kirk", "Value" + i))),
          "mockFunctionId");
      long id = identifierMap.getIdentifier(valueSpec);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_2ba14_c767f/rev_2ba14-c767f;/roboguice/src/main/java/roboguice/event/EventManager;fire(Object);        for (EventListener observer : copyObservers(observers))
            observer.onEvent(event);;        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
        //noinspection SynchronizationOnLocalVariableOrMethodParameter
        synchronized (observers) {
            for (EventListener observer : observers)
                observer.onEvent(event);
        };        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
        //noinspection SynchronizationOnLocalVariableOrMethodParameter
        synchronized (observers) {
            for (EventListener observer : observers)
                //noinspection unchecked
                observer.onEvent(event);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2c3c9_92737/rev_2c3c9-92737;/test/unit/voldemort/server/socket/SocketPoolTest;setUp();                                                                         null);
        this.server = new SocketServer(port, 10, 10 + 3, 10000, handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();;                                                                         null);
        this.server = new SocketServer(port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();;                                                                         ServerTestUtils.getVoldemortConfig());
        this.socketService = ServerTestUtils.getSocketService(handlerFactory,
                                                              port,
                                                              maxTotalConnections,
                                                              maxTotalConnections + 3,
                                                              10000);
        this.socketService.start();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_2d04a_68356/rev_2d04a-68356;/src/main/java/redis/clients/jedis/Jedis;blpop(String);public List<String> blpop(String... args) {
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> blpop(String... args) {
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> blpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_2d04a_68356/rev_2d04a-68356;/src/main/java/redis/clients/jedis/Jedis;brpop(String);public List<String> brpop(String... args) {
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> brpop(String... args) {
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> brpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2d210_da636/rev_2d210-da636;/src/java/org/apache/cassandra/cli/CliClient;updateCfDefAttributes(Tree,CfDef);                if (chance > 1)
                    throw new RuntimeException("Error: read_repair_chance should not be greater than 1.");;                if (chance > 1)
                    throw new RuntimeException("Error: read_repair_chance / 100 should not be greater than 1.");;                if (chance < 0 || chance > 1)
                    throw new RuntimeException("Error: read_repair_chance must be between 0 and 1.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2d210_da636/rev_2d210-da636;/src/java/org/apache/cassandra/cli/CliClient;describeKeySpace(String,KsDef);                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);;                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb, cf_def.memtable_flush_after_mins);;                sessionState.out.printf("      Memtable thresholds: %s/%s (millions of ops/MB)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_2e486_5430f/rev_2e486-5430f;/subprojects/gradle-launcher/src/main/java/org/gradle/launcher/Main;execute();public void execute() {
        Clock buildTimeClock = new Clock();;public void execute() throws Exception {
        Clock buildTimeClock = new Clock();;public void execute() throws Exception {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_2eb11_b899c/rev_2eb11-b899c;/tightdb-java-test/src/test/java/com/tightdb/typed/TableQueryTest;shouldMatchOnSimpleStringCriteria();        assertEquals(2, employees.firstName.neq("John").findAll().size());
        assertEquals(2, employees.firstName.notEqual("John").findAll().size());
        assertEquals(2, employees.firstName.neq("John", true).findAll().size());
        assertEquals(2, employees.firstName.notEqual("John", true).findAll().size());
        
        assertEquals(2, employees.firstName.neq("johN", false).findAll().size());
        assertEquals(2, employees.firstName.notEqual("johN", false).findAll().size());;        assertEquals(2, employees.firstName.neq("John").findAll().size());
        assertEquals(2, employees.firstName.notEqual("John").findAll().size());;        assertEquals(2, employees.firstName.notEqualTo("John").findAll().size());
        assertEquals(2, employees.firstName.notEqualTo("John").findAll().size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/util/HighFrequencyDictionary;next();public String next() {
      if (!hasNextCalled && !hasNext()) {
        return null;;public Object next() {
      if (!hasNextCalled) {
        hasNext();;public Object next() {
      if (!hasNextCalled && !hasNext()) {
        return null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/search/function/FileFloatSource;getFloats(FileFloatSource,IndexReader);        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {
          if (notFoundCount<10) {  // collect first 10 not found for logging
            notFound.add(key);;        if (sorted) {
          // make sure this key is greater than the previous key
          sorted = internalKey.compareTo(prevKey) >= 0;
          prevKey = internalKey;

          if (sorted) {
            int countNext = 0;
            for(;;) {
              int cmp = internalKey.compareTo(termVal);
              if (cmp == 0) {
                termDocs.seek(termEnum);
                while (termDocs.next()) {
                  vals[termDocs.doc()] = fval;
                }
                break;
              } else if (cmp < 0) {
                // term enum has already advanced past current key... we didn't find it.
                if (notFoundCount<10) {  // collect first 10 not found for logging
                  notFound.add(key);
                }
                notFoundCount++;
                break;
              } else {
                // termEnum is less than our current key, so skip ahead

                // try next() a few times to see if we hit or pass the target.
                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())
                // so the best thing is to simply ask the reader for a new termEnum(target)
                // if we really need to skip.
                if (++countNext > numTimesNext) {
                  termEnum = reader.terms(protoTerm.createTerm(internalKey));
                  t = termEnum.term();
                } else {
                  hasNext = termEnum.next();
                  t = hasNext ? termEnum.term() : null;
                }

                if (t != null && t.field() == idName) { // intern'd comparison
                  termVal = t.text();
                } else {
                  termVal = lastVal;
                }
              }
            } // end for(;;);        if (sorted) {
          // make sure this key is greater than the previous key
          sorted = internalKey.compareTo(prevKey) >= 0;

          if (sorted) {
            int countNext = 0;
            for(;;) {
              int cmp = internalKey.compareTo(t);
              if (cmp == 0) {
                docsEnum = termsEnum.docs(delDocs, docsEnum);
                int doc;
                while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                  vals[doc] = fval;
                }
                break;
              } else if (cmp < 0) {
                // term enum has already advanced past current key... we didn't find it.
                if (notFoundCount<10) {  // collect first 10 not found for logging
                  notFound.add(key);
                }
                notFoundCount++;
                break;
              } else {
                // termEnum is less than our current key, so skip ahead

                // try next() a few times to see if we hit or pass the target.
                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())
                // so the best thing is to simply ask the reader for a new termEnum(target)
                // if we really need to skip.
                if (++countNext > numTimesNext) {
                  termsEnum.seek(internalKey);
                  t = termsEnum.term();
                } else {
                  t = termsEnum.next();
                }

                if (t==null) t = lastVal;
              }
            } // end for(;;)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/search/function/FileFloatSource;getFloats(FileFloatSource,IndexReader);        docsEnum = termsEnum.docs(null, docsEnum);
        int doc;
        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
          vals[doc] = fval;;        if (!sorted) {
          termEnum = reader.terms(protoTerm.createTerm(internalKey));
          t = termEnum.term();
          if (t != null && t.field() == idName  // intern'd comparison
                  && internalKey.equals(t.text()))
          {
            termDocs.seek (termEnum);
            while (termDocs.next()) {
              vals[termDocs.doc()] = fval;
            }
          } else {
            if (notFoundCount<10) {  // collect first 10 not found for logging
              notFound.add(key);
            }
            notFoundCount++;
          };        if (!sorted) {
          TermsEnum.SeekStatus result = termsEnum.seek(internalKey);
          t = termsEnum.term();
          if (result == TermsEnum.SeekStatus.FOUND) {
            docsEnum = termsEnum.docs(delDocs, docsEnum);
            int doc;
            while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
              vals[doc] = fval;
            }
          } else {
            if (notFoundCount<10) {  // collect first 10 not found for logging
              notFound.add(key);
            }
            notFoundCount++;
          }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/core/SolrCore;close();      searcherExecutor.shutdown();
      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
        log.error("Timeout waiting for searchExecutor to terminate");
      };      searcherExecutor.shutdown();;      closeSearcher();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/core/CoreContainer;create(CoreDescriptor);    if (indexSchemaCache != null) {
      if (zkController != null) {
        File schemaFile = new File(dcore.getSchemaName());
        if (!schemaFile.isAbsolute()) {
          schemaFile = new File(solrLoader.getInstanceDir() + "conf"
              + File.separator + dcore.getSchemaName());
        }
        if (schemaFile.exists()) {
          String key = schemaFile.getAbsolutePath()
              + ":"
              + new SimpleDateFormat("yyyyMMddHHmmss", Locale.US).format(new Date(
                  schemaFile.lastModified()));
          schema = indexSchemaCache.get(key);
          if (schema == null) {
            log.info("creating new schema object for core: " + dcore.name);
            schema = new IndexSchema(config, dcore.getSchemaName(), null);
            indexSchemaCache.put(key, schema);
          } else {
            log.info("re-using schema object for core: " + dcore.name);
          };    if(indexSchemaCache != null){
      //schema sharing is enabled. so check if it already is loaded
      File schemaFile = new File(dcore.getSchemaName());
      if (!schemaFile.isAbsolute()) {
        schemaFile = new File(solrLoader.getInstanceDir() + "conf" + File.separator + dcore.getSchemaName());
      }
      if(schemaFile. exists()){
        String key = schemaFile.getAbsolutePath()+":"+new SimpleDateFormat("yyyyMMddhhmmss", Locale.US).format(new Date(schemaFile.lastModified()));
        schema = indexSchemaCache.get(key);
        if(schema == null){
          log.info("creating new schema object for core: " + dcore.name);
          schema = new IndexSchema(config, dcore.getSchemaName(), null);
          indexSchemaCache.put(key,schema);
        } else {
          log.info("re-using schema object for core: " + dcore.name);;    if(indexSchemaCache != null){
      //schema sharing is enabled. so check if it already is loaded
      File schemaFile = new File(dcore.getSchemaName());
      if (!schemaFile.isAbsolute()) {
        schemaFile = new File(solrLoader.getInstanceDir() + "conf" + File.separator + dcore.getSchemaName());
      }
      if(schemaFile. exists()){
        String key = schemaFile.getAbsolutePath()+":"+new SimpleDateFormat("yyyyMMddHHmmss", Locale.US).format(new Date(schemaFile.lastModified()));
        schema = indexSchemaCache.get(key);
        if(schema == null){
          log.info("creating new schema object for core: " + dcore.name);
          schema = new IndexSchema(config, dcore.getSchemaName(), null);
          indexSchemaCache.put(key,schema);
        } else {
          log.info("re-using schema object for core: " + dcore.name);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_2ede7_249fd/rev_2ede7-249fd;/solr/src/java/org/apache/solr/request/UnInvertedField;getCounts(SolrIndexSearcher,DocSet,int,int,Integer,boolean,String,String);
        // if we are deep paging, we don't have to order the highest "offset" counts.
        int collectCount = Math.max(0, queue.size() - off);
        assert collectCount <= lim;

        // the start and end indexes of our list "sorted" (starting with the highest value)
        int sortedIdxStart = queue.size() - (collectCount - 1);
        int sortedIdxEnd = queue.size() + 1;
        final long[] sorted = queue.sort(collectCount);

        final int[] indirect = counts;  // reuse the counts array for the index into the tnums array
        assert indirect.length >= sortedIdxEnd;

        for (int i=sortedIdxStart; i<sortedIdxEnd; i++) {
          long pair = sorted[i];
          int c = (int)(pair >>> 32);
          int tnum = Integer.MAX_VALUE - (int)pair;

          indirect[i] = i;   // store the index for indirect sorting
          sorted[i] = tnum;  // reuse the "sorted" array to store the term numbers for indirect sorting

          // add a null label for now... we'll fill it in later.
          res.add(null, c);
        }

        // now sort the indexes by the term numbers
        PrimUtils.sort(sortedIdxStart, sortedIdxEnd, indirect, new PrimUtils.IntComparator() {
          @Override
          public int compare(int a, int b) {
            return (int)sorted[a] - (int)sorted[b];
          }

          @Override
          public boolean lessThan(int a, int b) {
            return sorted[a] < sorted[b];
          }

          @Override
          public boolean equals(int a, int b) {
            return sorted[a] == sorted[b];
          }
        });

        // convert the term numbers to term values and set as the label
        for (int i=sortedIdxStart; i<sortedIdxEnd; i++) {
          int idx = indirect[i];
          int tnum = (int)sorted[idx];
          String label = getReadableValue(getTermValue(te, tnum), ft, spare);
          res.setName(idx - sortedIdxStart, label);;        for (Long p : queue) {
          if (--off>=0) continue;
          if (--lim<0) break;
          int c = -(int)(p.longValue() >>> 32);
          //int tnum = 0x7fffffff - (int)p.longValue();  // use if priority queue
          int tnum = (int)p.longValue();
          String label = ft.indexedToReadable(getTermText(te, tnum));
          res.add(label, c);;        for (Long p : queue) {
          if (--off>=0) continue;
          if (--lim<0) break;
          int c = -(int)(p.longValue() >>> 32);
          //int tnum = 0x7fffffff - (int)p.longValue();  // use if priority queue
          int tnum = (int)p.longValue();
          String label = getReadableValue(getTermValue(te, tnum), ft, spare);
          res.add(label, c);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49;/src/java/voldemort/VoldemortAdminTool;main(String[]);            // Not the most elegant way to do this
            if (!(missing.equals(ImmutableSet.of("node")) && (options.has("add-stores") || options.has("delete-store")))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                parser.printHelpOn(System.err);
                System.exit(1);
            };            // Not the most elegant way to do this
            if (!(missing.equals(ImmutableSet.of("node")) && options.has("add-stores"))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                parser.printHelpOn(System.err);
                System.exit(1);
            };            System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
            parser.printHelpOn(System.err);
            System.exit(1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49;/src/java/voldemort/VoldemortAdminTool;main(String[]);        if (options.has("add-stores")) {
            ops += "a";
        }
        if (options.has("update-entries")) {
            ops += "u";
        }
        if (options.has("delete-store")) {
            ops += "s";
        }
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, fetch-keys, add-stores, delete-store, update-entries) must be specified");;        if (options.has("add-stores")) {
            ops += "a";
        }
        if (options.has("update-entries")) {
            ops += "u";
        }
        if (ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, fetch-keys) must be specified");;        if (ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node) must be specified");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49;/src/java/voldemort/VoldemortAdminTool;main(String[]);            if (ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, storeNames);
            }
            if (ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                boolean useAscii = options.has("ascii");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir, useAscii);

            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName);
            }
        } catch(Exception e) {;            if (ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient,
                                 storesXml,
                                 storeNames);
            }
            if (ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                boolean useAscii = options.has("ascii");
                executeUpdateEntries(nodeId,
                                     adminClient,
                                     storeNames,
                                     inputDir,
                                     useAscii);
                
            }
        } catch (Exception e) {;        } catch (Exception e) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_9e8e1/rev_2f90f-9e8e1;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;build();            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));

                    // If the key is in (row) cache, we need the cache to be aware of the streamed row. To keep this simple, we
                    // simply invalidate the row (we always invalidate but invalidating a key not in the cache is a no-op).
                    cfs.invalidateCachedRow(key);

                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));
                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = indexer.index();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_9e8e1/rev_2f90f-9e8e1;/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator;SSTableIdentityIterator(SSTableReader,BufferedRandomAccessFile,DecoratedKey,long,long,boolean);        this.sstable = sstable;
        this.file = file;
        this.key = key;
        this.dataStart = dataStart;
        this.dataSize = dataSize;
        this.expireBefore = (int)(System.currentTimeMillis() / 1000);
        this.validateColumns = checkData;
        finishedAt = dataStart + dataSize;

        try
        {
            file.seek(this.dataStart);
            if (checkData)
            {
                try
                {
                    IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
                }
                catch (Exception e)
                {
                    if (e instanceof EOFException)
                        throw (EOFException) e;

                    logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
                    // deFreeze should have left the file position ready to deserialize index
                }
                try
                {
                    IndexHelper.deserializeIndex(file);
                }
                catch (Exception e)
                {
                    logger.debug("Invalid row summary in {}; will rebuild it", sstable);
                }
                file.seek(this.dataStart);
            }

            IndexHelper.skipBloomFilter(file);
            IndexHelper.skipIndex(file);
            columnFamily = sstable.createColumnFamily();
            ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, file);
            columnCount = file.readInt();
            columnPosition = file.getFilePointer();
        }
        catch (IOException e)
        {
            throw new IOError(e);
        };        this.sstable = sstable;
        this.file = file;
        this.key = key;
        this.dataStart = dataStart;
        this.dataSize = dataSize;
        this.expireBefore = (int)(System.currentTimeMillis() / 1000);
        finishedAt = dataStart + dataSize;

        try
        {
            file.seek(this.dataStart);
            if (deserializeRowHeader)
            {
                try
                {
                    IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
                }
                catch (Exception e)
                {
                    if (e instanceof EOFException)
                        throw (EOFException) e;

                    logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
                    // deFreeze should have left the file position ready to deserialize index
                }
                try
                {
                    IndexHelper.deserializeIndex(file);
                }
                catch (Exception e)
                {
                    logger.debug("Invalid row summary in {}; will rebuild it", sstable);
                }
                file.seek(this.dataStart);
            }

            IndexHelper.skipBloomFilter(file);
            IndexHelper.skipIndex(file);
            columnFamily = sstable.createColumnFamily();
            ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, file);
            columnCount = file.readInt();
            columnPosition = file.getFilePointer();
        }
        catch (IOException e)
        {
            throw new IOError(e);
        };        this(sstable.metadata, file, key, dataStart, dataSize, checkData, sstable, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_9e8e1/rev_2f90f-9e8e1;/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator;getColumnFamilyWithColumns();        ColumnFamily.serializer().deserializeColumns(file, cf);
        if (validateColumns)
        {
            try
            {
                cf.validateColumnFields();
            }
            catch (MarshalException e)
            {
                throw new IOException("Error validating row " + key, e);
            }
        };        ColumnFamily.serializer().deserializeColumns(file, cf);;        ColumnFamily.serializer().deserializeColumns(file, cf, false, fromRemote);
        if (validateColumns)
        {
            try
            {
                cf.validateColumnFields();
            }
            catch (MarshalException e)
            {
                throw new IOException("Error validating row " + key, e);
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_c948f/rev_2f90f-c948f;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;build();            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));

                    // If the key is in (row) cache, we need the cache to be aware of the streamed row. To keep this simple, we
                    // simply invalidate the row (we always invalidate but invalidating a key not in the cache is a no-op).
                    cfs.invalidateCachedRow(key);

                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));
                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = indexer.index();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_c948f/rev_2f90f-c948f;/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator;SSTableIdentityIterator(SSTableReader,BufferedRandomAccessFile,DecoratedKey,long,long,boolean);        this.sstable = sstable;
        this.file = file;
        this.key = key;
        this.dataStart = dataStart;
        this.dataSize = dataSize;
        this.expireBefore = (int)(System.currentTimeMillis() / 1000);
        this.validateColumns = checkData;
        finishedAt = dataStart + dataSize;

        try
        {
            file.seek(this.dataStart);
            if (checkData)
            {
                try
                {
                    IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
                }
                catch (Exception e)
                {
                    if (e instanceof EOFException)
                        throw (EOFException) e;

                    logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
                    // deFreeze should have left the file position ready to deserialize index
                }
                try
                {
                    IndexHelper.deserializeIndex(file);
                }
                catch (Exception e)
                {
                    logger.debug("Invalid row summary in {}; will rebuild it", sstable);
                }
                file.seek(this.dataStart);
            }

            IndexHelper.skipBloomFilter(file);
            IndexHelper.skipIndex(file);
            columnFamily = sstable.createColumnFamily();
            ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, file);
            columnCount = file.readInt();
            columnPosition = file.getFilePointer();
        }
        catch (IOException e)
        {
            throw new IOError(e);
        };        this.sstable = sstable;
        this.file = file;
        this.key = key;
        this.dataStart = dataStart;
        this.dataSize = dataSize;
        this.expireBefore = (int)(System.currentTimeMillis() / 1000);
        finishedAt = dataStart + dataSize;

        try
        {
            file.seek(this.dataStart);
            if (deserializeRowHeader)
            {
                try
                {
                    IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
                }
                catch (Exception e)
                {
                    if (e instanceof EOFException)
                        throw (EOFException) e;

                    logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
                    // deFreeze should have left the file position ready to deserialize index
                }
                try
                {
                    IndexHelper.deserializeIndex(file);
                }
                catch (Exception e)
                {
                    logger.debug("Invalid row summary in {}; will rebuild it", sstable);
                }
                file.seek(this.dataStart);
            }

            IndexHelper.skipBloomFilter(file);
            IndexHelper.skipIndex(file);
            columnFamily = sstable.createColumnFamily();
            ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, file);
            columnCount = file.readInt();
            columnPosition = file.getFilePointer();
        }
        catch (IOException e)
        {
            throw new IOError(e);
        };        this(sstable.metadata, file, key, dataStart, dataSize, checkData, sstable, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2f90f_c948f/rev_2f90f-c948f;/src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator;getColumnFamilyWithColumns();        ColumnFamily.serializer().deserializeColumns(file, cf);
        if (validateColumns)
        {
            try
            {
                cf.validateColumnFields();
            }
            catch (MarshalException e)
            {
                throw new IOException("Error validating row " + key, e);
            }
        };        ColumnFamily.serializer().deserializeColumns(file, cf);;        ColumnFamily.serializer().deserializeColumns(file, cf, false, fromRemote);
        if (validateColumns)
        {
            try
            {
                cf.validateColumnFields();
            }
            catch (MarshalException e)
            {
                throw new IOException("Error validating row " + key, e);
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_2f879_6fb53/rev_2f879-6fb53;/src/main/java/org/junit/rules/TestWatcher;apply(Statement,Description);                startingQuietly(description, errors);
                try {
                    base.evaluate();
                    succeededQuietly(description, errors);
                } catch (AssumptionViolatedException e) {
                    skipped(e, description);
                    throw e;
                } catch (Throwable t) {
                    errors.add(t);
                    failedQuietly(t, description, errors);
                } finally {
                    finishedQuietly(description, errors);
                }

                MultipleFailureException.assertEmpty(errors);
            }
        };
    };				startingQuietly(description, errors);
				try {
					base.evaluate();
					succeededQuietly(description, errors);
				} catch (AssumptionViolatedException e) {
					skipped(e, description);
					throw e;
				} catch (Throwable t) {
					errors.add(t);
					failedQuietly(t, description, errors);
				} finally {
					finishedQuietly(description, errors);
				}
				
				MultipleFailureException.assertEmpty(errors);
			}
		};
	};				startingQuietly(description, errors);
				try {
					base.evaluate();
					succeededQuietly(description, errors);
				} catch (AssumptionViolatedException e) {
					errors.add(e);
					skippedQuietly(e, description, errors);
				} catch (Throwable t) {
					errors.add(t);
					failedQuietly(t, description, errors);
				} finally {
					finishedQuietly(description, errors);
				}
				
				MultipleFailureException.assertEmpty(errors);
			}
		};
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_2f879_bbacb/rev_2f879-bbacb;/src/main/java/org/junit/runners/BlockJUnit4ClassRunner;withMethodRules(FrameworkMethod,List<TestRule>,Object,Statement);@SuppressWarnings("deprecation")
    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
            Object target, Statement result) {
        for (org.junit.rules.MethodRule each : getMethodRules(target)) {
            if (!testRules.contains(each)) {
                result = each.apply(result, method, target);
            }
        }
        return result;
    };@SuppressWarnings("deprecation")
	private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
			Object target, Statement result) {
		for (org.junit.rules.MethodRule each : getMethodRules(target))
			if (! testRules.contains(each))
				result= each.apply(result, method, target);
		return result;
	};private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
			Object target, Statement result) {
		for (org.junit.rules.MethodRule each : getMethodRules(target))
			if (! testRules.contains(each))
				result= each.apply(result, method, target);
		return result;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_2f879_bbacb/rev_2f879-bbacb;/src/main/java/org/junit/runners/BlockJUnit4ClassRunner;getMethodRules(Object);@SuppressWarnings("deprecation")
    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
        return rules(target);
    };@SuppressWarnings("deprecation")
	private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
		return rules(target);
	};private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
		return rules(target);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_2f879_bbacb/rev_2f879-bbacb;/src/main/java/org/junit/runners/BlockJUnit4ClassRunner;rules(Object);@Deprecated
    protected List<org.junit.rules.MethodRule> rules(Object target) {
        return getTestClass().getAnnotatedFieldValues(target, Rule.class,
                org.junit.rules.MethodRule.class);
    };@Deprecated
	protected List<org.junit.rules.MethodRule> rules(Object target) {
		return getTestClass().getAnnotatedFieldValues(target, Rule.class,
				org.junit.rules.MethodRule.class);
	};protected List<org.junit.rules.MethodRule> rules(Object target) {
		return getTestClass().getAnnotatedFieldValues(target, Rule.class,
				org.junit.rules.MethodRule.class);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Transaction;exec();	client.exec();
	client.getAll(1); // Discard all but the last reply;        client.exec();
        client.getAll(1); // Discard all but the last reply;    	// Discard QUEUED or ERROR
    	client.getMany(getPipelinedResponseLength());
    	
        client.exec();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Transaction;execGetResponse();	client.exec();
	client.getAll(1); // Discard all but the last reply;        client.exec();
        client.getAll(1); // Discard all but the last reply;    	// Discard QUEUED or ERROR
    	client.getMany(getPipelinedResponseLength());
    	
        client.exec();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Transaction;discard();	client.discard();
	client.getAll(1); // Discard all but the last reply
	inTransaction = false;
	clean();
	return client.getStatusCodeReply();;        client.discard();
        client.getAll(1); // Discard all but the last reply
        inTransaction = false;
        clean();
        return client.getStatusCodeReply();;    	client.getMany(getPipelinedResponseLength());
        client.discard();
        inTransaction = false;
        clean();
        return client.getStatusCodeReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/BinaryJedis;multi(TransactionBlock);	client.multi();
	jedisTransaction.execute();
	results = jedisTransaction.exec();;	try {
	    client.multi();
	    jedisTransaction.execute();
	    results = jedisTransaction.exec();
	} catch (Exception ex) {
	    jedisTransaction.discard();
	};	try {
	    client.multi();
	    client.getOne();	// expected OK
	    jedisTransaction.execute();
	    results = jedisTransaction.exec();
	} catch (Exception ex) {
	    jedisTransaction.discard();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/BinaryJedis;blpop(byte[]);public List<byte[]> blpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<byte[]> blpop(byte[] arg) {
        checkIsInMulti();
        byte[][] args = new byte[1][];
        args[0] = arg;
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<byte[]> blpop(byte[]... args) {
        checkIsInMulti();
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/BinaryJedis;brpop(byte[]);public List<byte[]> brpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<byte[]> brpop(byte[] arg) {
        checkIsInMulti();
        byte[][] args = new byte[1][];
        args[0] = arg;
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<byte[]> brpop(byte[]... args) {
        checkIsInMulti();
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;sendCommand(Command,byte[]);	try {
	    connect();
	    Protocol.sendCommand(outputStream, cmd, args);
	    pipelinedCommands++;
	    return this;
	} catch (JedisConnectionException ex) {
	    // Any other exceptions related to connection?
	    broken = true;
	    throw ex;
	};        connect();
        Protocol.sendCommand(outputStream, cmd, args);
        pipelinedCommands++;
        return this;;        connect();
        Protocol.sendCommand(outputStream, cmd, args);
        return this;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;sendCommand(Command);	try {
	    connect();
	    Protocol.sendCommand(outputStream, cmd, new byte[0][]);
	    pipelinedCommands++;
	    return this;
	} catch (JedisConnectionException ex) {
	    // Any other exceptions related to connection?
	    broken = true;
	    throw ex;
	};        connect();
        Protocol.sendCommand(outputStream, cmd, new byte[0][]);
        pipelinedCommands++;
        return this;;        connect();
        Protocol.sendCommand(outputStream, cmd, new byte[0][]);
        return this;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getStatusCodeReply();	flush();
	pipelinedCommands--;
	final byte[] resp = (byte[]) readProtocolWithCheckingBroken();
	if (null == resp) {
	    return null;
	} else {
	    return SafeEncoder.encode(resp);
	};        flush();
        pipelinedCommands--;
        final byte[] resp = (byte[]) Protocol.read(inputStream);
        if (null == resp) {
            return null;
        } else {
            return SafeEncoder.encode(resp);
        };        flush();
        final byte[] resp = (byte[]) Protocol.read(inputStream);
        if (null == resp) {
            return null;
        } else {
            return SafeEncoder.encode(resp);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getBinaryBulkReply();	flush();
	pipelinedCommands--;
	return (byte[]) readProtocolWithCheckingBroken();;        flush();
        pipelinedCommands--;
        return (byte[]) Protocol.read(inputStream);;        flush();
        return (byte[]) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getIntegerReply();	flush();
	pipelinedCommands--;
	return (Long) readProtocolWithCheckingBroken();;        flush();
        pipelinedCommands--;
        return (Long) Protocol.read(inputStream);;        flush();
        return (Long) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getBinaryMultiBulkReply();	flush();
	pipelinedCommands--;
	return (List<byte[]>) readProtocolWithCheckingBroken();;        flush();
        pipelinedCommands--;
        return (List<byte[]>) Protocol.read(inputStream);;        flush();
        return (List<byte[]>) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getObjectMultiBulkReply();public List<Object> getObjectMultiBulkReply() {
	flush();
	pipelinedCommands--;
	return getRawObjectMultiBulkReply();;@SuppressWarnings("unchecked")
    public List<Object> getObjectMultiBulkReply() {
        flush();
        pipelinedCommands--;
        return (List<Object>) Protocol.read(inputStream);;@SuppressWarnings("unchecked")
    public List<Object> getObjectMultiBulkReply() {
        flush();
        return (List<Object>) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getIntegerMultiBulkReply();	flush();
	pipelinedCommands--;
	return (List<Long>) readProtocolWithCheckingBroken();;        flush();
        pipelinedCommands--;
        return (List<Long>) Protocol.read(inputStream);;        flush();
        return (List<Long>) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_03c0a_360e2/rev_03c0a-360e2;/src/main/java/redis/clients/jedis/Connection;getOne();	flush();
	pipelinedCommands--;
	return readProtocolWithCheckingBroken();;        flush();
        pipelinedCommands--;
        return Protocol.read(inputStream);;        flush();
        return Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3a2bd_83cd5/rev_3a2bd-83cd5;/src/java/org/apache/cassandra/db/DataTracker;removeOldSSTablesSize(Iterable<SSTableReader>);            liveSize.addAndGet(-sstable.bytesOnDisk());
            sstable.markCompacted();;            sstable.markCompacted();;            boolean firstToCompact = sstable.markCompacted();
            assert firstToCompact : sstable + " was already marked compacted";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3a51c_c609f/rev_3a51c-c609f;/src/java/org/apache/cassandra/db/BatchlogManager;getBatchlogMutationFor(Collection<RowMutation>,UUID);        ColumnFamily cf = ColumnFamily.create(CFMetaData.BatchlogCf);
        cf.addColumn(new Column(columnName(""), ByteBufferUtil.EMPTY_BYTE_BUFFER, timestamp));
        cf.addColumn(new Column(columnName("written_at"), writtenAt, timestamp));
        cf.addColumn(new Column(columnName("data"), data, timestamp));
        RowMutation rm = new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(uuid));
        rm.add(cf);;        ColumnFamily cf = ColumnFamily.create(CFMetaData.BatchlogCf);
        cf.addColumn(new Column(WRITTEN_AT, writtenAt, timestamp));
        cf.addColumn(new Column(DATA, data, timestamp));
        RowMutation rm = new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(uuid));
        rm.add(cf);;        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(CFMetaData.BatchlogCf);
        cf.addColumn(new Column(DATA, data, timestamp));
        cf.addColumn(new Column(WRITTEN_AT, writtenAt, timestamp));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3a51c_c609f/rev_3a51c-c609f;/src/java/org/apache/cassandra/db/BatchlogManager;replayAllFailedBatches();            for (UntypedResultSet.Row row : process("SELECT id, written_at FROM %s.%s", Table.SYSTEM_KS, SystemTable.BATCHLOG_CF))
                if (System.currentTimeMillis() > row.getLong("written_at") + TIMEOUT)
                    replayBatch(row.getUUID("id"));;            logger.debug("Started replayAllFailedBatches");

            for (Row row : getRangeSlice(new NamesQueryFilter(WRITTEN_AT)))
            {
                if (row.cf == null || row.cf.isMarkedForDelete())
                    continue;

                IColumn writtenAt = row.cf.getColumn(WRITTEN_AT);
                if (writtenAt == null || System.currentTimeMillis() > LongType.instance.compose(writtenAt.value()) + TIMEOUT)
                    replayBatch(row.key);
            };            logger.debug("Started replayAllFailedBatches");

            for (Row row : getRangeSlice(new NamesQueryFilter(WRITTEN_AT)))
            {
                if (row.cf == null || row.cf.isMarkedForDelete())
                    continue;

                Column writtenAt = row.cf.getColumn(WRITTEN_AT);
                if (writtenAt == null || System.currentTimeMillis() > LongType.instance.compose(writtenAt.value()) + TIMEOUT)
                    replayBatch(row.key);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3b334_0de64/rev_3b334-0de64;/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/model/volatility/smile/fitting/interpolation/SmileInterpolatorSpline;getVolatilityFunction(double,double[],double,double[]);    final Function1D<Double, Double> dSigmaDx = DIFFERENTIATOR.differentiate(interpFunc, domain);
    
    // The 'quiet' method reduces smile if the volatility gradient is either out of bounds of ShiftedLognormal model, or if root-finder fails to find solution
    if (_extrapolatorFailureBehaviour.equalsIgnoreCase(s_quiet)) {;    
    // FIXME - Remove this hard-coded behaviour, and set up as a Property which can be set
    // By simply passing in a target gradient of zero, we will produce a 'FLAT EXTRAPOLATION'
    final Function1D<Double, Double> returnZero = new Function1D<Double, Double>() {
      @Override
      public Double evaluate(final Double k) {
        return 0.0;
      }
    };
    final Function1D<Double, Double> dSigmaDx = returnZero;
    
    // !!! The line below, instead, computes the derivative using the interpolator
    //final Function1D<Double, Double> dSigmaDx = DIFFERENTIATOR.differentiate(interpFunc, domain);
    
    if (_extrapolatorFailureBehaviour.equalsIgnoreCase("Quiet")) {
      
      // The current *hard-coded* method reduces smile if the volatility gradient is either out of bounds of ShiftedLognormal model, or if root-finder fails to find solution;
    // FIXME - Remove this hard-coded behaviour, and set up as a Property which can be set
    // By simply passing in a target gradient of zero, we will produce a 'FLAT EXTRAPOLATION'
    final Function1D<Double, Double> returnZero = new Function1D<Double, Double>() {
      @Override
      public Double evaluate(final Double k) {
        return 0.0;
      }
    };
    final Function1D<Double, Double> dSigmaDx = returnZero;

    // !!! The line below, instead, computes the derivative using the interpolator
    //final Function1D<Double, Double> dSigmaDx = DIFFERENTIATOR.differentiate(interpFunc, domain);

    if (_extrapolatorFailureBehaviour.equalsIgnoreCase("Quiet")) {

      // The current *hard-coded* method reduces smile if the volatility gradient is either out of bounds of ShiftedLognormal model, or if root-finder fails to find solution
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3b907_67112/rev_3b907-67112;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;build();            logger.debug("estimated row count was %s of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, componentsFor(desc, false)));;            logger.debug("estimated row count was %s of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, SSTable.componentsFor(desc)));;            logger.debug("estimated row count was {} of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, SSTable.componentsFor(desc)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3c795_72d30/rev_3c795-72d30;/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration;addBlackCalculators(List<FunctionConfiguration>);    functionConfigs.add(new ParameterizedFunctionConfiguration(InterestRateFutureOptionBlackDefaultPropertiesFunction.class.getName(),
        Arrays.asList("FORWARD_3M", "FUNDING", "DEFAULT", "PresentValue", "USD", "EUR")));;    functionConfigs.add(new ParameterizedFunctionConfiguration(InterestRateFutureOptionBlackDefaultPropertiesFunction.class.getName(), 
        Arrays.asList("FORWARD_3M", "FUNDING", "DEFAULT", "PresentValue", "USD", "EUR")));;    functionConfigs.add(functionConfiguration(InterestRateFutureOptionBlackYieldCurveNodeSensitivitiesFunction.class));
    functionConfigs.add(functionConfiguration(InterestRateFutureOptionBlackGammaFunction.class));
    functionConfigs.add(new ParameterizedFunctionConfiguration(InterestRateFutureOptionBlackDefaultPropertiesFunction.class.getName(), 
        Arrays.asList("FORWARD_3M", "FUNDING", "DEFAULT", "PresentValue", "USD", "EUR")));  // TODO Change FORWARD_3M to FUTURES once available in db
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3cc86_18a1a/rev_3cc86-18a1a;/src/java/org/apache/cassandra/db/compaction/CompactionTask;execute(CompactionExecutorStatsCollector);        // The collection of sstables passed may be empty (but not null); even if
        // it is not empty, it may compact down to nothing if all rows are deleted.
        assert sstables != null;

        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);
        if (!isCompactionInteresting(toCompact))
            return 0;

        File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
        if (compactionFileLocation == null && partialCompactionsAcceptable())
        {
            // If the compaction file path is null that means we have no space left for this compaction.
            // Try again w/o the largest one.
            while (compactionFileLocation == null && toCompact.size() > 1)
            {
                logger.warn("insufficient space to compact all requested files " + StringUtils.join(toCompact, ", "));
                // Note that we have removed files that are still marked as compacting.
                // This suboptimal but ok since the caller will unmark all the sstables at the end.
                toCompact.remove(cfs.getMaxSizeFile(toCompact));
                compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
            }
        }

        if (compactionFileLocation == null)
        {
            logger.warn("insufficient space to compact; aborting compaction");
            return 0;
        }

        if (DatabaseDescriptor.isSnapshotBeforeCompaction())
            cfs.snapshotWithoutFlush(System.currentTimeMillis() + "-" + "compact-" + cfs.columnFamily);

        // sanity check: all sstables must belong to the same cfs
        for (SSTableReader sstable : toCompact)
            assert sstable.descriptor.cfname.equals(cfs.columnFamily);

        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);
        // new sstables from flush can be added during a compaction, but only the compaction can remove them,
        // so in our single-threaded compaction world this is a valid way of determining if we're compacting
        // all the sstables (that existed when we started)
        logger.info("Compacting {}", toCompact);

        long startTime = System.currentTimeMillis();
        long totalkeysWritten = 0;

        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));
        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / strategy.getMaxSSTableSize());
        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
        if (logger.isDebugEnabled())
            logger.debug("Expected bloom filter size : " + keysPerSSTable);

        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()
                                      ? new ParallelCompactionIterable(compactionType, strategy.getScanners(toCompact), controller)
                                      : new CompactionIterable(compactionType, strategy.getScanners(toCompact), controller);
        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());
        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();

        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to
        // replace the old entries.  Track entries to preheat here until then.
        Map<Descriptor, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<Descriptor, Map<DecoratedKey, Long>>();

        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();

        if (collector != null)
            collector.beginCompaction(ci);
        try
        {
            if (!nni.hasNext())
            {
                // don't mark compacted in the finally block, since if there _is_ nondeleted data,
                // we need to sync it (via closeAndOpen) first, so there is no period during which
                // a crash could cause data loss.
                cfs.markCompacted(toCompact, compactionType);
                return 0;
            }

            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
            writers.add(writer);
            while (nni.hasNext())
            {
                if (ci.isStopRequested())
                    throw new CompactionInterruptedException(ci.getCompactionInfo());

                AbstractCompactedRow row = nni.next();
                if (row.isEmpty())
                {
                    row.close();
                    continue;
                }

                long position = writer.append(row);
                totalkeysWritten++;

                if (DatabaseDescriptor.getPreheatKeyCache())
                {
                    for (SSTableReader sstable : toCompact)
                    {
                        if (sstable.getCachedPosition(row.key, false) != null)
                        {
                            cachedKeys.put(row.key, position);
                            break;
                        }
                    }
                }
                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                {
                    // tmp = false because later we want to query it with descriptor from SSTableReader
                    cachedKeyMap.put(writer.descriptor.asTemporary(false), cachedKeys);
                    if (nni.hasNext())
                    {
                        writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
                        writers.add(writer);
                        cachedKeys = new HashMap<DecoratedKey, Long>();
                    }
                }
            }

            long maxAge = getMaxDataAge(toCompact);
            for (SSTableWriter completedWriter : writers)
                sstables.add(completedWriter.closeAndOpenReader(maxAge));
        }
        catch (Exception e)
        {
            for (SSTableWriter writer : writers)
                writer.abort();
            // also remove already completed SSTables
            for (SSTableReader sstable : sstables)
            {
                sstable.markCompacted();
                sstable.releaseReference();
            }
            throw FBUtilities.unchecked(e);
        }
        finally
        {
            iter.close();
            if (collector != null)
                collector.finishCompaction(ci);
        }

        cfs.replaceCompactedSSTables(toCompact, sstables, compactionType);
        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up
        for (SSTableReader sstable : sstables)
        {
            for (Map.Entry<DecoratedKey, Long> entry : cachedKeyMap.get(sstable.descriptor).entrySet())
               sstable.cacheKey(entry.getKey(), entry.getValue());
        }

        long dTime = System.currentTimeMillis() - startTime;
        long startsize = SSTable.getTotalBytes(toCompact);
        long endsize = SSTable.getTotalBytes(sstables);
        double ratio = (double)endsize / (double)startsize;

        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (SSTableReader reader : sstables)
            builder.append(reader.getFilename()).append(",");
        builder.append("]");

        double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;
        logger.info(String.format("Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMB/s.  Time: %,dms.",
                                  builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));
        logger.debug(String.format("CF Total Bytes Compacted: %,d", CompactionTask.addToTotalBytesCompacted(endsize)));;        // The collection of sstables passed may be empty (but not null); even if
        // it is not empty, it may compact down to nothing if all rows are deleted.
        assert sstables != null;

        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);
        if (!isCompactionInteresting(toCompact))
            return 0;

        File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
        if (compactionFileLocation == null && partialCompactionsAcceptable())
        {
            // If the compaction file path is null that means we have no space left for this compaction.
            // Try again w/o the largest one.
            while (compactionFileLocation == null && toCompact.size() > 1)
            {
                logger.warn("insufficient space to compact all requested files " + StringUtils.join(toCompact, ", "));
                // Note that we have removed files that are still marked as compacting.
                // This suboptimal but ok since the caller will unmark all the sstables at the end.
                toCompact.remove(cfs.getMaxSizeFile(toCompact));
                compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
            }
        }

        if (compactionFileLocation == null)
        {
            logger.warn("insufficient space to compact; aborting compaction");
            return 0;
        }

        if (DatabaseDescriptor.isSnapshotBeforeCompaction())
            cfs.snapshotWithoutFlush(System.currentTimeMillis() + "-" + "compact-" + cfs.columnFamily);

        // sanity check: all sstables must belong to the same cfs
        for (SSTableReader sstable : toCompact)
            assert sstable.descriptor.cfname.equals(cfs.columnFamily);

        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);
        // new sstables from flush can be added during a compaction, but only the compaction can remove them,
        // so in our single-threaded compaction world this is a valid way of determining if we're compacting
        // all the sstables (that existed when we started)
        logger.info("Compacting {}", toCompact);

        long startTime = System.currentTimeMillis();
        long totalkeysWritten = 0;

        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));
        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / strategy.getMaxSSTableSize());
        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
        if (logger.isDebugEnabled())
            logger.debug("Expected bloom filter size : " + keysPerSSTable);

        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()
                                      ? new ParallelCompactionIterable(compactionType, strategy.getScanners(toCompact), controller)
                                      : new CompactionIterable(compactionType, strategy.getScanners(toCompact), controller);
        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());
        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();

        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to
        // replace the old entries.  Track entries to preheat here until then.
        Map<SSTableReader, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<SSTableReader, Map<DecoratedKey, Long>>();

        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();

        if (collector != null)
            collector.beginCompaction(ci);
        try
        {
            if (!nni.hasNext())
            {
                // don't mark compacted in the finally block, since if there _is_ nondeleted data,
                // we need to sync it (via closeAndOpen) first, so there is no period during which
                // a crash could cause data loss.
                cfs.markCompacted(toCompact, compactionType);
                return 0;
            }

            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
            writers.add(writer);
            while (nni.hasNext())
            {
                if (ci.isStopRequested())
                    throw new CompactionInterruptedException(ci.getCompactionInfo());

                AbstractCompactedRow row = nni.next();
                if (row.isEmpty())
                {
                    row.close();
                    continue;
                }

                long position = writer.append(row);
                totalkeysWritten++;

                if (DatabaseDescriptor.getPreheatKeyCache())
                {
                    for (SSTableReader sstable : toCompact)
                    {
                        if (sstable.getCachedPosition(row.key, false) != null)
                        {
                            cachedKeys.put(row.key, position);
                            break;
                        }
                    }
                }
                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                {
                    SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));
                    cachedKeyMap.put(toIndex, cachedKeys);
                    sstables.add(toIndex);
                    if (nni.hasNext())
                    {
                        writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
                        writers.add(writer);
                        cachedKeys = new HashMap<DecoratedKey, Long>();
                    }
                }
            }
        }
        catch (Exception e)
        {
            for (SSTableWriter writer : writers)
                writer.abort();
            throw FBUtilities.unchecked(e);
        }
        finally
        {
            iter.close();
            if (collector != null)
                collector.finishCompaction(ci);
        }

        cfs.replaceCompactedSSTables(toCompact, sstables, compactionType);
        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up
        for (Map.Entry<SSTableReader, Map<DecoratedKey, Long>> ssTableReaderMapEntry : cachedKeyMap.entrySet())
        {
            SSTableReader key = ssTableReaderMapEntry.getKey();
            for (Map.Entry<DecoratedKey, Long> entry : ssTableReaderMapEntry.getValue().entrySet())
               key.cacheKey(entry.getKey(), entry.getValue());
        }

        long dTime = System.currentTimeMillis() - startTime;
        long startsize = SSTable.getTotalBytes(toCompact);
        long endsize = SSTable.getTotalBytes(sstables);
        double ratio = (double)endsize / (double)startsize;

        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (SSTableReader reader : sstables)
            builder.append(reader.getFilename()).append(",");
        builder.append("]");

        double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;
        logger.info(String.format("Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMB/s.  Time: %,dms.",
                                  builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));
        logger.debug(String.format("CF Total Bytes Compacted: %,d", CompactionTask.addToTotalBytesCompacted(endsize)));;        this.collector = collector;
        run();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3d10f_0de41/rev_3d10f-0de41;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/interpolation/MonotoneConvexSplineInterpolatorTest;knotsControlTest1();    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27. };
    final double[] yValues = new double[] {3., 2., 2., 2., 3., 2.5, 2., 2., 3., 3., 2.5, 2., 2., 4., 5., 5., 4.9, 5., 6., 8., 3., -2., -1.5, -1., -2., -1.5, -1., };
    final int nData = xValues.length;
    double[] yValuesInput = new double[nData];
    for (int i = 0; i < nData; ++i) {
      yValuesInput[i] = yValues[i] * xValues[i];
    }

    final double[][] xValuesMatrix = new double[][] { {1., 2. }, {3., 4. } };
    final double[] xValuesMod = new double[] {1., 2., 3., 4. + 1.e-14, 5., 6. + 1.e-14, 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27. };
    final double[][] xValuesModMatrix = new double[][] { {1., 2. }, {3., 4. + 1.e-14 } };
    final double[][] yValuesMatrix = new double[][] { {3., 2. }, {2., 2. } };;    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27. };
    final double[] yValues = new double[] {3., 2., 2., 2., 3., 2.5, 2., 2., 3., 3., 2.5, 2., 2., 4., 5., 5., 4.9, 5., 6., 8., 3., -2., -1.5, -1., -2., -1.5, -1., };
    final double[][] xValuesMatrix = new double[][] { {1., 2. }, {3., 4. } };
    final double[] xValuesMod = new double[] {1., 2., 3., 4. + 1.e-14, 5., 6. + 1.e-14, 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27. };
    final double[][] xValuesModMatrix = new double[][] { {1., 2. }, {3., 4. + 1.e-14 } };
    final double[][] yValuesMatrix = new double[][] { {3., 2. }, {2., 2. } };;    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27.};
    final double[] yValues = new double[] {3., 2., 2., 2., 3., 2.5, 2., 2., 3., 3., 2.5, 2., 2., 4., 5., 5., 4.9, 5., 6., 8., 3., -2., -1.5, -1., -2., -1.5, -1.,};
    final double[][] xValuesMatrix = new double[][] { {1., 2.}, {3., 4.}};
    final double[] xValuesMod = new double[] {1., 2., 3., 4. + 1.e-14, 5., 6. + 1.e-14, 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27.};
    final double[][] xValuesModMatrix = new double[][] { {1., 2.}, {3., 4. + 1.e-14}};
    final double[][] yValuesMatrix = new double[][] { {3., 2.}, {2., 2.}};
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3d10f_0de41/rev_3d10f-0de41;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/interpolation/MonotoneConvexSplineInterpolatorTest;knotsControlTest1();    final double[] modifiedFwds = new double[] {0.75, 1.5, 2., 4., 0., -2, -2, 4., 6., -5., -7., -7., 4., 24.5, 10., 4.15, 5., 13.4, 35., -194., -214., -214., 10., -52., -52., 11.5, 12.25, };
    final double[][] modifiedFwdsMatrix = new double[][] { {0.75, 1.5 }, {2., 4. } };;    final double[] modifiedFwds = new double[] {0.75, 1.5, 2., 4., 0., -2, -2, 4., 6., -5., -7., -7., 4., 24.5, 10., 4.15, 5., 13.4, 35., -194., -214., -214., 10., -52., -52., 11.5, 12.25, };
    final double[][] modifiedFwdsMatrix = new double[][] { {0.75, 1.5 }, {2., 4. } };
    final int nData = xValues.length;;    final double[] modifiedFwds = new double[] {0.75, 1.5, 2., 4., 0., -2, -2, 4., 6., -5., -7., -7., 4., 24.5, 10., 4.15, 5., 13.4, 35., -194., -214., -214., 10., -52., -52., 11.5, 12.25,};
    final double[][] modifiedFwdsMatrix = new double[][] { {0.75, 1.5}, {2., 4.}};
    final int nData = xValues.length;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3d10f_0de41/rev_3d10f-0de41;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/interpolation/MonotoneConvexSplineInterpolatorTest;constTest();    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6. };
    final double[] yValuesTmp = new double[] {1., 1., 1., 1., 1., 1. };
    final int nData = xValues.length;
    final double[] yValues = new double[nData];
    for (int i = 0; i < xValues.length; ++i) {
      yValues[i] = yValuesTmp[i] * xValues[i];
    };    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6. };
    final double[] yValues = new double[] {1., 1., 1., 1., 1., 1. };;    final double[] xValues = new double[] {1., 2., 3., 4., 5., 6.};
    final double[] yValues = new double[] {1., 1., 1., 1., 1., 1.};
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3d10f_0de41/rev_3d10f-0de41;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/interpolation/MonotoneConvexSplineInterpolatorTest;positiveTest();    final double[] xValues = new double[] {0., 0.1, 1., 2., 6., 9., 30 };
    final double[] yValues = new double[] {0., 2., 2., 2., 3., 2., 1. };
    final int nData = xValues.length;
    double[] yValuesInput = new double[nData];
    for (int i = 0; i < nData; ++i) {
      yValuesInput[i] = xValues[i] * yValues[i];
    };    final double[] xValues = new double[] {0., 0.1, 1., 2., 6., 9., 30 };
    final double[] yValues = new double[] {0., 2., 2., 2., 3., 2., 1. };;    final double[] xValues = new double[] {0., 0.1, 1., 2., 6., 9., 30};
    final double[] yValues = new double[] {0., 2., 2., 2., 3., 2., 1.};
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3d10f_0de41/rev_3d10f-0de41;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/math/interpolation/MonotoneConvexSplineInterpolatorTest;monotonicTest();    final double[] xValues = new double[] {0., 0.3, 0.6, 1.5, 2.7, 3.4, 4.8, 5.9 };
    final int nData = xValues.length;
    final double[] yValuesTmp = new double[] {1.0, 1.2, 1.5, 2.0, 2.1, 3.0, 3.1, 3.3 };
    double[] yValues = new double[nData];
    for (int i = 0; i < nData; ++i) {
      yValues[i] = yValuesTmp[i] * xValues[i];
    };    final double[] xValues = new double[] {0., 0.3, 0.6, 1.5, 2.7, 3.4, 4.8, 5.9 };
    final double[] yValues = new double[] {1.0, 1.2, 1.5, 2.0, 2.1, 3.0, 3.1, 3.3 };;    final double[] xValues = new double[] {0., 0.3, 0.6, 1.5, 2.7, 3.4, 4.8, 5.9};
    final double[] yValues = new double[] {1.0, 1.2, 1.5, 2.0, 2.1, 3.0, 3.1, 3.3};
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3e6be_aa81b/rev_3e6be-aa81b;/src/com/opengamma/engine/view/SingleComputationCycle;prepareInputs();public boolean prepareInputs() {
    long snapshotTime = getProcessingContext().getLiveDataSnapshotProvider().snapshot();
    setSnapshotTime(snapshotTime);;public boolean prepareInputs() {
    setSnapshotTime(getProcessingContext().getLiveDataSnapshotProvider().snapshot());
    ViewComputationCache cache = getProcessingContext().getComputationCacheSource().getCache(getViewName(), getSnapshotTime());
    assert cache != null;
    setComputationCache(cache);;public void prepareInputs() {
    setSnapshotTime(getProcessingContext().getLiveDataSnapshotProvider().snapshot());
    ViewComputationCache cache = getProcessingContext().getComputationCacheSource().getCache(getViewName(), getSnapshotTime());
    assert cache != null;
    setComputationCache(cache);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3e7e5_16ad4/rev_3e7e5-16ad4;/projects/OG-Web/src/main/java/com/opengamma/web/spring/DemoStandardFunctionConfiguration;addEquityOptionCalculators(List<FunctionConfiguration>);        .useInterpolationMethodNames();
    final List<String> equityOptionPerEquityDefaults = new ArrayList<String>();
    equityOptionPerEquityDefaults.add(PriorityClass.ABOVE_NORMAL.name());
    equityOptionPerEquityDefaults.addAll(equityIndexOptionDefaults.createPerEquityDefaults());
    final List<String> equityOptionPerExchangeDefaults = new ArrayList<String>();
    equityOptionPerExchangeDefaults.add(PriorityClass.NORMAL.name());
    equityOptionPerExchangeDefaults.addAll(equityIndexOptionDefaults.createPerExchangeDefaults());
    final List<String> equityOptionPerCurrencyDefaults = new ArrayList<String>();
    equityOptionPerCurrencyDefaults.add(PriorityClass.BELOW_NORMAL.name());
    equityOptionPerCurrencyDefaults.addAll(equityIndexOptionDefaults.createPerCurrencyDefaults());
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityOptionPerTickerDefaults.class.getName(), equityOptionPerEquityDefaults));
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityOptionPerExchangeDefaults.class.getName(), equityOptionPerExchangeDefaults));
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityOptionPerCurrencyDefaults.class.getName(), equityOptionPerCurrencyDefaults));;        .useInterpolationMethodNames()
        .createDefaults();
    final List<String> equityIndexOptionDefaultsWithPriority = new ArrayList<String>();
    equityIndexOptionDefaultsWithPriority.add(PriorityClass.NORMAL.name());
    equityIndexOptionDefaultsWithPriority.addAll(equityIndexOptionDefaults);
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityOptionDefaults.class.getName(), equityIndexOptionDefaultsWithPriority));;        .useInterpolationMethodNames()
        .useForwardCurveNames()
        .useForwardCurveCalculationMethodNames();
    final List<String> equityOptionBlackSurfaceInterpolationDefaultsWithPriority = Lists.newArrayList(PriorityClass.NORMAL.name());
    equityOptionBlackSurfaceInterpolationDefaultsWithPriority.addAll(equityOptionBlackSurfaceInterpolationDefaults.createDefaults());
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityOptionInterpolatedBlackLognormalDefaults.class.getName(), equityOptionBlackSurfaceInterpolationDefaultsWithPriority));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3e70d_2eaea/rev_3e70d-2eaea;/src/java/org/apache/cassandra/db/ColumnFamilyStore;getTopLevelColumns(QueryFilter,int,boolean);        Tracing.trace("Executing single-partition query on {}", columnFamily);
        CollationController controller = new CollationController(this,
                                                                 forCache && !CacheService.instance.rowCache.isPutCopying(),
                                                                 filter,
                                                                 gcBefore);;        Tracing.trace("Executing single-partition query on {}", columnFamily);
        CollationController controller = new CollationController(this, forCache, filter, gcBefore);;        Tracing.trace("Executing single-partition query on {}", name);
        CollationController controller = new CollationController(this, forCache, filter, gcBefore);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3edc1_1ef9b/rev_3edc1-1ef9b;/tests/unit/com/opengamma/math/rootfinding/MultiInstrumentDoubleCurveBootstrapTest;testNewton();    // VectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    // doHotSpot(rootFinder, "default Newton FD , double curve", DOUBLE_CURVE_FINDER);

    VectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN,
        new SVDecompositionCommons());;    // VectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    // doHotSpot(rootFinder, "default Newton FD , double curve", DOUBLE_CURVE_FINDER);

    VectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN, new SVDecompositionCommons());;    VectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_3eec4_24b48/rev_3eec4-24b48;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/FixedIncomeInstrumentCurveExposureHelper;getCurveNamesForSecurity(FinancialSecurity,String,String);        return new String[] {fundingCurveName, forwardCurveName};
      case BOND_FUTURE:
        return new String[] {fundingCurveName, fundingCurveName};;        return new String[] {fundingCurveName, forwardCurveName};;        return new String[] {fundingCurveName, forwardCurveName };
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_3f05a_a4020/rev_3f05a-a4020;/src/main/java/org/junit/Assert;assertThat(String,T,Matcher<T>);		if (!matcher.matches(actual)) {
            Description description = new StringDescription();
            description.appendText(reason)
                       .appendText("\nExpected: ")
                       .appendDescriptionOf(matcher)
                       .appendText("\n     but: ");
            matcher.describeMismatch(actual, description);
			throw new java.lang.AssertionError(description.toString());
		};		if (!matcher.matches(actual)) {
			Description description= new StringDescription();
			description.appendText(reason);
			description.appendText("\nExpected: ");
			matcher.describeTo(description);
			description.appendText("\n     got: ").appendValue(actual)
					.appendText("\n");
			throw new java.lang.AssertionError(description.toString());
		};		MatcherAssert.assertThat(reason, actual, matcher);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_04ab5_87ae3/rev_04ab5-87ae3;/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientEdge;convertToDocument();    doc.field(OrientBaseGraph.CONNECTION_OUT, settings.keepInMemoryReferences ? vOutRecord.getIdentity() : vOutRecord);
    doc.field(OrientBaseGraph.CONNECTION_IN, settings.keepInMemoryReferences ? vInRecord.getIdentity() : vInRecord);;    doc.field(OrientBaseGraph.CONNECTION_OUT, graph.isKeepInMemoryReferences() ? vOutRecord.getIdentity() : vOutRecord);
    doc.field(OrientBaseGraph.CONNECTION_IN, graph.isKeepInMemoryReferences() ? vInRecord.getIdentity() : vInRecord);;    doc.field(OrientBaseGraph.CONNECTION_OUT, graph.isKeepInMemoryReferences() ? vOutRecord.getIdentity() : vOutRecord);
    doc.field(OrientBaseGraph.CONNECTION_IN, graph.isKeepInMemoryReferences() ? vInRecord.getIdentity() : vInRecord);
    doc.save();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4a4e7_b1d12/rev_4a4e7-b1d12;/test/unit/org/apache/cassandra/net/MessageSerializer;serialize(Message,DataOutput,int);        Header.serializer().serialize( t.header_, dos, version);;        assert t.getVersion() == version : "internode protocol version mismatch"; // indicates programmer error.
        Header.serializer().serialize( t.header_, dos, version);;        assert t.getVersion() == version : "internode protocol version mismatch"; // indicates programmer error.
        Header.serializer().serialize(t.header, dos, version);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4a010_1533f/rev_4a010-1533f;/src/java/org/apache/cassandra/config/DatabaseDescriptor;loadYaml();                authority = FBUtilities.<IAuthority>construct(conf.authority, "authority");

            if (conf.internode_authenticator != null)
                internodeAuthenticator = FBUtilities.construct(conf.internode_authenticator, "internode_authenticator");
            else
                internodeAuthenticator = new AllowAllInternodeAuthenticator();;                authority = FBUtilities.<IAuthority>construct(conf.authority, "authority");;            {
                logger.warn("Please rename 'authority' to 'authorizer' in cassandra.yaml");
                if (!conf.authority.equals("org.apache.cassandra.auth.AllowAllAuthority"))
                    throw new ConfigurationException("IAuthority interface has been deprecated,"
                                                     + " please implement IAuthorizer instead.");
            }

            if (conf.authorizer != null)
                authorizer = FBUtilities.construct(conf.authorizer, "authorizer");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4a010_1533f/rev_4a010-1533f;/src/java/org/apache/cassandra/config/DatabaseDescriptor;loadYaml();            authority.validateConfiguration();
            internodeAuthenticator.validateConfiguration();;            authority.validateConfiguration();;            authorizer.validateConfiguration();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4a604_c5c07/rev_4a604-c5c07;/src/java/org/apache/cassandra/db/commitlog/CommitLog;recover(File[]);                                Table.open(newRm.getTable()).apply(newRm, null, false);
                                tablesRecovered.add(table);;                                Table.open(newRm.getTable()).apply(newRm, null, false);;                                Table.open(newRm.getTable()).apply(newRm, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4a604_c5c07/rev_4a604-c5c07;/src/java/org/apache/cassandra/gms/Gossiper;start(int);        maybeInitializeLocalState(generationNbr);
        EndpointState localState = endpointStateMap_.get(localEndpoint_);;        EndpointState localState = endpointStateMap_.get(localEndpoint_);
        if ( localState == null )
        {
            HeartBeatState hbState = new HeartBeatState(generationNbr);
            localState = new EndpointState(hbState);
            localState.isAlive(true);
            localState.isAGossiper(true);
            endpointStateMap_.put(localEndpoint_, localState);
        };        EndpointState localState = endpointStateMap.get(FBUtilities.getLocalAddress());
        if ( localState == null )
        {
            HeartBeatState hbState = new HeartBeatState(generationNbr);
            localState = new EndpointState(hbState);
            localState.markAlive();
            endpointStateMap.put(FBUtilities.getLocalAddress(), localState);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4aa82_7b6ac/rev_4aa82-7b6ac;/projects/OG-Integration/src/main/java/com/opengamma/integration/tool/marketdata/MarketDataSnapshotTool;doRun();      for (StructuredMarketDataSnapshot snapshot : task.get()) {
        ManageableMarketDataSnapshot manageableMarketDataSnapshot = new ManageableMarketDataSnapshot(snapshot);
        manageableMarketDataSnapshot.setName(snapshot.getBasisViewName() + "/" + valuationInstant);;      for (StructuredMarketDataSnapshot snapshot : task.get()) {
        ManageableMarketDataSnapshot manageableMarketDataSnapshot = new ManageableMarketDataSnapshot(
            snapshot.getBasisViewName() + "/" + valuationInstant, snapshot.getGlobalValues(), snapshot.getYieldCurves());;      for (final StructuredMarketDataSnapshot snapshot : task.get()) {
        final ManageableMarketDataSnapshot manageableMarketDataSnapshot = new ManageableMarketDataSnapshot(snapshot);
        manageableMarketDataSnapshot.setBasisViewName(snapshot.getBasisViewName() + "/" + valuationInstant);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4bfd8_543bd/rev_4bfd8-543bd;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, getFundingCurveDefinitionName()).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4c22b_c0aa7/rev_4c22b-c0aa7;/tools/stress/src/org/apache/cassandra/stress/operations/CqlIndexedRangeSlicer;buildQuery();        StringBuilder query = new StringBuilder("SELECT ");

        if (state.isCql2())
            query.append(state.settings.columns.maxColumnsPerKey).append(" ''..''");
        else
            query.append("*");

        query.append(" FROM ");
        query.append(wrapInQuotesIfRequired(state.type.table));

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        final String columnName = (state.settings.columns.namestrs.get(1));;        StringBuilder query = new StringBuilder("SELECT ");

        if (state.isCql2())
            query.append(state.settings.columns.maxColumnsPerKey).append(" ''..''");
        else
            query.append("*");

        query.append(" FROM Standard1");

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        final String columnName = getColumnName(1);;        StringBuilder query = new StringBuilder("SELECT * FROM \"Standard1\"");
        final String columnName = getColumnName(1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4c22b_c0aa7/rev_4c22b-c0aa7;/tools/stress/src/org/apache/cassandra/stress/operations/CqlRangeSlicer;buildQuery();        StringBuilder query = new StringBuilder("SELECT FIRST ").append(state.settings.columns.maxColumnsPerKey)
                .append(" ''..'' FROM ").append(wrapInQuotesIfRequired(state.type.table));

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        return query.append(" WHERE KEY > ?").toString();;        StringBuilder query = new StringBuilder("SELECT FIRST ").append(state.settings.columns.maxColumnsPerKey)
                .append(" ''..'' FROM ").append(state.settings.schema.columnFamily);

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        return query.append(" WHERE KEY > ?").toString();;        return "SELECT FIRST " + state.settings.columns.maxColumnsPerKey + " ''..'' FROM " + state.settings.schema.columnFamily + " WHERE KEY > ?";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4c22b_c0aa7/rev_4c22b-c0aa7;/tools/stress/src/org/apache/cassandra/stress/operations/CqlCounterGetter;buildQuery();        StringBuilder query = new StringBuilder("SELECT ");

        // TODO: obey slice/noslice option (instead of always slicing)
        if (state.isCql2())
            query.append("FIRST ").append(state.settings.columns.maxColumnsPerKey).append(" ''..''");
        else
            query.append("*");

        String counterCF = state.isCql2() ? state.type.table : "Counter3";

        query.append(" FROM ").append(wrapInQuotesIfRequired(counterCF));

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        return query.append(" WHERE KEY=?").toString();;        StringBuilder query = new StringBuilder("SELECT ");

        if (state.isCql2())
            query.append("FIRST ").append(state.settings.columns.maxColumnsPerKey).append(" ''..''");
        else
            query.append("*");

        String counterCF = state.isCql2() ? "Counter1" : "Counter3";

        query.append(" FROM ").append(wrapInQuotesIfRequired(counterCF));

        if (state.isCql2())
            query.append(" USING CONSISTENCY ").append(state.settings.command.consistencyLevel);

        return query.append(" WHERE KEY=?").toString();;        return "SELECT * FROM \"Counter3\" USING CONSISTENCY " + state.settings.command.consistencyLevel + " WHERE KEY=?";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4c25e_02b51/rev_4c25e-02b51;/src/java/org/apache/cassandra/thrift/CassandraServer;describe_keyspace(String);        validateLogin();

        KSMetaData ksm = Schema.instance.getTableDefinition(table);;        KSMetaData ksm = Schema.instance.getTableDefinition(table);;        KSMetaData ksm = Schema.instance.getKSMetaData(table);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriterConfig;testInvalidValues();    IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));
    ;    IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer());
    ;    IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testCommitOnClose();        Directory dir = newDirectory();      
        IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)));;        Directory dir = newDirectory();      
        IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()));;        Directory dir = newDirectory();
        IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testCommitOnCloseAbort();      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();
      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testIndexNoDocuments();      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)));;      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()));;      MockDirectoryWrapper dir = newDirectory();
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testManyFields();      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testDiverseDocs();      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setRAMBufferSizeMB(0.5));;      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setRAMBufferSizeMB(0.5));;      MockDirectoryWrapper dir = newDirectory();
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setRAMBufferSizeMB(0.5));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testEnablingNorms();      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();      
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));;      MockDirectoryWrapper dir = newDirectory();
      IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(10));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testBadSegment();        TEST_VERSION_CURRENT, new MockAnalyzer(random)));
    ;        TEST_VERSION_CURRENT, new MockAnalyzer()));
    ;        TEST_VERSION_CURRENT, new MockAnalyzer()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testExpungeDeletes();    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random));    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer());    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testCommitUserData();      
    w = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2));;      
    w = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2));;
    w = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;run();            IndexWriterConfig conf = newIndexWriterConfig( 
                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);;            IndexWriterConfig conf = newIndexWriterConfig( 
                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);;            IndexWriterConfig conf = newIndexWriterConfig(
                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testNoDocsIndex();    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random)));;    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer()));;    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testCommitThreadSafety();    final RandomIndexWriter w = new RandomIndexWriter(random, dir, newIndexWriterConfig( 
                                                                                        TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));;    final RandomIndexWriter w = new RandomIndexWriter(random, dir, newIndexWriterConfig( 
                                                                                        TEST_VERSION_CURRENT, new MockAnalyzer()).setMergePolicy(newLogMergePolicy()));;    final RandomIndexWriter w = new RandomIndexWriter(random, dir, newIndexWriterConfig(
                                                                                        TEST_VERSION_CURRENT, new MockAnalyzer()).setMergePolicy(newLogMergePolicy()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testDeleteUnsedFiles2();    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random));    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer());    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testEmptyDirRollback();    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random));    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer());    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testNoSegmentFile();    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2));
    ;    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2));
    ;    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4d8d5_6c29a/rev_4d8d5-6c29a;/lucene/src/test/org/apache/lucene/index/TestIndexWriter;testNoSegmentFile();    IndexWriter w2 = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);    IndexWriter w2 = new IndexWriter(dir, newIndexWriterConfig( 
        TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);    IndexWriter w2 = new IndexWriter(dir, newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackBaseClient;getWebResource();		if (serviceWebResource == null) {
			this.renewTokenIfNeeded();

			String endpoint = this.getEndpointByName(this.getServiceName());
			if (endpoint == null) {
				logger.finer("EndPoint by name returned null, trying to get service endpoint by its type '"
						+ this.getDefaultServiceType() + "'");
				endpoint = this.getServiceNameByType(this.getDefaultServiceType());
			}

			if (endpoint == null) {
				throw new OpenstackException("Cannot find endpoint for service '"
						+ this.getServiceName() + "' in the service catalog.");;		if (serviceWebResource == null) {
			this.renewTokenIfNeeded();
			final String endpoint = this.getEndpoint(this.getServiceName());
			if (endpoint == null) {
				throw new OpenstackException("Cannot find endpoint for service '"
						+ this.getServiceName() + "' in the service catalog.");;		synchronized (this.webResourceMutex) {
			if (this.serviceWebResource == null) {
				this.renewTokenIfNeeded();
				final String endpoint = this.getEndpoint(this.getServiceName());
				if (endpoint == null) {
					throw new OpenstackException("Cannot find endpoint for service '"
							+ this.getServiceName() + "' in the service catalog.");
				}
				this.serviceClient = Client.create();
				if (WIRE_LOGGER.isLoggable(Level.FINE)) {
					this.serviceClient.addFilter(new LoggingFilter(WIRE_LOGGER));
				}
				this.serviceWebResource = this.serviceClient.resource(endpoint);
				logger.info("Openstack " + this.getServiceName() + " endpoint: " + endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackBaseClient;getWebResource();
			this.serviceClient = Client.create();
			this.serviceWebResource = serviceClient.resource(endpoint);
			logger.info("Openstack endpoint: " + endpoint);;			this.serviceClient = Client.create();
			this.serviceWebResource = serviceClient.resource(endpoint);
			logger.info("Openstack " + this.getServiceName() + " endpoint: " + endpoint);;			return serviceWebResource;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackNetworkClient;OpenStackNetworkClient(String,String,String,String,String,String,String);		this.initToken();;		logger.info("Openstack " + this.serviceName + " api version: " + this.networkApiVersion);
		this.initToken();;		logger.info("Openstack " + this.serviceName + " api version: " + this.networkApiVersion);
		// this.initToken();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackComputeClient;OpenStackComputeClient(String,String,String,String,String,String);		this.serviceName = serviceName;
		this.initToken();;		this.serviceName = StringUtils.isEmpty(serviceName) ? "nova" : serviceName;
		this.initToken();;		this.serviceName = StringUtils.isEmpty(serviceName) ? "nova" : serviceName;
		// this.initToken();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4efe5_2c926/rev_4efe5-2c926;/lucene/core/src/java/org/apache/lucene/codecs/intblock/FixedIntBlockIndexInput;Reader(IndexInput,int[],BlockReader);public Reader(final IndexInput in, final int[] pending, final BlockReader blockReader) {;public Reader(final IndexInput in, final int[] pending, final BlockReader blockReader)
    throws IOException {;public Reader(final IndexInput in, final int[] pending, final BlockReader blockReader)
      throws IOException {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_4efe5_54581/rev_4efe5-54581;/src/com/opengamma/engine/test/CalculationNodeUtils;getCalculationJob(MockFunction);        function.getUniqueIdentifier(), function.getTarget().toSpecification(), function.getRequirements(), function.getResultRequirements());;        function.getUniqueIdentifier(), 
        function.getTarget().toSpecification(), 
        function.getRequirements(), 
        function.getResultRequirements());;        function.getUniqueIdentifier(), 
        function.getDefaultParameters(),
        function.getTarget().toSpecification(), 
        function.getRequirements(), 
        function.getResultRequirements());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4f3a9_bd889/rev_4f3a9-bd889;/test/unit/org/apache/cassandra/db/compaction/AntiCompactionTest;antiCompactOne();        ColumnFamilyStore store = prepareColumnFamilyStore();;        Keyspace keyspace = Keyspace.open(KEYSPACE1);
        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF);
        store.disableAutoCompaction();
        long timestamp = System.currentTimeMillis();
        for (int i = 0; i < 10; i++)
        {
            DecoratedKey key = Util.dk(Integer.toString(i));
            Mutation rm = new Mutation(KEYSPACE1, key.getKey());
            for (int j = 0; j < 10; j++)
                rm.add("Standard1", Util.cellname(Integer.toString(j)),
                       ByteBufferUtil.EMPTY_BYTE_BUFFER,
                       timestamp,
                       0);
            rm.apply();
        }
        store.forceBlockingFlush();;        Keyspace keyspace = Keyspace.open(KEYSPACE1);
        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF);
        store.disableAutoCompaction();
        long timestamp = System.currentTimeMillis();
        for (int i = 0; i < 10; i++)
        {
            DecoratedKey key = Util.dk(Integer.toString(i));
            Mutation rm = new Mutation(KEYSPACE1, key.getKey());
            for (int j = 0; j < 10; j++)
                rm.add(CF, Util.cellname(Integer.toString(j)),
                       ByteBufferUtil.EMPTY_BYTE_BUFFER,
                       timestamp,
                       0);
            rm.applyUnsafe();
        }
        store.forceBlockingFlush();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4f758_313c7/rev_4f758-313c7;/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader;SimpleSliceReader(SSTableReader,RowIndexEntry,FileDataInput,ByteBuffer);            emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));
            atomSerializer = emptyColumnFamily.getOnDiskSerializer();
            columns = file.readInt();;            emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, sstable.descriptor.version));
            atomSerializer = emptyColumnFamily.getOnDiskSerializer();
            columns = file.readInt();;            emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, sstable.descriptor.version));
            atomIterator = emptyColumnFamily.metadata().getOnDiskIterator(file, file.readInt(), sstable.descriptor.version);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;newTestWriteEndpointsDuringMove();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;newTestWriteEndpointsDuringMove();        ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(newToken));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(newToken));;        ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;testSimultaneousMove();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;testSimultaneousMove();        ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5)));;        Gossiper.instance.initializeNodeUnsafe(boot1, UUID.randomUUID(), 1);
        Gossiper.instance.injectApplicationState(boot1, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(5))));
        ss.onChange(boot1,
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;testSimultaneousMove();        ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));;        Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
        Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
        ss.onChange(boot2,
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;testStateJumpToNormal();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_4ff5b_5e57a/rev_4ff5b-5e57a;/test/unit/org/apache/cassandra/service/MoveTest;testStateJumpToNormal();        PendingRangeCalculatorService.instance.blockUntilFinished();
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(newToken));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(newToken)));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(newToken)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_05a39_77db8/rev_05a39-77db8;/src/java/org/apache/cassandra/cql3/Lists;execute(ByteBuffer,ColumnFamily,ColumnNameBuilder,UpdateParameters);            List<Pair<ByteBuffer, IColumn>> existingList = params.getPrefetchedList(rowKey, columnName.key);
            int idx = ByteBufferUtil.toInt(index);;            List<Pair<ByteBuffer, IColumn>> existingList = params.getPrefetchedList(rowKey, columnName.key);
            int idx = ByteBufferUtil.toInt(((Constants.Value)index).bytes);;            List<Pair<ByteBuffer, Column>> existingList = params.getPrefetchedList(rowKey, columnName.key);
            int idx = ByteBufferUtil.toInt(((Constants.Value)index).bytes);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_5a893_6d0a6/rev_5a893-6d0a6;/core/src/main/java/com/orientechnologies/orient/core/index/hashindex/local/OLocalHashTable;doPut(K,V);          bucket.deleteEntry(index);
          size--;
          markPageAsDirty(pageIndex, fileLevel);;          bucket.updateEntry(index, value);
          return;;          bucket.updateEntry(index, value);
          markPageAsDirty(pageIndex, fileLevel);

          return;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5abee_5a901/rev_5abee-5a901;/src/java/org/apache/cassandra/config/DatabaseDescriptor;loadYaml();                conf.rpc_min_threads = conf.rpc_server_type.toLowerCase().equals("hsha")
                                     ? FBUtilities.getAvailableProcessors() * 4
                                     : 16;;                conf.rpc_min_threads = conf.rpc_server_type.toLowerCase().equals("hsha")
                                     ? Runtime.getRuntime().availableProcessors() * 4
                                     : 16;;                conf.rpc_min_threads = 16;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5abee_5a901/rev_5abee-5a901;/src/java/org/apache/cassandra/config/DatabaseDescriptor;loadYaml();                conf.rpc_max_threads = conf.rpc_server_type.toLowerCase().equals("hsha")
                                     ? FBUtilities.getAvailableProcessors() * 4
                                     : Integer.MAX_VALUE;;                conf.rpc_max_threads = conf.rpc_server_type.toLowerCase().equals("hsha")
                                     ? Runtime.getRuntime().availableProcessors() * 4
                                     : Integer.MAX_VALUE;;                conf.rpc_max_threads = Integer.MAX_VALUE;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5aef3_9779b/rev_5aef3-9779b;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;test();    assertEquals(FRA.accept(VISITOR), "FRA2");
    assertEquals(FRA.accept(VISITOR, o), "FRA1");
    assertEquals(IR_FUTURE.accept(VISITOR), "IRFuture2");
    assertEquals(IR_FUTURE.accept(VISITOR, o), "IRFuture1");
    assertEquals(ANNUITY_FIXED.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "Annuity1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "Annuity1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "Annuity1");;    assertEquals(FRA.accept(VISITOR), "FRA2");
    assertEquals(FRA.accept(VISITOR, o), "FRA1");
    assertEquals(IR_FUTURE.accept(VISITOR), "IRFuture2");
    assertEquals(IR_FUTURE.accept(VISITOR, o), "IRFuture1");
    assertEquals(ANNUITY_FIXED.accept(VISITOR), "AnnuityCouponFixed2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "AnnuityCouponFixed1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "AnnuityCouponIbor2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "AnnuityCouponIbor1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "AnnuityCouponIborSpread2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "AnnuityCouponIborSpread1");;    assertEquals(ANNUITY_FIXED.accept(VISITOR), "AnnuityCouponFixed2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "AnnuityCouponFixed1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "AnnuityCouponIbor2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "AnnuityCouponIbor1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "AnnuityCouponIborSpread2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "AnnuityCouponIborSpread1");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.memtableLiveDataSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableLiveDataSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOnHeapSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);        }); 
        memtableOnHeapDataSize = createKeyspaceGauge("MemtableOnHeapDataSize", new MetricValue();        });
        memtableOnHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOnHeapDataSize"), new Gauge<Long>();        });
        memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOffHeapDataSize"), new Gauge<Long>()
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.memtableOnHeapSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOnHeapSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOffHeapSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.memtableOffHeapSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOffHeapSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableLiveDataSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.allMemtablesLiveDataSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesLiveDataSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOnHeapSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.allMemtablesOnHeapSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOnHeapSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOffHeapSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.allMemtablesOffHeapSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOffHeapSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesLiveDataSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b8ac_33c5e/rev_5b8ac-33c5e;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;release();        for(String name : allMetrics) 
        {
            Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
        }
        // latency metrics contain multiple metrics internally and need to be released manually
        readLatency.release();
        writeLatency.release();
        rangeLatency.release();;        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOnHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOffHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableLiveDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOnHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOffHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingFlushes"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingCompactions"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));;        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOnHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOffHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableLiveDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOnHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOffHeapDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingFlushes"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5b9c5_56e65/rev_5b9c5-56e65;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/credit/ISDAYieldCurveFunction;compile(FunctionCompilationContext,Instant);        final SnapshotDataBundle data = (SnapshotDataBundle) dataObject;
        final Map<ExternalId, Double> marketData = data.getDataPoints();
        final InterpolatedYieldCurveSpecification specification = getCurveSpecification(curveDefinition, LocalDate.parse(curveDate));
        final InterpolatedYieldCurveSpecificationWithSecurities specificationWithSecurities = getCurveWithSecurities(specification, executionContext, marketData);;        final InterpolatedYieldCurveSpecificationWithSecurities specification = (InterpolatedYieldCurveSpecificationWithSecurities) specificationObject;
        final SnapshotDataBundle data = (SnapshotDataBundle) dataObject;
        final Map<ExternalId, Double> marketData = data.getDataPoints();;        final InterpolatedYieldCurveSpecificationWithSecurities specification = (InterpolatedYieldCurveSpecificationWithSecurities) specificationObject;
        final SnapshotDataBundle marketData = (SnapshotDataBundle) dataObject;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5b511_bddfa/rev_5b511-bddfa;/src/java/org/apache/cassandra/db/context/CounterContext;merge(ByteBuffer,ByteBuffer,Allocator);                            logger.warn("invalid counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                        + "count; will pick highest to self-heal on compaction",
                                        new Object[] { leftState.getNodeId(), leftClock, leftCount, rightState.getNodeId(), rightClock, rightCount, });;                            logger.error("invalid counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                    + "count; will pick highest to self-heal; this indicates a bug or corruption generated a bad counter shard",
                                    new Object[] {
                                            leftState.getNodeId(), leftClock, leftCount,
                                            rightState.getNodeId(), rightClock, rightCount,
                                     });;                            logger.error("invalid counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                    + "count; will pick highest to self-heal; this indicates a bug or corruption generated a bad counter shard",
                                    new Object[] {
                                            leftState.getCounterId(), leftClock, leftCount,
                                            rightState.getCounterId(), rightClock, rightCount,
                                     });
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5cda7_cfe58/rev_5cda7-cfe58;/src/java/org/apache/cassandra/io/sstable/SSTableReader;getPosition(RowPosition,Operator);        return getPosition(key, op, true);;        // first, check bloom filter
        if (op == Operator.EQ)
        {
            assert key instanceof DecoratedKey; // EQ only make sense if the key is a valid row key
            if (!bf.isPresent(((DecoratedKey)key).key))
                return -1;
        }

        // next, the key cache (only make sense for valid row key)
        if ((op == Operator.EQ || op == Operator.GE) && (key instanceof DecoratedKey))
        {
            DecoratedKey decoratedKey = (DecoratedKey)key;
            Long cachedPosition = getCachedPosition(new KeyCacheKey(descriptor, decoratedKey.key), true);
            if (cachedPosition != null)
                return cachedPosition;
        }

        // next, see if the sampled index says it's impossible for the key to be present
        long sampledPosition = getIndexScanPosition(key);
        if (sampledPosition == -1)
        {
            if (op == Operator.EQ)
                bloomFilterTracker.addFalsePositive();
            // we matched the -1th position: if the operator might match forward, return the 0th position
            return op.apply(1) >= 0 ? 0 : -1;
        }

        // scan the on-disk index, starting at the nearest sampled position
        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition, INDEX_FILE_BUFFER_BYTES);
        while (segments.hasNext())
        {
            FileDataInput input = segments.next();
            try
            {
                while (!input.isEOF())
                {
                    // read key & data position from index entry
                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));
                    long dataPosition = input.readLong();

                    int comparison = indexDecoratedKey.compareTo(key);
                    int v = op.apply(comparison);
                    if (v == 0)
                    {
                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)
                        {
                            assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key
                            DecoratedKey decoratedKey = (DecoratedKey)key;
                            // store exact match for the key
                            cacheKey(decoratedKey, dataPosition);
                        }
                        if (op == Operator.EQ)
                            bloomFilterTracker.addTruePositive();
                        return dataPosition;
                    }
                    if (v < 0)
                    {
                        if (op == Operator.EQ)
                            bloomFilterTracker.addFalsePositive();
                        return -1;
                    }
                }
            }
            catch (IOException e)
            {
                markSuspect();
                throw new IOError(e);
            }
            finally
            {
                FileUtils.closeQuietly(input);
            }
        }

        if (op == Operator.EQ)
            bloomFilterTracker.addFalsePositive();
        return -1;;        // first, check bloom filter
        if (op == Operator.EQ)
        {
            assert key instanceof DecoratedKey; // EQ only make sense if the key is a valid row key
            if (!bf.isPresent(((DecoratedKey)key).key))
                return null;
        }

        // next, the key cache (only make sense for valid row key)
        if ((op == Operator.EQ || op == Operator.GE) && (key instanceof DecoratedKey))
        {
            DecoratedKey decoratedKey = (DecoratedKey)key;
            RowIndexEntry cachedPosition = getCachedPosition(new KeyCacheKey(descriptor, decoratedKey.key), true);
            if (cachedPosition != null)
                return cachedPosition;
        }

        // next, see if the sampled index says it's impossible for the key to be present
        long sampledPosition = getIndexScanPosition(key);
        if (sampledPosition == -1)
        {
            if (op == Operator.EQ)
                bloomFilterTracker.addFalsePositive();
            // we matched the -1th position: if the operator might match forward, we'll start at the first
            // position. We however need to return the correct index entry for that first position.
            if (op.apply(1) >= 0)
                sampledPosition = 0;
            else
                return null;
        }

        // scan the on-disk index, starting at the nearest sampled position
        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition, INDEX_FILE_BUFFER_BYTES);
        while (segments.hasNext())
        {
            FileDataInput input = segments.next();
            try
            {
                while (!input.isEOF())
                {
                    // read key & data position from index entry
                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));
                    int comparison = indexDecoratedKey.compareTo(key);
                    int v = op.apply(comparison);
                    if (v == 0)
                    {
                        RowIndexEntry indexEntry = RowIndexEntry.serializer.deserialize(input, descriptor.version);
                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)
                        {
                            assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key
                            DecoratedKey decoratedKey = (DecoratedKey)key;
                            // store exact match for the key
                            cacheKey(decoratedKey, indexEntry);
                        }
                        if (op == Operator.EQ)
                            bloomFilterTracker.addTruePositive();
                        return indexEntry;
                    }
                    if (v < 0)
                    {
                        if (op == Operator.EQ)
                            bloomFilterTracker.addFalsePositive();
                        return null;
                    }
                    RowIndexEntry.serializer.skip(input, descriptor.version);
                }
            }
            catch (IOException e)
            {
                markSuspect();
                throw new IOError(e);
            }
            finally
            {
                FileUtils.closeQuietly(input);
            }
        }

        if (op == Operator.EQ)
            bloomFilterTracker.addFalsePositive();
        return null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5d5f2_160ee/rev_5d5f2-160ee;/projects/OG-Financial/src/com/opengamma/financial/fudgemsg/VolatilitySurfaceSpeficiationBuilder;buildObject(FudgeDeserializationContext,FudgeMsg);      target = context.fieldValueToObject(UniqueIdentifiable.class, message.getByName("target"));;//      try {
        target = context.fieldValueToObject(UniqueIdentifiable.class, message.getByName("target"));
//      } catch (Exception fre) { // arghhhhhh
//        target = Currency.of(message.getString("target"));
//      };//      try {
      target = context.fieldValueToObject(UniqueIdentifiable.class, message.getByName("target"));
//      } catch (Exception fre) { // arghhhhhh
//        target = Currency.of(message.getString("target"));
//      }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5df7b_b2899/rev_5df7b-b2899;/src/java/org/apache/cassandra/db/commitlog/CommitLogSegment;CommitLogSegment(String);        id = getNextId();
        logFile = new File(DatabaseDescriptor.getCommitLogLocation(), FILENAME_PREFIX + id + FILENAME_EXTENSION);;        id = System.nanoTime();
        logFile = new File(DatabaseDescriptor.getCommitLogLocation(), FILENAME_PREFIX + id + FILENAME_EXTENSION);;        id = System.nanoTime();
        descriptor = new CommitLogDescriptor(id);
        logFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_5df7b_b2899/rev_5df7b-b2899;/src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver;maybeRestoreArchive();                File toFile = new File(DatabaseDescriptor.getCommitLogLocation(),
                                       CommitLogSegment.FILENAME_PREFIX +
                                       CommitLogSegment.getNextId() +
                                       CommitLogSegment.FILENAME_EXTENSION);             ;                File toFile = new File(DatabaseDescriptor.getCommitLogLocation(),
                                       CommitLogSegment.FILENAME_PREFIX +
                                       System.nanoTime() +
                                       CommitLogSegment.FILENAME_EXTENSION);             ;                File toFile = new File(DatabaseDescriptor.getCommitLogLocation(), new CommitLogDescriptor(System.nanoTime()).fileName());            
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5ffb0_ad675/rev_5ffb0-ad675;/projects/OG-Analytics/tests/unit/com/opengamma/math/statistics/leastsquare/NonLinearLeastSquareTest;smallPertubationTest();    final DoubleMatrix2D res = ls.calInverseJacobian(SIGMA,FUNCTION,GRAD,solution);
  //  System.out.println("invese Jac: " + res);
    
    DoubleMatrix1D deltaParms = (DoubleMatrix1D) ma.multiply(res, deltaY);
   // System.out.println("delta parms: " + deltaParms);
    
    DoubleMatrix1D y = (DoubleMatrix1D) ma.add(Y, deltaY);
    ;    final DoubleMatrix2D res = ls.calInverseJacobian(SIGMA,FUNCTION,GRAD,solution);
    System.out.println("invese Jac: " + res);
    
    DoubleMatrix1D deltaParms = (DoubleMatrix1D) ma.multiply(res, deltaY);
    System.out.println("delta parms: " + deltaParms);
    
    DoubleMatrix1D y = (DoubleMatrix1D) ma.add(Y, deltaY);
    ;    final DoubleMatrix2D res = ls.calInverseJacobian(SIGMA, FUNCTION, GRAD, solution);
    System.out.println("invese Jac: " + res);

    final DoubleMatrix1D deltaParms = (DoubleMatrix1D) ma.multiply(res, deltaY);
    System.out.println("delta parms: " + deltaParms);

    final DoubleMatrix1D y = (DoubleMatrix1D) ma.add(Y, deltaY);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_5ffb0_ad675/rev_5ffb0-ad675;/projects/OG-Analytics/tests/unit/com/opengamma/math/statistics/leastsquare/NonLinearLeastSquareTest;smallPertubationTest();    DoubleMatrix1D trueDeltaParms  = (DoubleMatrix1D) ma.subtract(lsRes.getParameters(), solution);
   // System.out.println("true delta parms: " + trueDeltaParms);
 
    assertEquals(trueDeltaParms.getEntry(0),deltaParms.getEntry(0),5e-5);
    assertEquals(trueDeltaParms.getEntry(1),deltaParms.getEntry(1),5e-5);
    assertEquals(trueDeltaParms.getEntry(2),deltaParms.getEntry(2),5e-5);
    assertEquals(trueDeltaParms.getEntry(3),deltaParms.getEntry(3),5e-5);
   };    DoubleMatrix1D trueDeltaParms  = (DoubleMatrix1D) ma.subtract(lsRes.getParameters(), solution);
    System.out.println("true delta parms: " + trueDeltaParms);
 
    assertEquals(trueDeltaParms.getEntry(0),deltaParms.getEntry(0),5e-5);
    assertEquals(trueDeltaParms.getEntry(1),deltaParms.getEntry(1),5e-5);
    assertEquals(trueDeltaParms.getEntry(2),deltaParms.getEntry(2),5e-5);
    assertEquals(trueDeltaParms.getEntry(3),deltaParms.getEntry(3),5e-5);
   };    final DoubleMatrix1D trueDeltaParms = (DoubleMatrix1D) ma.subtract(lsRes.getParameters(), solution);
    System.out.println("true delta parms: " + trueDeltaParms);

    assertEquals(trueDeltaParms.getEntry(0), deltaParms.getEntry(0), 5e-5);
    assertEquals(trueDeltaParms.getEntry(1), deltaParms.getEntry(1), 5e-5);
    assertEquals(trueDeltaParms.getEntry(2), deltaParms.getEntry(2), 5e-5);
    assertEquals(trueDeltaParms.getEntry(3), deltaParms.getEntry(3), 5e-5);
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6a6b7_f650d/rev_6a6b7-f650d;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;deserialize(DataInputStream,Descriptor);                                    : Double.MIN_VALUE;
            String partitioner = desc.hasPartitioner ? dis.readUTF() : null;
            int nbAncestors = desc.hasAncestors ? dis.readInt() : 0;
            Set<Integer> ancestors = new HashSet<Integer>(nbAncestors);
            for (int i = 0; i < nbAncestors; i++)
                ancestors.add(dis.readInt());
            return new SSTableMetadata(rowSizes, columnCounts, replayPosition, maxTimestamp, compressionRatio, partitioner, ancestors);;                                    : Double.MIN_VALUE;
            String partitioner = desc.hasPartitioner ? dis.readUTF() : null;
            return new SSTableMetadata(rowSizes, columnCounts, replayPosition, maxTimestamp, compressionRatio, partitioner);;                                              : Double.MIN_VALUE;
            String partitioner = desc.version.hasPartitioner ? dis.readUTF() : null;
            StreamingHistogram tombstoneHistogram = desc.version.tracksTombstones
                                                   ? StreamingHistogram.serializer.deserialize(dis)
                                                   : defaultTombstoneDropTimeHistogram();
            return new SSTableMetadata(rowSizes, columnCounts, replayPosition, maxTimestamp, compressionRatio, partitioner, tombstoneHistogram);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Frequency,int);    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, frequency, settlementDays);
    return add(bundle, convention);;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, frequency, settlementDays);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention,
        frequency, settlementDays);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Frequency,int,double);    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, frequency, settlementDays, yearFraction);
    return add(bundle, convention);;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, frequency, settlementDays, yearFraction);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention,
        frequency, settlementDays, yearFraction);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Period,int);    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, period, settlementDays);
    return add(bundle, convention);;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention, period, settlementDays);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, dayCount, businessDayConvention,
        period, settlementDays);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Frequency,Integer,Identifier,DayCount,BusinessDayConvention,Frequency,Integer,Identifier,Identifier);    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, swapFixedLegDayCount, swapFixedLegBusinessDayConvention, swapFixedLegFrequency, swapFixedLegSettlementDays,
        swapFixedLegRegion, swapFloatingLegDayCount, swapFloatingLegBusinessDayConvention, swapFloatingLegFrequency, swapFloatingLegSettlementDays, swapFloatingLegInitialRate, swapFloatingLegRegion);
    return add(bundle, convention);;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, swapFixedLegDayCount, swapFixedLegBusinessDayConvention, swapFixedLegFrequency, swapFixedLegSettlementDays,
        swapFixedLegRegion, swapFloatingLegDayCount, swapFloatingLegBusinessDayConvention, swapFloatingLegFrequency, swapFloatingLegSettlementDays, swapFloatingLegInitialRate, swapFloatingLegRegion);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, swapFixedLegDayCount,
        swapFixedLegBusinessDayConvention, swapFixedLegFrequency, swapFixedLegSettlementDays,
        swapFixedLegRegion, swapFloatingLegDayCount, swapFloatingLegBusinessDayConvention, swapFloatingLegFrequency,
        swapFloatingLegSettlementDays, swapFloatingLegInitialRate, swapFloatingLegRegion);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,DayCount,BusinessDayConvention,Frequency,Integer,Identifier,Identifier,DayCount,BusinessDayConvention,Frequency,Integer,Identifier,Identifier);  public UniqueIdentifier addConventionBundle(final IdentifierBundle bundle, final String name, final DayCount basisSwapPayFloatingLegDayCount,
      final BusinessDayConvention basisSwapPayFloatingLegBusinessDayConvention, final Frequency basisSwapPayFloatingLegFrequency, final Integer basisSwapPayFloatingLegSettlementDays,
      final Identifier basisSwapPayFloatingLegInitialRate, final Identifier basisSwapPayFloatingLegRegion, final DayCount basisSwapReceiveFloatingLegDayCount,
      final BusinessDayConvention basisSwapReceiveFloatingLegBusinessDayConvention, final Frequency basisSwapReceiveFloatingLegFrequency, final Integer basisSwapReceiveFloatingLegSettlementDays,
      final Identifier basisSwapReceiveFloatingLegInitialRate, final Identifier basisSwapReceiveFloatingLegRegion) {
    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, basisSwapPayFloatingLegDayCount, basisSwapPayFloatingLegBusinessDayConvention, basisSwapPayFloatingLegFrequency,
        basisSwapPayFloatingLegSettlementDays, basisSwapPayFloatingLegInitialRate, basisSwapPayFloatingLegRegion, basisSwapReceiveFloatingLegDayCount,
        basisSwapReceiveFloatingLegBusinessDayConvention, basisSwapReceiveFloatingLegFrequency, basisSwapReceiveFloatingLegSettlementDays, basisSwapReceiveFloatingLegInitialRate,
        basisSwapReceiveFloatingLegRegion);
    return add(bundle, convention);;  public UniqueIdentifier addConventionBundle(final IdentifierBundle bundle, final String name, final DayCount basisSwapPayFloatingLegDayCount,
      final BusinessDayConvention basisSwapPayFloatingLegBusinessDayConvention, final Frequency basisSwapPayFloatingLegFrequency, final Integer basisSwapPayFloatingLegSettlementDays,
      final Identifier basisSwapPayFloatingLegInitialRate, final Identifier basisSwapPayFloatingLegRegion, final DayCount basisSwapReceiveFloatingLegDayCount,
      final BusinessDayConvention basisSwapReceiveFloatingLegBusinessDayConvention, final Frequency basisSwapReceiveFloatingLegFrequency, final Integer basisSwapReceiveFloatingLegSettlementDays,
      final Identifier basisSwapReceiveFloatingLegInitialRate, final Identifier basisSwapReceiveFloatingLegRegion) {
    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, basisSwapPayFloatingLegDayCount, basisSwapPayFloatingLegBusinessDayConvention, basisSwapPayFloatingLegFrequency,
        basisSwapPayFloatingLegSettlementDays, basisSwapPayFloatingLegInitialRate, basisSwapPayFloatingLegRegion, basisSwapReceiveFloatingLegDayCount,
        basisSwapReceiveFloatingLegBusinessDayConvention, basisSwapReceiveFloatingLegFrequency, basisSwapReceiveFloatingLegSettlementDays, basisSwapReceiveFloatingLegInitialRate,
        basisSwapReceiveFloatingLegRegion);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;  public UniqueIdentifier addConventionBundle(final IdentifierBundle bundle, final String name,
      final DayCount tenorSwapPayFloatingLegDayCount,
      final BusinessDayConvention tenorSwapPayFloatingLegBusinessDayConvention,
      final Frequency tenorSwapPayFloatingLegFrequency, final Integer tenorSwapPayFloatingLegSettlementDays,
      final Identifier tenorSwapPayFloatingLegInitialRate, final Identifier tenorSwapPayFloatingLegRegion,
      final DayCount tenorSwapReceiveFloatingLegDayCount,
      final BusinessDayConvention tenorSwapReceiveFloatingLegBusinessDayConvention,
      final Frequency tenorSwapReceiveFloatingLegFrequency, final Integer tenorSwapReceiveFloatingLegSettlementDays,
      final Identifier tenorSwapReceiveFloatingLegInitialRate, final Identifier tenorSwapReceiveFloatingLegRegion) {
    final ConventionBundleImpl convention = new ConventionBundleImpl(bundle, name, tenorSwapPayFloatingLegDayCount,
        tenorSwapPayFloatingLegBusinessDayConvention, tenorSwapPayFloatingLegFrequency,
        tenorSwapPayFloatingLegSettlementDays, tenorSwapPayFloatingLegInitialRate, tenorSwapPayFloatingLegRegion,
        tenorSwapReceiveFloatingLegDayCount,
        tenorSwapReceiveFloatingLegBusinessDayConvention, tenorSwapReceiveFloatingLegFrequency,
        tenorSwapReceiveFloatingLegSettlementDays, tenorSwapReceiveFloatingLegInitialRate,
        tenorSwapReceiveFloatingLegRegion);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6a205_ef881/rev_6a205-ef881;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addConventionBundle(IdentifierBundle,String,boolean,boolean,int,int,boolean);    final ConventionBundleImpl convention = new ConventionBundleImpl(name, isEOMConvention, calculateScheduleFromMaturity, exDividendDays, settlementDays, rollToSettlement);
    return add(bundle, convention);;    final ConventionBundleImpl convention = new ConventionBundleImpl(name, isEOMConvention, calculateScheduleFromMaturity, exDividendDays, settlementDays, rollToSettlement);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;;    final ConventionBundleImpl convention = new ConventionBundleImpl(name, isEOMConvention,
        calculateScheduleFromMaturity, exDividendDays, settlementDays, rollToSettlement);
    final UniqueIdentifier uid = _mapper.add(bundle, convention);
    convention.setUniqueId(uid);
    return uid;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6aba6_81eb1/rev_6aba6-81eb1;/graphdb/src/main/java/com/tinkerpop/blueprints/impls/orient/OrientVertex;removeEdges(ODocument,String,OIdentifiable,boolean,boolean);        if (!set.remove(iVertexToRemove)) {
          // SEARCH SEQUENTIALLY (SLOWER)
          boolean found = false;
          for (Iterator<Object> it = set.iterator(); it.hasNext();) {
            final ODocument curr = ((OIdentifiable) it.next()).getRecord();;        if (!set.remove(iVertexToRemove)) {
          // SEARCH SEQUENTIALLY (SLOWER)
          boolean found = false;
          for (OLazyIterator<OIdentifiable> it = set.iterator(false); it.hasNext();) {
            final ODocument curr = it.next().getRecord();;        // SEARCH SEQUENTIALLY (SLOWER)
        boolean found = false;
        for (Iterator<OIdentifiable> it = bag.rawIterator(); it.hasNext();) {
          final ODocument curr = it.next().getRecord();

          if (iVertexToRemove.equals(curr)) {
            // FOUND AS VERTEX
            it.remove();
            if (iAlsoInverse)
              removeInverseEdge(iVertex, iFieldName, iVertexToRemove, curr, useVertexFieldsForEdgeLabels);
            found = true;
            break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_6b28c_ce6b9/rev_6b28c-ce6b9;/src/main/java/org/graylog2/messagehandlers/gelf/GELFClientHandlerThread;run();        } catch (java.io.IOException e) {
            Log.crit("IO Error while handling GELF message: " + e.toString());;        } catch (java.io.IOException e) {
            Log.crit("IO Error while handling GELF message: " + e.toString());
        } catch (jave.io.EOFException e) {
            Log.crit("EOF Exception while handling GELF message: " + e.toString());
        } catch (java.net.SocketException e) {
            Log.crit("SocketException while handling GELF message: " + e.toString());;        } catch (java.io.EOFException e) {
            Log.crit("EOF Exception while handling GELF message: " + e.toString());
        } catch (java.net.SocketException e) {
            Log.crit("SocketException while handling GELF message: " + e.toString());
        } catch (java.io.IOException e) {
            Log.crit("IO Error while handling GELF message: " + e.toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b63d_ed2ea/rev_6b63d-ed2ea;/projects/OG-Financial/src/com/opengamma/financial/fudgemsg/YieldCurveDefinitionBuilder;buildObject(FudgeDeserializationContext,FudgeFieldContainer);    YieldCurveDefinition curveDefinition = new YieldCurveDefinition(currency, region, name, interpolatorName, strips);;    YieldCurveDefinition curveDefinition = new YieldCurveDefinition(currency, name, interpolatorName, strips);;    YieldCurveDefinition curveDefinition = new YieldCurveDefinition(currency, name, interpolatorName, strips);
    FudgeField uniqueId = message.getByName("uniqueId");
    if (uniqueId != null) {
      curveDefinition.setUniqueId(context.fieldValueToObject(UniqueIdentifier.class, uniqueId));
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-Financial/src/main/java/com/opengamma/financial/generator/SecurityGenerator;nextWorkingDay(ZonedDateTime,Currency);protected ZonedDateTime nextWorkingDay(ZonedDateTime zdt, final Currency currency) {
    while (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt.getDate(), currency)) {
      zdt = zdt.plusDays(1);
    }
    return zdt;;protected ZonedDateTime nextWorkingDay(ZonedDateTime zdt, final Currency currency) {
    while (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt, currency)) {
      zdt = zdt.plusDays(1);
    }
    return zdt;;protected ZonedDateTime nextWorkingDay(ZonedDateTime zdt, final Currency... currencies) {
    ArgumentChecker.isTrue(currencies.length > 0, "currencies");
    do {
      for (Currency currency : currencies) {
        if (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt, currency)) {
          zdt = zdt.plusDays(1);
          continue;
        }
      }
      return zdt;
    } while (true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-Financial/src/main/java/com/opengamma/financial/generator/SecurityGenerator;previousWorkingDay(ZonedDateTime,Currency);protected ZonedDateTime previousWorkingDay(ZonedDateTime zdt, final Currency currency) {
    while (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt.getDate(), currency)) {
      zdt = zdt.minusDays(1);
    }
    return zdt;;protected ZonedDateTime previousWorkingDay(ZonedDateTime zdt, final Currency currency) {
    while (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt, currency)) {
      zdt = zdt.minusDays(1);
    }
    return zdt;;protected ZonedDateTime previousWorkingDay(ZonedDateTime zdt, final Currency... currencies) {
    ArgumentChecker.isTrue(currencies.length > 0, "currencies");
    do {
      for (Currency currency : currencies) {
        if (!isWorkday(zdt.getDayOfWeek(), currency) || isHoliday(zdt, currency)) {
          zdt = zdt.minusDays(1);
          continue;
        }
      }
      return zdt;
    } while (true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-Engine/src/main/java/com/opengamma/engine/view/calcnode/SimpleCalculationNode;invoke(CalculationJobItem,DeferredInvocationStatistics,CalculationJobResultItemBuilder);    for (final Pair<ValueSpecification, Object> input : cache.getValues(inputValueSpecs, getJob().getCacheSelectHint())) {
      if ((input.getValue() == null) || (input.getValue() instanceof MissingInput)) {
        missing.add(input.getKey());;    for (Pair<ValueSpecification, Object> input : cache.getValues(jobItem.getInputs(), getJob().getCacheSelectHint())) {
      if ((input.getValue() == null) || (input.getValue() instanceof MissingInput)) {
        missing.add(input.getKey());;    for (Pair<ValueSpecification, Object> input : cache.getValues(jobItem.getInputs(), getJob().getCacheSelectHint())) {
      if ((input._2() == null) || (input._2() instanceof MissingInput)) {
        missing.add(input._1());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-Engine/src/main/java/com/opengamma/engine/view/helper/AvailablePortfolioOutputs;AvailablePortfolioOutputs(Portfolio,CompiledFunctionRepository,FunctionExclusionGroups,MarketDataAvailabilityProvider,String);    final Collection<CompiledFunctionDefinition> functions = functionRepository.getAllFunctions();
    final TargetCachePopulator targetCachePopulator = new TargetCachePopulator();
    PortfolioNodeTraverser.depthFirst(targetCachePopulator).traverse(portfolio.getRootNode());
    PortfolioNodeTraverser.depthFirst(new FunctionApplicator(functionRepository.getCompilationContext(), functions, functionExclusionGroups, marketDataAvailabilityProvider, targetCachePopulator))
        .traverse(portfolio.getRootNode());;    final Collection<CompiledFunctionDefinition> functions = removeDummyFunctions(functionRepository.getAllFunctions());
    final Map<UniqueId, Object> targetCache = new HashMap<UniqueId, Object>();
    PortfolioNodeTraverser.depthFirst(new AbstractPortfolioNodeTraversalCallback() {

      @Override
      public void preOrderOperation(final PortfolioNode portfolioNode) {
        targetCache.put(portfolioNode.getUniqueId(), portfolioNode);
      }

      @Override
      public void preOrderOperation(final Position position) {
        targetCache.put(position.getUniqueId(), position);
        targetCache.put(position.getSecurity().getUniqueId(), position.getSecurity());
        for (Trade trade : position.getTrades()) {
          targetCache.put(trade.getUniqueId(), trade);
          targetCache.put(trade.getSecurity().getUniqueId(), trade.getSecurity());
        }
      }

    }).traverse(portfolio.getRootNode());
    PortfolioNodeTraverser.depthFirst(new AbstractPortfolioNodeTraversalCallback() {

      private final FunctionCompilationContext _context = functionRepository.getCompilationContext();
      private final Map<ComputationTarget, Map<CompiledFunctionDefinition, Set<ValueSpecification>>> _resultsCache =
          new HashMap<ComputationTarget, Map<CompiledFunctionDefinition, Set<ValueSpecification>>>();
      private final Map<ValueRequirement, List<Pair<List<ValueRequirement>, Set<ValueSpecification>>>> _resolutionCache =
          new HashMap<ValueRequirement, List<Pair<List<ValueRequirement>, Set<ValueSpecification>>>>();

      private Set<ValueSpecification> getCachedResult(final Set<ValueRequirement> visited, final ValueRequirement requirement) {
        final List<Pair<List<ValueRequirement>, Set<ValueSpecification>>> entries = _resolutionCache.get(requirement);
        if (entries == null) {
          return null;
        }
        for (Pair<List<ValueRequirement>, Set<ValueSpecification>> entry : entries) {
          boolean subset = true;
          for (ValueRequirement entryKey : entry.getKey()) {
            if (!visited.contains(entryKey)) {
              subset = false;
              break;
            }
          }
          if (subset) {
            //s_logger.debug("Cache hit on {}", requirement);
            //s_logger.debug("Cached parent = {}", entry.getKey());
            //s_logger.debug("Active parent = {}", visited);
            return entry.getValue();
          }
        }
        return null;
      }

      @SuppressWarnings("unchecked")
      private void setCachedResult(final Set<ValueRequirement> visited, final ValueRequirement requirement, final Set<ValueSpecification> results) {
        s_logger.debug("Caching result for {} on {}", requirement, visited);
        List<Pair<List<ValueRequirement>, Set<ValueSpecification>>> entries = _resolutionCache.get(requirement);
        if (entries == null) {
          entries = new LinkedList<Pair<List<ValueRequirement>, Set<ValueSpecification>>>();
          _resolutionCache.put(requirement, entries);
        }
        entries.add((Pair<List<ValueRequirement>, Set<ValueSpecification>>) (Pair<?, ?>) Pair.of(new ArrayList<ValueRequirement>(visited), (results != null) ? results : Collections.emptySet()));
      }

      private Set<ValueSpecification> satisfyRequirement(final Set<ValueRequirement> visitedRequirements, final Set<FunctionExclusionGroup> visitedFunctions, final ComputationTarget target,
          final ValueRequirement requirement) {
        Set<ValueSpecification> allResults = getCachedResult(visitedRequirements, requirement);
        if (allResults != null) {
          if (allResults.isEmpty()) {
            s_logger.debug("Cache failure hit on {}", requirement);
            return null;
          } else {
            s_logger.debug("Cache result hit on {}", requirement);
            return allResults;
          }
        }
        Map<CompiledFunctionDefinition, Set<ValueSpecification>> functionResults = _resultsCache.get(target);
        if (functionResults == null) {
          functionResults = new HashMap<CompiledFunctionDefinition, Set<ValueSpecification>>();
          for (CompiledFunctionDefinition function : functions) {
            try {
              if ((function.getTargetType() == target.getType()) && function.canApplyTo(_context, target)) {
                final Set<ValueSpecification> results = function.getResults(_context, target);
                if (results != null) {
                  functionResults.put(function, results);
                }
              }
            } catch (Throwable t) {
              s_logger.error("Error applying {} to {}", function, target);
              s_logger.warn("Exception thrown", t);
            }
          }
          _resultsCache.put(target, functionResults);
        }
        if (!visitedRequirements.add(requirement)) {
          // This shouldn't happen
          throw new IllegalStateException();
        }
        for (Map.Entry<CompiledFunctionDefinition, Set<ValueSpecification>> functionResult : functionResults.entrySet()) {
          final CompiledFunctionDefinition function = functionResult.getKey();
          for (ValueSpecification result : functionResult.getValue()) {
            if (requirement.isSatisfiedBy(result)) {
              final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
              if ((group == null) || visitedFunctions.add(group)) {
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target, requirement, result.compose(requirement));
                if (resolved != null) {
                  if (allResults == null) {
                    allResults = new HashSet<ValueSpecification>();
                  }
                  allResults.addAll(resolved);
                }
                if (group != null) {
                  visitedFunctions.remove(group);
                }
              }
            }
          }
        }
        visitedRequirements.remove(requirement);
        setCachedResult(visitedRequirements, requirement, allResults);
        return allResults;
      }

      private Set<ValueSpecification> resultWithSatisfiedRequirements(final Set<ValueRequirement> visitedRequirements, final Set<FunctionExclusionGroup> visitedFunctions,
          final CompiledFunctionDefinition function, final ComputationTarget target, final ValueRequirement requiredOutputValue, final ValueSpecification resolvedOutputValue) {
        final Set<ValueRequirement> requirements;
        try {
          requirements = function.getRequirements(_context, target, requiredOutputValue);
          if (requirements == null) {
            return null;
          }
        } catch (Throwable t) {
          s_logger.error("Error applying {} to {}", function, target);
          s_logger.warn("Exception thrown", t);
          return null;
        }
        if (requirements.isEmpty()) {
          return Collections.singleton(resolvedOutputValue);
        }
        for (ValueRequirement requirement : requirements) {
          if (visitedRequirements.contains(requirement)) {
            return null;
          }
        }
        final Map<Iterator<ValueSpecification>, ValueRequirement> inputs = new HashMap<Iterator<ValueSpecification>, ValueRequirement>();
        for (ValueRequirement requirement : requirements) {
          final ComputationTargetSpecification targetSpec = requirement.getTargetSpecification();
          if (targetSpec.getUniqueId() != null) {
            if (MarketDataUtils.isAvailable(marketDataAvailabilityProvider, requirement)) {
              s_logger.debug("Requirement {} can be satisfied by market data", requirement);
              inputs.put(Collections.singleton(new ValueSpecification(requirement, "marketdata")).iterator(), requirement);
            } else {
              final Object requirementTarget = targetCache.get(targetSpec.getUniqueId());
              if (requirementTarget != null) {
                final Set<ValueSpecification> satisfied = satisfyRequirement(visitedRequirements, visitedFunctions, new ComputationTarget(requirementTarget), requirement);
                if (satisfied == null) {
                  s_logger.debug("Can't satisfy {} for function {}", requirement, function);
                  if (!function.canHandleMissingRequirements()) {
                    return null;
                  }
                } else {
                  inputs.put(satisfied.iterator(), requirement);
                }
              } else {
                s_logger.debug("No target cached for {}, assuming ok", targetSpec);
                inputs.put(new SingleItem<ValueSpecification>(new ValueSpecification(requirement, "")), requirement);
              }
            }
          } else {
            s_logger.debug("No unique ID for {}, assuming ok", targetSpec);
            inputs.put(new SingleItem<ValueSpecification>(new ValueSpecification(requirement, "")), requirement);
          }
        }
        final Set<ValueSpecification> outputs = new HashSet<ValueSpecification>();
        Map<ValueSpecification, ValueRequirement> inputSet = new HashMap<ValueSpecification, ValueRequirement>();
        do {
          for (Map.Entry<Iterator<ValueSpecification>, ValueRequirement> input : inputs.entrySet()) {
            if (!input.getKey().hasNext()) {
              inputSet.clear();
              break;
            }
            inputSet.put(input.getKey().next(), input.getValue());
          }
          if (inputSet.isEmpty()) {
            break;
          } else {
            try {
              final Set<ValueSpecification> results = function.getResults(_context, target, inputSet);
              if (results != null) {
                for (ValueSpecification result : results) {
                  if ((resolvedOutputValue == result) || requiredOutputValue.isSatisfiedBy(result)) {
                    outputs.add(result.compose(requiredOutputValue));
                  }
                }
              }
            } catch (Throwable t) {
              s_logger.error("Error applying {} to {}", function, target);
              s_logger.warn("Exception thrown", t);
            }
            inputSet.clear();
          }
        } while (true);
        if (outputs.isEmpty()) {
          s_logger.debug("Provisional result {} not in results after late resolution", resolvedOutputValue);
          return null;
        } else {
          return outputs;
        }
      }

      @Override
      public void preOrderOperation(final PortfolioNode portfolioNode) {
        if (portfolioNode.getUniqueId() == null) {
          // Anonymous node in the portfolio means it cannot be referenced so no results can be produced on it.
          // Being presented with a portfolio like this almost certainly implies a temporary portfolio for which
          // node-level results are not required.
          s_logger.debug("Ignoring portfolio node with no unique ID: {}", portfolioNode);
          return;
        }
        final ComputationTarget target = new ComputationTarget(ComputationTargetType.PORTFOLIO_NODE, portfolioNode);
        final Set<ValueRequirement> visitedRequirements = new HashSet<ValueRequirement>();
        final Set<FunctionExclusionGroup> visitedFunctions = new HashSet<FunctionExclusionGroup>();
        for (CompiledFunctionDefinition function : functions) {
          try {
            if ((function.getTargetType() == ComputationTargetType.PORTFOLIO_NODE) && function.canApplyTo(_context, target)) {
              final Set<ValueSpecification> results = function.getResults(_context, target);
              for (ValueSpecification result : results) {
                visitedRequirements.clear();
                visitedFunctions.clear();
                final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
                if (group != null) {
                  visitedFunctions.add(group);
                }
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target, new ValueRequirement(result.getValueName(), result
                    .getTargetSpecification()), result);
                if (resolved != null) {
                  s_logger.info("Resolved {} on {}", result.getValueName(), portfolioNode);
                  for (ValueSpecification resolvedItem : resolved) {
                    portfolioNodeOutput(resolvedItem.getValueName(), resolvedItem.getProperties());
                  }
                } else {
                  s_logger.info("Did not resolve {} on {}", result.getValueName(), portfolioNode);
                }
              }
            }
          } catch (Throwable t) {
            s_logger.error("Error applying {} to {}", function, target);
            s_logger.warn("Exception thrown", t);
          }
        }
      }

      @Override
      public void preOrderOperation(final Position position) {
        final ComputationTarget target = new ComputationTarget(ComputationTargetType.POSITION, position);
        final Set<ValueRequirement> visitedRequirements = new HashSet<ValueRequirement>();
        final Set<FunctionExclusionGroup> visitedFunctions = new HashSet<FunctionExclusionGroup>();
        for (CompiledFunctionDefinition function : functions) {
          try {
            if ((function.getTargetType() == ComputationTargetType.POSITION) && function.canApplyTo(_context, target)) {
              final Set<ValueSpecification> results = function.getResults(_context, target);
              for (ValueSpecification result : results) {
                visitedRequirements.clear();
                visitedFunctions.clear();
                final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
                if (group != null) {
                  visitedFunctions.add(group);
                }
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target,
                    new ValueRequirement(result.getValueName(), result.getTargetSpecification()), result);
                if (resolved != null) {
                  s_logger.info("Resolved {} on {}", result.getValueName(), position);
                  for (ValueSpecification resolvedItem : resolved) {
                    positionOutput(resolvedItem.getValueName(), position.getSecurity().getSecurityType(), resolvedItem.getProperties());
                  }
                } else {
                  s_logger.info("Did not resolve {} on {}", result.getValueName(), position);
                }
              }
            }
          } catch (Throwable t) {
            s_logger.error("Error applying {} to {}", function, target);
            s_logger.warn("Exception thrown", t);
          }
        }
      }

    }).traverse(portfolio.getRootNode());;    final Collection<CompiledFunctionDefinition> functions = removeDummyFunctions(functionRepository.getAllFunctions());
    final Map<UniqueId, Object> targetCache = new HashMap<UniqueId, Object>();
    PortfolioNodeTraverser.depthFirst(new AbstractPortfolioNodeTraversalCallback() {

      @Override
      public void preOrderOperation(final PortfolioNode portfolioNode) {
        targetCache.put(portfolioNode.getUniqueId(), portfolioNode);
      }

      @Override
      public void preOrderOperation(final Position position) {
        targetCache.put(position.getUniqueId(), position);
        targetCache.put(position.getSecurity().getUniqueId(), position.getSecurity());
        for (Trade trade : position.getTrades()) {
          targetCache.put(trade.getUniqueId(), trade);
          targetCache.put(trade.getSecurity().getUniqueId(), trade.getSecurity());
        }
      }

    }).traverse(portfolio.getRootNode());
    PortfolioNodeTraverser.depthFirst(new AbstractPortfolioNodeTraversalCallback() {

      private final FunctionCompilationContext _context = functionRepository.getCompilationContext();
      private final Map<ComputationTarget, Map<CompiledFunctionDefinition, Set<ValueSpecification>>> _resultsCache =
          new HashMap<ComputationTarget, Map<CompiledFunctionDefinition, Set<ValueSpecification>>>();
      private final Map<ValueRequirement, List<Pair<List<ValueRequirement>, Set<ValueSpecification>>>> _resolutionCache =
          new HashMap<ValueRequirement, List<Pair<List<ValueRequirement>, Set<ValueSpecification>>>>();

      private Set<ValueSpecification> getCachedResult(final Set<ValueRequirement> visited, final ValueRequirement requirement) {
        final List<Pair<List<ValueRequirement>, Set<ValueSpecification>>> entries = _resolutionCache.get(requirement);
        if (entries == null) {
          return null;
        }
        for (Pair<List<ValueRequirement>, Set<ValueSpecification>> entry : entries) {
          boolean subset = true;
          for (ValueRequirement entryKey : entry._1()) {
            if (!visited.contains(entryKey)) {
              subset = false;
              break;
            }
          }
          if (subset) {
            //s_logger.debug("Cache hit on {}", requirement);
            //s_logger.debug("Cached parent = {}", entry.getKey());
            //s_logger.debug("Active parent = {}", visited);
            return entry._2();
          }
        }
        return null;
      }

      @SuppressWarnings("unchecked")
      private void setCachedResult(final Set<ValueRequirement> visited, final ValueRequirement requirement, final Set<ValueSpecification> results) {
        s_logger.debug("Caching result for {} on {}", requirement, visited);
        List<Pair<List<ValueRequirement>, Set<ValueSpecification>>> entries = _resolutionCache.get(requirement);
        if (entries == null) {
          entries = new LinkedList<Pair<List<ValueRequirement>, Set<ValueSpecification>>>();
          _resolutionCache.put(requirement, entries);
        }
        entries.add((Pair<List<ValueRequirement>, Set<ValueSpecification>>) (Pair<?, ?>) Pair.of(new ArrayList<ValueRequirement>(visited), (results != null) ? results : Collections.emptySet()));
      }

      private Set<ValueSpecification> satisfyRequirement(final Set<ValueRequirement> visitedRequirements, final Set<FunctionExclusionGroup> visitedFunctions, final ComputationTarget target,
          final ValueRequirement requirement) {
        Set<ValueSpecification> allResults = getCachedResult(visitedRequirements, requirement);
        if (allResults != null) {
          if (allResults.isEmpty()) {
            s_logger.debug("Cache failure hit on {}", requirement);
            return null;
          } else {
            s_logger.debug("Cache result hit on {}", requirement);
            return allResults;
          }
        }
        Map<CompiledFunctionDefinition, Set<ValueSpecification>> functionResults = _resultsCache.get(target);
        if (functionResults == null) {
          functionResults = new HashMap<CompiledFunctionDefinition, Set<ValueSpecification>>();
          for (CompiledFunctionDefinition function : functions) {
            try {
              if ((function.getTargetType() == target.getType()) && function.canApplyTo(_context, target)) {
                final Set<ValueSpecification> results = function.getResults(_context, target);
                if (results != null) {
                  functionResults.put(function, results);
                }
              }
            } catch (Throwable t) {
              s_logger.error("Error applying {} to {}", function, target);
              s_logger.warn("Exception thrown", t);
            }
          }
          _resultsCache.put(target, functionResults);
        }
        if (!visitedRequirements.add(requirement)) {
          // This shouldn't happen
          throw new IllegalStateException();
        }
        for (Map.Entry<CompiledFunctionDefinition, Set<ValueSpecification>> functionResult : functionResults.entrySet()) {
          final CompiledFunctionDefinition function = functionResult.getKey();
          for (ValueSpecification result : functionResult.getValue()) {
            if (requirement.isSatisfiedBy(result)) {
              final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
              if ((group == null) || visitedFunctions.add(group)) {
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target, requirement, result.compose(requirement));
                if (resolved != null) {
                  if (allResults == null) {
                    allResults = new HashSet<ValueSpecification>();
                  }
                  allResults.addAll(resolved);
                }
                if (group != null) {
                  visitedFunctions.remove(group);
                }
              }
            }
          }
        }
        visitedRequirements.remove(requirement);
        setCachedResult(visitedRequirements, requirement, allResults);
        return allResults;
      }

      private Set<ValueSpecification> resultWithSatisfiedRequirements(final Set<ValueRequirement> visitedRequirements, final Set<FunctionExclusionGroup> visitedFunctions,
          final CompiledFunctionDefinition function, final ComputationTarget target, final ValueRequirement requiredOutputValue, final ValueSpecification resolvedOutputValue) {
        final Set<ValueRequirement> requirements;
        try {
          requirements = function.getRequirements(_context, target, requiredOutputValue);
          if (requirements == null) {
            return null;
          }
        } catch (Throwable t) {
          s_logger.error("Error applying {} to {}", function, target);
          s_logger.warn("Exception thrown", t);
          return null;
        }
        if (requirements.isEmpty()) {
          return Collections.singleton(resolvedOutputValue);
        }
        for (ValueRequirement requirement : requirements) {
          if (visitedRequirements.contains(requirement)) {
            return null;
          }
        }
        final Map<Iterator<ValueSpecification>, ValueRequirement> inputs = new HashMap<Iterator<ValueSpecification>, ValueRequirement>();
        for (ValueRequirement requirement : requirements) {
          final ComputationTargetSpecification targetSpec = requirement.getTargetSpecification();
          if (targetSpec.getUniqueId() != null) {
            if (MarketDataUtils.isAvailable(marketDataAvailabilityProvider, requirement)) {
              s_logger.debug("Requirement {} can be satisfied by market data", requirement);
              inputs.put(Collections.singleton(new ValueSpecification(requirement, "marketdata")).iterator(), requirement);
            } else {
              final Object requirementTarget = targetCache.get(targetSpec.getUniqueId());
              if (requirementTarget != null) {
                final Set<ValueSpecification> satisfied = satisfyRequirement(visitedRequirements, visitedFunctions, new ComputationTarget(requirementTarget), requirement);
                if (satisfied == null) {
                  s_logger.debug("Can't satisfy {} for function {}", requirement, function);
                  if (!function.canHandleMissingRequirements()) {
                    return null;
                  }
                } else {
                  inputs.put(satisfied.iterator(), requirement);
                }
              } else {
                s_logger.debug("No target cached for {}, assuming ok", targetSpec);
                inputs.put(new SingleItem<ValueSpecification>(new ValueSpecification(requirement, "")), requirement);
              }
            }
          } else {
            s_logger.debug("No unique ID for {}, assuming ok", targetSpec);
            inputs.put(new SingleItem<ValueSpecification>(new ValueSpecification(requirement, "")), requirement);
          }
        }
        final Set<ValueSpecification> outputs = new HashSet<ValueSpecification>();
        Map<ValueSpecification, ValueRequirement> inputSet = new HashMap<ValueSpecification, ValueRequirement>();
        do {
          for (Map.Entry<Iterator<ValueSpecification>, ValueRequirement> input : inputs.entrySet()) {
            if (!input.getKey().hasNext()) {
              inputSet.clear();
              break;
            }
            inputSet.put(input.getKey().next(), input.getValue());
          }
          if (inputSet.isEmpty()) {
            break;
          } else {
            try {
              final Set<ValueSpecification> results = function.getResults(_context, target, inputSet);
              if (results != null) {
                for (ValueSpecification result : results) {
                  if ((resolvedOutputValue == result) || requiredOutputValue.isSatisfiedBy(result)) {
                    outputs.add(result.compose(requiredOutputValue));
                  }
                }
              }
            } catch (Throwable t) {
              s_logger.error("Error applying {} to {}", function, target);
              s_logger.warn("Exception thrown", t);
            }
            inputSet.clear();
          }
        } while (true);
        if (outputs.isEmpty()) {
          s_logger.debug("Provisional result {} not in results after late resolution", resolvedOutputValue);
          return null;
        } else {
          return outputs;
        }
      }

      @Override
      public void preOrderOperation(final PortfolioNode portfolioNode) {
        if (portfolioNode.getUniqueId() == null) {
          // Anonymous node in the portfolio means it cannot be referenced so no results can be produced on it.
          // Being presented with a portfolio like this almost certainly implies a temporary portfolio for which
          // node-level results are not required.
          s_logger.debug("Ignoring portfolio node with no unique ID: {}", portfolioNode);
          return;
        }
        final ComputationTarget target = new ComputationTarget(ComputationTargetType.PORTFOLIO_NODE, portfolioNode);
        final Set<ValueRequirement> visitedRequirements = new HashSet<ValueRequirement>();
        final Set<FunctionExclusionGroup> visitedFunctions = new HashSet<FunctionExclusionGroup>();
        for (CompiledFunctionDefinition function : functions) {
          try {
            if ((function.getTargetType() == ComputationTargetType.PORTFOLIO_NODE) && function.canApplyTo(_context, target)) {
              final Set<ValueSpecification> results = function.getResults(_context, target);
              for (ValueSpecification result : results) {
                visitedRequirements.clear();
                visitedFunctions.clear();
                final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
                if (group != null) {
                  visitedFunctions.add(group);
                }
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target, new ValueRequirement(result.getValueName(), result
                    .getTargetSpecification()), result);
                if (resolved != null) {
                  s_logger.info("Resolved {} on {}", result.getValueName(), portfolioNode);
                  for (ValueSpecification resolvedItem : resolved) {
                    portfolioNodeOutput(resolvedItem.getValueName(), resolvedItem.getProperties());
                  }
                } else {
                  s_logger.info("Did not resolve {} on {}", result.getValueName(), portfolioNode);
                }
              }
            }
          } catch (Throwable t) {
            s_logger.error("Error applying {} to {}", function, target);
            s_logger.warn("Exception thrown", t);
          }
        }
      }

      @Override
      public void preOrderOperation(final Position position) {
        final ComputationTarget target = new ComputationTarget(ComputationTargetType.POSITION, position);
        final Set<ValueRequirement> visitedRequirements = new HashSet<ValueRequirement>();
        final Set<FunctionExclusionGroup> visitedFunctions = new HashSet<FunctionExclusionGroup>();
        for (CompiledFunctionDefinition function : functions) {
          try {
            if ((function.getTargetType() == ComputationTargetType.POSITION) && function.canApplyTo(_context, target)) {
              final Set<ValueSpecification> results = function.getResults(_context, target);
              for (ValueSpecification result : results) {
                visitedRequirements.clear();
                visitedFunctions.clear();
                final FunctionExclusionGroup group = (functionExclusionGroups == null) ? null : functionExclusionGroups.getExclusionGroup(function.getFunctionDefinition());
                if (group != null) {
                  visitedFunctions.add(group);
                }
                final Set<ValueSpecification> resolved = resultWithSatisfiedRequirements(visitedRequirements, visitedFunctions, function, target,
                    new ValueRequirement(result.getValueName(), result.getTargetSpecification()), result);
                if (resolved != null) {
                  s_logger.info("Resolved {} on {}", result.getValueName(), position);
                  for (ValueSpecification resolvedItem : resolved) {
                    positionOutput(resolvedItem.getValueName(), position.getSecurity().getSecurityType(), resolvedItem.getProperties());
                  }
                } else {
                  s_logger.info("Did not resolve {} on {}", result.getValueName(), position);
                }
              }
            }
          } catch (Throwable t) {
            s_logger.error("Error applying {} to {}", function, target);
            s_logger.warn("Exception thrown", t);
          }
        }
      }

    }).traverse(portfolio.getRootNode());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-Integration/src/main/java/com/opengamma/integration/tool/marketdata/CurveHtsResolverTool;doRun();    final List<LocalDate> dates = buildDates();
    final Set<String> curveNames = map(new HashSet<String>(), curves, new Function1<YieldCurveDefinition, String>() {;    List<LocalDate> dates = buildDates();
    Set<String> curveNames = map(new HashSet<String>(), curves, new Function1<YieldCurveDefinition, String>() {;    List<LocalDate> dates = buildDates();
    Set<String> curveNames = functional(curves).map(new Function1<YieldCurveDefinition, String>() {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6b100_ecf80/rev_6b100-ecf80;/projects/OG-MasterDB/src/test/java/com/opengamma/masterdb/batch/ViewClientTest;testListenerNotifications();      newHashSet(
        new ComputedValueResult(
          new ValueSpecification(
            "Value2",
                    ComputationTargetSpecification.of(UniqueId.of("Scheme", "PrimitiveValue")),
            ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
          (byte) 2, AggregatedExecutionLog.EMPTY),
        new ComputedValueResult(
          new ValueSpecification(
            "Value1",
                    ComputationTargetSpecification.of(UniqueId.of("Scheme", "PrimitiveValue")),
            ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
          (byte) 1, AggregatedExecutionLog.EMPTY)
      ),
      fullFragment.getValue().getAllMarketData());;      newHashSet(
        new ComputedValueResult(
          new ValueSpecification(
            "Value2",
            new ComputationTargetSpecification(
              ComputationTargetType.PRIMITIVE,
              UniqueId.of("Scheme", "PrimitiveValue")),
            ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
          (byte) 2, AggregatedExecutionLog.EMPTY),
        new ComputedValueResult(
          new ValueSpecification(
            "Value1",
            new ComputationTargetSpecification(
              ComputationTargetType.PRIMITIVE,
              UniqueId.of("Scheme", "PrimitiveValue")),
            ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
          (byte) 1, AggregatedExecutionLog.EMPTY)
      ),
      fullFragment.getValue().getAllMarketData());;        newHashSet(
            new ComputedValueResult(
                new ValueSpecification(
                    "Value2",
                    new ComputationTargetSpecification(
                        ComputationTargetType.PRIMITIVE,
                        UniqueId.of("Scheme", "PrimitiveValue")),
                    ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
                (byte) 2, AggregatedExecutionLog.EMPTY),
            new ComputedValueResult(
                new ValueSpecification(
                    "Value1",
                    new ComputationTargetSpecification(
                        ComputationTargetType.PRIMITIVE,
                        UniqueId.of("Scheme", "PrimitiveValue")),
                    ValueProperties.with("Function", newHashSet("MarketDataSourcingFunction")).get()),
                (byte) 1, AggregatedExecutionLog.EMPTY)
        ),
        fullFragment.getValue().getAllMarketData());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6ba5a_3c588/rev_6ba5a-3c588;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/FixedIncomeConverterDataProvider;getIndexTimeSeries(InterestRateInstrumentType,SwapLeg,ZonedDateTime,ZonedDateTime,HistoricalTimeSeriesSource);      final IdentifierBundle id;
      //if (!indexID.getScheme().equals(SecurityUtils.BLOOMBERG_TICKER)) {
      ConventionBundle indexConvention = _conventionSource.getConventionBundle(floatingLeg.getFloatingReferenceRateIdentifier());
      if (indexConvention == null) {
        //TODO remove this immediately
        indexConvention = _conventionSource.getConventionBundle(Identifier.of(SecurityUtils.BLOOMBERG_TICKER, indexID.getValue()));
      }
      id = indexConvention.getIdentifiers();
      //indexID = indexConvention.getIdentifiers().getIdentifier(SecurityUtils.BLOOMBERG_TICKER);
      
      //final IdentifierBundle id = indexID.toBundle();;      if (!indexID.getScheme().equals(SecurityUtils.BLOOMBERG_TICKER)) {
        ConventionBundle indexConvention = _conventionSource.getConventionBundle(floatingLeg.getFloatingReferenceRateIdentifier());
        if (indexConvention == null) {
          //TODO remove this immediately
          indexConvention = _conventionSource.getConventionBundle(Identifier.of(SecurityUtils.BLOOMBERG_TICKER, indexID.getValue()));
        }
        indexID = indexConvention.getIdentifiers().getIdentifier(SecurityUtils.BLOOMBERG_TICKER);
      } 

      final IdentifierBundle id = indexID.toBundle();;      if (!indexID.getScheme().equals(SecurityUtils.BLOOMBERG_TICKER)) {
        ConventionBundle indexConvention = _conventionSource.getConventionBundle(floatingLeg.getFloatingReferenceRateIdentifier());
        if (indexConvention == null) {
          //TODO remove this immediately
          indexConvention = _conventionSource.getConventionBundle(Identifier.of(SecurityUtils.BLOOMBERG_TICKER, indexID.getValue()));
        }
        indexID = indexConvention.getIdentifiers().getIdentifier(SecurityUtils.BLOOMBERG_TICKER);
      }

      final IdentifierBundle id = indexID.toBundle();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6ba5a_3c588/rev_6ba5a-3c588;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/FixedIncomeConverterDataProvider;getIndexTimeSeries(InterestRateInstrumentType,SwapLeg,ZonedDateTime,ZonedDateTime,HistoricalTimeSeriesSource);          .getHistoricalTimeSeries(_fieldName, id, null, null, startDate, true, now.toLocalDate(), true);
      if (ts == null) {        
        throw new OpenGammaRuntimeException("Could not get time series of underlying index " + indexID.toString() + " bundle used was " + id);;          .getHistoricalTimeSeries(id, _dataSourceName, _dataProvider, _fieldName, startDate, true, now.toLocalDate(), true);
      if (ts == null) {        
        throw new OpenGammaRuntimeException("Could not get time series of underlying index " + indexID.toString());;          .getHistoricalTimeSeries(id, _dataSourceName, _dataProvider, _fieldName, startDate, true, now.toLocalDate(), true);
      if (ts == null) {
        throw new OpenGammaRuntimeException("Could not get time series of underlying index " + indexID.toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6be70_ef50e/rev_6be70-ef50e;/src/java/org/apache/cassandra/net/IncomingTcpConnection;run();            Gossiper.instance.setVersion(from, version);
            logger.debug("set version for {} to {}", from, version);
            ;            else if (msg != null)
            {
                Gossiper.instance.setVersion(from, version);
                logger.debug("set version for {} to {}", from, version);
            }
            ;            else if (msg != null)
            {
                Gossiper.instance.setVersion(from, version);
                logger.debug("set version for {} to {}", from, version);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6c195_05343/rev_6c195-05343;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);      if (_fundingCurveDefinitionName.equals(_forwardCurveDefinitionName)) {
        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, _fundingCurveDefinitionName).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;      if (getFundingCurveDefinitionName().equals(getForwardCurveDefinitionName())) {
        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, getFundingCurveDefinitionName()).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;      if (getFundingCurveDefinitionName().equals(getForwardCurveDefinitionName())) {
        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, getFundingCurveDefinitionName()).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6c195_05343/rev_6c195-05343;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);          derivative = financialSecurity.accept(futureAdapter).toDerivative(localNow, marketValue,
              _fundingCurveDefinitionName);;          derivative = financialSecurity.accept(futureAdapter).toDerivative(localNow, marketValue,
              getFundingCurveDefinitionName());;          derivative = financialSecurity.accept(futureAdapter).toDerivative(now, marketValue,
              getFundingCurveDefinitionName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6c195_05343/rev_6c195-05343;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);          derivative = financialSecurity.accept(futureAdapter).toDerivative(localNow, marketValue,
              _forwardCurveDefinitionName);;          derivative = financialSecurity.accept(futureAdapter).toDerivative(localNow, marketValue,
              getForwardCurveDefinitionName());;          derivative = financialSecurity.accept(futureAdapter).toDerivative(now, marketValue,
              getForwardCurveDefinitionName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6cd83_9dd28/rev_6cd83-9dd28;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;compile(FunctionCompilationContext,InstantProvider);    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _fundingHelper.compile(context, atInstant);
    ;    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _forwardHelper.compile(context, atInstant);
    ;    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _forwardHelper.compile(context, atInstant);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6cd83_d6e47/rev_6cd83-d6e47;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;compile(FunctionCompilationContext,InstantProvider);  public CompiledFunctionDefinition compile(FunctionCompilationContext context, InstantProvider atInstant) {
    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> forwardCompile = _forwardHelper.compile(context, atInstant);
    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _fundingHelper.compile(context, atInstant);
    
    InstantProvider earliest = max(forwardCompile.getFirst(), fundingCompile.getFirst());
    InstantProvider latest = min(forwardCompile.getSecond(), fundingCompile.getSecond());
    ;  public CompiledFunctionDefinition compile(FunctionCompilationContext context, InstantProvider atInstant) {
    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> forwardCompile = _forwardHelper.compile(context, atInstant);
    Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _forwardHelper.compile(context, atInstant);
    
    InstantProvider earliest = max(forwardCompile.getFirst(), fundingCompile.getFirst());
    InstantProvider latest = min(forwardCompile.getSecond(), fundingCompile.getSecond());
    ;  public CompiledFunctionDefinition compile(final FunctionCompilationContext context, final InstantProvider atInstant) {
    final Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> forwardCompile = _forwardHelper
        .compile(context, atInstant);
    final Triple<InstantProvider, InstantProvider, InterpolatedYieldCurveSpecification> fundingCompile = _forwardHelper
        .compile(context, atInstant);

    final InstantProvider earliest = max(forwardCompile.getFirst(), fundingCompile.getFirst());
    final InstantProvider latest = min(forwardCompile.getSecond(), fundingCompile.getSecond());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6d0e6_dc833/rev_6d0e6-dc833;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InstrumentDoubleCurveSensitivityCalculatorTest;testBumpedData();    final InterestRateDerivative cash = makeIRD("cash", 1.5, CURVE_NAMES.get(0), CURVE_NAMES.get(1), 0.04, notional);
    testBumpedDataParRateMethod(cash, notional, eps);
    final InterestRateDerivative libor = makeIRD("libor", 1.5, CURVE_NAMES.get(0), CURVE_NAMES.get(1), 0.04, notional);;    final InterestRateDerivative libor = makeIRD("libor", 1.5, CURVE_NAMES.get(0), CURVE_NAMES.get(1), 0.04, notional);;    final InterestRateDerivative libor = makeSingleCurrencyIRD("libor", 1.5, FRQ, CURVE_NAMES.get(0), CURVE_NAMES.get(1), 0.04, notional);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6db8a_cf532/rev_6db8a-cf532;/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement;getTypeAndRemove(Map<ColumnIdentifier,AbstractType>,ColumnIdentifier);                throw new InvalidRequestException(String.format("Unknown definition %s referenced in PRIMARY KEY", t));;                throw new InvalidRequestException(String.format("Unkown definition %s referenced in PRIMARY KEY", t));;                throw new InvalidRequestException(String.format("Unkown definition %s referenced in PRIMARY KEY", t));
            if (type instanceof CollectionType)
                throw new InvalidRequestException(String.format("Invalid collection type for PRIMARY KEY component %s", t));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6de04_f7033/rev_6de04-f7033;/examples/client_only/src/ClientOnlyExample;testWriting();            QueryProcessor.process(
                    new StringBuilder()
                            .append("INSERT INTO ")
                            .append(COLUMN_FAMILY)
                            .append(" (id, name, value) VALUES ( 'key")
                            .append(i)
                            .append("', 'colb', 'value")
                            .append(i)
                            .append("' )")
                            .toString(),
                    ConsistencyLevel.QUORUM,
                    new QueryState(state)
            );;            RowMutation change = new RowMutation(KEYSPACE, ByteBufferUtil.bytes(("key" + i)));
            ColumnPath cp = new ColumnPath(COLUMN_FAMILY).setColumn(("colb").getBytes());
            change.add(new QueryPath(cp), ByteBufferUtil.bytes(("value" + i)), 0);;            RowMutation change = new RowMutation(KEYSPACE, ByteBufferUtil.bytes(("key" + i)));
            change.add(COLUMN_FAMILY, ByteBufferUtil.bytes("colb"), ByteBufferUtil.bytes(("value" + i)), 0);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6de04_f7033/rev_6de04-f7033;/examples/client_only/src/ClientOnlyExample;testReading();            List<List<ByteBuffer>> rows = ((ResultMessage.Rows)QueryProcessor.process(
                    new StringBuilder()
                    .append("SELECT id, name, value FROM ")
                    .append(COLUMN_FAMILY)
                    .append(" WHERE id = 'key")
                    .append(i)
                    .append("'")
                    .toString(),
                    ConsistencyLevel.QUORUM,
                    new QueryState(state)
            )).result.rows;;            List<ReadCommand> commands = new ArrayList<ReadCommand>();
            SliceByNamesReadCommand readCommand = new SliceByNamesReadCommand(KEYSPACE, ByteBufferUtil.bytes(("key" + i)),
                                                                              new QueryPath(COLUMN_FAMILY, null, null), cols);
            readCommand.setDigestQuery(false);
            commands.add(readCommand);
            List<Row> rows = StorageProxy.read(commands, ConsistencyLevel.ONE);;            List<ReadCommand> commands = new ArrayList<ReadCommand>();
            SliceByNamesReadCommand readCommand = new SliceByNamesReadCommand(KEYSPACE, ByteBufferUtil.bytes(("key" + i)), COLUMN_FAMILY, new NamesQueryFilter(ByteBufferUtil.bytes("colb")));
            readCommand.setDigestQuery(false);
            commands.add(readCommand);
            List<Row> rows = StorageProxy.read(commands, ConsistencyLevel.ONE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6e81f_daff1/rev_6e81f-daff1;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;append(DecoratedKey,ColumnFamily);            ByteBufferUtil.writeWithShortLength(decoratedKey.key, dataFile.stream);

            // Since the columnIndex may insert RangeTombstone marker, computing
            // the size of the data is tricky.
            DataOutputBuffer buffer = new DataOutputBuffer();

            // build column index && write columns
            ColumnIndex.Builder builder = new ColumnIndex.Builder(cf, decoratedKey.key, buffer);
            ColumnIndex index = builder.build(cf);

            TypeSizes typeSizes = TypeSizes.NATIVE;
            long delSize = DeletionTime.serializer.serializedSize(cf.deletionInfo().getTopLevelDeletion(), typeSizes);
            dataFile.stream.writeLong(buffer.getLength() + delSize + typeSizes.sizeof(0));

            // Write deletion infos + column count
            DeletionTime.serializer.serialize(cf.deletionInfo().getTopLevelDeletion(), dataFile.stream);
            dataFile.stream.writeInt(builder.writtenAtomCount());
            dataFile.stream.write(buffer.getData(), 0, buffer.getLength());
            afterAppend(decoratedKey, startPosition, cf.deletionInfo().getTopLevelDeletion(), index);;            ByteBufferUtil.writeWithShortLength(decoratedKey.key, dataFile.stream);

            // Since the columnIndex may insert RangeTombstone marker, computing
            // the size of the data is tricky.
            DataOutputBuffer buffer = new DataOutputBuffer();

            // build column index && write columns
            ColumnIndex.Builder builder = new ColumnIndex.Builder(cf, decoratedKey.key, buffer);
            ColumnIndex index = builder.build(cf);

            TypeSizes typeSizes = TypeSizes.NATIVE;
            long delSize = DeletionTime.serializer.serializedSize(cf.deletionInfo().getTopLevelDeletion(), typeSizes);
            dataFile.stream.writeLong(buffer.getLength() + delSize + typeSizes.sizeof(0));

            // Write deletion infos + column count
            DeletionInfo.serializer().serializeForSSTable(cf.deletionInfo(), dataFile.stream);
            dataFile.stream.writeInt(builder.writtenAtomCount());
            dataFile.stream.write(buffer.getData(), 0, buffer.getLength());
            afterAppend(decoratedKey, startPosition, cf.deletionInfo(), index);;            RowIndexEntry entry = rawAppend(cf, startPosition, decoratedKey, dataFile.stream);
            afterAppend(decoratedKey, startPosition, entry);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_6e88c_5520e/rev_6e88c-5520e;/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper;uninstallApplications(long);		final Collection<String> applicationsList = adminFacade.getApplicationsNamesAndAuthGroups().values();
		
		final long startTime = System.currentTimeMillis();
		final long millisToEnd = end - startTime;
		final int minutesToEnd = (int) TimeUnit.MILLISECONDS.toMinutes(millisToEnd);
		;		final Collection<String> applicationsList = adminFacade.getApplicationsNamesAndAuthGroups().values();;		final Collection<String> applicationsList = adminFacade.getApplicationNamesList();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6e240_83b0b/rev_6e240-83b0b;/src/java/org/apache/cassandra/gms/Gossiper;unsafeAssassinateEndpoint(String);        try
        {
            Thread.sleep(intervalInMillis * 4);
        }
        catch (InterruptedException e)
        {
            throw new AssertionError(e);
        }
        logger.warn("Finished assassinating {}", endpoint);;        try
        {
            Thread.sleep(intervalInMillis * 4);
        }
        catch (InterruptedException e)
        {
            throw new AssertionError(e);
        }
        logger.warn("Finished killing {}", endpoint);;        Uninterruptibles.sleepUninterruptibly(intervalInMillis * 4, TimeUnit.MILLISECONDS);
        logger.warn("Finished killing {}", endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7;/src/java/voldemort/client/AbstractStoreClientFactory;getRawStore(String,InconsistencyResolver<Versioned<V>>);        Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                   storeDef,
                                                                   clientMapping,
                                                                   nonblockingStores,
                                                                   slopStores,
                                                                   repairReads,
                                                                   clientZoneId,
                                                                   getFailureDetector());;        Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                   storeDef,
                                                                   clientMapping,
                                                                   nonblockingStores,
                                                                   repairReads,
                                                                   clientZoneId,
                                                                   getFailureDetector());;        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6f31a_0f255/rev_6f31a-0f255;/src/java/org/apache/cassandra/io/sstable/SSTableScanner;next();                if (filter == null)
                {
                    row = new SSTableIdentityIterator(sstable, file, key, dataStart, dataSize);
                    return row;
                }
                else
                {
                    return row = new LazyColumnIterator(key, new IColumnIteratorFactory()
                    {
                        public IColumnIterator create()
                        {
                            return filter.getSSTableColumnIterator(sstable, file, key);
                        }
                    });
                };                if (filter == null)
                {
                    row = new SSTableIdentityIterator(sstable, file, key, dataStart, dataSize);
                    return row;
                }
                else
                {
                    return row = filter.getSSTableColumnIterator(sstable, file, key);
                };                row = new SSTableIdentityIterator(sstable, dfile, key, dataStart, dataSize);
                return row;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6ff3f_10b79/rev_6ff3f-10b79;/projects/OG-Engine/src/com/opengamma/engine/fudgemsg/DependencyNodeBuilder;buildMessage(FudgeSerializationContext,DependencyNode);      //TODO PLAT-1305 : at the moment this is largely useless, the ParameterizedFunction's inner function is more interesting
      msg.add(FUNCTION_UNIQUE_ID_FIELD, null, node.getFunction().getUniqueId());;      msg.add(FUNCTION_UNIQUE_ID_FIELD, null, node.getFunction().getUniqueId());;      msg.add(PARAMETERIZED_FUNCTION_UNIQUE_ID_FIELD, null, node.getFunction().getUniqueId());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_07b04_f7064/rev_07b04-f7064;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocal;OStorageLocal(String,String,String);      diskCache = new O2QCache(OGlobalConfiguration.DISK_CACHE_SIZE.getValueAsLong() * 1024 * 1024, directMemory,
          OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger(), this, false);;      diskCache = new OLRUCache(OGlobalConfiguration.DISK_CACHE_SIZE.getValueAsLong() * 1024 * 1024, directMemory,
          OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger(), this, false);;      diskCache = new OLRUCache(OGlobalConfiguration.DISK_CACHE_SIZE.getValueAsLong() * 1024 * 1024, directMemory,
          OGlobalConfiguration.DISK_CACHE_PAGE_SIZE.getValueAsInteger() * 1024, this, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_07b04_f7064/rev_07b04-f7064;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/OLocalPaginatedCluster;updateRecord(OClusterPosition,byte[],ORecordVersion,byte);      int deleteContentSize;
      long firstPageMemoryPointer = diskCache.loadForWrite(fileId, firstPageIndex);;      int deleteContentSize;
      long firstPageMemoryPointer = diskCache.loadAndLockForWrite(fileId, firstPageIndex);;      long firstPageMemoryPointer = diskCache.loadAndLockForWrite(fileId, firstPageIndex);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_07b04_f7064/rev_07b04-f7064;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/OLocalPaginatedCluster;addEntry(ORecordVersion,byte[]);    long pagePointer = diskCache.loadForWrite(fileId, pageIndex);;    long pagePointer = diskCache.loadAndLockForWrite(fileId, pageIndex);;    long pagePointer = diskCache.loadAndLockForWrite(fileId, pageIndex);
    int recordSizesDiff;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7b0bf_3d0f1/rev_7b0bf-3d0f1;/src/java/org/apache/cassandra/db/ColumnFamilyStore;maybeSwitchMemtable(Memtable,boolean);        if (oldMemtable.isFrozen())
        {
            logger.debug("memtable is already frozen; another thread must be flushing it");
            return null;
        }

        /*
         * If we can get the writelock, that means no new updates can come in and
         * all ongoing updates to memtables have completed. We can get the tail
         * of the log and use it as the starting position for log replay on recovery.
         *
         * This is why we Table.flusherLock needs to be global instead of per-Table:
         * we need to schedule discardCompletedSegments calls in the same order as their
         * contexts (commitlog position) were read, even though the flush executor
         * is multithreaded.
         */
        Table.flusherLock.writeLock().lock();
        try;        /*
         * If we can get the writelock, that means no new updates can come in and
         * all ongoing updates to memtables have completed. We can get the tail
         * of the log and use it as the starting position for log replay on recovery.
         *
         * This is why we Table.flusherLock needs to be global instead of per-Table:
         * we need to schedule discardCompletedSegments calls in the same order as their
         * contexts (commitlog position) were read, even though the flush executor
         * is multithreaded.
         */
        Table.flusherLock.writeLock().lock();
        try;        // Only one thread will succeed in marking it as pending flush; the others can go back to processing writes
        if (!oldMemtable.markPendingFlush())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7b0bf_3d0f1/rev_7b0bf-3d0f1;/src/java/org/apache/cassandra/db/ColumnFamilyStore;maybeSwitchMemtable(Memtable,boolean);            Table.flusherLock.writeLock().unlock();;            Table.flusherLock.writeLock().unlock();
            if (memtableSwitchCount == Integer.MAX_VALUE)
            {
                memtableSwitchCount = 0;
            }
            memtableSwitchCount++;;            Table.flusherLock.unlock();
            if (memtableSwitchCount == Integer.MAX_VALUE)
            {
                memtableSwitchCount = 0;
            }
            memtableSwitchCount++;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7bc35_ab5a8/rev_7bc35-ab5a8;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;getTotalBytes();                // (length is still valid post-close)
                return dfile.length();;                return dfile.length();;                return indexer.dfile.length();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7bc35_ab5a8/rev_7bc35-ab5a8;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;getBytesComplete();            maybeOpenFile();
            // (getFilePointer is still valid post-close)
            return dfile.getFilePointer();;            return dfile.getFilePointer();;            return indexer.dfile.getFilePointer();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7bfd0_2b1f4/rev_7bfd0-2b1f4;/src/java/org/apache/cassandra/thrift/CassandraServer;describe_ring(String);        return StorageService.instance.describeRing(keyspace);;        if (keyspace == null || !Schema.instance.getNonSystemTables().contains(keyspace))
            throw new InvalidRequestException("There is no ring for the keyspace: " + keyspace);

        List<TokenRange> ranges = new ArrayList<TokenRange>();
        Token.TokenFactory tf = StorageService.getPartitioner().getTokenFactory();

        for (Map.Entry<Range, List<InetAddress>> entry : StorageService.instance.getRangeToAddressMap(keyspace).entrySet())
        {
            Range range = entry.getKey();
            List<String> endpoints = new ArrayList<String>();
            List<String> rpc_endpoints = new ArrayList<String>();
            List<EndpointDetails> epDetails = new ArrayList<EndpointDetails>();

            for (InetAddress endpoint : entry.getValue())
            {
                EndpointState eps = Gossiper.instance.getEndpointStateForEndpoint(endpoint);
                EndpointDetails details = new EndpointDetails();

                details.host = endpoint.getHostAddress();
                details.datacenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);
                details.rack = DatabaseDescriptor.getEndpointSnitch().getRack(endpoint);

                endpoints.add(details.host);
                rpc_endpoints.add(StorageService.instance.getRpcaddress(endpoint));

                epDetails.add(details);
            }

            TokenRange tr = new TokenRange(tf.toString(range.left), tf.toString(range.right), endpoints)
                            .setEndpoint_details(epDetails)
                            .setRpc_endpoints(rpc_endpoints);
            ranges.add(tr);
        }

        return ranges;;        if (keyspace == null || !Schema.instance.getNonSystemTables().contains(keyspace))
            throw new InvalidRequestException("There is no ring for the keyspace: " + keyspace);

        List<TokenRange> ranges = new ArrayList<TokenRange>();
        Token.TokenFactory tf = StorageService.getPartitioner().getTokenFactory();

        for (Map.Entry<Range<Token>, List<InetAddress>> entry : StorageService.instance.getRangeToAddressMap(keyspace).entrySet())
        {
            Range<Token> range = entry.getKey();
            List<String> endpoints = new ArrayList<String>();
            List<String> rpc_endpoints = new ArrayList<String>();
            List<EndpointDetails> epDetails = new ArrayList<EndpointDetails>();

            for (InetAddress endpoint : entry.getValue())
            {
                EndpointState eps = Gossiper.instance.getEndpointStateForEndpoint(endpoint);
                EndpointDetails details = new EndpointDetails();

                details.host = endpoint.getHostAddress();
                details.datacenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);
                details.rack = DatabaseDescriptor.getEndpointSnitch().getRack(endpoint);

                endpoints.add(details.host);
                rpc_endpoints.add(StorageService.instance.getRpcaddress(endpoint));

                epDetails.add(details);
            }

            TokenRange tr = new TokenRange(tf.toString(range.left), tf.toString(range.right), endpoints)
                            .setEndpoint_details(epDetails)
                            .setRpc_endpoints(rpc_endpoints);
            ranges.add(tr);
        }

        return ranges;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7c628_6ad81/rev_7c628-6ad81;/src/com/opengamma/engine/view/ViewDefinition;equals(Object);    if (obj instanceof ViewDefinition) {
      ViewDefinition other = (ViewDefinition) obj;
      return ObjectUtils.equals(getName(), other.getName()) 
        && ObjectUtils.equals(getPortfolioId(), other.getPortfolioId())
        && ObjectUtils.equals(getLiveDataUser(), other.getLiveDataUser())
        && ObjectUtils.equals(getResultModelDefinition(), other.getResultModelDefinition())
        && ObjectUtils.equals(_deltaRecalculationPeriod, other._deltaRecalculationPeriod)
        && ObjectUtils.equals(_fullRecalculationPeriod, other._fullRecalculationPeriod)
        && ObjectUtils.equals(getAllCalculationConfigurationNames(), other.getAllCalculationConfigurationNames())
        && ObjectUtils.equals(getAllValueRequirements(), other.getAllValueRequirements());;    if (obj instanceof ViewDefinition) {
      ViewDefinition other = (ViewDefinition) obj;
      return ObjectUtils.equals(getName(), other.getName()) 
        && ObjectUtils.equals(getPortfolioId(), other.getPortfolioId())
        && ObjectUtils.equals(getLiveDataUser(), other.getLiveDataUser())
        && ObjectUtils.equals(_computePortfolioNodeCalculations, other._computePortfolioNodeCalculations)
        && ObjectUtils.equals(_computePositionNodeCalculations, other._computePositionNodeCalculations)
        && ObjectUtils.equals(_computePrimitiveNodeCalculations, other._computePrimitiveNodeCalculations)
        && ObjectUtils.equals(_computeSecurityNodeCalculations, other._computeSecurityNodeCalculations)
        && ObjectUtils.equals(_deltaRecalculationPeriod, other._deltaRecalculationPeriod)
        && ObjectUtils.equals(_fullRecalculationPeriod, other._fullRecalculationPeriod)
        && ObjectUtils.equals(getAllCalculationConfigurationNames(), other.getAllCalculationConfigurationNames())
        && ObjectUtils.equals(getAllValueRequirements(), other.getAllValueRequirements());;    
    if (!(obj instanceof ViewDefinition)) {
      return false;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7d0f7_a0710/rev_7d0f7-a0710;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeFunction;compile(FunctionCompilationContext,InstantProvider);      public Set<ComputedValue> execute(FunctionExecutionContext executionContext, FunctionInputs inputs,
          ComputationTarget target, Set<ValueRequirement> desiredValues) {
        
        VolatilityCubeData data = (VolatilityCubeData) inputs.getValue(getMarketDataRequirement());
        Map<Tenor, Map<Tenor, Pair<double[], double[]>>> smiles = data.getSmiles();
        //TODO this
        return Sets.newHashSet(new ComputedValue(_cubeResult, smiles.size()));;      public Set<ComputedValue> execute(FunctionExecutionContext executionContext, FunctionInputs inputs,
          ComputationTarget target, Set<ValueRequirement> desiredValues) {
        @SuppressWarnings("unused")
        VolatilityCubeData data = (VolatilityCubeData) inputs.getValue(getMarketDataRequirement());
        //TODO this
        return Sets.newHashSet(new ComputedValue(_cubeResult, 0xdeadbeef));;      public Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final FunctionInputs inputs,
          final ComputationTarget target, final Set<ValueRequirement> desiredValues) {
        @SuppressWarnings("unused")
        final VolatilityCubeData data = (VolatilityCubeData) inputs.getValue(getMarketDataRequirement());
        //TODO this is where the data should be sorted into useable form
        return Sets.newHashSet(new ComputedValue(_cubeResult, 0xdeadbeef));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7d36c_83ff1/rev_7d36c-83ff1;/src/java/org/apache/cassandra/db/Memtable;getLiveSize();
        // 25% fudge factor on the base throughput * liveRatio calculation.  (Based on observed
        // pre-slabbing behavior -- not sure what accounts for this. May have changed with introduction of slabbing.)
        long estimatedSize = (long) (currentSize.get() * cfs.liveRatio * 1.25);

        // cap the estimate at both ends by what the allocator can tell us
        if (estimatedSize < allocator.getMinimumSize())
            return allocator.getMinimumSize();
        if (estimatedSize > allocator.getMaximumSize())
            return allocator.getMaximumSize();

        return estimatedSize;;        // 25% fudge factor on the base throughput * liveRatio calculation.  (Based on observed
        // pre-slabbing behavior -- not sure what accounts for this. May have changed with introduction of slabbing.)
        return (long) (currentSize.get() * cfs.liveRatio * 1.25);;        return (long) (currentSize.get() * cfs.liveRatio);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_7dbde_50c40/rev_7dbde-50c40;/roboguice/src/main/java/roboguice/RoboGuice;setBaseApplicationInjector(Application,Stage);            final ArrayList<Module> modules = new ArrayList<Module>();

            try {
                final ApplicationInfo ai = application.getPackageManager().getApplicationInfo(application.getPackageName(), PackageManager.GET_META_DATA);
                final Bundle bundle = ai.metaData;
                final String roboguiceModules = bundle!=null ? bundle.getString("roboguice.modules") : null;
                final DefaultRoboModule defaultRoboModule = newDefaultRoboModule(application);
                final String[] moduleNames = roboguiceModules!=null ? roboguiceModules.split("[\\s,]") : new String[]{};

                modules.add(defaultRoboModule);

                for (String name : moduleNames) {
                    if( Strings.notEmpty(name)) {
                        final Class<? extends Module> clazz = Class.forName(name).asSubclass(Module.class);
                        try {
                            modules.add(clazz.getDeclaredConstructor(Application.class).newInstance(application));
                        } catch( NoSuchMethodException ignored ) {
                            modules.add( clazz.newInstance() );
                        }
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Unable to instantiate your Module.  Check your roboguice.modules metadata in your AndroidManifest.xml",e);
            };            final ArrayList<Module> modules = new ArrayList<Module>();

            try {
                final ApplicationInfo ai = application.getPackageManager().getApplicationInfo(application.getPackageName(), PackageManager.GET_META_DATA);
                final Bundle bundle = ai.metaData;
                final String roboguiceModules = bundle!=null ? bundle.getString("roboguice.modules") : null;
                final DefaultRoboModule defaultRoboModule = newDefaultRoboModule(application);
                final String[] moduleNames = roboguiceModules!=null ? roboguiceModules.split("[\\s,]") : new String[]{};

                modules.add(defaultRoboModule);

                for (String name : moduleNames) {
                    if( Strings.notEmpty(name)) {
                        final Class<? extends Module> clazz = Class.forName(name).asSubclass(Module.class);
                        try {
                            modules.add(clazz.getDeclaredConstructor(Context.class).newInstance(application));
                        } catch( NoSuchMethodException ignored ) {
                            modules.add( clazz.newInstance() );
                        }
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Unable to instantiate your Module.  Check your roboguice.modules metadata in your AndroidManifest.xml",e);
            };            final ArrayList<Module> modules = getModulesFromManifest(application);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;newTestWriteEndpointsDuringLeave();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;newTestWriteEndpointsDuringLeave();                valueFactory.leaving(endpointTokens.get(LEAVING_NODE)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.leaving(endpointTokens.get(LEAVING_NODE)));;                valueFactory.leaving(Collections.singleton(endpointTokens.get(LEAVING_NODE))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testSimultaneousMove();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testSimultaneousMove();            ss.onChange(hosts.get(leaving), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(leaving)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;            ss.onChange(hosts.get(leaving), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(leaving)));;            ss.onChange(hosts.get(leaving),
                        ApplicationState.STATUS,
                        valueFactory.leaving(Collections.singleton(endpointTokens.get(leaving))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testSimultaneousMove();        ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));;        Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
        Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
        ss.onChange(boot2,
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testSimultaneousMove();                valueFactory.left(endpointTokens.get(LEAVING[0]), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(endpointTokens.get(LEAVING[0]), Gossiper.computeExpireTime()));;                valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[0])), Gossiper.computeExpireTime()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testSimultaneousMove();                valueFactory.left(endpointTokens.get(LEAVING[2]), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();
        ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(keyTokens.get(5)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(endpointTokens.get(LEAVING[2]), Gossiper.computeExpireTime()));
        ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(keyTokens.get(5)));;                valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[2])), Gossiper.computeExpireTime()));
        ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(5))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToBootstrap();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToBootstrap();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));;        ss.onChange(hosts.get(2),
                    ApplicationState.STATUS,
                    valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToBootstrap();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(4)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(4)));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
        ss.onChange(hosts.get(2),
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(4))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToBootstrap();        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));;        Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
        ss.onChange(hosts.get(3),
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToBootstrap();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(3)));
        PendingRangeCalculatorService.instance.blockUntilFinished();
        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(3)));
        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));;        Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(3))));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(3))));
        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToNormal();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToNormal();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToNormal();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToNormal();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(2)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(2)));;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(2))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToNormal();                valueFactory.left(keyTokens.get(2), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(4)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(keyTokens.get(2), Gossiper.computeExpireTime()));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(4)));;                valueFactory.left(Collections.singleton(keyTokens.get(2)), Gossiper.computeExpireTime()));
        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(4))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeaving();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeaving();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(0)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(0)));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(0))));
        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(0))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeaving();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));;        Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
        ss.onChange(hosts.get(2),
                    ApplicationState.STATUS,
                    valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeaving();        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(1)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(1)));;        ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(1))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeaving();                valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));;                valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeft();        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
        PendingRangeCalculatorService.instance.blockUntilFinished();;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);;        Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeft();                valueFactory.left(endpointTokens.get(2), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(endpointTokens.get(2), Gossiper.computeExpireTime()));;                valueFactory.left(Collections.singleton(endpointTokens.get(2)), Gossiper.computeExpireTime()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeft();        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
        PendingRangeCalculatorService.instance.blockUntilFinished();;        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));;        Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
        ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7de6f_3a81a/rev_7de6f-3a81a;/test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest;testStateJumpToLeft();                valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));
        PendingRangeCalculatorService.instance.blockUntilFinished();;                valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));;                valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0;/src/java/voldemort/store/routed/RoutedStore;delete(ByteArray,Version);                        markUnavailable(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;;                        markUnavailable(node, e);;                        failureDetector.recordException(node, e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0;/src/java/voldemort/store/routed/RoutedStore;getAll(Iterable<ByteArray>);                            markUnavailable(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;;                            markUnavailable(node, e);;                            failureDetector.recordException(node, e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0;/src/java/voldemort/store/routed/RoutedStore;get(ByteArray,StoreOp<R>,Function<List<GetResult<R>>,Void>);                markUnavailable(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;;                markUnavailable(node, e);;                failureDetector.recordException(node, e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_7e1a1_bbb86/rev_7e1a1-bbb86;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolOverflow();        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");;        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");;	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_7e1a1_bbb86/rev_7e1a1-bbb86;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;securePool();        JedisPoolConfig config = new JedisPoolConfig();
        config.setTestOnBorrow(true);
        JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort(), 
        		2000, "foobared");
        Jedis jedis = pool.getResource();
        jedis.set("foo", "bar");
        pool.returnResource(jedis);
        pool.destroy();;        JedisPoolConfig config = new JedisPoolConfig();
        config.setTestOnBorrow(true);
        JedisPool pool = new JedisPool(config, hnp.host, hnp.port, 2000, "foobared");
        Jedis jedis = pool.getResource();
        jedis.set("foo", "bar");
        pool.returnResource(jedis);
        pool.destroy();;	JedisPoolConfig config = new JedisPoolConfig();
	config.setTestOnBorrow(true);
	JedisPool pool = new JedisPool(config, hnp.host, hnp.port, 2000,
		"foobared");
	Jedis jedis = pool.getResource();
	jedis.set("foo", "bar");
	pool.returnResource(jedis);
	pool.destroy();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_7e1a1_bbb86/rev_7e1a1-bbb86;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;selectDatabaseOnActivation();	public void selectDatabaseOnActivation() {
		JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
				hnp.getPort(), 2000, "foobared");;	public void selectDatabaseOnActivation() {
		JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host, hnp.port, 2000, "foobared");;    public void selectDatabaseOnActivation() {
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7e6c4_f3b7b/rev_7e6c4-f3b7b;/projects/OG-Financial/src/com/opengamma/financial/view/rest/DataViewClientResource;getLatestResult();    FudgeSerializationContext context = getFudgeSerializationContext();
    MutableFudgeMsg msg = context.newMessage();
    context.objectToFudgeMsg(msg, PATH_LATEST_RESULT, null, getViewClient().getLatestResult());
    return Response.ok(new FudgeMsgEnvelope(msg)).build();;    FudgeSerializationContext context = getFudgeSerializationContext();
    MutableFudgeFieldContainer msg = context.newMessage();
    context.objectToFudgeMsg(msg, PATH_LATEST_RESULT, null, getViewClient().getLatestResult());
    return Response.ok(new FudgeMsgEnvelope(msg)).build();;    return Response.ok(getViewClient().getLatestResult()).build();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7f2c9_148a3/rev_7f2c9-148a3;/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedFundingAndForwardCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);    final LocalDate now = executionContext.getSnapshotClock().today();
    final Calendar calendar = new HolidayRepositoryCalendarAdapter(OpenGammaExecutionContext.getHolidayRepository(executionContext), _currency);
    final Region region = OpenGammaExecutionContext.getRegionRepository(executionContext).getHierarchyNode(now.toLocalDate(), _currency.getUniqueIdentifier());
    final List<InterestRateDerivative> derivatives = new ArrayList<InterestRateDerivative>();
    final Set<FixedIncomeStrip> fundingStrips = _fundingDefinition.getStrips();
    final int nFund = fundingStrips.size();
    final Set<FixedIncomeStrip> forwardStrips = _forwardDefinition.getStrips();
    final int nForward = forwardStrips.size();
    final double[] marketRates = new double[nFund + nForward];
    final double[] initialRatesGuess = new double[nFund + nForward];
    final double[] fundingNodeTimes = new double[nFund];
    InterestRateDerivative derivative;
    ValueRequirement stripRequirement;
    Double rate = (Double) inputs.getValue(_spotRateRequirement);
    if (rate == null) {
      throw new NullPointerException("Could not get spot rate for " + _currency);
    }
    rate = (Double) inputs.getValue(_referenceRateRequirement);
    if (rate == null) {
      throw new NullPointerException("Could not get first floating rate for " + _currency);
    }
    int i = 0;
    for (final FixedIncomeStrip strip : fundingStrips) {     
      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
      rate = (Double) inputs.getValue(stripRequirement);
      if (rate == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      if (strip.getInstrumentType() != StripInstrument.FUTURE) {
        rate = rate / 100.;
      }
      derivative = getInterestRateDerivative(strip, calendar, region, now, rate);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.05;
      
      fundingNodeTimes[i] = getLastTime(derivative);
      i++;
    }
    final double[] forwardNodeTimes = new double[nForward];
    
    int j = 0;
    for (final FixedIncomeStrip strip : forwardStrips) {
      
      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
      rate = (Double) inputs.getValue(stripRequirement);
      if (rate == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      if (strip.getInstrumentType() != StripInstrument.FUTURE) {
        rate = rate / 100.;
      }
      derivative = getInterestRateDerivative(strip, calendar, region, now, rate);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.05;
      
      marketRates[i] = rate;
      forwardNodeTimes[j] = getLastTime(derivative);
      i++;
      j++;
    }
    LinkedHashMap<String, double[]> curveNodes = new LinkedHashMap<String, double[]>();
    LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>> curveInterpolators = new LinkedHashMap<String, Interpolator1D<? extends Interpolator1DDataBundle>>();
    LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>> curveSensitivityCalculators = 
      new LinkedHashMap<String, Interpolator1DNodeSensitivityCalculator<? extends Interpolator1DDataBundle>>();
    curveNodes.put(LIBOR_CURVE_NAME, forwardNodeTimes);
    curveNodes.put(FUNDING_CURVE_NAME, fundingNodeTimes);
    curveInterpolators.put(LIBOR_CURVE_NAME, _forwardInterpolator);
    curveInterpolators.put(FUNDING_CURVE_NAME, _fundingInterpolator);
    curveSensitivityCalculators.put(LIBOR_CURVE_NAME, _forwardSensitivityCalculator);
    curveSensitivityCalculators.put(FUNDING_CURVE_NAME, _fundingSensitivityCalculator);
    MultipleYieldCurveFinderDataBundle data = new MultipleYieldCurveFinderDataBundle(derivatives, null, curveNodes, curveInterpolators, curveSensitivityCalculators);
    JacobianCalculator jacobian = new MultipleYieldCurveFinderJacobian(data, ParRateCurveSensitivityCalculator.getInstance()); //TODO have calculator as input
    Function1D<DoubleMatrix1D, DoubleMatrix1D> curveFinder = new MultipleYieldCurveFinderFunction(data, ParRateDifferenceCalculator.getInstance()); //TODO have calculator as input
    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, jacobian, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
    final double[] yields = rootFinder.getRoot(curveFinder, new DoubleMatrix1D(initialRatesGuess)).getData();
    final double[] forwardYields = Arrays.copyOfRange(yields, 0, nForward);
    final double[] fundingYields = Arrays.copyOfRange(yields, nForward, yields.length);
    final YieldAndDiscountCurve fundingCurve = new InterpolatedYieldCurve(fundingNodeTimes, fundingYields, _fundingInterpolator);
    final YieldAndDiscountCurve forwardCurve = new InterpolatedYieldCurve(forwardNodeTimes, forwardYields, _forwardInterpolator);
    final DoubleMatrix2D jacobianMatrix = jacobian.evaluate(new DoubleMatrix1D(yields), (Function1D<DoubleMatrix1D, DoubleMatrix1D>[]) null);
    return Sets.newHashSet(new ComputedValue(_fundingCurveResult, fundingCurve), new ComputedValue(_forwardCurveResult, forwardCurve), new ComputedValue(_jacobianResult, jacobianMatrix.getData()));;    final LocalDate now = executionContext.getSnapshotClock().today();
    final Calendar calendar = new HolidayRepositoryCalendarAdapter(OpenGammaExecutionContext.getHolidayRepository(executionContext), _currency);
    final Region region = OpenGammaExecutionContext.getRegionRepository(executionContext).getHierarchyNode(now.toLocalDate(), _currency.getUniqueIdentifier());
    final List<InterestRateDerivative> derivatives = new ArrayList<InterestRateDerivative>();
    final Set<FixedIncomeStrip> fundingStrips = _fundingDefinition.getStrips();
    final int nFund = fundingStrips.size();
    final Set<FixedIncomeStrip> forwardStrips = _forwardDefinition.getStrips();
    final int nForward = forwardStrips.size();
    final double[] marketRates = new double[nFund + nForward];
    final double[] initialRatesGuess = new double[nFund + nForward];
    final double[] fundingNodeTimes = new double[nFund];
    InterestRateDerivative derivative;
    ValueRequirement stripRequirement;
    Double rate = (Double) inputs.getValue(_spotRateRequirement);
    if (rate == null) {
      throw new NullPointerException("Could not get spot rate for " + _currency);
    }
    rate = (Double) inputs.getValue(_referenceRateRequirement);
    if (rate == null) {
      throw new NullPointerException("Could not get first floating rate for " + _currency);
    }
    //final double referenceFloatingRate = rate;
    int i = 0;
    for (final FixedIncomeStrip strip : fundingStrips) {     
      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
      rate = (Double) inputs.getValue(stripRequirement);
      if (rate == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      if (strip.getInstrumentType() != StripInstrument.FUTURE) {
        rate = rate / 100.;
      }
      derivative = getInterestRateDerivative(strip, calendar, region, now,rate);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.05;
      
      fundingNodeTimes[i] = getLastTime(derivative);
      i++;
    }
    final double[] forwardNodeTimes = new double[nForward];
    
    int j = 0;
    for (final FixedIncomeStrip strip : forwardStrips) {
      
      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
      rate = (Double) inputs.getValue(stripRequirement);
      if (rate == null) {
        throw new NullPointerException("Could not get market data for " + strip);
      }
      if (strip.getInstrumentType() != StripInstrument.FUTURE) {
        rate = rate/100.;
      }
      derivative = getInterestRateDerivative(strip, calendar, region, now,rate);
      if (derivative == null) {
        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
      }
      derivatives.add(derivative);
      initialRatesGuess[i] = 0.05;
      
      marketRates[i] = rate;
      forwardNodeTimes[j] = getLastTime(derivative);
      i++;
      j++;
    }

//    LinkedHashMap<String, FixedNodeInterpolator1D> unknownCurves = new LinkedHashMap<String, FixedNodeInterpolator1D>();
//    FixedNodeInterpolator1D fnInterpolator = new FixedNodeInterpolator1D(forwardNodeTimes, _interpolatorWithSensitivity);
//    unknownCurves.put(LIBOR_CURVE_NAME, fnInterpolator);
//    fnInterpolator = new FixedNodeInterpolator1D(fundingNodeTimes, _interpolatorWithSensitivity);
//    unknownCurves.put(FUNDING_CURVE_NAME, fnInterpolator);
//    final JacobianCalculator jacobian = new MultipleYieldCurveFinderJacobian(derivatives, unknownCurves, null,ParRateCurveSensitivityCalculator.getInstance());
//
//    unknownCurves = new LinkedHashMap<String, FixedNodeInterpolator1D>();
//    fnInterpolator = new FixedNodeInterpolator1D(forwardNodeTimes, _interpolator);
//    unknownCurves.put(LIBOR_CURVE_NAME, fnInterpolator);
//    fnInterpolator = new FixedNodeInterpolator1D(fundingNodeTimes, _interpolator);
//    unknownCurves.put(FUNDING_CURVE_NAME, fnInterpolator);
//    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveFinder = new MultipleYieldCurveFinderFunction(derivatives, unknownCurves, null,ParRateDifferanceCalculator.getInstance());
//
//
//    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, jacobian, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
//    final double[] yields = rootFinder.getRoot(curveFinder, new DoubleMatrix1D(initialRatesGuess)).getData();
//    final double[] forwardYields = Arrays.copyOfRange(yields, 0, nForward);
//    final double[] fundingYields = Arrays.copyOfRange(yields, nForward, yields.length);
//    final YieldAndDiscountCurve fundingCurve = new InterpolatedYieldCurve(fundingNodeTimes, fundingYields, _interpolator);
//    final YieldAndDiscountCurve forwardCurve = new InterpolatedYieldCurve(forwardNodeTimes, forwardYields, _interpolator);
//    final DoubleMatrix2D jacobianMatrix = jacobian.evaluate(new DoubleMatrix1D(yields), (Function1D<DoubleMatrix1D, DoubleMatrix1D>[]) null);
//    return Sets.newHashSet(new ComputedValue(_fundingCurveResult, fundingCurve), new ComputedValue(_forwardCurveResult, forwardCurve), new ComputedValue(_jacobianResult, jacobianMatrix.getData()));
    return null;;//    final LocalDate now = executionContext.getSnapshotClock().today();
//    final Calendar calendar = new HolidayRepositoryCalendarAdapter(OpenGammaExecutionContext.getHolidayRepository(executionContext), _currency);
//    final Region region = OpenGammaExecutionContext.getRegionRepository(executionContext).getHierarchyNode(now.toLocalDate(), _currency.getUniqueIdentifier());
//    final List<InterestRateDerivative> derivatives = new ArrayList<InterestRateDerivative>();
//    final Set<FixedIncomeStrip> fundingStrips = _fundingDefinition.getStrips();
//    final int nFund = fundingStrips.size();
//    final Set<FixedIncomeStrip> forwardStrips = _forwardDefinition.getStrips();
//    final int nForward = forwardStrips.size();
//    final double[] marketRates = new double[nFund + nForward];
//    final double[] initialRatesGuess = new double[nFund + nForward];
//    final double[] fundingNodeTimes = new double[nFund];
//    InterestRateDerivative derivative;
//    ValueRequirement stripRequirement;
//    Double rate = (Double) inputs.getValue(_spotRateRequirement);
//    if (rate == null) {
//      throw new NullPointerException("Could not get spot rate for " + _currency);
//    }
//    rate = (Double) inputs.getValue(_referenceRateRequirement);
//    if (rate == null) {
//      throw new NullPointerException("Could not get first floating rate for " + _currency);
//    }
//    //final double referenceFloatingRate = rate;
//    int i = 0;
//    for (final ResolvedFixedIncomeStrip strip : fundingStrips) {     
//      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
//      rate = (Double) inputs.getValue(stripRequirement);
//      if (rate == null) {
//        throw new NullPointerException("Could not get market data for " + strip);
//      }
//      if (strip.getInstrumentType() != StripInstrumentType.FUTURE) {
//        rate = rate / 100.;
//      }
//      derivative = getInterestRateDerivative(strip, calendar, region, now,rate);
//      if (derivative == null) {
//        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
//      }
//      derivatives.add(derivative);
//      initialRatesGuess[i] = 0.05;
//      
//      fundingNodeTimes[i] = getLastTime(derivative);
//      i++;
//    }
//    final double[] forwardNodeTimes = new double[nForward];
//    
//    int j = 0;
//    for (final FixedIncomeStrip strip : forwardStrips) {
//      
//      stripRequirement = new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, strip.getMarketDataSpecification());
//      rate = (Double) inputs.getValue(stripRequirement);
//      if (rate == null) {
//        throw new NullPointerException("Could not get market data for " + strip);
//      }
//      if (strip.getInstrumentType() != StripInstrumentType.FUTURE) {
//        rate = rate/100.;
//      }
//      derivative = getInterestRateDerivative(strip, calendar, region, now,rate);
//      if (derivative == null) {
//        throw new NullPointerException("Had a null InterestRateDefinition for " + strip);
//      }
//      derivatives.add(derivative);
//      initialRatesGuess[i] = 0.05;
//      
//      marketRates[i] = rate;
//      forwardNodeTimes[j] = getLastTime(derivative);
//      i++;
//      j++;
//    }

//    LinkedHashMap<String, FixedNodeInterpolator1D> unknownCurves = new LinkedHashMap<String, FixedNodeInterpolator1D>();
//    FixedNodeInterpolator1D fnInterpolator = new FixedNodeInterpolator1D(forwardNodeTimes, _interpolatorWithSensitivity);
//    unknownCurves.put(LIBOR_CURVE_NAME, fnInterpolator);
//    fnInterpolator = new FixedNodeInterpolator1D(fundingNodeTimes, _interpolatorWithSensitivity);
//    unknownCurves.put(FUNDING_CURVE_NAME, fnInterpolator);
//    final JacobianCalculator jacobian = new MultipleYieldCurveFinderJacobian(derivatives, unknownCurves, null,ParRateCurveSensitivityCalculator.getInstance());
//
//    unknownCurves = new LinkedHashMap<String, FixedNodeInterpolator1D>();
//    fnInterpolator = new FixedNodeInterpolator1D(forwardNodeTimes, _interpolator);
//    unknownCurves.put(LIBOR_CURVE_NAME, fnInterpolator);
//    fnInterpolator = new FixedNodeInterpolator1D(fundingNodeTimes, _interpolator);
//    unknownCurves.put(FUNDING_CURVE_NAME, fnInterpolator);
//    final Function1D<DoubleMatrix1D, DoubleMatrix1D> curveFinder = new MultipleYieldCurveFinderFunction(derivatives, unknownCurves, null,ParRateDifferanceCalculator.getInstance());
//
//
//    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(1e-7, 1e-7, 100, jacobian, DecompositionFactory.getDecomposition(DecompositionFactory.SV_COMMONS_NAME));
//    final double[] yields = rootFinder.getRoot(curveFinder, new DoubleMatrix1D(initialRatesGuess)).getData();
//    final double[] forwardYields = Arrays.copyOfRange(yields, 0, nForward);
//    final double[] fundingYields = Arrays.copyOfRange(yields, nForward, yields.length);
//    final YieldAndDiscountCurve fundingCurve = new InterpolatedYieldCurve(fundingNodeTimes, fundingYields, _interpolator);
//    final YieldAndDiscountCurve forwardCurve = new InterpolatedYieldCurve(forwardNodeTimes, forwardYields, _interpolator);
//    final DoubleMatrix2D jacobianMatrix = jacobian.evaluate(new DoubleMatrix1D(yields), (Function1D<DoubleMatrix1D, DoubleMatrix1D>[]) null);
//    return Sets.newHashSet(new ComputedValue(_fundingCurveResult, fundingCurve), new ComputedValue(_forwardCurveResult, forwardCurve), new ComputedValue(_jacobianResult, jacobianMatrix.getData()));
    return null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7f9e9_92193/rev_7f9e9-92193;/src/java/org/apache/cassandra/db/ColumnIndex;add(OnDiskAtom);            if (tombstoneTracker != null)
                tombstoneTracker.update(column, false);;            if (tombstoneTracker != null)
                tombstoneTracker.update(column);;            tombstoneTracker.update(column);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_00008_87f5a/rev_00008-87f5a;/compiler/cli/src/org/jetbrains/jet/cli/KotlinCompiler;main(String[]);        environment.registerFileType(JetFileType.INSTANCE, "kt");
        environment.registerParserDefinition(new JetParserDefinition());

        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(arguments.src);;        environment.registerFileType(JetFileType.INSTANCE, "kt");
        environment.registerFileType(JetFileType.INSTANCE, "jet");
        environment.registerParserDefinition(new JetParserDefinition());
        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(args [0]);;        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(args [0]);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_8b38c_d170a/rev_8b38c-d170a;/lucene/core/src/java/org/apache/lucene/index/DocInverterPerField;processFields(IndexableField[],int);      if (fieldType.indexed() && doInvert) {
        final boolean analyzed = fieldType.tokenized() && docState.analyzer != null;;      if (fieldType.indexed() && doInvert) {;      if (doInvert) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_8b38c_d170a/rev_8b38c-d170a;/lucene/analysis/uima/src/test/org/apache/lucene/analysis/uima/UIMABaseAnalyzerTest;baseUIMAAnalyzerIntegrationTest();    result = indexSearcher.search(new MatchAllDocsQuery(), 2);
    Document d1 = indexSearcher.doc(result.scoreDocs[1].doc);;    result = indexSearcher.search(new MatchAllDocsQuery(), 10);
    Document d1 = indexSearcher.doc(result.scoreDocs[1].doc);;    result = indexSearcher.search(new MatchAllDocsQuery(), 10);
    StoredDocument d1 = indexSearcher.doc(result.scoreDocs[1].doc);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_8baf4_5e981/rev_8baf4-5e981;/projects/OG-Web/src/main/java/com/opengamma/web/spring/DemoStandardFunctionConfiguration;usdCurrencyInfo();    i.setForwardCurveName("model/futureoption", "BBG");
    i.setForwardCurveName("model/curve/forward", "BBG");
    i.setForwardCurveCalculationMethod("model/futureoption", ForwardCurveValuePropertyNames.PROPERTY_FUTURE_PRICE_METHOD);
    i.setSurfaceCalculationMethod("model/futureoption", BlackVolatilitySurfacePropertyNamesAndValues.INTERPOLATED_BLACK_LOGNORMAL);;    i.setForwardCurveName("model/futureoption", "BBG");
    i.setForwardCurveCalculationMethod("model/futureoption", ForwardCurveValuePropertyNames.PROPERTY_FUTURE_PRICE_METHOD);
    i.setSurfaceCalculationMethod("model/futureoption", BlackVolatilitySurfacePropertyNamesAndValues.INTERPOLATED_BLACK_LOGNORMAL);;    i.setForwardCurveName(null, "BBG");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_8be7e_8cb7b/rev_8be7e-8cb7b;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;handleGroup(List<Pair<CFDefinition.Name,Selector>>,ByteBuffer,ByteBuffer[],ColumnGroupMap,ResultSet);                        List<Pair<ByteBuffer, IColumn>> collection = columns.getCollection(name.name.key);
                        ByteBuffer value = collection == null
                                         ? null
                                         : ((CollectionType)name.type).serialize(collection);
                        addReturnValue(cqlRows, selector, value);
                    }
                    else
                    {
                        IColumn c = columns.getSimple(name.name.key);
                        addReturnValue(cqlRows, selector, c);;                        List<Pair<ByteBuffer, IColumn>> collection = columns.getCollection(name.name.key);
                        if (collection == null)
                            cqlRows.addColumnValue(null);
                        else
                            cqlRows.addColumnValue(((CollectionType)name.type).serialize(collection));
                        break;;                        List<Pair<ByteBuffer, Column>> collection = columns.getCollection(name.name.key);
                        if (collection == null)
                            cqlRows.addColumnValue(null);
                        else
                            cqlRows.addColumnValue(((CollectionType)name.type).serialize(collection));
                        break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_8d17c_51511/rev_8d17c-51511;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;prepare();                    throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key (you will need to use the token() function for non equality based relation)");;                    if (!partitioner.preservesOrder())
                        throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");

                    stmt.isKeyRange = true;
                    shouldBeDone = true;;                    if (!partitioner.preservesOrder())
                    {
                        if (hasQueriableIndex)
                        {
                            stmt.usesSecondaryIndexing = true;
                            break;
                        }
                        throw new InvalidRequestException("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");
                    }

                    stmt.isKeyRange = true;
                    lastRestrictedPartitionKey = i;
                    shouldBeDone = true;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_8d24e_fc68d/rev_8d24e-fc68d;/lucene/src/java/org/apache/lucene/index/CompoundFileWriter;addFile(String);      addFile(file, directory);;        if (merged)
            throw new IllegalStateException(
                "Can't add extensions after merge has been called");

        if (file == null)
            throw new NullPointerException(
                "file cannot be null");

        if (! ids.add(file))
            throw new IllegalArgumentException(
                "File " + file + " already added");

        FileEntry entry = new FileEntry();
        entry.file = file;
        entries.add(entry);;        if (merged)
            throw new IllegalStateException(
                "Can't add extensions after merge has been called");

        if (file == null)
            throw new NullPointerException(
                "file cannot be null");

        if (! ids.add(file))
            throw new IllegalArgumentException(
                "File " + file + " already added");
        entries.add(new FileEntry(file));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_8fb45_c91a3/rev_8fb45-c91a3;/extensions/freebase/src/com/google/refine/freebase/model/recon/KeyBasedReconConfig;batchRecon(List<ReconJob>,long);            String query = null;
            {
                StringWriter stringWriter = new StringWriter();
                JSONWriter jsonWriter = new JSONWriter(stringWriter);
                
                jsonWriter.array();
                jsonWriter.object();
                
                    jsonWriter.key("id"); jsonWriter.value(null);
                    jsonWriter.key("name"); jsonWriter.value(null);
                    jsonWriter.key("guid"); jsonWriter.value(null);
                    jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                    
                    jsonWriter.key("key");
                        jsonWriter.array();
                        jsonWriter.object();
                        
                        jsonWriter.key("namespace");
                            jsonWriter.object();
                            jsonWriter.key("id"); jsonWriter.value(namespace.id);
                            jsonWriter.endObject();
                            
                        jsonWriter.key("value"); jsonWriter.value(null);
                        jsonWriter.key("value|=");
                            jsonWriter.array();
                            for (ReconJob job : jobs) {
                                jsonWriter.value(((KeyBasedReconJob) job).key);
                            }
                            jsonWriter.endArray();
                            
                        jsonWriter.endObject();
                        jsonWriter.endArray();
                    
                jsonWriter.endObject();
                jsonWriter.endArray();
                
                query = stringWriter.toString();
            };            String query = null;
            {
                StringWriter stringWriter = new StringWriter();
                JSONWriter jsonWriter = new JSONWriter(stringWriter);
                
                    jsonWriter.array();
                    jsonWriter.object();
                    
                        jsonWriter.key("id"); jsonWriter.value(null);
                        jsonWriter.key("name"); jsonWriter.value(null);
                        jsonWriter.key("guid"); jsonWriter.value(null);
                        jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                        
                        jsonWriter.key("key");
                            jsonWriter.array();
                            jsonWriter.object();
                            
                            jsonWriter.key("namespace");
                                jsonWriter.object();
                                jsonWriter.key("id"); jsonWriter.value(namespace.id);
                                jsonWriter.endObject();
                                
                            jsonWriter.key("value"); jsonWriter.value(null);
                            jsonWriter.key("value|=");
                                jsonWriter.array();
                                for (ReconJob job : jobs) {
                                    jsonWriter.value(((KeyBasedReconJob) job).key);
                                }
                                jsonWriter.endArray();
                                
                            jsonWriter.endObject();
                            jsonWriter.endArray();
                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();
                
                query = stringWriter.toString();
            };            String query = buildQuery(jobs);
            String s = FreebaseUtils.mqlread(query);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_8fb45_c91a3/rev_8fb45-c91a3;/extensions/freebase/src/com/google/refine/freebase/model/recon/KeyBasedReconConfig;batchRecon(List<ReconJob>,long);            StringBuffer sb = new StringBuffer(1024);
            sb.append(getMqlreadService());
            sb.append("&query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();
                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String key = result.getJSONArray("key").getJSONObject(0).getString("value");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    result.getString("id"),
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;            StringBuffer sb = new StringBuffer(1024);
            sb.append(s_mqlreadService);
            sb.append("query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();
                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String key = result.getJSONArray("key").getJSONObject(0).getString("value");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    result.getString("id"),
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;            JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
            if (o.has("result")) {
                JSONArray results = o.getJSONArray("result");
                int count = results.length();

                for (int i = 0; i < count; i++) {
                    JSONObject result = results.getJSONObject(i);

                    String key = result.getJSONArray("key").getJSONObject(0).getString("value");

                    JSONArray types = result.getJSONArray("type");
                    String[] typeIDs = new String[types.length()];
                    for (int j = 0; j < typeIDs.length; j++) {
                        typeIDs[j] = types.getString(j);
                    }

                    ReconCandidate candidate = new ReconCandidate(
                            result.getString("id"),
                            result.getString("name"),
                            typeIDs,
                            100
                            );

                    Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                    recon.addCandidate(candidate);
                    recon.service = "mql";
                    recon.judgment = Judgment.Matched;
                    recon.judgmentAction = "auto";
                    recon.match = candidate;
                    recon.matchRank = 0;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_8fb45_c91a3/rev_8fb45-c91a3;/extensions/freebase/src/com/google/refine/freebase/model/recon/GuidBasedReconConfig;batchRecon(List<ReconJob>,long);                query = stringWriter.toString();
            }
            
            StringBuffer sb = new StringBuffer(1024);
            sb.append(getMqlreadService());
            sb.append("&query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();

                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String guid = result.getString("guid");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    result.getString("id"),
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;                query = stringWriter.toString();
            }
            
            StringBuffer sb = new StringBuffer(1024);
            sb.append(s_mqlreadService);
            sb.append("query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();

                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String guid = result.getString("guid");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    result.getString("id"),
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;                    ReconCandidate candidate = new ReconCandidate(
                            result.getString("id"),
                            result.getString("name"),
                            typeIDs,
                            100
                            );

                    Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                    recon.addCandidate(candidate);
                    recon.service = "mql";
                    recon.judgment = Judgment.Matched;
                    recon.judgmentAction = "auto";
                    recon.match = candidate;
                    recon.matchRank = 0;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_8fb45_c91a3/rev_8fb45-c91a3;/extensions/freebase/src/com/google/refine/freebase/model/recon/IdBasedReconConfig;batchRecon(List<ReconJob>,long);            String query = null;
            {
                StringWriter stringWriter = new StringWriter();
                JSONWriter jsonWriter = new JSONWriter(stringWriter);
                
                jsonWriter.array();
                jsonWriter.object();
                
                    jsonWriter.key("id"); jsonWriter.value(null);
                    jsonWriter.key("name"); jsonWriter.value(null);
                    jsonWriter.key("guid"); jsonWriter.value(null);
                    jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                    
                    jsonWriter.key("id|=");
                        jsonWriter.array();
                        for (ReconJob job : jobs) {
                            jsonWriter.value(((IdBasedReconJob) job).id);
                        }
                        jsonWriter.endArray();
                    
                jsonWriter.endObject();
                jsonWriter.endArray();
                
                query = stringWriter.toString();
            }
            
            StringBuffer sb = new StringBuffer(1024);
            sb.append(getMqlreadService());
            sb.append("&query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();
                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String id = result.getString("id");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    id,
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;            String query = null;
            {
                StringWriter stringWriter = new StringWriter();
                JSONWriter jsonWriter = new JSONWriter(stringWriter);
                
                    jsonWriter.array();
                    jsonWriter.object();
                    
                        jsonWriter.key("id"); jsonWriter.value(null);
                        jsonWriter.key("name"); jsonWriter.value(null);
                        jsonWriter.key("guid"); jsonWriter.value(null);
                        jsonWriter.key("type"); jsonWriter.array(); jsonWriter.endArray();
                        
                        jsonWriter.key("id|=");
                            jsonWriter.array();
                            for (ReconJob job : jobs) {
                                jsonWriter.value(((IdBasedReconJob) job).id);
                            }
                            jsonWriter.endArray();
                        
                    jsonWriter.endObject();
                    jsonWriter.endArray();
                
                query = stringWriter.toString();
            }
            
            StringBuffer sb = new StringBuffer(1024);
            sb.append(s_mqlreadService);
            sb.append("query=");
            sb.append(ParsingUtilities.encode(query));
            
            URL url = new URL(sb.toString());
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(5000);
            connection.connect();
            
            if (connection.getResponseCode() >= 400) {
                String responseMessage = connection.getResponseMessage();
                String errorString = ParsingUtilities.inputStreamToString(connection.getErrorStream());
                LOGGER.error("HTTP response error during recon: " + connection.getResponseCode() 
                        + " : " + responseMessage + " : " + errorString);
            } else {
                InputStream is = connection.getInputStream();
                try {
                    String s = ParsingUtilities.inputStreamToString(is);
                    JSONObject o = ParsingUtilities.evaluateJsonStringToObject(s);
                    if (o.has("result")) {
                        JSONArray results = o.getJSONArray("result");
                        int count = results.length();

                        for (int i = 0; i < count; i++) {
                            JSONObject result = results.getJSONObject(i);

                            String id = result.getString("id");

                            JSONArray types = result.getJSONArray("type");
                            String[] typeIDs = new String[types.length()];
                            for (int j = 0; j < typeIDs.length; j++) {
                                typeIDs[j] = types.getString(j);
                            }

                            ReconCandidate candidate = new ReconCandidate(
                                    id,
                                    result.getString("name"),
                                    typeIDs,
                                    100
                                    );

                            Recon recon = Recon.makeFreebaseRecon(historyEntryID);
                            recon.addCandidate(candidate);
                            recon.service = "mql";
                            recon.judgment = Judgment.Matched;
                            recon.judgmentAction = "auto";
                            recon.match = candidate;
                            recon.matchRank = 0;;            String query = buildQuery(jobs);
            String s = FreebaseUtils.mqlread(query);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_8fef6_319a2/rev_8fef6-319a2;/src/main/java/redis/clients/jedis/Jedis;blpop(String);public List<String> blpop(String... args) {
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> blpop(String... args) {
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> blpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_8fef6_319a2/rev_8fef6-319a2;/src/main/java/redis/clients/jedis/Jedis;brpop(String);public List<String> brpop(String... args) {
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> brpop(String... args) {
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> brpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_09d59_acbf8/rev_09d59-acbf8;/projects/OG-Financial/src/com/opengamma/financial/OpenGammaCompilationContextFactoryBean;configureCompilationContext(FunctionCompilationContext);    OpenGammaCompilationContext.setInterpolatedYieldCurveDefinitionSource(context, _interpolatedYieldCurveDefinitionSource);
    OpenGammaCompilationContext.setInterpolatedYieldCurveSpecificationBuilder(context, _interpolatedYieldCurveSpecificationBuilder);
    OpenGammaCompilationContext.setVolatilityCubeDefinitionSource(context, _volatilityCubeDefinitionSource);;    OpenGammaCompilationContext.setInterpolatedYieldCurveDefinitionSource(context, _interpolatedYieldCurveDefinitionSource);
    OpenGammaCompilationContext.setInterpolatedYieldCurveSpecificationBuilder(context, _interpolatedYieldCurveSpecificationBuilder);;    OpenGammaCompilationContext.setInterpolatedYieldCurveDefinitionSource(context,
        _interpolatedYieldCurveDefinitionSource);
    OpenGammaCompilationContext.setInterpolatedYieldCurveSpecificationBuilder(context,
        _interpolatedYieldCurveSpecificationBuilder);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9a154_129d5/rev_9a154-129d5;/src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics;release();        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("CompressionRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedRowSizeHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedColumnCountHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("SSTablesPerReadHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveSSTableCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MinRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MaxRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MeanRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalsePositives"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalsePositives"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalseRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalseRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("KeyCacheHitRate"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("SpeculativeRetry"));;        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("CompressionRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedRowSizeHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("EstimatedColumnCountHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("SSTablesPerReadHistogram"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveSSTableCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MinRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MaxRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MeanRowSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalsePositives"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalsePositives"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterFalseRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalseRatio"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));;        CassandraMetricRegistry.unregister(factory.createMetricName("MemtableColumnsCount"));
        CassandraMetricRegistry.unregister(factory.createMetricName("MemtableDataSize"));
        CassandraMetricRegistry.unregister(factory.createMetricName("MemtableSwitchCount"));
        CassandraMetricRegistry.unregister(factory.createMetricName("CompressionRatio"));
        CassandraMetricRegistry.unregister(factory.createMetricName("EstimatedRowSizeHistogram"));
        CassandraMetricRegistry.unregister(factory.createMetricName("EstimatedColumnCountHistogram"));
        CassandraMetricRegistry.unregister(factory.createMetricName("SSTablesPerReadHistogram"));
        CassandraMetricRegistry.unregister(factory.createMetricName("PendingTasks"));
        CassandraMetricRegistry.unregister(factory.createMetricName("LiveSSTableCount"));
        CassandraMetricRegistry.unregister(factory.createMetricName("LiveDiskSpaceUsed"));
        CassandraMetricRegistry.unregister(factory.createMetricName("TotalDiskSpaceUsed"));
        CassandraMetricRegistry.unregister(factory.createMetricName("MinRowSize"));
        CassandraMetricRegistry.unregister(factory.createMetricName("MaxRowSize"));
        CassandraMetricRegistry.unregister(factory.createMetricName("MeanRowSize"));
        CassandraMetricRegistry.unregister(factory.createMetricName("BloomFilterFalsePositives"));
        CassandraMetricRegistry.unregister(factory.createMetricName("RecentBloomFilterFalsePositives"));
        CassandraMetricRegistry.unregister(factory.createMetricName("BloomFilterFalseRatio"));
        CassandraMetricRegistry.unregister(factory.createMetricName("RecentBloomFilterFalseRatio"));
        CassandraMetricRegistry.unregister(factory.createMetricName("BloomFilterDiskSpaceUsed"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_9ae16_c9fb3/rev_9ae16-c9fb3;/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/NamedElementSelector;transform(NamedDomainObjectContainer<?superT>);            return Lists.newArrayList(allWithType);;            if (allWithType.size() == 1) {
                return Lists.newArrayList(allWithType);
            } else if (allWithType.size() > 1) {
                //TODO freekh: for now, we pick the first one defined, but we could pick the best based on the toolchains we have?
                // TODO:DAZ This actually selects the first alphabetically
                return Collections.singletonList(allWithType.iterator().next());
            }

            throw new GradleException(String.format("No element is registered for type: '%s'", type));;            if (allWithType.size() == 1) {
                return Lists.newArrayList(allWithType);
            } else if (allWithType.size() > 1 && defaultElement != null) {
                return Collections.singletonList(defaultElement);
            }

            throw new GradleException(String.format("No element is registered for type: '%s'", type));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9ba0f_78b0d/rev_9ba0f-78b0d;/src/java/org/apache/cassandra/service/StorageService;initClient();            // sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply).
            outer:
            while (true);            // sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply).
            boolean isUp = false;
            while (!isUp);            Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
            for (InetAddress address : Gossiper.instance.getLiveMembers())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9ba0f_78b0d/rev_9ba0f-78b0d;/src/java/org/apache/cassandra/service/StorageService;initClient();                    if (!Gossiper.instance.isFatClient(address))
                        break outer;;                    if (!Gossiper.instance.isFatClient(address))
                    {
                        isUp = true;
                    };                    isUp = true;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9c8d9_9719b/rev_9c8d9-9719b;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;deserialize(DataInputStream,Descriptor);            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                maxTimestamp = Long.MAX_VALUE;
            double compressionRatio = desc.hasCompressionRatio;            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                maxTimestamp = Long.MIN_VALUE;
            double compressionRatio = desc.hasCompressionRatio;            long minTimestamp = desc.version.tracksMinTimestamp ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.version.tracksMinTimestamp)
                minTimestamp = Long.MAX_VALUE;
            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.version.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                maxTimestamp = Long.MIN_VALUE;
            double compressionRatio = desc.version.hasCompressionRatio
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9c8d9_9719b/rev_9c8d9-9719b;/src/java/org/apache/cassandra/net/OutboundTcpConnectionPool;reset();        for (OutboundTcpConnection con : new OutboundTcpConnection[] { cmdCon, ackCon })
            con.closeSocket(false);;        for (OutboundTcpConnection con : new OutboundTcpConnection[] { cmdCon, ackCon })
            con.closeSocket();;        for (OutboundTcpConnection conn : new OutboundTcpConnection[] { cmdCon, ackCon })
            conn.closeSocket(false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9ca84_c5986/rev_9ca84-c5986;/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy;calculateNaturalEndpoints(Token,TokenMetadata);            // collect endpoints in this DC
            TokenMetadata dcTokens = new TokenMetadata();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet());            // collect endpoints in this DC
            TokenMetadata dcTokens = new TokenMetadata();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet());            // collect endpoints in this DC; add in bulk to token meta data for computational complexity
            // reasons (CASSANDRA-3831).
            Set<Pair<Token, InetAddress>> dcTokensToUpdate = new HashSet<Pair<Token, InetAddress>>();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9ccaa_118cd/rev_9ccaa-118cd;/src/java/org/apache/cassandra/db/HintedHandOffManager;deliverHintsToEndpointInternal(InetAddress);            // check if hints delivery has been paused during the process
            if (hintedHandOffPaused)
            {
                logger.debug("Hints delivery process is paused, aborting");
                break;
            }

            QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(SystemTable.HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);;            QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(SystemTable.HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);;            QueryFilter filter = QueryFilter.getSliceFilter(epkey, SystemTable.HINTS_CF, startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9d0ee_1d2c1/rev_9d0ee-1d2c1;/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;getNextWide();                        tuple = addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, IColumn> entry : lastRow.entrySet());                        addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, IColumn> entry : lastRow.entrySet());                        addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, Column> entry : lastRow.entrySet())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_9d6c3_e80de/rev_9d6c3-e80de;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/tool/ExampleDatabasePopulator;loadHistoricalData(Set<ExternalId>);    final Log log = new Log("Loading historical reference data");
    try {
      BloombergHistoricalTimeSeriesLoader loader = new BloombergHistoricalTimeSeriesLoader(
          getToolContext().getHistoricalTimeSeriesMaster(),
          getToolContext().getBloombergHistoricalTimeSeriesSource(),
          new BloombergIdentifierProvider(getToolContext().getBloombergReferenceDataProvider()));;    BloombergHistoricalTimeSeriesLoader loader = new BloombergHistoricalTimeSeriesLoader(
      getToolContext().getHistoricalTimeSeriesMaster(),
      getToolContext().getBloombergHistoricalTimeSeriesSource(),
      new BloombergIdentifierProvider(getToolContext().getBloombergReferenceDataProvider()));;    BloombergHistoricalTimeSeriesLoader loader = new BloombergHistoricalTimeSeriesLoader(
      getToolContext().getHistoricalTimeSeriesMaster(),
      getToolContext().getHistoricalTimeSeriesProvider(),
      new BloombergIdentifierProvider(getToolContext().getBloombergReferenceDataProvider()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9d7bb_26480/rev_9d7bb-26480;/src/java/org/apache/cassandra/io/sstable/SSTableReader;releaseReference();            FileUtils.closeQuietly(this);;            // Force finalizing mmapping if necessary
            ifile.cleanup();
            dfile.cleanup();;            /**
             * Make OS a favour and suggest (using fadvice call) that we
             * don't want to see pages of this SSTable in memory anymore.
             *
             * NOTE: We can't use madvice in java because it requires address of
             * the mapping, so instead we always open a file and run fadvice(fd, 0, 0) on it
             */
            dropPageCache();

            // Force finalizing mmapping if necessary
            ifile.cleanup();
            dfile.cleanup();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9d7fb_c44af/rev_9d7fb-c44af;/test/unit/org/apache/cassandra/db/HintedHandOffTest;testCompactionOfHintsCF();@Test
    public void testCompactionOfHintsCF() throws Exception
    {
        // prepare hints column family
        Table systemTable = Table.open("system");
        ColumnFamilyStore hintStore = systemTable.getColumnFamilyStore(HintedHandOffManager.HINTS_CF);
        hintStore.clearUnsafe();
        hintStore.metadata.gcGraceSeconds(36000); // 10 hours
        hintStore.setCompactionStrategyClass(SizeTieredCompactionStrategy.class.getCanonicalName());
        hintStore.disableAutoCompaction();

        // insert 1 hint
        RowMutation rm = new RowMutation(TABLE4, ByteBufferUtil.bytes(1));
        rm.add(new QueryPath(STANDARD1_CF,
                             null,
                             ByteBufferUtil.bytes(String.valueOf(COLUMN1))),
               ByteBufferUtil.EMPTY_BYTE_BUFFER,
               System.currentTimeMillis());

        RowMutation.hintFor(rm, ByteBufferUtil.bytes("foo")).apply();

        // flush data to disk
        hintStore.forceBlockingFlush();
        assertEquals(1, hintStore.getSSTables().size());

        // submit compaction
        FBUtilities.waitOnFuture(HintedHandOffManager.instance.compact());
        while (CompactionManager.instance.getPendingTasks() > 0 || CompactionManager.instance.getActiveCompactions() > 0)
            TimeUnit.SECONDS.sleep(1);

        // single row should not be removed because of gc_grace_seconds
        // is 10 hours and there are no any tombstones in sstable
        assertEquals(1, hintStore.getSSTables().size());;@Test
    public void testCompactionOfHintsCF() throws Exception
    {
        // prepare hints column family
        Table systemTable = Table.open("system");
        ColumnFamilyStore hintStore = systemTable.getColumnFamilyStore(HintedHandOffManager.HINTS_CF);
        hintStore.clearUnsafe();
        hintStore.metadata.gcGraceSeconds(36000); // 10 hours
        hintStore.setCompactionStrategyClass(SizeTieredCompactionStrategy.class.getCanonicalName());
        hintStore.disableAutoCompaction();

        // insert 1 hint
        RowMutation rm = new RowMutation(TABLE4, ByteBufferUtil.bytes(1));
        rm.add(new QueryPath(STANDARD1_CF,
                             null,
                             ByteBufferUtil.bytes(String.valueOf(COLUMN1))),
               ByteBufferUtil.EMPTY_BYTE_BUFFER,
               System.currentTimeMillis());

        RowMutation.hintFor(rm, ByteBufferUtil.bytes("foo")).apply();

        // flush data to disk
        hintStore.forceBlockingFlush();
        assertEquals(1, hintStore.getSSTables().size());

        // submit compaction
        FBUtilities.waitOnFuture(HintedHandOffManager.instance.compact());
        while (CompactionManager.instance.getPendingTasks() > 0 || CompactionManager.instance.getActiveCompactions() > 0)
            TimeUnit.SECONDS.sleep(1);

        // single row should not be removed because of gc_grace_seconds
        // is 10 hours and there are no any tombstones in sstable
        assertEquals(1, hintStore.getSSTables().size());;@Test
    public void testCompactionOfHintsCF() throws Exception
    {
        // prepare hints column family
        Table systemTable = Table.open("system");
        ColumnFamilyStore hintStore = systemTable.getColumnFamilyStore(SystemTable.HINTS_CF);
        hintStore.clearUnsafe();
        hintStore.metadata.gcGraceSeconds(36000); // 10 hours
        hintStore.setCompactionStrategyClass(SizeTieredCompactionStrategy.class.getCanonicalName());
        hintStore.disableAutoCompaction();

        // insert 1 hint
        RowMutation rm = new RowMutation(TABLE4, ByteBufferUtil.bytes(1));
        rm.add(new QueryPath(STANDARD1_CF,
                             null,
                             ByteBufferUtil.bytes(String.valueOf(COLUMN1))),
               ByteBufferUtil.EMPTY_BYTE_BUFFER,
               System.currentTimeMillis());

        RowMutation.hintFor(rm, UUID.randomUUID()).apply();

        // flush data to disk
        hintStore.forceBlockingFlush();
        assertEquals(1, hintStore.getSSTables().size());

        // submit compaction
        FBUtilities.waitOnFuture(HintedHandOffManager.instance.compact());
        while (CompactionManager.instance.getPendingTasks() > 0 || CompactionManager.instance.getActiveCompactions() > 0)
            TimeUnit.SECONDS.sleep(1);

        // single row should not be removed because of gc_grace_seconds
        // is 10 hours and there are no any tombstones in sstable
        assertEquals(1, hintStore.getSSTables().size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_9d8bb_e8571/rev_9d8bb-e8571;/src/main/java/org/junit/runners/BlockJUnit4ClassRunner;withTestRules(FrameworkMethod,Object,Statement);			Statement result) {
		for (TestRule each : getTestRules(target))
			result= each.apply(result, describeChild(method));
		return result;;			Statement result) {
		return TestRule.applyAll(getTestRules(target), result, describeChild(method));;			Statement statement) {
		List<TestRule> testRules= getTestRules(target);
		return testRules.isEmpty() ? statement :
			new RunRules(statement, testRules, describeChild(method));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_9d8bb_e8571/rev_9d8bb-e8571;/src/main/java/org/junit/runners/ParentRunner;withClassRules(Statement);		final List<TestRule> classRules= classRules();
		if (classRules.isEmpty()) {
			return statement;
		}
		Statement next = statement;
		for (final TestRule classRule : classRules) {
			next = classRule.apply(next, getDescription());
		}
		return next;;		final List<TestRule> classRules= classRules();
		if (classRules.isEmpty()) {
			return statement;
		}
		return TestRule.applyAll(classRules, statement, getDescription());;		List<TestRule> classRules= classRules();
		return classRules.isEmpty() ? statement :
		    new RunRules(statement, classRules, getDescription());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9eb34_e9bdb/rev_9eb34-e9bdb;/src/java/org/apache/cassandra/utils/SimpleCondition;await(long,TimeUnit);        // micro/nanoseconds not supported
        assert unit == TimeUnit.DAYS || unit == TimeUnit.HOURS || unit == TimeUnit.MINUTES || unit == TimeUnit.SECONDS || unit == TimeUnit.MILLISECONDS;

        long end = System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(time, unit);
        while (!set && end > System.currentTimeMillis());        // micro/nanoseconds not supported
        assert unit == TimeUnit.DAYS || unit == TimeUnit.HOURS || unit == TimeUnit.MINUTES || unit == TimeUnit.SECONDS || unit == TimeUnit.MILLISECONDS;

        long end = System.currentTimeMillis() + unit.convert(time, TimeUnit.MILLISECONDS);
        while (!set && end > System.currentTimeMillis());        long start = System.nanoTime();
        long timeout = unit.toNanos(time);
        long elapsed;
        while (!set && (elapsed = System.nanoTime() - start) < timeout)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9f6ad_dce71/rev_9f6ad-dce71;/src/java/org/apache/cassandra/cli/CliClient;describeKeySpace(String,KsDef);                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);;                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb, cf_def.memtable_flush_after_mins);;                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/MB/minutes)%n",
                                cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb, cf_def.memtable_flush_after_mins);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9f36c_673f8/rev_9f36c-673f8;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;build();            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, ByteBufferUtil.readWithShortLength(dfile));
                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = 0;
            try
            {
                DecoratedKey key;
                long rowPosition = 0;
                while (rowPosition < dfile.length())
                {
                    key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, FBUtilities.readShortByteArray(dfile));
                    iwriter.afterAppend(key, rowPosition);

                    long dataSize = SSTableReader.readRowSize(dfile, desc);
                    rowPosition = dfile.getFilePointer() + dataSize; // next row

                    IndexHelper.skipBloomFilter(dfile);
                    IndexHelper.skipIndex(dfile);
                    ColumnFamily.serializer().deserializeFromSSTableNoColumns(ColumnFamily.create(cfs.metadata), dfile);
                    rowSizes.add(dataSize);
                    columnCounts.add(dfile.readInt());

                    dfile.seek(rowPosition);
                    rows++;
                }

                writeStatistics(desc, rowSizes, columnCounts);
            }
            finally
            {
                try
                {
                    dfile.close();
                    iwriter.close();
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            };            long rows = indexer.index();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2;/src/java/voldemort/store/routed/action/PerformParallelPutRequests;execute(Pipeline);                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),;                                                                                             + " succeeded",;                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2;/src/java/voldemort/store/routed/action/PerformSerialPutRequests;execute(Pipeline);                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),;                                                                                             + " succeeded",;                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2;/src/java/voldemort/store/routed/action/PerformParallelRequests;execute(Pipeline);                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),;                                                                                             + " succeeded",;                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2;/src/java/voldemort/store/routed/action/PerformParallelDeleteRequests;execute(Pipeline);                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),;                                                                                             + " succeeded",;                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2;/src/java/voldemort/store/routed/action/PerformSerialRequests;execute(Pipeline);                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),;                                                                                             + " succeeded",;                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_11d41_d58ad/rev_11d41-d58ad;/projects/OG-Analytics/src/com/opengamma/math/rootfinding/newton/NewtonVectorRootFinder;bisectBacktrack(DoubleMatrix1D,Function1D<DoubleMatrix1D,DoubleMatrix1D>,DataBundle);      if (data.getLambda0() == 0.0) {
        throw new MathException("Failed to converge");
      }
    } while (Double.isNaN(data.getG1()) || Double.isInfinite(data.getG1()) || Double.isNaN(data.getG2()) || Double.isInfinite(data.getG2()));;    } while (Double.isNaN(data.getG1()) || Double.isInfinite(data.getG1()) || Double.isNaN(data.getG2()) || Double.isInfinite(data.getG2()));;    } while (Double.isNaN(data.getG1()) || Double.isInfinite(data.getG1()) || Double.isNaN(data.getG2())
        || Double.isInfinite(data.getG2()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;test();    assertEquals(FRA.accept(VISITOR), "FRA2");
    assertEquals(FRA.accept(VISITOR, o), "FRA1");
    assertEquals(IR_FUTURE.accept(VISITOR), "IRFuture2");
    assertEquals(IR_FUTURE.accept(VISITOR, o), "IRFuture1");
    assertEquals(ANNUITY_FIXED.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "Annuity1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "Annuity1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "Annuity1");;    assertEquals(FRA.accept(VISITOR), "FRA2");
    assertEquals(FRA.accept(VISITOR, o), "FRA1");
    assertEquals(IR_FUTURE.accept(VISITOR), "IRFuture2");
    assertEquals(IR_FUTURE.accept(VISITOR, o), "IRFuture1");
    assertEquals(ANNUITY_FIXED.accept(VISITOR), "AnnuityCouponFixed2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "AnnuityCouponFixed1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "AnnuityCouponIbor2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "AnnuityCouponIbor1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "AnnuityCouponIborSpread2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "AnnuityCouponIborSpread1");;    assertEquals(ANNUITY_FIXED.accept(VISITOR), "AnnuityCouponFixed2");
    assertEquals(ANNUITY_FIXED.accept(VISITOR, o), "AnnuityCouponFixed1");
    assertEquals(ANNUITY_IBOR.accept(VISITOR), "AnnuityCouponIbor2");
    assertEquals(ANNUITY_IBOR.accept(VISITOR, o), "AnnuityCouponIbor1");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR), "AnnuityCouponIborSpread2");
    assertEquals(ANNUITY_IBOR_SPREAD_1.accept(VISITOR, o), "AnnuityCouponIborSpread1");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;test();    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR), "Annuity2");
    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR, o), "Annuity1");
    assertEquals(IR_FUT_SECURITY_DEFINITION.accept(VISITOR), "InterestRateFutureSecurity1");
    assertEquals(IR_FUT_SECURITY_DEFINITION.accept(VISITOR, o), "InterestRateFutureSecurity2");
    assertEquals(IR_FUT_TRANSACTION_DEFINITION.accept(VISITOR), "InterestRateFutureTransaction1");
    assertEquals(IR_FUT_TRANSACTION_DEFINITION.accept(VISITOR, o), "InterestRateFutureTransaction2");
    assertEquals(BNDFUT_SECURITY_DEFINITION.accept(VISITOR), "BondFutureSecurity1");
    assertEquals(BNDFUT_SECURITY_DEFINITION.accept(VISITOR, o), "BondFutureSecurity2");
    assertEquals(BNDFUT_TRANSACTION_DEFINITION.accept(VISITOR), "BondFutureTransaction1");
    assertEquals(BNDFUT_TRANSACTION_DEFINITION.accept(VISITOR, o), "BondFutureTransaction2");
    assertEquals(SWAPTION_CASH.accept(VISITOR), "SwaptionCashFixedIbor1");
    assertEquals(SWAPTION_CASH.accept(VISITOR, o), "SwaptionCashFixedIbor2");
    assertEquals(SWAPTION_PHYS.accept(VISITOR), "SwaptionPhysicalFixedIbor1");
    assertEquals(SWAPTION_PHYS.accept(VISITOR, o), "SwaptionPhysicalFixedIbor2");;    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR), "AnnuityCouponCMS2");
    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR, o), "AnnuityCouponCMS1");;    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR), "AnnuityCouponCMS2");
    assertEquals(ANNUITY_COUPON_CMS.accept(VISITOR, o), "AnnuityCouponCMS1");
    assertEquals(CASH_SWAPTION.accept(VISITOR), "CashSettledSwaption2");
    assertEquals(CASH_SWAPTION.accept(VISITOR, o), "CashSettledSwaption1");
    assertEquals(PHYSICAL_SWAPTION.accept(VISITOR), "PhysicalSettledSwaption2");
    assertEquals(PHYSICAL_SWAPTION.accept(VISITOR, o), "PhysicalSettledSwaption1");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition,T);    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future, T data) {
      return "InterestRateFutureSecurity2";;    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future, T data) {
      return "InterestRateFutureSecurity1";;    public String visitInterestRateFutureSecurityDefinition(final InterestRateFutureSecurityDefinition future, final T data) {
      return "InterestRateFutureSecurity1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition);    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity1";;    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity2";;    public String visitInterestRateFutureSecurityDefinition(final InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition,T);    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future, T data) {
      return "InterestRateFutureTransaction2";;    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future, T data) {
      return "InterestRateFutureTransaction1";;    public String visitInterestRateFutureTransactionDefinition(final InterestRateFutureTransactionDefinition future, final T data) {
      return "InterestRateFutureTransaction1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition);    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction1";;    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction2";;    public String visitInterestRateFutureTransactionDefinition(final InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureSecurityDefinition(BondFutureSecurityDefinition,T);    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond, T data) {
      return "BondFutureSecurity2";;    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond, T data) {
      return "BondFutureSecurity1";;    public String visitBondFutureSecurityDefinition(final BondFutureSecurityDefinition bond, final T data) {
      return "BondFutureSecurity1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureSecurityDefinition(BondFutureSecurityDefinition);    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity1";;    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity2";;    public String visitBondFutureSecurityDefinition(final BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureTransactionDefinition(BondFutureTransactionDefinition,T);    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond, T data) {
      return "BondFutureTransaction2";;    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond, T data) {
      return "BondFutureTransaction1";;    public String visitBondFutureTransactionDefinition(final BondFutureTransactionDefinition bond, final T data) {
      return "BondFutureTransaction1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_13e71_71871/rev_13e71-71871;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureTransactionDefinition(BondFutureTransactionDefinition);    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction1";;    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction2";;    public String visitBondFutureTransactionDefinition(final BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeFunction;init(FunctionCompilationContext);  public void init(FunctionCompilationContext context) {
    
    ComputationTargetSpecification currencyTargetSpec = new ComputationTargetSpecification(_helper.getCurrency());
    _cubeResult = new ValueSpecification(ValueRequirementNames.VOLATILITY_CUBE, currencyTargetSpec,
        createValueProperties().with(ValuePropertyNames.CUBE, _helper.getDefinitionName()).get());;  public void init(FunctionCompilationContext context) {
    
    ComputationTargetSpecification currencyTargetSpec = new ComputationTargetSpecification(_helper.getKey().getCurrency());
    _cubeResult = new ValueSpecification(ValueRequirementNames.VOLATILITY_CUBE, currencyTargetSpec,
        createValueProperties().with(ValuePropertyNames.CUBE, _helper.getKey().getName()).get());;  public void init(final FunctionCompilationContext context) {
    final ComputationTargetSpecification currencyTargetSpec = new ComputationTargetSpecification(_helper.getKey().getCurrency());
    _cubeResult = new ValueSpecification(ValueRequirementNames.STANDARD_VOLATILITY_CUBE_DATA, currencyTargetSpec,
        createValueProperties().with(ValuePropertyNames.CUBE, _helper.getKey().getName()).get());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeFunction;compile(FunctionCompilationContext,InstantProvider);      public boolean canApplyTo(FunctionCompilationContext context, ComputationTarget target) {
        return _helper.getCurrency().getUniqueId().equals(target.getUniqueId());;      public boolean canApplyTo(FunctionCompilationContext context, ComputationTarget target) {
        return _helper.getKey().getCurrency().getUniqueId().equals(target.getUniqueId());;      public boolean canApplyTo(final FunctionCompilationContext context, final ComputationTarget target) {
        return _helper.getKey().getCurrency().getUniqueId().equals(target.getUniqueId());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeMarketDataFunction;init(FunctionCompilationContext);    
    final ComputationTargetSpecification currencySpec = new ComputationTargetSpecification(_helper.getCurrency());
    ;    
    final ComputationTargetSpecification currencySpec = new ComputationTargetSpecification(_helper.getKey().getCurrency());
    ;
    final ComputationTargetSpecification currencySpec = new ComputationTargetSpecification(_helper.getKey().getCurrency());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeMarketDataFunction;compile(FunctionCompilationContext,InstantProvider);  public CompiledFunctionDefinition compile(FunctionCompilationContext context, InstantProvider atInstant) {
    Triple<InstantProvider, InstantProvider, VolatilityCubeSpecification> compile = _helper.compile(context, atInstant);
    return new CompiledImpl(compile.getFirst(), compile.getSecond(), buildRequirements(compile.getThird(), context));;  public CompiledFunctionDefinition compile(FunctionCompilationContext context, InstantProvider atInstant) {
    Triple<InstantProvider, InstantProvider, VolatilityCubeSpecification> compile = _helper.compile(context, atInstant);
    return new CompiledImpl(compile.getFirst(), compile.getSecond(), buildRequirements(compile.getThird(), context),
        _helper.getKey());;  public CompiledFunctionDefinition compile(final FunctionCompilationContext context, final InstantProvider atInstant) {
    final Triple<InstantProvider, InstantProvider, VolatilityCubeSpecification> compile = _helper.compile(context, atInstant);
    return new CompiledImpl(compile.getFirst(), compile.getSecond(), buildRequirements(compile.getThird(), context),
        _helper.getKey());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeMarketDataFunction;getValueRequirements(VolatilityPoint);private Set<ValueRequirement> getValueRequirements(VolatilityPoint point) {
    Set<Identifier> instruments = INSTRUMENT_PROVIDER.getInstruments(_helper.getCurrency(), point);;private Set<ValueRequirement> getValueRequirements(VolatilityPoint point) {
    Set<Identifier> instruments = INSTRUMENT_PROVIDER.getInstruments(_helper.getKey()
        .getCurrency(), point);;private Set<ValueRequirement> getValueRequirements(final VolatilityPoint point) {
    Set<Identifier> instruments = INSTRUMENT_PROVIDER.getInstruments(_helper.getKey()
        .getCurrency(), point);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_16c7c_9b0c5/rev_16c7c-9b0c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/VolatilityCubeMarketDataFunction;getValueRequirements(VolatilityPoint);      
      Identifier strikeInstruments = INSTRUMENT_PROVIDER.getStrikeInstrument(_helper.getCurrency(), point);;      
      Identifier strikeInstruments = INSTRUMENT_PROVIDER.getStrikeInstrument(_helper.getKey().getCurrency(), point);;
      final Identifier strikeInstruments = INSTRUMENT_PROVIDER.getStrikeInstrument(_helper.getKey().getCurrency(), point);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_18d76_f7d0f/rev_18d76-f7d0f;/src/com/opengamma/timeseries/db/RowStoreTimeSeriesMaster;addTimeSeries(IdentifierBundle,String,String,String,String,LocalDateDoubleTimeSeries);      bundleId = bundleBean.getIds().iterator().next();
      List<TimeSeriesMetaData> tsMetaDataList = getTimeSeriesMetaData(bundleId, identifiers, dataSource, dataProvider, field, observationTime);;      bundleId = bundleBean.getIds().iterator().next();
      s_logger.debug("Looking up timeSeriesMetaData by quotedObj for identifiers={}, dataSource={}, dataProvider={}, dataField={}, observationTime={}, bundleId={}", 
          new Object[]{identifiers, dataSource, dataProvider, field, observationTime, bundleId});
      
      String sql = _namedSQLMap.get(GET_ACTIVE_META_DATA_BY_PARAMETERS);
      
      MapSqlParameterSource parameters = new MapSqlParameterSource().addValue("bundleId", bundleId, Types.BIGINT)
        .addValue("dataSource", dataSource, Types.VARCHAR)
        .addValue("dataField", field, Types.VARCHAR)
        .addValue("dataProvider", dataProvider, Types.VARCHAR)
        .addValue("observationTime", observationTime, Types.VARCHAR);
      
      List<TimeSeriesMetaData> tsMetaDataList = _simpleJdbcTemplate.query(sql, new TimeSeriesMetaDataRowMapper(), parameters);;      bundleId = bundleMap.keySet().iterator().next();
      s_logger.debug("Looking up timeSeriesMetaData by quotedObj for identifiers={}, dataSource={}, dataProvider={}, dataField={}, observationTime={}, bundleId={}", 
          new Object[]{identifiers, dataSource, dataProvider, field, observationTime, bundleId});
      
      String sql = _namedSQLMap.get(GET_ACTIVE_META_DATA_BY_IDENTIFIERS);
      
      MapSqlParameterSource parameters = new MapSqlParameterSource().addValue("bundleIds", bundleId, Types.BIGINT);
      
      if (dataSource != null) {
        sql +=  " AND ds.name = :dataSource ";
        parameters.addValue("dataSource", dataSource, Types.VARCHAR);
      }
      if (dataProvider != null) {
        sql +=  " AND dp.name = :dataProvider ";
        parameters.addValue("dataProvider", dataProvider, Types.VARCHAR);
      }
      if (field != null) {
        sql +=  " df.name = :dataField ";
        parameters.addValue("dataField", field, Types.VARCHAR);
      }
      if (observationTime != null) {
        sql +=  " ot.name = :observationTime ";
        parameters.addValue("observationTime", observationTime, Types.VARCHAR);
      }
      
      List<MetaData> tsMetaDataList = _simpleJdbcTemplate.query(sql, new TimeSeriesMetaDataRowMapper(), parameters);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_18d76_f7d0f/rev_18d76-f7d0f;/src/com/opengamma/timeseries/db/RowStoreTimeSeriesMaster;loadTimeSeries(long,LocalDate,LocalDate);    
    if (start != null) {
      sql += " AND ts_date >= :startDate";
      parameters.addValue("startDate", toSQLDate(start), Types.DATE);
    }
    
    if (end != null) {
      sql += " AND ts_date < :endDate";
      parameters.addValue("endDate", toSQLDate(end), Types.DATE);
    }
    
    sql += " ORDER BY ts_date";;    parameters.addValue("startDate", start != null ? toSQLDate(start) : null, Types.DATE);
    parameters.addValue("endDate", end != null ? toSQLDate(end) : null, Types.DATE);;    
    if (start != null) {
      sql += " AND ts_date >= :startDate";
      parameters.addValue("startDate", toSQLDate(start), Types.DATE);
    }
    
    if (end != null) {
      sql += " AND ts_date < :endDate";
      parameters.addValue("endDate", toSQLDate(end), Types.DATE);
    }
    
    sql += " ORDER BY ts_date";
    
    parameters.addValue("startDate", start != null ? toSQLDate(start) : null, Types.DATE);
    parameters.addValue("endDate", end != null ? toSQLDate(end) : null, Types.DATE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_21f63_0467c/rev_21f63-0467c;/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef;read(org.apache.thrift.protocol.TProtocol);    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // KEYSPACE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.keyspace = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // NAME
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.name = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // COLUMN_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.column_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // COMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // SUBCOMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.subcomparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 8: // COMMENT
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comment = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 12: // READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.read_repair_chance = iprot.readDouble();
            setRead_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 13: // COLUMN_METADATA
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list46 = iprot.readListBegin();
              this.column_metadata = new ArrayList<ColumnDef>(_list46.size);
              for (int _i47 = 0; _i47 < _list46.size; ++_i47)
              {
                ColumnDef _elem48; // required
                _elem48 = new ColumnDef();
                _elem48.read(iprot);
                this.column_metadata.add(_elem48);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 14: // GC_GRACE_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.gc_grace_seconds = iprot.readI32();
            setGc_grace_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 15: // DEFAULT_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.default_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 16: // ID
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.id = iprot.readI32();
            setIdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 17: // MIN_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.min_compaction_threshold = iprot.readI32();
            setMin_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 18: // MAX_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.max_compaction_threshold = iprot.readI32();
            setMax_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 24: // REPLICATE_ON_WRITE
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.replicate_on_write = iprot.readBool();
            setReplicate_on_writeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 26: // KEY_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 28: // KEY_ALIAS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_alias = iprot.readBinary();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 29: // COMPACTION_STRATEGY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.compaction_strategy = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 30: // COMPACTION_STRATEGY_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map49 = iprot.readMapBegin();
              this.compaction_strategy_options = new HashMap<String,String>(2*_map49.size);
              for (int _i50 = 0; _i50 < _map49.size; ++_i50)
              {
                String _key51; // required
                String _val52; // required
                _key51 = iprot.readString();
                _val52 = iprot.readString();
                this.compaction_strategy_options.put(_key51, _val52);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 32: // COMPRESSION_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map53 = iprot.readMapBegin();
              this.compression_options = new HashMap<String,String>(2*_map53.size);
              for (int _i54 = 0; _i54 < _map53.size; ++_i54)
              {
                String _key55; // required
                String _val56; // required
                _key55 = iprot.readString();
                _val56 = iprot.readString();
                this.compression_options.put(_key55, _val56);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 33: // BLOOM_FILTER_FP_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.bloom_filter_fp_chance = iprot.readDouble();
            setBloom_filter_fp_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 34: // CACHING
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.caching = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 37: // DCLOCAL_READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.dclocal_read_repair_chance = iprot.readDouble();
            setDclocal_read_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 38: // POPULATE_IO_CACHE_ON_FLUSH
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.populate_io_cache_on_flush = iprot.readBool();
            setPopulate_io_cache_on_flushIsSet(true);
          } else {
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;  
        case 9: // ROW_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.row_cache_size = iprot.readDouble();
            setRow_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 11: // KEY_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.key_cache_size = iprot.readDouble();
            setKey_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 19: // ROW_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_save_period_in_seconds = iprot.readI32();
            setRow_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 20: // KEY_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.key_cache_save_period_in_seconds = iprot.readI32();
            setKey_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 21: // MEMTABLE_FLUSH_AFTER_MINS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_flush_after_mins = iprot.readI32();
            setMemtable_flush_after_minsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 22: // MEMTABLE_THROUGHPUT_IN_MB
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_throughput_in_mb = iprot.readI32();
            setMemtable_throughput_in_mbIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 23: // MEMTABLE_OPERATIONS_IN_MILLIONS
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.memtable_operations_in_millions = iprot.readDouble();
            setMemtable_operations_in_millionsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 25: // MERGE_SHARDS_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.merge_shards_chance = iprot.readDouble();
            setMerge_shards_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 27: // ROW_CACHE_PROVIDER
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.row_cache_provider = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 31: // ROW_CACHE_KEYS_TO_SAVE
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_keys_to_save = iprot.readI32();
            setRow_cache_keys_to_saveIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();;    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // KEYSPACE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.keyspace = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // NAME
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.name = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // COLUMN_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.column_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // COMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // SUBCOMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.subcomparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 8: // COMMENT
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comment = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 12: // READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.read_repair_chance = iprot.readDouble();
            setRead_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 13: // COLUMN_METADATA
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list46 = iprot.readListBegin();
              this.column_metadata = new ArrayList<ColumnDef>(_list46.size);
              for (int _i47 = 0; _i47 < _list46.size; ++_i47)
              {
                ColumnDef _elem48; // required
                _elem48 = new ColumnDef();
                _elem48.read(iprot);
                this.column_metadata.add(_elem48);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 14: // GC_GRACE_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.gc_grace_seconds = iprot.readI32();
            setGc_grace_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 15: // DEFAULT_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.default_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 16: // ID
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.id = iprot.readI32();
            setIdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 17: // MIN_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.min_compaction_threshold = iprot.readI32();
            setMin_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 18: // MAX_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.max_compaction_threshold = iprot.readI32();
            setMax_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 24: // REPLICATE_ON_WRITE
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.replicate_on_write = iprot.readBool();
            setReplicate_on_writeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 26: // KEY_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 28: // KEY_ALIAS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_alias = iprot.readBinary();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 29: // COMPACTION_STRATEGY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.compaction_strategy = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 30: // COMPACTION_STRATEGY_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map49 = iprot.readMapBegin();
              this.compaction_strategy_options = new HashMap<String,String>(2*_map49.size);
              for (int _i50 = 0; _i50 < _map49.size; ++_i50)
              {
                String _key51; // required
                String _val52; // required
                _key51 = iprot.readString();
                _val52 = iprot.readString();
                this.compaction_strategy_options.put(_key51, _val52);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 32: // COMPRESSION_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map53 = iprot.readMapBegin();
              this.compression_options = new HashMap<String,String>(2*_map53.size);
              for (int _i54 = 0; _i54 < _map53.size; ++_i54)
              {
                String _key55; // required
                String _val56; // required
                _key55 = iprot.readString();
                _val56 = iprot.readString();
                this.compression_options.put(_key55, _val56);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 33: // BLOOM_FILTER_FP_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.bloom_filter_fp_chance = iprot.readDouble();
            setBloom_filter_fp_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 34: // CACHING
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.caching = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 37: // DCLOCAL_READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.dclocal_read_repair_chance = iprot.readDouble();
            setDclocal_read_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 9: // ROW_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.row_cache_size = iprot.readDouble();
            setRow_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 11: // KEY_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.key_cache_size = iprot.readDouble();
            setKey_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 19: // ROW_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_save_period_in_seconds = iprot.readI32();
            setRow_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 20: // KEY_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.key_cache_save_period_in_seconds = iprot.readI32();
            setKey_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 21: // MEMTABLE_FLUSH_AFTER_MINS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_flush_after_mins = iprot.readI32();
            setMemtable_flush_after_minsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 22: // MEMTABLE_THROUGHPUT_IN_MB
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_throughput_in_mb = iprot.readI32();
            setMemtable_throughput_in_mbIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 23: // MEMTABLE_OPERATIONS_IN_MILLIONS
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.memtable_operations_in_millions = iprot.readDouble();
            setMemtable_operations_in_millionsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 25: // MERGE_SHARDS_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.merge_shards_chance = iprot.readDouble();
            setMerge_shards_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 27: // ROW_CACHE_PROVIDER
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.row_cache_provider = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 31: // ROW_CACHE_KEYS_TO_SAVE
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_keys_to_save = iprot.readI32();
            setRow_cache_keys_to_saveIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();;    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_21f63_0467c/rev_21f63-0467c;/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef;write(org.apache.thrift.protocol.TProtocol);    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.keyspace != null) {
      oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
      oprot.writeString(this.keyspace);
      oprot.writeFieldEnd();
    }
    if (this.name != null) {
      oprot.writeFieldBegin(NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    if (this.column_type != null) {
      if (isSetColumn_type()) {
        oprot.writeFieldBegin(COLUMN_TYPE_FIELD_DESC);
        oprot.writeString(this.column_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.comparator_type != null) {
      if (isSetComparator_type()) {
        oprot.writeFieldBegin(COMPARATOR_TYPE_FIELD_DESC);
        oprot.writeString(this.comparator_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.subcomparator_type != null) {
      if (isSetSubcomparator_type()) {
        oprot.writeFieldBegin(SUBCOMPARATOR_TYPE_FIELD_DESC);
        oprot.writeString(this.subcomparator_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.comment != null) {
      if (isSetComment()) {
        oprot.writeFieldBegin(COMMENT_FIELD_DESC);
        oprot.writeString(this.comment);
        oprot.writeFieldEnd();
      }
    }
    if (isSetRow_cache_size()) {
      oprot.writeFieldBegin(ROW_CACHE_SIZE_FIELD_DESC);
      oprot.writeDouble(this.row_cache_size);
      oprot.writeFieldEnd();
    }
    if (isSetKey_cache_size()) {
      oprot.writeFieldBegin(KEY_CACHE_SIZE_FIELD_DESC);
      oprot.writeDouble(this.key_cache_size);
      oprot.writeFieldEnd();
    }
    if (isSetRead_repair_chance()) {
      oprot.writeFieldBegin(READ_REPAIR_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.read_repair_chance);
      oprot.writeFieldEnd();
    }
    if (this.column_metadata != null) {
      if (isSetColumn_metadata()) {
        oprot.writeFieldBegin(COLUMN_METADATA_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.column_metadata.size()));
          for (ColumnDef _iter57 : this.column_metadata)
          {
            _iter57.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetGc_grace_seconds()) {
      oprot.writeFieldBegin(GC_GRACE_SECONDS_FIELD_DESC);
      oprot.writeI32(this.gc_grace_seconds);
      oprot.writeFieldEnd();
    }
    if (this.default_validation_class != null) {
      if (isSetDefault_validation_class()) {
        oprot.writeFieldBegin(DEFAULT_VALIDATION_CLASS_FIELD_DESC);
        oprot.writeString(this.default_validation_class);
        oprot.writeFieldEnd();
      }
    }
    if (isSetId()) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI32(this.id);
      oprot.writeFieldEnd();
    }
    if (isSetMin_compaction_threshold()) {
      oprot.writeFieldBegin(MIN_COMPACTION_THRESHOLD_FIELD_DESC);
      oprot.writeI32(this.min_compaction_threshold);
      oprot.writeFieldEnd();
    }
    if (isSetMax_compaction_threshold()) {
      oprot.writeFieldBegin(MAX_COMPACTION_THRESHOLD_FIELD_DESC);
      oprot.writeI32(this.max_compaction_threshold);
      oprot.writeFieldEnd();
    }
    if (isSetRow_cache_save_period_in_seconds()) {
      oprot.writeFieldBegin(ROW_CACHE_SAVE_PERIOD_IN_SECONDS_FIELD_DESC);
      oprot.writeI32(this.row_cache_save_period_in_seconds);
      oprot.writeFieldEnd();
    }
    if (isSetKey_cache_save_period_in_seconds()) {
      oprot.writeFieldBegin(KEY_CACHE_SAVE_PERIOD_IN_SECONDS_FIELD_DESC);
      oprot.writeI32(this.key_cache_save_period_in_seconds);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_flush_after_mins()) {
      oprot.writeFieldBegin(MEMTABLE_FLUSH_AFTER_MINS_FIELD_DESC);
      oprot.writeI32(this.memtable_flush_after_mins);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_throughput_in_mb()) {
      oprot.writeFieldBegin(MEMTABLE_THROUGHPUT_IN_MB_FIELD_DESC);
      oprot.writeI32(this.memtable_throughput_in_mb);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_operations_in_millions()) {
      oprot.writeFieldBegin(MEMTABLE_OPERATIONS_IN_MILLIONS_FIELD_DESC);
      oprot.writeDouble(this.memtable_operations_in_millions);
      oprot.writeFieldEnd();
    }
    if (isSetReplicate_on_write()) {
      oprot.writeFieldBegin(REPLICATE_ON_WRITE_FIELD_DESC);
      oprot.writeBool(this.replicate_on_write);
      oprot.writeFieldEnd();
    }
    if (isSetMerge_shards_chance()) {
      oprot.writeFieldBegin(MERGE_SHARDS_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.merge_shards_chance);
      oprot.writeFieldEnd();
    }
    if (this.key_validation_class != null) {
      if (isSetKey_validation_class()) {
        oprot.writeFieldBegin(KEY_VALIDATION_CLASS_FIELD_DESC);
        oprot.writeString(this.key_validation_class);
        oprot.writeFieldEnd();
      }
    }
    if (this.row_cache_provider != null) {
      if (isSetRow_cache_provider()) {
        oprot.writeFieldBegin(ROW_CACHE_PROVIDER_FIELD_DESC);
        oprot.writeString(this.row_cache_provider);
        oprot.writeFieldEnd();
      }
    }
    if (this.key_alias != null) {
      if (isSetKey_alias()) {
        oprot.writeFieldBegin(KEY_ALIAS_FIELD_DESC);
        oprot.writeBinary(this.key_alias);
        oprot.writeFieldEnd();
      }
    }
    if (this.compaction_strategy != null) {
      if (isSetCompaction_strategy()) {
        oprot.writeFieldBegin(COMPACTION_STRATEGY_FIELD_DESC);
        oprot.writeString(this.compaction_strategy);
        oprot.writeFieldEnd();
      }
    }
    if (this.compaction_strategy_options != null) {
      if (isSetCompaction_strategy_options()) {
        oprot.writeFieldBegin(COMPACTION_STRATEGY_OPTIONS_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, this.compaction_strategy_options.size()));
          for (Map.Entry<String, String> _iter58 : this.compaction_strategy_options.entrySet())
          {
            oprot.writeString(_iter58.getKey());
            oprot.writeString(_iter58.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetRow_cache_keys_to_save()) {
      oprot.writeFieldBegin(ROW_CACHE_KEYS_TO_SAVE_FIELD_DESC);
      oprot.writeI32(this.row_cache_keys_to_save);
      oprot.writeFieldEnd();
    }
    if (this.compression_options != null) {
      if (isSetCompression_options()) {
        oprot.writeFieldBegin(COMPRESSION_OPTIONS_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, this.compression_options.size()));
          for (Map.Entry<String, String> _iter59 : this.compression_options.entrySet())
          {
            oprot.writeString(_iter59.getKey());
            oprot.writeString(_iter59.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetBloom_filter_fp_chance()) {
      oprot.writeFieldBegin(BLOOM_FILTER_FP_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.bloom_filter_fp_chance);
      oprot.writeFieldEnd();
    }
    if (this.caching != null) {
      if (isSetCaching()) {
        oprot.writeFieldBegin(CACHING_FIELD_DESC);
        oprot.writeString(this.caching);
        oprot.writeFieldEnd();
      }
    }
    if (isSetDclocal_read_repair_chance()) {
      oprot.writeFieldBegin(DCLOCAL_READ_REPAIR_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.dclocal_read_repair_chance);
      oprot.writeFieldEnd();
    }
    if (isSetPopulate_io_cache_on_flush()) {
      oprot.writeFieldBegin(POPULATE_IO_CACHE_ON_FLUSH_FIELD_DESC);
      oprot.writeBool(this.populate_io_cache_on_flush);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();;    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.keyspace != null) {
      oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
      oprot.writeString(this.keyspace);
      oprot.writeFieldEnd();
    }
    if (this.name != null) {
      oprot.writeFieldBegin(NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    if (this.column_type != null) {
      if (isSetColumn_type()) {
        oprot.writeFieldBegin(COLUMN_TYPE_FIELD_DESC);
        oprot.writeString(this.column_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.comparator_type != null) {
      if (isSetComparator_type()) {
        oprot.writeFieldBegin(COMPARATOR_TYPE_FIELD_DESC);
        oprot.writeString(this.comparator_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.subcomparator_type != null) {
      if (isSetSubcomparator_type()) {
        oprot.writeFieldBegin(SUBCOMPARATOR_TYPE_FIELD_DESC);
        oprot.writeString(this.subcomparator_type);
        oprot.writeFieldEnd();
      }
    }
    if (this.comment != null) {
      if (isSetComment()) {
        oprot.writeFieldBegin(COMMENT_FIELD_DESC);
        oprot.writeString(this.comment);
        oprot.writeFieldEnd();
      }
    }
    if (isSetRow_cache_size()) {
      oprot.writeFieldBegin(ROW_CACHE_SIZE_FIELD_DESC);
      oprot.writeDouble(this.row_cache_size);
      oprot.writeFieldEnd();
    }
    if (isSetKey_cache_size()) {
      oprot.writeFieldBegin(KEY_CACHE_SIZE_FIELD_DESC);
      oprot.writeDouble(this.key_cache_size);
      oprot.writeFieldEnd();
    }
    if (isSetRead_repair_chance()) {
      oprot.writeFieldBegin(READ_REPAIR_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.read_repair_chance);
      oprot.writeFieldEnd();
    }
    if (this.column_metadata != null) {
      if (isSetColumn_metadata()) {
        oprot.writeFieldBegin(COLUMN_METADATA_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.column_metadata.size()));
          for (ColumnDef _iter57 : this.column_metadata)
          {
            _iter57.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetGc_grace_seconds()) {
      oprot.writeFieldBegin(GC_GRACE_SECONDS_FIELD_DESC);
      oprot.writeI32(this.gc_grace_seconds);
      oprot.writeFieldEnd();
    }
    if (this.default_validation_class != null) {
      if (isSetDefault_validation_class()) {
        oprot.writeFieldBegin(DEFAULT_VALIDATION_CLASS_FIELD_DESC);
        oprot.writeString(this.default_validation_class);
        oprot.writeFieldEnd();
      }
    }
    if (isSetId()) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI32(this.id);
      oprot.writeFieldEnd();
    }
    if (isSetMin_compaction_threshold()) {
      oprot.writeFieldBegin(MIN_COMPACTION_THRESHOLD_FIELD_DESC);
      oprot.writeI32(this.min_compaction_threshold);
      oprot.writeFieldEnd();
    }
    if (isSetMax_compaction_threshold()) {
      oprot.writeFieldBegin(MAX_COMPACTION_THRESHOLD_FIELD_DESC);
      oprot.writeI32(this.max_compaction_threshold);
      oprot.writeFieldEnd();
    }
    if (isSetRow_cache_save_period_in_seconds()) {
      oprot.writeFieldBegin(ROW_CACHE_SAVE_PERIOD_IN_SECONDS_FIELD_DESC);
      oprot.writeI32(this.row_cache_save_period_in_seconds);
      oprot.writeFieldEnd();
    }
    if (isSetKey_cache_save_period_in_seconds()) {
      oprot.writeFieldBegin(KEY_CACHE_SAVE_PERIOD_IN_SECONDS_FIELD_DESC);
      oprot.writeI32(this.key_cache_save_period_in_seconds);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_flush_after_mins()) {
      oprot.writeFieldBegin(MEMTABLE_FLUSH_AFTER_MINS_FIELD_DESC);
      oprot.writeI32(this.memtable_flush_after_mins);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_throughput_in_mb()) {
      oprot.writeFieldBegin(MEMTABLE_THROUGHPUT_IN_MB_FIELD_DESC);
      oprot.writeI32(this.memtable_throughput_in_mb);
      oprot.writeFieldEnd();
    }
    if (isSetMemtable_operations_in_millions()) {
      oprot.writeFieldBegin(MEMTABLE_OPERATIONS_IN_MILLIONS_FIELD_DESC);
      oprot.writeDouble(this.memtable_operations_in_millions);
      oprot.writeFieldEnd();
    }
    if (isSetReplicate_on_write()) {
      oprot.writeFieldBegin(REPLICATE_ON_WRITE_FIELD_DESC);
      oprot.writeBool(this.replicate_on_write);
      oprot.writeFieldEnd();
    }
    if (isSetMerge_shards_chance()) {
      oprot.writeFieldBegin(MERGE_SHARDS_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.merge_shards_chance);
      oprot.writeFieldEnd();
    }
    if (this.key_validation_class != null) {
      if (isSetKey_validation_class()) {
        oprot.writeFieldBegin(KEY_VALIDATION_CLASS_FIELD_DESC);
        oprot.writeString(this.key_validation_class);
        oprot.writeFieldEnd();
      }
    }
    if (this.row_cache_provider != null) {
      if (isSetRow_cache_provider()) {
        oprot.writeFieldBegin(ROW_CACHE_PROVIDER_FIELD_DESC);
        oprot.writeString(this.row_cache_provider);
        oprot.writeFieldEnd();
      }
    }
    if (this.key_alias != null) {
      if (isSetKey_alias()) {
        oprot.writeFieldBegin(KEY_ALIAS_FIELD_DESC);
        oprot.writeBinary(this.key_alias);
        oprot.writeFieldEnd();
      }
    }
    if (this.compaction_strategy != null) {
      if (isSetCompaction_strategy()) {
        oprot.writeFieldBegin(COMPACTION_STRATEGY_FIELD_DESC);
        oprot.writeString(this.compaction_strategy);
        oprot.writeFieldEnd();
      }
    }
    if (this.compaction_strategy_options != null) {
      if (isSetCompaction_strategy_options()) {
        oprot.writeFieldBegin(COMPACTION_STRATEGY_OPTIONS_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, this.compaction_strategy_options.size()));
          for (Map.Entry<String, String> _iter58 : this.compaction_strategy_options.entrySet())
          {
            oprot.writeString(_iter58.getKey());
            oprot.writeString(_iter58.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetRow_cache_keys_to_save()) {
      oprot.writeFieldBegin(ROW_CACHE_KEYS_TO_SAVE_FIELD_DESC);
      oprot.writeI32(this.row_cache_keys_to_save);
      oprot.writeFieldEnd();
    }
    if (this.compression_options != null) {
      if (isSetCompression_options()) {
        oprot.writeFieldBegin(COMPRESSION_OPTIONS_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, this.compression_options.size()));
          for (Map.Entry<String, String> _iter59 : this.compression_options.entrySet())
          {
            oprot.writeString(_iter59.getKey());
            oprot.writeString(_iter59.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetBloom_filter_fp_chance()) {
      oprot.writeFieldBegin(BLOOM_FILTER_FP_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.bloom_filter_fp_chance);
      oprot.writeFieldEnd();
    }
    if (this.caching != null) {
      if (isSetCaching()) {
        oprot.writeFieldBegin(CACHING_FIELD_DESC);
        oprot.writeString(this.caching);
        oprot.writeFieldEnd();
      }
    }
    if (isSetDclocal_read_repair_chance()) {
      oprot.writeFieldBegin(DCLOCAL_READ_REPAIR_CHANCE_FIELD_DESC);
      oprot.writeDouble(this.dclocal_read_repair_chance);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();;    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_23e2e_f1d8f/rev_23e2e-f1d8f;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/ConfigDBInterpolatedYieldCurveSpecificationBuilder;buildCurve(LocalDate,YieldCurveDefinition);    Interpolator1D<?> interpolator = Interpolator1DFactory.getInterpolator(curveDefinition.getInterpolatorName());
    return new InterpolatedYieldCurveSpecification(curveDate, curveDefinition.getName(), curveDefinition.getCurrency(), interpolator, securities, curveDefinition.getRegionId());;    Interpolator1D<?> interpolator = Interpolator1DFactory.getInterpolator(curveDefinition.getInterpolatorName());
    return new InterpolatedYieldCurveSpecification(curveDate, curveDefinition.getName(), curveDefinition.getCurrency(), interpolator, securities, curveDefinition.getRegion());;    final Interpolator1D<?> interpolator = Interpolator1DFactory.getInterpolator(curveDefinition.getInterpolatorName());
    return new InterpolatedYieldCurveSpecification(curveDate, curveDefinition.getName(), curveDefinition.getCurrency(),
        interpolator, securities, curveDefinition.getRegion());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_23e2e_f1d8f/rev_23e2e-f1d8f;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/YieldCurveDefinition;propertySet(String,Object,boolean);        throw new UnsupportedOperationException("Property cannot be written: regionId");
      case 3373707:  // name;        throw new UnsupportedOperationException("Property cannot be written: region");
      case 3373707:  // name;        throw new UnsupportedOperationException("Property cannot be written: region");
      case 3373707: // name
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_23e2e_f1d8f/rev_23e2e-f1d8f;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/YieldCurveDefinition;equals(Object);      YieldCurveDefinition other = (YieldCurveDefinition) obj;
      return JodaBeanUtils.equal(getUniqueId(), other.getUniqueId()) &&
          JodaBeanUtils.equal(getCurrency(), other.getCurrency()) &&
          JodaBeanUtils.equal(getRegionId(), other.getRegionId()) &&
          JodaBeanUtils.equal(getName(), other.getName()) &&
          JodaBeanUtils.equal(getInterpolatorName(), other.getInterpolatorName()) &&
          JodaBeanUtils.equal(getStrips(), other.getStrips());;      YieldCurveDefinition other = (YieldCurveDefinition) obj;
      return JodaBeanUtils.equal(getUniqueId(), other.getUniqueId()) &&
          JodaBeanUtils.equal(getCurrency(), other.getCurrency()) &&
          JodaBeanUtils.equal(getRegion(), other.getRegion()) &&
          JodaBeanUtils.equal(getName(), other.getName()) &&
          JodaBeanUtils.equal(getInterpolatorName(), other.getInterpolatorName()) &&
          JodaBeanUtils.equal(getStrips(), other.getStrips());;      final YieldCurveDefinition other = (YieldCurveDefinition) obj;
      return JodaBeanUtils.equal(getUniqueId(), other.getUniqueId())
          && JodaBeanUtils.equal(getCurrency(), other.getCurrency())
          && JodaBeanUtils.equal(getRegion(), other.getRegion()) && JodaBeanUtils.equal(getName(), other.getName())
          && JodaBeanUtils.equal(getInterpolatorName(), other.getInterpolatorName())
          && JodaBeanUtils.equal(getStrips(), other.getStrips());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_24f39_baf90/rev_24f39-baf90;/projects/OG-Master/src/com/opengamma/master/marketdatasnapshot/MarketDataSnapshotSearchRequest;Meta();@SuppressWarnings({"unchecked", "rawtypes" })
    protected Meta() {
      LinkedHashMap temp = new LinkedHashMap(super.metaPropertyMap());
      temp.put("snapshotIds", _snapshotIds);
      temp.put("name", _name);
      temp.put("includeData", _includeData);
      _map = Collections.unmodifiableMap(temp);;@SuppressWarnings({"unchecked", "rawtypes" })
    protected Meta() {
      LinkedHashMap temp = new LinkedHashMap(super.metaPropertyMap());
      temp.put("snapshotIds", _snapshotIds);
      temp.put("name", _name);
      _map = Collections.unmodifiableMap(temp);;protected Meta() {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_25a46_931be/rev_25a46-931be;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;prepare();                    // We don't support IN for indexed values (basically this would require supporting a form of OR)
                    if (restriction.eqValues.size() > 1)
                        throw new InvalidRequestException("Cannot use IN operator on column not part of the partition key");;                    // We don't support IN for indexed values (basically this would require supporting a form of OR)
                    if (restriction.eqValues.size() > 1)
                        throw new InvalidRequestException("Cannot use IN operator on column not part of the PRIMARY KEY");;            // Even if usesSecondaryIndexing is false at this point, we'll still have to use one if
            // there is restrictions not covered by the PK.
            if (!stmt.metadataRestrictions.isEmpty())
            {
                if (!hasQueriableIndex)
                    throw new InvalidRequestException("No indexed columns present in by-columns clause with Equal operator");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_26e7d_ed7c8/rev_26e7d-ed7c8;/lucene/core/src/java/org/apache/lucene/index/StoredFieldsConsumer;finishDocument();void finishDocument() throws IOException {
    assert docWriter.writer.testPoint("StoredFieldsWriter.finishDocument start");

    initFieldsWriter(IOContext.DEFAULT);
    fill(docState.docID);

    if (fieldsWriter != null && numStoredFields > 0) {
      fieldsWriter.startDocument(numStoredFields);
      for (int i = 0; i < numStoredFields; i++) {
        fieldsWriter.writeField(fieldInfos[i], storedFields[i]);
      }
      fieldsWriter.finishDocument();
      lastDocID++;
    }

    reset();
    assert docWriter.writer.testPoint("StoredFieldsWriter.finishDocument end");
  };void finishDocument() throws IOException {
    assert docWriter.writer.testPoint("StoredFieldsWriter.finishDocument start");

    initFieldsWriter(IOContext.DEFAULT);
    fill(docState.docID);

    if (fieldsWriter != null && numStoredFields > 0) {
      fieldsWriter.startDocument(numStoredFields);
      for (int i = 0; i < numStoredFields; i++) {
        fieldsWriter.writeField(fieldInfos[i], storedFields[i]);
      }
      lastDocID++;
    }

    reset();
    assert docWriter.writer.testPoint("StoredFieldsWriter.finishDocument end");
  };abstract void finishDocument() throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_29f54_2b51a/rev_29f54-2b51a;/solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent;toSolrDoc(SolrInputDocument,IndexSchema);      if (f.fieldType().stored() ) {
        out.add(f);;      if (f.fieldType().stored()) {
        out.add(f);;      if (f.fieldType().stored()) {
        out.add((StorableField) f);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_032b7_c5a80/rev_032b7-c5a80;/realm-annotations-processor/src/main/java/io/realm/processor/RealmSourceCodeGenerator;setField(String,Element);        String shortType = convertSimpleTypesToObject(fieldElement.asType().toString());;        String fieldId = "index_" + fieldName;

        String shortType = convertSimpleTypesToObject(fieldElement.asType().toString());;        String fieldId = "index_" + fieldName;

        String shortType = objectTypes.get(fieldElement.asType().toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_33a3d_e5e72/rev_33a3d-e5e72;/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader;RowIterator();                CqlResult result = client.execute_cql3_query(
                                        ByteBufferUtil.bytes(String.format(query, keyspace, cfName)),
                                        Compression.NONE,
                                        ConsistencyLevel.ONE);;                // Get the Keyspace metadata, then get the specific CF metadata
                // in order to populate the sub/comparator.
                KsDef ks_def = client.describe_keyspace(keyspace);
                List<String> cfnames = new ArrayList<String>();
                for (CfDef cfd : ks_def.cf_defs)
                    cfnames.add(cfd.name);
                int idx = cfnames.indexOf(cfName);
                CfDef cf_def = ks_def.cf_defs.get(idx);;                // Get the Keyspace metadata, then get the specific CF metadata
                // in order to populate the sub/comparator.
                KsDef ks_def = client.describe_keyspace(keyspace);
                List<String> cfnames = new ArrayList<String>(ks_def.cf_defs.size());
                for (CfDef cfd : ks_def.cf_defs)
                    cfnames.add(cfd.name);
                int idx = cfnames.indexOf(cfName);
                CfDef cf_def = ks_def.cf_defs.get(idx);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_33a3d_e5e72/rev_33a3d-e5e72;/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader;RowIterator();                Iterator<CqlRow> iteraRow = result.rows.iterator();
                CfDef cfDef = new CfDef();
                if (iteraRow.hasNext())
                {
                    CqlRow cqlRow = iteraRow.next();
                    cfDef.comparator_type = ByteBufferUtil.string(cqlRow.columns.get(0).value);
                    ByteBuffer subComparator = cqlRow.columns.get(1).value;
                    if (subComparator != null)
                        cfDef.subcomparator_type = ByteBufferUtil.string(subComparator);
                }

                comparator = TypeParser.parse(cfDef.comparator_type);
                subComparator = cfDef.subcomparator_type == null ? null : TypeParser.parse(cfDef.subcomparator_type);;                comparator = TypeParser.parse(cf_def.comparator_type);
                subComparator = cf_def.subcomparator_type == null ? null : TypeParser.parse(cf_def.subcomparator_type);;                isSuper = cf_def.column_type.equals("Super");
                comparator = TypeParser.parse(cf_def.comparator_type);
                subComparator = cf_def.subcomparator_type == null ? null : TypeParser.parse(cf_def.subcomparator_type);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_35cf5_e866b/rev_35cf5-e866b;/tests/unit/com/opengamma/financial/interestrate/PresentValueSensitivityCalculatorTest;TestFutures();    final double settlementDate = 1.453;
    final double yearFraction = 0.25;
    final YieldAndDiscountCurve curve = CURVES.getCurve(FIVE_PC_CURVE_NAME);
    final double rate = (curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction) - 1.0) / yearFraction;
    final double price = 100 * (1 - rate);
    final InterestRateFuture edf = new InterestRateFuture(settlementDate, yearFraction, price, FIVE_PC_CURVE_NAME);
    final Map<String, List<DoublesPair>> sense = PVSC.getValue(edf, CURVES);
    final double ratio = 100 * curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction);;    double settlementDate = 1.453;
    double yearFraction = 0.25;
    YieldAndDiscountCurve curve = CURVES.getCurve(FIVE_PC_CURVE_NAME);
    double rate = (curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction) - 1.0) / yearFraction;
    double price = 100 * (1 - rate);
    InterestRateFuture edf = new InterestRateFuture(settlementDate, yearFraction, price, FIVE_PC_CURVE_NAME);
    Map<String, List<Pair<Double, Double>>> sense = PVSC.getValue(edf, CURVES);
    double ratio = 100 * curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction);;    double settlementDate = 1.453;
    double yearFraction = 0.25;
    YieldAndDiscountCurve curve = CURVES.getCurve(FIVE_PC_CURVE_NAME);
    double rate = (curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction) - 1.0) / yearFraction;
    double price = 100 * (1 - rate);
    InterestRateFuture edf = new InterestRateFuture(settlementDate, yearFraction, price, FIVE_PC_CURVE_NAME);
    Map<String, List<Pair<Double, Double>>> sense = PVSC.getValue(edf, CURVES);
    double ratio = curve.getDiscountFactor(settlementDate) / curve.getDiscountFactor(settlementDate + yearFraction);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_37ec7_8fe50/rev_37ec7-8fe50;/src/java/org/apache/cassandra/db/RowMutationVerbHandler;doVerb(Message);            MessagingService.instance().sendOneWay(responseMessage, message.getFrom());;            MessagingService.instance.sendOneWay(responseMessage, message.getFrom());;            MessagingService.instance.sendOneWay(responseMessage, message.getFrom());

            // repair-on-write (remote message)
            ReplicateOnWriteTask replicateOnWriteTask = new ReplicateOnWriteTask(rm);
            StageManager.getStage(Stage.REPLICATE_ON_WRITE).execute(replicateOnWriteTask);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_37fe2_fed61/rev_37fe2-fed61;/projects/OG-Financial/src/com/opengamma/financial/batch/CommandLineBatchJobRun;createView();    InMemoryLKVSnapshotProvider snapshotProvider = getSnapshotProvider();
    
    VersionCorrection vc = VersionCorrection.of(getStaticDataTime(), getOriginalCreationTime());;    InMemoryLKVSnapshotProvider snapshotProvider = getSnapshotProvider();;    InMemoryLKVSnapshotProvider snapshotProvider = createSnapshotProvider();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_38d61_ca1bb/rev_38d61-ca1bb;/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/configurations/DefaultConfiguration;DefaultConfiguration(String,String,ConfigurationsProvider,ConfigurationResolver,ListenerManager,DependencyMetaDataProvider,ResolutionStrategyInternal);        ownArtifacts.beforeChange(new VetoContainerChangeAction());;        ownArtifacts.beforeChange(new VetoContainerChangeAction());;        ownArtifacts.beforeChange(veto);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_38d91_8d7f5/rev_38d91-8d7f5;/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest;theoryMeansOnlyAssumeShouldFail();	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
		Assert.assertEquals(1, result.getFailureCount());
	};	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		JUnitCore junitRunner = new JUnitCore();
		Runner theoryRunner = new Theories(TheoryWithNoUnassumedParameters.class);
		Request request = Request.runner(theoryRunner);
		Result result = junitRunner.run(request);
		Assert.assertEquals(1, result.getFailureCount());
	};    public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
        Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
        Assert.assertEquals(1, result.getFailureCount());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_38d91_8d7f5/rev_38d91-8d7f5;/src/main/java/org/junit/experimental/theories/internal/AllMembersSupplier;addMultiPointMethods(ParameterSignature,List<PotentialAssignment>);            try {
                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));
            } catch (Throwable t) {
                DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);
                if (annotation != null) {
                    for (Class<? extends Throwable> ignored : annotation.ignoredExceptions()) {
                        if (ignored.isAssignableFrom(t.getClass())) {
                            return;
                        }
                    }
                }
                throw t;;            try {
                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));
            } catch (Throwable e) {
                // ignore and move on;            Class<?> returnType = dataPointsMethod.getReturnType();
            
            if (returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) {
                try {
                    addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));
                } catch (Throwable e) {
                    // ignore and move on
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_38e5c_70e31/rev_38e5c-70e31;/src/java/org/apache/cassandra/service/StorageService;joinTokenRing(int);        Token<?> token;
        InetAddress current = null;
        logger_.debug(String.format("Bootstrap variables: %s %s %s %s",
                      DatabaseDescriptor.isAutoBootstrap(), SystemTable.bootstrapInProgress(), SystemTable.bootstrapComplete(), schemaPresent));;        Token<?> token;
        InetAddress current = null;
        logger_.debug("Bootstrap variables: %s %s %s %s",
                      new Object[] {DatabaseDescriptor.isAutoBootstrap(), SystemTable.bootstrapInProgress(), SystemTable.bootstrapComplete(), schemaPresent});;        Set<InetAddress> current = new HashSet<InetAddress>();
        Collection<Token> tokens;
        logger.debug("Bootstrap variables: %s %s %s %s",
                      new Object[] {DatabaseDescriptor.isAutoBootstrap(), SystemTable.bootstrapInProgress(), SystemTable.bootstrapComplete(), schemaPresent});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_39a38_47ac4/rev_39a38-47ac4;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                if (endpoints.size() == 1)
                    continue;

                // send the other endpoints a digest request
                ReadCommand digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
                MessageOut message = null;
                for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
                {
                    if (digestPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                    {
                        StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                    }
                    else
                    {
                        Tracing.trace("Enqueuing digest request to {}", digestPoint);
                        // (We lazy-construct the digest Message object since it may not be necessary if we
                        // are doing a local digest read, or no digest reads at all.)
                        if (message == null)
                            message = digestCommand.createMessage();
                        MessagingService.instance().sendRR(message, digestPoint, handler);
                    }
                }
            };                if (endpoints.size() == 1)
                    continue;

                // send the other endpoints a digest request
                ReadCommand digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
                MessageOut message = null;
                for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
                {
                    if (digestPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                    {
                        StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                    }
                    else
                    {
                        Tracing.trace("Enqueuing digest request to {}", dataPoint);
                        // (We lazy-construct the digest Message object since it may not be necessary if we
                        // are doing a local digest read, or no digest reads at all.)
                        if (message == null)
                            message = digestCommand.createMessage();
                        MessagingService.instance().sendRR(message, digestPoint, handler);
                    }
                }
            };            for (AbstractReadExecutor exec: readExecutors)
                exec.speculate();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_39a38_47ac4/rev_39a38-47ac4;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                }
                catch (ReadTimeoutException ex)
                {
                    int blockFor = consistency_level.blockFor(Table.open(command.getKeyspace()));
                    int responseCount = handler.getReceivedCount();
                    String gotData = responseCount > 0 ?
                                     gotData = handler.resolver.isDataPresent() ? " (including data)" : " (only digests)" :
                                     "";

                    if (Tracing.isTracing())
                    {
                        Tracing.trace("Timed out; received {} of {} responses{}",
                                      new Object[]{ responseCount, blockFor, gotData });
                    }
                    else if (logger.isDebugEnabled())
                    {
                        logger.debug("Read timeout; received {} of {} responses{}", responseCount, blockFor, gotData);
                    }
                    throw ex;;                }
                catch (ReadTimeoutException ex)
                {
                    if (logger.isDebugEnabled())
                        logger.debug("Read timeout: {}", ex.toString());
                    throw ex;;                    if (logger.isDebugEnabled())
                        logger.debug("Read: {} ms.", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - exec.handler.start));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_39a38_47ac4/rev_39a38-47ac4;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                        Tracing.trace("Timed out on digest mismatch retries");
                        int blockFor = consistency_level.blockFor(Table.open(command.getKeyspace()));;                        int blockFor = consistency_level.blockFor(Table.open(command.getKeyspace()));;                        int blockFor = consistency_level.blockFor(Keyspace.open(command.getKeyspace()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_41cc5_5e11f/rev_41cc5-5e11f;/lucene/src/java/org/apache/lucene/index/DocumentsWriter;initFlushState(boolean);    final SegmentCodecs info = SegmentCodecs.build(fieldInfos, writer.codecs);
    flushState = new SegmentWriteState(infoStream, directory, segment, fieldInfos,
                                       docStoreSegment, numDocsInRAM, numDocsInStore, writer.getConfig().getTermIndexInterval(), info);;    final SegmentCodecs info = SegmentCodecs.build(docFieldProcessor.fieldInfos, writer.codecs);
    flushState = new SegmentWriteState(infoStream, directory, segment, docFieldProcessor.fieldInfos,
                                       docStoreSegment, numDocsInRAM, numDocsInStore, writer.getConfig().getTermIndexInterval(), info);;    final SegmentCodecs info = SegmentCodecs.build(docFieldProcessor.fieldInfos, writer.codecs);
    flushState = new SegmentWriteState(infoStream, directory, segment, docFieldProcessor.fieldInfos,
                                       docStoreSegment, numDocsInRAM, numDocsInStore, writer.getConfig().getTermIndexInterval(), info, bytesUsed);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestPanAndZoomManager;setup();			                        axisOrientation(AxisOrientationSetting.X_AXIS_AS_TIME).
		                            nonTimeVaribleAxisMaxValue(100).
		                            nonTimeVaribleAxisMinValue(0).
		                            timeVariableAxisMinValue(now).
		                            timeVariableAxisMaxValue(now + 300000L).
		                            nonTimeAxisMinSubsequentSetting(PlotConstants.NonTimeAxisSubsequentBoundsSetting.FIXED).
		                            nonTimeAxisMaxSubsequentSetting(PlotConstants.NonTimeAxisSubsequentBoundsSetting.FIXED).;			                        axisOrientation(AxisOrientationSetting.X_AXIS_AS_TIME).
		                            nonTimeVaribleAxisMaxValue(100).
		                            nonTimeVaribleAxisMinValue(0).;			                        plotSettings(settings).
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestPanAndZoomManager;setup();	    PlotAbstraction testPlotTimeY = new PlotView.Builder(PlotterPlot.class).
        axisOrientation(AxisOrientationSetting.Y_AXIS_AS_TIME).
        nonTimeVaribleAxisMaxValue(100).
        nonTimeVaribleAxisMinValue(0).
        timeVariableAxisMinValue(now).
        timeVariableAxisMaxValue(now + 300000L).
        nonTimeAxisMinSubsequentSetting(PlotConstants.NonTimeAxisSubsequentBoundsSetting.FIXED).
        nonTimeAxisMaxSubsequentSetting(PlotConstants.NonTimeAxisSubsequentBoundsSetting.FIXED).
        build();;	    PlotAbstraction testPlotTimeY = new PlotView.Builder(PlotterPlot.class).
        axisOrientation(AxisOrientationSetting.Y_AXIS_AS_TIME).
        nonTimeVaribleAxisMaxValue(100).
        nonTimeVaribleAxisMinValue(0).
        build();;		PlotAbstraction testPlotTimeY = new PlotView.Builder(PlotterPlot.class).
							        plotSettings(settings2).
							        build();
                
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestLimitArrowIndicators;testAlarmTransitionSquenceMinFixedMode();			            Color.white, 
			            1, 
			            0.5, 
			            0.5,
			            0.5,
			            0, 
			            10, 
			            now.getTimeInMillis(), 
			            now.getTimeInMillis() + (5L * 60L * 1000L),;			            Color.white, 
			            1, 
			            0.5, 
			            0.5,
			            0.5,
			            0, 
			            10, 
			            0, 
			            10,;			            Color.white, 	
			            1,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestLimitArrowIndicators;testAlarmTransitionSquenceMaxSemiFixedMode();			            1, 
			            0.5,
			            0.5,
			            0.5,
			            0, 
			            10, 
			            now.getTimeInMillis(), 
			            now.getTimeInMillis() + (5L * 60L * 1000L),;			            1, 
			            0.5,
			            0.5,
			            0.5,
			            0, 
			            10, 
			            0, 
			            10,;			            1, 			            
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestLimitArrowIndicators;testAlarmTransitionSquenceMaxSemiFixedMode();	   Assert.assertFalse(plot.isCompresionEnabled());
	   now.add(Calendar.MINUTE, 1);;	   Assert.assertFalse(plot.isCompresionEnabled());
	   ;	   Assert.assertFalse(plot.isCompressionEnabled());
	   
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotCornerResetButtonManager;resetX();void resetX() {
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetTimeAxis();
		} else {
			resetNonTimeAxis();
		}
		if (!plot.limitManager.isUntranslated()) {
			plot.limitManager.setModeUntranslated(true);
		};void resetX() {
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetTimeAxis();
		} else {
			resetNonTimeAxis();
		};void resetX() {
		if (plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetTimeAxis();
		} else {
			resetNonTimeAxis();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotCornerResetButtonManager;resetY();void resetY() {
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetNonTimeAxis();
		} else {
			resetTimeAxis();
		};void resetY() {
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetNonTimeAxis();
		} else {
			resetTimeAxis();
		};void resetY() {
		if (plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
			resetNonTimeAxis();
		} else {
			resetTimeAxis();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotCornerResetButtonManager;updateButtons();public void updateButtons() {
		Axis timeAxis = plot.plotAbstraction.getTimeAxis();
		Axis nonTimeAxis = plot.getNonTimeAxis();
		Axis xAxis;
		Axis yAxis;
		if(plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			xAxis = timeAxis;
			yAxis = nonTimeAxis;
		} else {
			xAxis = nonTimeAxis;
			yAxis = timeAxis;
		}

		List<AbstractPlottingPackage> plots = plot.plotAbstraction.getSubPlots();
		// Only show the top right reset button on the top plot.
		if(plots.get(0) == plot) {
			// This was changed to fix MCT-2613: [Plot] Top right corner button appears briefly in jump and scrunch modes, between the time that the plot line hits the end of the time axis and when the jump
			// The problem was that the jump occurs based on the maximum time plotted, which due to compression, is not the same as the current MCT time.
			// As an easy fix, the button is always hidden when the time axis is not pinned.
			// Assuming that data should never appear off the right of a jump plot, this works well enough.
			// If that assumption breaks, the code should be modified to check against the maximum plotted time instead of the current MCT time.
			long now = plot.plotAbstraction.getCurrentMCTTime();
			if(!timeAxis.isPinned()) {
				plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
			} else if(plot.getCurrentTimeAxisMaxAsLong() < now || plot.getCurrentTimeAxisMinAsLong() > now) {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(true);
			} else {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(false);
			}
		} else {
			plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
		}
		// Only show the time axis reset button on the bottom plot.
		boolean enableX = true;
		boolean enableY = true;
		if(plots.get(plots.size() - 1) != plot) {
			if(plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
				enableX = false;
			} else {
				enableY = false;
			}
		}

		plot.localControlsManager.setXAxisCornerResetButtonVisible(enableX && !xAxis.isInDefaultState());
		plot.localControlsManager.setYAxisCornerResetButtonVisible(enableY && !yAxis.isInDefaultState());
		plot.localControlsManager.setXAndYAxisCornerResetButtonVisible(!xAxis.isInDefaultState() && !yAxis.isInDefaultState());;public void updateButtons() {
		Axis timeAxis = plot.plotAbstraction.getTimeAxis();
		Axis nonTimeAxis = plot.getNonTimeAxis();
		Axis xAxis;
		Axis yAxis;
		if(plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			xAxis = timeAxis;
			yAxis = nonTimeAxis;
		} else {
			xAxis = nonTimeAxis;
			yAxis = timeAxis;
		}

		List<AbstractPlottingPackage> plots = plot.plotAbstraction.getSubPlots();
		// Only show the top right reset button on the top plot.
		if(plots.get(0) == plot) {
			// This was changed to fix MCT-2613: [Plot] Top right corner button appears briefly in jump and scrunch modes, between the time that the plot line hits the end of the time axis and when the jump
			// The problem was that the jump occurs based on the maximum time plotted, which due to compression, is not the same as the current MCT time.
			// As an easy fix, the button is always hidden when the time axis is not pinned.
			// Assuming that data should never appear off the right of a jump plot, this works well enough.
			// If that assumption breaks, the code should be modified to check against the maximum plotted time instead of the current MCT time.
			long now = plot.plotAbstraction.getCurrentMCTTime();
			if(!timeAxis.isPinned()) {
				plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
			} else if(plot.getCurrentTimeAxisMaxAsLong() < now || plot.getCurrentTimeAxisMinAsLong() > now) {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(true);
			} else {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(false);
			}
		} else {
			plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
		}
		// Only show the time axis reset button on the bottom plot.
		boolean enableX = true;
		boolean enableY = true;
		if(plots.get(plots.size() - 1) != plot) {
			if(plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
				enableX = false;
			} else {
				enableY = false;
			}
		}

		plot.localControlsManager.setXAxisCornerResetButtonVisible(enableX && !xAxis.isInDefaultState());
		plot.localControlsManager.setYAxisCornerResetButtonVisible(enableY && !yAxis.isInDefaultState());
		plot.localControlsManager.setXAndYAxisCornerResetButtonVisible(!xAxis.isInDefaultState() && !yAxis.isInDefaultState());;public void updateButtons() {
		Axis timeAxis = plot.plotAbstraction.getTimeAxis();
		Axis nonTimeAxis = plot.getNonTimeAxis();
		Axis xAxis;
		Axis yAxis;
		if(plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
			xAxis = timeAxis;
			yAxis = nonTimeAxis;
		} else {
			xAxis = nonTimeAxis;
			yAxis = timeAxis;
		}

		List<AbstractPlottingPackage> plots = plot.plotAbstraction.getSubPlots();
		// Only show the top right reset button on the top plot.
		if(plots.get(0) == plot) {
			// This was changed to fix MCT-2613: [Plot] Top right corner button appears briefly in jump and scrunch modes, between the time that the plot line hits the end of the time axis and when the jump
			// The problem was that the jump occurs based on the maximum time plotted, which due to compression, is not the same as the current MCT time.
			// As an easy fix, the button is always hidden when the time axis is not pinned.
			// Assuming that data should never appear off the right of a jump plot, this works well enough.
			// If that assumption breaks, the code should be modified to check against the maximum plotted time instead of the current MCT time.
			long now = plot.plotAbstraction.getCurrentMCTTime();
			if(!timeAxis.isPinned()) {
				plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
			} else if(plot.getMaxTime() < now || plot.getMinTime() > now) {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(true);
			} else {
				plot.localControlsManager.setJumpToCurrentTimeButtonAlarm(false);
			}
		} else {
			plot.localControlsManager.setJumpToCurrentTimeButtonVisible(false);
		}
		// Only show the time axis reset button on the bottom plot.
		boolean enableX = true;
		boolean enableY = true;
		if(plots.get(plots.size() - 1) != plot) {
			if(plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
				enableX = false;
			} else {
				enableY = false;
			}
		}

		plot.localControlsManager.setXAxisCornerResetButtonVisible(enableX && !xAxis.isInDefaultState());
		plot.localControlsManager.setYAxisCornerResetButtonVisible(enableY && !yAxis.isInDefaultState());
		plot.localControlsManager.setXAndYAxisCornerResetButtonVisible(!xAxis.isInDefaultState() && !yAxis.isInDefaultState());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PanAndZoomManager;panAction(PanDirection);public void panAction(PanDirection panningAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;

			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();
			}		
		} else {
			
			double nonTimeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			
			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			}	
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		//Always request data refresh
		plot.clearAllDataFromPlot();
		plot.limitManager.setModeUntranslated(false);
		plot.plotAbstraction.requestPlotData(plot.getCurrentTimeAxisMin(), plot.getCurrentTimeAxisMax());;public void panAction(PanDirection panningAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		boolean timeChanged = false;
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;

			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();			
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			}		
		} else {
			
			double nonTimeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			
			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			}	
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		if(timeChanged) {
			plot.clearAllDataFromPlot();
			plot.plotAbstraction.requestPlotData(plot.getCurrentTimeAxisMin(), plot.getCurrentTimeAxisMax());
		};public void panAction(PanDirection panningAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		boolean timeChanged = false;
		if (plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;

			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();			
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			}		
		} else {
			
			double nonTimeScalePanAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScalePanAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScalePanAmount = (timeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			nonTimeScalePanAmount= (nonTimeScalePanAmount/100) * PlotConstants.PANNING_TIME_AXIS_PERCENTAGE;
			
			if (panningAction == PanDirection.PAN_HIGHER_Y_AXIS) {
				yAxis.shift(timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_LOWER_Y_AXIS) {
				yAxis.shift(-timeScalePanAmount);
				pinTime();
				plot.notifyObserversTimeChange();	
				timeChanged = true;
			} else if (panningAction == PanDirection.PAN_LOWER_X_AXIS) {
				xAxis.shift(-nonTimeScalePanAmount);
				pinNonTime();
			} else if (panningAction == PanDirection.PAN_HIGHER_X_AXIS) {
				xAxis.shift(nonTimeScalePanAmount);
				pinNonTime();
			}	
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		if(timeChanged) {
			plot.clearAllDataFromPlot();
			plot.plotAbstraction.requestPlotData(plot.getCurrentTimeAxisMin(), plot.getCurrentTimeAxisMax());
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PanAndZoomManager;zoomAction(ZoomDirection);public void zoomAction(ZoomDirection zoomAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount= (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			}
		
		} else {
			double nonTimeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount = (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
					yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
					xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			}
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		//Always request data refresh
		plot.limitManager.setModeUntranslated(false);
		plot.plotDataManager.resizeAndReloadPlotBuffer();;public void zoomAction(ZoomDirection zoomAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		boolean timeChanged = false;
		if (plot.axisOrientation == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount= (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			}
		
		} else {
			double nonTimeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount = (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();	
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
					yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();	
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
					xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			}
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		if(timeChanged) {
			plot.plotDataManager.resizeAndReloadPlotBuffer();
		};public void zoomAction(ZoomDirection zoomAction) {
		XYAxis xAxis = plot.plotView.getXAxis();
		XYAxis yAxis = plot.plotView.getYAxis();
		boolean timeChanged = false;
		if (plot.getAxisOrientationSetting() == AxisOrientationSetting.X_AXIS_AS_TIME) {
			double nonTimeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			double timeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount= (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - timeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			}
		
		} else {
			double nonTimeScaleZoomAmount = xAxis.getEnd() - xAxis.getStart();
			double timeScaleZoomAmount = yAxis.getEnd() - yAxis.getStart();
			
			timeScaleZoomAmount = (timeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			nonTimeScaleZoomAmount = (nonTimeScaleZoomAmount/100) * PlotConstants.ZOOMING_TIME_AXIS_PERCENTAGE;
			
			if (zoomAction == ZoomDirection.ZOOM_IN_HIGH_Y_AXIS) {
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_HIGH_Y_AXIS) {
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();	
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_Y_AXIS) {
					yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
					yAxis.setEnd(yAxis.getEnd() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				yAxis.setEnd(yAxis.getEnd() + timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() + timeScaleZoomAmount);
				  markTimeZoomed();
				 plot.notifyObserversTimeChange();	
				 timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LOW_Y_AXIS) {
				yAxis.setStart(yAxis.getStart() - timeScaleZoomAmount);
				  markTimeZoomed();
				  plot.notifyObserversTimeChange();	
				  timeChanged = true;
			} else if (zoomAction == ZoomDirection.ZOOM_IN_LEFT_X_AXIS) {
				xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_LEFT_X_AXIS) {
					xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_CENTER_X_AXIS) {
					xAxis.setStart(xAxis.getStart() + nonTimeScaleZoomAmount);
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_CENTER_X_AXIS) {
				xAxis.setStart(xAxis.getStart() - nonTimeScaleZoomAmount);
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_IN_RIGHT_X_AXIS) {
					xAxis.setEnd(xAxis.getEnd() - nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			} else if (zoomAction == ZoomDirection.ZOOM_OUT_RIGHT_X_AXIS) {
				xAxis.setEnd(xAxis.getEnd() + nonTimeScaleZoomAmount);
				  markNonTimeZoomed();
			}
		}
		plot.plotAbstraction.updateResetButtons();
		plot.refreshDisplay();
		if(timeChanged) {
			plot.plotDataManager.resizeAndReloadPlotBuffer();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotLimitManager;informPointPlottedAtTime(long,double);		boolean checkMax = plot.nonTimeAxisMaxSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.nonTimeAxisMaxSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED 
				|| plot.getNonTimeAxis().isPinned() 
				|| plot.plotAbstraction.getTimeAxisUserPin().isPinned()
				|| plot.plotAbstraction.getTimeAxis().isPinned()
				|| plot.plotAbstraction.getTimeAxis().isZoomed();
		if(checkMax && 
				(value >= plot.getCurrentNonTimeAxisMax()
				|| nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMaxPhysicalValue)) 
				&& atTime >= plot.getCurrentTimeAxisMinAsLong() && atTime <= plot.getCurrentTimeAxisMaxAsLong()) {
			if (nonTimeMaxAlarm != LimitAlarmState.ALARM_OPENED_BY_USER ) { ;		boolean checkMax = plot.nonTimeAxisMaxSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.nonTimeAxisMaxSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED;
		if(checkMax && (value >= plot.nonTimeVaribleAxisMaxValue  || 
				nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMaxPhysicalValue))) {
			if (nonTimeMaxAlarm != LimitAlarmState.ALARM_OPENED_BY_USER && plot.isNonTimeMaxFixed()) {;		boolean checkMax = plot.getNonTimeAxisSubsequentMaxSetting() == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.getNonTimeAxisSubsequentMaxSetting() == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED;
		if(checkMax && (value >= plot.getMinNonTime()  || 
				nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMaxPhysicalValue))) {
			if (nonTimeMaxAlarm != LimitAlarmState.ALARM_OPENED_BY_USER && plot.isNonTimeMaxFixed()) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotLimitManager;informPointPlottedAtTime(long,double);		}
		
		boolean checkMin = plot.nonTimeAxisMinSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.nonTimeAxisMinSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED 
				|| plot.getNonTimeAxis().isPinned() 
				|| plot.plotAbstraction.getTimeAxisUserPin().isPinned() 
				|| plot.plotAbstraction.getTimeAxis().isPinned()
				|| plot.plotAbstraction.getTimeAxis().isZoomed();
		if(checkMin && (value <= plot.getCurrentNonTimeAxisMin() ||
				nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMinPhysicalValue)) &&
				atTime >= plot.getCurrentTimeAxisMinAsLong() && atTime <= plot.getCurrentTimeAxisMaxAsLong()) {
			if (nonTimeMinAlarm != LimitAlarmState.ALARM_OPENED_BY_USER ) { ;		}
		boolean checkMin = plot.nonTimeAxisMinSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.nonTimeAxisMinSubsequentSetting == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED;
		if(checkMin && (value <= plot.nonTimeVaribleAxisMinValue ||
				nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMinPhysicalValue))) {
			if (nonTimeMinAlarm != LimitAlarmState.ALARM_OPENED_BY_USER && plot.isNonTimeMinFixed()) {;		}
		boolean checkMin = plot.getNonTimeAxisSubsequentMinSetting() == NonTimeAxisSubsequentBoundsSetting.FIXED
				|| plot.getNonTimeAxisSubsequentMinSetting() == NonTimeAxisSubsequentBoundsSetting.SEMI_FIXED;
		if(checkMin && (value <= plot.getMinNonTime() ||
				nonTimeValueWithin1PixelOfLimit(value, plot.nonTimeAxisMinPhysicalValue))) {
			if (nonTimeMinAlarm != LimitAlarmState.ALARM_OPENED_BY_USER && plot.isNonTimeMinFixed()) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotterPlot;getInitialNonTimeMinSetting();@Override
	public double getInitialNonTimeMinSetting() {
		if (getNonTimeAxis().isInDefaultState()) {
		return nonTimeVaribleAxisMinValue;
		} else {
			return limitManager.getCachedNonTimeMinValue();
		};@Override
	public double getInitialNonTimeMinSetting() {
		return nonTimeVaribleAxisMinValue;;@Override
	public double getInitialNonTimeMinSetting() {
		return super.getMinNonTime();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_42cbc_49b5d/rev_42cbc-49b5d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotterPlot;getInitialNonTimeMaxSetting();@Override
	public double getInitialNonTimeMaxSetting() {
		if (getNonTimeAxis().isInDefaultState()) {
			return nonTimeVaribleAxisMaxValue;
		} else {
			return limitManager.getCachedNonTimeMaxValue();
		};@Override
	public double getInitialNonTimeMaxSetting() {
		return nonTimeVaribleAxisMaxValue;;@Override
	public double getInitialNonTimeMaxSetting() {
		// TODO Auto-generated method stub
		return super.getMaxNonTime();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_43a98_cc831/rev_43a98-cc831;/src/java/org/apache/cassandra/service/CacheService;deserialize(DataInputStream,ColumnFamilyStore);            RowIndexEntry entry = promotedIndexes
                                ? RowIndexEntry.serializer.deserialize(input, reader.descriptor.version)
                                : reader.getPosition(reader.partitioner.decorateKey(key), Operator.EQ);;            RowIndexEntry entry;
            if (input.readBoolean())
                entry = RowIndexEntry.serializer.deserialize(input, reader.descriptor.version);
            else
                entry = reader.getPosition(reader.partitioner.decorateKey(key), Operator.EQ);;            RowIndexEntry entry;
            input.readBoolean(); // backwards compatibility for "promoted indexes" boolean
            entry = RowIndexEntry.serializer.deserialize(input, reader.descriptor.version);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_044eb_bcc87/rev_044eb-bcc87;/src/java/org/apache/cassandra/db/AbstractColumnContainer;maybeResetDeletionTimes(int);        while (true)
        {
            DeletionInfo current = deletionInfo.get();
            // Stop if either we don't need to change the deletion info (it's
            // still MIN_VALUE or not expired yet) or we've succesfully changed it
            if (current.localDeletionTime == Integer.MIN_VALUE
                || current.localDeletionTime >= gcBefore
                || deletionInfo.compareAndSet(current, new DeletionInfo()))
            {
                break;
            }
        };        while (true)
        {
            DeletionInfo current = deletionInfo.get();
            // Stop if either we don't need to change the deletion info (it's
            // still MIN_VALUE or not expired yet) or we've succesfully changed it
            if (current.localDeletionTime == Integer.MIN_VALUE
                || current.localDeletionTime > gcBefore
                || deletionInfo.compareAndSet(current, new DeletionInfo()))
            {
                break;
            }
        };        columns.maybeResetDeletionTimes(gcBefore);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_44e8b_505d5/rev_44e8b-505d5;/projects/OG-Analytics/src/com/opengamma/analytics/financial/model/volatility/smile/fitting/interpolation/SmileInterpolatorSpline;getVolatilityFunction(double,double[],double,double[]);    double gradL = dSigmaDx.evaluate(kL);
    double gradH = dSigmaDx.evaluate(kH);;    final double gradL = dSigmaDx.evaluate(kL);
    final double gradH = dSigmaDx.evaluate(kH);
    //
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f1 = getDifferenceFunc(forward, kL, expiry, volL, gradL);
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f2 = getDifferenceFunc(forward, kH, expiry, volH, gradH);
    //
    //    final double[] res1 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f1, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volL)))).getData();
    //    final double[] res2 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f2, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volH)))).getData();;    final double gradL = dSigmaDx.evaluate(kL);
    final double gradH = dSigmaDx.evaluate(kH);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_45af9_9f0b0/rev_45af9-9f0b0;/src/java/org/apache/cassandra/db/compaction/CompactionController;CompactionController(ColumnFamilyStore,Collection<SSTableReader>,int,boolean);        deserializeRequired = forceDeserialize || !allLatestVersion(sstables);
        Set<SSTableReader> overlappingSSTables = cfs.getOverlappingSSTables(sstables);
        overlappingTree = DataTracker.buildIntervalTree(overlappingSSTables);
        keyExistenceIsExpensive = cfs.getCompactionStrategy().isKeyExistenceExpensive(ImmutableSet.copyOf(sstables));;        this.forceDeserialize = forceDeserialize;
        keyExistenceIsExpensive = cfs.getCompactionStrategy().isKeyExistenceExpensive(this.sstables);;        this.forceDeserialize = forceDeserialize;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45f93_e34ac/rev_45f93-e34ac;/projects/OG-Financial/src/com/opengamma/financial/convention/USConventions;addFixedIncomeInstrumentConventions(ConventionBundleMaster);        thirty360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD FF EFFECTIVE"), usgb, true, publicationLag);

    conventionMaster.addConventionBundle(
        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("FEDL01 Index"), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD FF EFFECTIVE")), "USD FF EFFECTIVE", act360,
        following, Period.ofDays(1), 2, false, null, publicationLag);

    conventionMaster.addConventionBundle(
        ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD_FRA")), "USD_FRA", act360,
        following, Period.ofMonths(3), 2, false, null);;        thirty360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD FF EFFECTIVE"), usgb, true);
    conventionMaster.addConventionBundle(
        ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD_FRA")), "USD_FRA", act360,
        following, Period.ofMonths(3), 2, false, null);;        thirty360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD FF EFFECTIVE"), usgb, true);

    // FRA conventions are stored as IRS
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD_3M_FRA")), "USD_3M_FRA", thirty360, modified, quarterly, 2, usgb,
        act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD LIBOR 3m"), usgb, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD_6M_FRA")), "USD_6M_FRA", thirty360, modified, semiAnnual, 2, usgb,
        act360, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "USD LIBOR 6m"), usgb, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45f93_e34ac/rev_45f93-e34ac;/projects/OG-Financial/src/com/opengamma/financial/convention/EUConventions;addFixedIncomeInstrumentConventions(ConventionBundleMaster);    final DayCount swapFloatDayCount = act360;
    final BusinessDayConvention swapFloatBusinessDay = modified;
    final Frequency swapFloatPaymentFrequency = semiAnnual;
    for (final int i : new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}) {
      final String bbgSwapId = "EUSA" + MONTH_NAMES[i - 1] + " Curncy";
      final String ogSwapName = "EUR SWAP " + i + "m";
      final String bbgOISId = "EUSWE" + MONTH_NAMES[i - 1] + " Curncy";
      final String ogOISName = "EUR OIS " + i + "m";
      final Frequency frequency = PeriodFrequency.of(Period.ofMonths(i));
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          act360, swapFixedBusinessDay, frequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, frequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogSwapName)), ogSwapName,
          swapFixedDayCount, swapFixedBusinessDay, frequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, frequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    }
    for (int i = 1; i <= 50; i++) {
      final String bbg6MSwapId = "EUSA" + i + " Curncy";
      final String og6MSwapName = "EUR SWAP " + i + "y";
      final String bbg3MSwapId = "EUSW" + i + "V3 Curncy";
      final String og3MSwapName = "EUR SWAP 3m " + i + "y";
      final String bbgOISId = "EUSWE" + i + " Curncy";
      final String ogOISName = "EUR OIS " + i + "y";
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          act360, swapFixedBusinessDay, annual, 2, eu, swapFloatDayCount, swapFloatBusinessDay, annual,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbg6MSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, og6MSwapName)), og6MSwapName,
          swapFixedDayCount, swapFixedBusinessDay, swapFixedPaymentFrequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, swapFloatPaymentFrequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbg3MSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, og3MSwapName)), og3MSwapName,
          swapFixedDayCount, swapFixedBusinessDay, swapFixedPaymentFrequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, quarterly,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 3m"), eu, true);
    }
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_SWAP")), "EUR_SWAP", thirty360, modified, annual, 2, eu, act360,
        modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_3M_SWAP")), "EUR_3M_SWAP", thirty360, modified, annual, 2, eu,
        act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 3m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_6M_SWAP")), "EUR_6M_SWAP", thirty360, modified, annual, 2, eu,
        act360, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);

    // Overnight Index Swap Convention have additional flag, publicationLag
    final Integer publicationLag = 0;;    final DayCount swapFloatDayCount = act360;
    final BusinessDayConvention swapFloatBusinessDay = modified;
    final Frequency swapFloatPaymentFrequency = semiAnnual;
    for (final int i : new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}) {
      final String bbgSwapId = "EUSA" + MONTH_NAMES[i - 1] + " Curncy";
      final String ogSwapName = "EUR SWAP " + i + "m";
      final String bbgOISId = "EUSWE" + MONTH_NAMES[i - 1] + " Curncy";
      final String ogOISName = "EUR OIS " + i + "m";
      final Frequency frequency = PeriodFrequency.of(Period.ofMonths(i));
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          act360, swapFixedBusinessDay, frequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, frequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogSwapName)), ogSwapName,
          swapFixedDayCount, swapFixedBusinessDay, frequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, frequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    }
    for (int i = 1; i <= 50; i++) {
      final String bbgSwapId = "EUSA" + i + " Curncy";
      final String ogSwapName = "EUR SWAP " + i + "y";
      final String bbgOISId = "EUSWE" + i + " Curncy";
      final String ogOISName = "EUR OIS " + i + "y";
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgOISId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogOISName)), ogOISName,
          act360, swapFixedBusinessDay, annual, 2, eu, swapFloatDayCount, swapFloatBusinessDay, annual,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu, true);
      conventionMaster.addConventionBundle(
          ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId(bbgSwapId), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, ogSwapName)), ogSwapName,
          swapFixedDayCount, swapFixedBusinessDay, swapFixedPaymentFrequency, 2, eu, swapFloatDayCount, swapFloatBusinessDay, swapFloatPaymentFrequency,
          2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    }
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_SWAP")), "EUR_SWAP", thirty360, modified, annual, 2, eu, act360,
        modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_3M_SWAP")), "EUR_3M_SWAP", thirty360, modified, annual, 2, eu,
        act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 3m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_6M_SWAP")), "EUR_6M_SWAP", thirty360, modified, annual, 2, eu,
        act360, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);;    final DayCount euriborDayCount = act360;

    // EURIBOR
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IBOR_INDEX")), "EUR_IBOR_INDEX", euriborDayCount, modified, 2, true);
    // EONIA
    conventionMaster.addConventionBundle(ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("EONIA Index"), ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA")),
        "EUR EONIA", act360, modified, Period.ofDays(1), 0, false, eu);
    // FRA
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_3M_FRA")), "EUR_3M_FRA", thirty360, modified, quarterly, 2, eu,
        act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EURIBOR 3m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_6M_FRA")), "EUR_6M_FRA", thirty360, modified, annual, 2, eu, act360,
        modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EURIBOR 6m"), eu, true);
    // IRS
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_SWAP")), "EUR_SWAP", swapFixedDayCount, swapFixedBusinessDay,
        swapFixedPaymentFrequency, 2, eu, euriborDayCount, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_3M_SWAP")), "EUR_3M_SWAP", swapFixedDayCount, swapFixedBusinessDay,
        swapFixedPaymentFrequency, 2, eu, act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 3m"), eu, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_6M_SWAP")), "EUR_6M_SWAP", swapFixedDayCount, swapFixedBusinessDay,
        swapFixedPaymentFrequency, 2, eu, act360, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), eu, true);
    // IR FUTURES
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IR_FUTURE")), "EUR_IR_FUTURE", euriborDayCount, modified,
        Period.ofMonths(3), 2, true, null);
    // OIS - EONIA
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45f93_e34ac/rev_45f93-e34ac;/projects/OG-Financial/src/com/opengamma/financial/convention/EUConventions;addFixedIncomeInstrumentConventions(ConventionBundleMaster);        act360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu, true, publicationLag);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IR_FUTURE")), "EUR_IR_FUTURE", act360, modified, Period.ofMonths(3),
        2, true, null);
    //TODO Check this, it's just copied from the US one.
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IBOR_INDEX")), "EUR_IBOR_INDEX", act360, following, 2, false);;        act360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IR_FUTURE")), "EUR_IR_FUTURE", act360, modified, Period.ofMonths(3),
        2, true, null);
    //TODO Check this, it's just copied from the US one.
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR_IBOR_INDEX")), "EUR_IBOR_INDEX", act360, following, 2, false);;        act360, modified, annual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "EUR EONIA"), eu);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45f93_e34ac/rev_45f93-e34ac;/projects/OG-Financial/src/com/opengamma/financial/convention/DKConventions;addFixedIncomeInstrumentConventions(ConventionBundleMaster);    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK_6M_SWAP")), "DKK_6M_SWAP", thirty360, modified, annual, 1, dk,
        act360, modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK CIBOR 6m"), dk, true);

    // Overnight Index Swap Convention have additional flag, publicationLag
    final Integer publicationLag = 0;;    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK_6M_SWAP")), "DKK_6M_SWAP", thirty360, modified, annual, 1, dk,
        act360, modified, semiAnnual, 1, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK CIBOR 6m"), dk, true);;    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK_3M_SWAP")), "DKK_3M_SWAP", thirty360, modified, annual, 2, dk,
        act360, modified, quarterly, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK CIBOR 3m"), dk, true);
    conventionMaster.addConventionBundle(ExternalIdBundle.of(ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK_6M_SWAP")), "DKK_6M_SWAP", thirty360, modified, annual, 2, dk,
        act360, modified, semiAnnual, 2, ExternalId.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, "DKK CIBOR 6m"), dk, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45f93_e34ac/rev_45f93-e34ac;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getSwap(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<ExternalId,Double>,Tenor);    // REVIEW: jim 25-Aug-2010 -- we need to change the swap to take settlement days.
    final SwapSecurity swap = new SwapSecurity(tradeDate, effectiveDate, maturityDate, counterparty, new FloatingInterestRateLeg(convention.getSwapFloatingLegDayCount(),
        convention.getSwapFloatingLegFrequency(), convention.getSwapFloatingLegRegion(), convention.getSwapFloatingLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false,
        floatRateTicker, FloatingRateType.IBOR), new FixedInterestRateLeg(convention.getSwapFixedLegDayCount(), convention.getSwapFixedLegFrequency(), convention.getSwapFixedLegRegion(),
            convention.getSwapFixedLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false, fixedRate));;    // REVIEW: jim 25-Aug-2010 -- we need to change the swap to take settlement days.
    final SwapSecurity swap = new SwapSecurity(tradeDate, effectiveDate, maturityDate, counterparty, new FloatingInterestRateLeg(convention.getSwapFloatingLegDayCount(),
        convention.getSwapFloatingLegFrequency(), convention.getSwapFloatingLegRegion(), convention.getSwapFloatingLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false,
        floatRateBloombergTicker, FloatingRateType.IBOR), new FixedInterestRateLeg(convention.getSwapFixedLegDayCount(), convention.getSwapFixedLegFrequency(), convention.getSwapFixedLegRegion(),
            convention.getSwapFixedLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false, fixedRate));;    final FloatingInterestRateLeg oisLeg = new FloatingInterestRateLeg(swapConvention.getSwapFloatingLegDayCount(), swapConvention.getSwapFloatingLegFrequency(),
        swapConvention.getSwapFloatingLegRegion(), swapConvention.getSwapFloatingLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false, floatingRateId,
        FloatingRateType.IBOR);
    final FixedInterestRateLeg fixedLeg = new FixedInterestRateLeg(swapConvention.getSwapFixedLegDayCount(), swapConvention.getSwapFixedLegFrequency(), swapConvention.getSwapFixedLegRegion(),
        swapConvention.getSwapFixedLegBusinessDayConvention(), new InterestRateNotional(spec.getCurrency(), 1), false, fixedRate);
    final SwapSecurity swap = new SwapSecurity(curveDate, spotDate, maturityDate, counterparty, oisLeg, fixedLeg);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_46ea0_80472/rev_46ea0-80472;/src/java/org/apache/cassandra/gms/Gossiper;removeEndpoint(InetAddress);        liveEndpoints_.remove(endpoint);
        unreachableEndpoints_.remove(endpoint);
        // do not remove endpointState until the quarantine expires;        liveEndpoints_.remove(endpoint);
        unreachableEndpoints_.remove(endpoint);
        endpointStateMap_.remove(endpoint);;        liveEndpoints.remove(endpoint);
        unreachableEndpoints.remove(endpoint);
        endpointStateMap.remove(endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_46ea0_80472/rev_46ea0-80472;/src/java/org/apache/cassandra/gms/Gossiper;doStatusCheck();                        logger_.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout_ + "ms, removing from gossip");
                        if (!justRemovedEndpoints_.containsKey(endpoint)) // if the node was decommissioned, it will have been removed but still appear as a fat client
                            removeEndpoint(endpoint); // after quarantine justRemoveEndpoints will remove the state;                        logger_.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout_ + "ms, removing from gossip");
                        removeEndpoint(endpoint);;                        logger.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout + "ms, removing from gossip");
                        removeEndpoint(endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_46ea0_80472/rev_46ea0-80472;/src/java/org/apache/cassandra/gms/Gossiper;doStatusCheck();                    if (logger_.isDebugEnabled())
                        logger_.debug(QUARANTINE_DELAY + " elapsed, " + entry.getKey() + " gossip quarantine over");
                    justRemovedEndpoints_.remove(entry.getKey());
                    endpointStateMap_.remove(entry.getKey());;                    if (logger_.isDebugEnabled())
                        logger_.debug(QUARANTINE_DELAY + " elapsed, " + entry.getKey() + " gossip quarantine over");
                    justRemovedEndpoints_.remove(entry.getKey());;                    if (logger.isDebugEnabled())
                        logger.debug(QUARANTINE_DELAY + " elapsed, " + entry.getKey() + " gossip quarantine over");
                    justRemovedEndpoints.remove(entry.getKey());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_46fc8_5e425/rev_46fc8-5e425;/src/java/org/apache/cassandra/cql3/statements/ModificationStatement;validate(ClientState);        if (timeToLive > ExpiringColumn.MAX_TTL)
            throw new InvalidRequestException(String.format("ttl is too large. requested (%d) maximum (%d)", timeToLive, ExpiringColumn.MAX_TTL));

        ThriftValidation.validateConsistencyLevel(keyspace(), getConsistencyLevel(), RequestType.WRITE);;        ThriftValidation.validateConsistencyLevel(keyspace(), getConsistencyLevel(), RequestType.WRITE);;        getConsistencyLevel().validateForWrite(keyspace());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_47cb9_20465/rev_47cb9-20465;/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest;testTSTPersistence();    runTest(TSTLookup.class, true);;    TSTLookup lookup = new TSTLookup();
    for (String k : keys) {
      lookup.add(k, new Float(k.length()));
    }
    File storeDir = new File(TEST_HOME);
    lookup.store(storeDir);
    lookup = new TSTLookup();
    lookup.load(storeDir);
    for (String k : keys) {
      Float val = (Float)lookup.get(k);
      assertNotNull(k, val);
      assertEquals(k, k.length(), val.intValue());
    };    TSTLookup lookup = new TSTLookup();
    for (String k : keys) {
      lookup.add(k, new Float(k.length()));
    }
    File storeDir = new File(TEST_HOME());
    lookup.store(storeDir);
    lookup = new TSTLookup();
    lookup.load(storeDir);
    for (String k : keys) {
      Float val = (Float)lookup.get(k);
      assertNotNull(k, val);
      assertEquals(k, k.length(), val.intValue());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_47cb9_20465/rev_47cb9-20465;/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest;testJaspellPersistence();    runTest(JaspellLookup.class, true);;    JaspellLookup lookup = new JaspellLookup();
    for (String k : keys) {
      lookup.add(k, new Float(k.length()));
    }
    File storeDir = new File(TEST_HOME);
    lookup.store(storeDir);
    lookup = new JaspellLookup();
    lookup.load(storeDir);
    for (String k : keys) {
      Float val = (Float)lookup.get(k);
      assertNotNull(k, val);
      assertEquals(k, k.length(), val.intValue());
    };    JaspellLookup lookup = new JaspellLookup();
    for (String k : keys) {
      lookup.add(k, new Float(k.length()));
    }
    File storeDir = new File(TEST_HOME());
    lookup.store(storeDir);
    lookup = new JaspellLookup();
    lookup.load(storeDir);
    for (String k : keys) {
      Float val = (Float)lookup.get(k);
      assertNotNull(k, val);
      assertEquals(k, k.length(), val.intValue());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_47e2b_301c3/rev_47e2b-301c3;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/resolution/DefaultArtifactResolutionQuery;execute();                            ArtifactResolveContext context = new ArtifactTypeResolveContext(artifactType);
                            BuildableArtifactSetResolveResult multiResolveResult = new DefaultBuildableArtifactSetResolveResult();
                            artifactResolver.resolveModuleArtifacts(moduleMetaData, context, multiResolveResult);
                            for (ModuleVersionArtifactMetaData artifactMetaData : multiResolveResult.getArtifacts()) {
                                BuildableArtifactResolveResult resolveResult = new DefaultBuildableArtifactResolveResult();
                                artifactResolver.resolveArtifact(moduleMetaData, artifactMetaData, resolveResult);
                                if (resolveResult.getFailure() != null) {
                                    // TODO: handle failure
                                    int x = 0; // make checkstyle happy
                                } else if (artifactType == JvmLibraryJavadocArtifact.class) {
                                    jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFile()));;                            DefaultBuildableMultipleArtifactResolveResult multiResolveResult = new DefaultBuildableMultipleArtifactResolveResult();
                            moduleResolveResult.getArtifactResolver().resolve(moduleResolveResult.getMetaData(), artifactType, multiResolveResult);
                            for (ArtifactResolveResult resolveResult : multiResolveResult.getResults().values()) {
                                if (resolveResult.getFailure() != null) {
                                    // TODO: handle failure
                                    int x = 0; // make checkstyle happy
                                } else if (artifactType == JvmLibraryJavadocArtifact.class) {
                                    jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFile()));;                            DefaultBuildableMultipleArtifactResolveResult multiResolveResult = new DefaultBuildableMultipleArtifactResolveResult();
                            moduleResolveResult.getArtifactResolver().resolve(moduleResolveResult.getMetaData(), artifactType, multiResolveResult);
                            for (ArtifactResolveResult resolveResult : multiResolveResult.getResults().values()) {
                                if (artifactType == JvmLibraryJavadocArtifact.class) {
                                    if (resolveResult.getFailure() != null) {
                                        jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFailure()));
                                    } else {
                                        jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFile()));
                                    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_50b49_0a418/rev_50b49-0a418;/src/java/org/apache/cassandra/service/AbstractRowResolver;preprocess(Message);            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn));;            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn));
            if (logger.isDebugEnabled())
                logger.debug("Preprocessed {} response", result.isDigestQuery() ? "digest" : "data");;            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn), message.getVersion());
            if (logger.isDebugEnabled())
                logger.debug("Preprocessed {} response", result.isDigestQuery() ? "digest" : "data");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_50b49_0a418/rev_50b49-0a418;/src/java/org/apache/cassandra/gms/Gossiper;start(int);        maybeInitializeLocalState(generationNbr);
        EndpointState localState = endpointStateMap_.get(localEndpoint_);;        EndpointState localState = endpointStateMap_.get(localEndpoint_);
        if ( localState == null )
        {
            HeartBeatState hbState = new HeartBeatState(generationNbr);
            localState = new EndpointState(hbState);
            localState.isAlive(true);
            localState.isAGossiper(true);
            endpointStateMap_.put(localEndpoint_, localState);
        };        maybeInitializeLocalState(generationNbr);
        EndpointState localState = endpointStateMap.get(FBUtilities.getLocalAddress());
        
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_51a4b_4fb85/rev_51a4b-4fb85;/src/main/java/redis/clients/jedis/Jedis;blpop(String);public List<String> blpop(String... args) {
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> blpop(String... args) {
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> blpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.blpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_51a4b_4fb85/rev_51a4b-4fb85;/src/main/java/redis/clients/jedis/Jedis;brpop(String);public List<String> brpop(String... args) {
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;;public List<String> brpop(String... args) {
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;;public List<String> brpop(String arg) {
        String[] args = new String[1];
        args[0] = arg;
        client.brpop(args);
        client.setTimeoutInfinite();
        final List<String> multiBulkReply = client.getMultiBulkReply();
        client.rollbackTimeout();
        return multiBulkReply;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_51a4b_4fb85/rev_51a4b-4fb85;/src/main/java/redis/clients/jedis/Jedis;getEvalResult();	Object result = client.getOne();

	if (result instanceof byte[])
	    return SafeEncoder.encode((byte[]) result);

	if (result instanceof List<?>) {
	    List<?> list = (List<?>) result;
	    List<String> listResult = new ArrayList<String>(list.size());
	    for (Object bin : list) {
		listResult.add((bin == null ? null : SafeEncoder
			.encode((byte[]) bin)));
	    }

	    return listResult;
	}

	return result;;	Object result = client.getOne();
	
	if (result instanceof byte[])
	    return SafeEncoder.encode((byte[]) result);

	if (result instanceof List<?>) {
	    List<?> list = (List<?>) result;
	    List<String> listResult = new ArrayList<String>(list.size());
	    for (Object bin : list) {
		listResult.add((bin == null ? null : SafeEncoder
			.encode((byte[]) bin)));
	    }

	    return listResult;
	}

	return result;;	return evalResult(client.getOne());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2;/src/java/org/apache/cassandra/db/marshal/TimeUUIDType;fromString(String);        UUID uuid = UUID.fromString(source);

        if (uuid.version() != 1)
            throw new IllegalArgumentException("TimeUUID supports only version 1 UUIDs");

        return decompose(uuid);;        UUID uuid = UUID.fromString(source);

        if (uuid.version() != 1)
            throw new IllegalArgumentException("TimeUUID supports only version 1 UUIDs");

        return ByteBuffer.wrap(UUIDGen.decompose(uuid));;        // Return an empty ByteBuffer for an empty string.
        if (source.isEmpty())
            return ByteBufferUtil.EMPTY_BYTE_BUFFER;
        
        ByteBuffer idBytes = null;
        
        // ffffffff-ffff-ffff-ffff-ffffffffff
        if (regexPattern.matcher(source).matches())
        {
            UUID uuid = null;
            try
            {
                uuid = UUID.fromString(source);
                idBytes = ByteBuffer.wrap(UUIDGen.decompose(uuid));
            }
            catch (IllegalArgumentException e)
            {
                throw new MarshalException(String.format("unable to make UUID from '%s'", source), e);
            }
            
            if (uuid.version() != 1)
                throw new MarshalException("TimeUUID supports only version 1 UUIDs");
        }
        else if (source.toLowerCase().equals("now"))
        {
            idBytes = ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress())));
        }
        // Milliseconds since epoch?
        else if (source.matches("^\\d+$"))
        {
            try
            {
                idBytes = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(Long.parseLong(source)));
            }
            catch (NumberFormatException e)
            {
                throw new MarshalException(String.format("unable to make version 1 UUID from '%s'", source), e);
            }
        }
        // Last chance, attempt to parse as date-time string
        else
        {
            try
            {
                long timestamp = DateUtils.parseDate(source, iso8601Patterns).getTime();
                idBytes = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(timestamp));
            }
            catch (ParseException e1)
            {
                throw new MarshalException(String.format("unable to coerce '%s' to version 1 UUID", source), e1);
            }
        }
            
        return idBytes;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2;/src/java/org/apache/cassandra/service/StorageProxy;getRangeSlice(RangeSliceCommand,ConsistencyLevel);                    try;                    // if we're done, great, otherwise, move to the next range
                    try ;                    // if we're done, great, otherwise, move to the next range
                    try
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2;/src/java/org/apache/cassandra/service/StorageProxy;getRangeSlice(RangeSliceCommand,ConsistencyLevel);                    }
                    catch (DigestMismatchException e) ;                        rows.addAll(handler.get());
                    } 
                    catch (DigestMismatchException e) ;                        rows.addAll(handler.get());
                    }
                    catch (DigestMismatchException e)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_51a07_22fc2/rev_51a07-22fc2;/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;putNext(Tuple);                       org.apache.cassandra.avro.Column column = new org.apache.cassandra.avro.Column();
                       column.name = marshallers.get(0).decompose((pair.get(0)));
                       if (validators.get(column.name) == null)
                           // Have to special case BytesType to convert DataByteArray into ByteBuffer
                           if (marshallers.get(1) instanceof BytesType)
                               column.value = ByteBuffer.wrap(((DataByteArray) pair.get(1)).get());
                           else
                               column.value = marshallers.get(1).decompose(pair.get(1));
                       else
                           column.value = validators.get(column.name).decompose(pair.get(1));;                       org.apache.cassandra.avro.Column column = new org.apache.cassandra.avro.Column();
                       column.name = objToBB(pair.get(0));
                       column.value = objToBB(pair.get(1));;                       org.apache.cassandra.hadoop.avro.Column column = new org.apache.cassandra.hadoop.avro.Column();
                       column.name = marshallers.get(0).decompose((pair.get(0)));
                       if (validators.get(column.name) == null)
                           // Have to special case BytesType to convert DataByteArray into ByteBuffer
                           if (marshallers.get(1) instanceof BytesType)
                               column.value = ByteBuffer.wrap(((DataByteArray) pair.get(1)).get());
                           else
                               column.value = marshallers.get(1).decompose(pair.get(1));
                       else
                           column.value = validators.get(column.name).decompose(pair.get(1));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_53af5_cd30d/rev_53af5-cd30d;/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponse;writeRecords(Iterator<OIdentifiable>,String,String,String);public void writeRecords(final Iterator<OIdentifiable> iRecords,
			final String iFetchPlan, String iFormat, final String accept)
			throws IOException {
		if (iRecords == null)
			return;

    if (accept != null && accept.contains("text/csv")) {
			sendStream(OHttpUtils.STATUS_OK_CODE, "OK",
                    OHttpUtils.CONTENT_JSON, "data.csv",
                    new OCallable<Void, OChunkedResponse>() {

                        @Override
                        public Void call(final OChunkedResponse iArgument) {
                            final LinkedHashSet<String> colNames = new LinkedHashSet<String>();
                            final List<ODocument> records = new ArrayList<ODocument>();

                            // BROWSE ALL THE RECORD TO HAVE THE COMPLETE COLUMN
                            // NAMES LIST
                            while (iRecords.hasNext()) {
                                final OIdentifiable r = iRecords.next();
                                if (r != null) {
                                    final ORecord<?> rec = r.getRecord();
                                    if (rec != null) {
                                        if (rec instanceof ODocument) {
                                            final ODocument doc = (ODocument) rec;
                                            records.add(doc);

                                            for (String fieldName : doc
                                                    .fieldNames())
                                                colNames.add(fieldName);
                                        }
                                    }
                                }
                            }

                            final List<String> orderedColumns = new ArrayList<String>(
                                    colNames);

                            try {
                                // WRITE THE HEADER
                                for (int col = 0; col < orderedColumns.size(); ++col) {
                                    if (col > 0)
                                        iArgument.write(',');
                                    iArgument.write(orderedColumns.get(col)
                                            .getBytes());
                                }
                                iArgument.write(OHttpUtils.EOL);

                                // WRITE EACH RECORD
                                for (ODocument doc : records) {
                                    for (int col = 0; col < orderedColumns
                                            .size(); ++col) {
                                        if (col > 0)
                                            iArgument.write(',');

                                        Object value = doc.field(orderedColumns
                                                .get(col));
                                        if (value != null) {
                                            if (!(value instanceof Number))
                                                value = "\"" + value + "\"";
                                            iArgument.write(value.toString()
                                                    .getBytes());
                                        }
                                    }
                                    iArgument.write(OHttpUtils.EOL);
                                }

                                iArgument.flush();

                            } catch (IOException e) {
                                e.printStackTrace();
                            }

                            return null;
                        }
                    });
		} else if (accept == null || (accept.contains(OHttpUtils.CONTENT_JSON))) {
			if (iFormat == null)
				iFormat = JSON_FORMAT;
			else
				iFormat = JSON_FORMAT + "," + iFormat;

			final StringWriter buffer = new StringWriter();
			final OJSONWriter json = new OJSONWriter(buffer, iFormat);
			json.beginObject();

			final String format = iFetchPlan != null ? iFormat + ",fetchPlan:"
					+ iFetchPlan : iFormat;

			// WRITE RECORDS
			json.beginCollection(-1, true, "result");
			formatMultiValue(iRecords, buffer, format);
			json.endCollection(-1, true);

			json.endObject();
			send(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON,
					buffer.toString(), null);
		}
	};public void writeRecords(final Iterator<OIdentifiable> iRecords,
			final String iFetchPlan, String iFormat, final String accept)
			throws IOException {
		if (iRecords == null)
			return;

		if (accept.contains("text/csv")) {
			sendStream(OHttpUtils.STATUS_OK_CODE, "OK",
					OHttpUtils.CONTENT_JSON, "data.csv",
					new OCallable<Void, OChunkedResponse>() {

						@Override
						public Void call(final OChunkedResponse iArgument) {
							final LinkedHashSet<String> colNames = new LinkedHashSet<String>();
							final List<ODocument> records = new ArrayList<ODocument>();

							// BROWSE ALL THE RECORD TO HAVE THE COMPLETE COLUMN
							// NAMES LIST
							while (iRecords.hasNext()) {
								final OIdentifiable r = iRecords.next();
								if (r != null) {
									final ORecord<?> rec = r.getRecord();
									if (rec != null) {
										if (rec instanceof ODocument) {
											final ODocument doc = (ODocument) rec;
											records.add(doc);

											for (String fieldName : doc
													.fieldNames())
												colNames.add(fieldName);
										}
									}
								}
							}

							final List<String> orderedColumns = new ArrayList<String>(
									colNames);

							try {
								// WRITE THE HEADER
								for (int col = 0; col < orderedColumns.size(); ++col) {
									if (col > 0)
										iArgument.write(',');
									iArgument.write(orderedColumns.get(col)
											.getBytes());
								}
								iArgument.write(OHttpUtils.EOL);

								// WRITE EACH RECORD
								for (ODocument doc : records) {
									for (int col = 0; col < orderedColumns
											.size(); ++col) {
										if (col > 0)
											iArgument.write(',');

										Object value = doc.field(orderedColumns
												.get(col));
										if (value != null) {
											if (!(value instanceof Number))
												value = "\"" + value + "\"";
											iArgument.write(value.toString()
													.getBytes());
										}
									}
									iArgument.write(OHttpUtils.EOL);
								}

								iArgument.flush();

							} catch (IOException e) {
								e.printStackTrace();
							}

							return null;
						}
					});
		} else if (accept == null || (accept.contains(OHttpUtils.CONTENT_JSON))) {
			if (iFormat == null)
				iFormat = JSON_FORMAT;
			else
				iFormat = JSON_FORMAT + "," + iFormat;

			final StringWriter buffer = new StringWriter();
			final OJSONWriter json = new OJSONWriter(buffer, iFormat);
			json.beginObject();

			final String format = iFetchPlan != null ? iFormat + ",fetchPlan:"
					+ iFetchPlan : iFormat;

			// WRITE RECORDS
			json.beginCollection(-1, true, "result");
			formatMultiValue(iRecords, buffer, format);
			json.endCollection(-1, true);

			json.endObject();
			send(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON,
					buffer.toString(), null);
		}
	};public void writeRecords(final Iterator<OIdentifiable> iRecords, final String iFetchPlan, String iFormat, final String accept)
      throws IOException {
    if (iRecords == null)
      return;

    if (accept != null && accept.contains("text/csv")) {
      sendStream(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON, "data.csv", new OCallable<Void, OChunkedResponse>() {

        @Override
        public Void call(final OChunkedResponse iArgument) {
          final LinkedHashSet<String> colNames = new LinkedHashSet<String>();
          final List<ODocument> records = new ArrayList<ODocument>();

          // BROWSE ALL THE RECORD TO HAVE THE COMPLETE COLUMN
          // NAMES LIST
          while (iRecords.hasNext()) {
            final OIdentifiable r = iRecords.next();
            if (r != null) {
              final ORecord<?> rec = r.getRecord();
              if (rec != null) {
                if (rec instanceof ODocument) {
                  final ODocument doc = (ODocument) rec;
                  records.add(doc);

                  for (String fieldName : doc.fieldNames())
                    colNames.add(fieldName);
                }
              }
            }
          }

          final List<String> orderedColumns = new ArrayList<String>(colNames);

          try {
            // WRITE THE HEADER
            for (int col = 0; col < orderedColumns.size(); ++col) {
              if (col > 0)
                iArgument.write(',');
              iArgument.write(orderedColumns.get(col).getBytes());
            }
            iArgument.write(OHttpUtils.EOL);

            // WRITE EACH RECORD
            for (ODocument doc : records) {
              for (int col = 0; col < orderedColumns.size(); ++col) {
                if (col > 0)
                  iArgument.write(',');

                Object value = doc.field(orderedColumns.get(col));
                if (value != null) {
                  if (!(value instanceof Number))
                    value = "\"" + value + "\"";
                  iArgument.write(value.toString().getBytes());
                }
              }
              iArgument.write(OHttpUtils.EOL);
            }

            iArgument.flush();

          } catch (IOException e) {
            e.printStackTrace();
          }

          return null;
        }
      });
    } else {
      /// JSON
      if (iFormat == null)
        iFormat = JSON_FORMAT;
      else
        iFormat = JSON_FORMAT + "," + iFormat;

      final StringWriter buffer = new StringWriter();
      final OJSONWriter json = new OJSONWriter(buffer, iFormat);
      json.beginObject();

      final String format = iFetchPlan != null ? iFormat + ",fetchPlan:" + iFetchPlan : iFormat;

      // WRITE RECORDS
      json.beginCollection(-1, true, "result");
      formatMultiValue(iRecords, buffer, format);
      json.endCollection(-1, true);

      json.endObject();
      send(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON, buffer.toString(), null);
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_54e18_e46b3/rev_54e18-e46b3;/projects/OG-LiveData/tests/unit/com/opengamma/livedata/server/distribution/MarketDataDistributorTest;getTestDistributor(MarketDataSenderFactory);public static MarketDataDistributor getTestDistributor(MarketDataSenderFactory factory) {
    MapLastKnownValueStoreProvider lkvStoreProvider = new MapLastKnownValueStoreProvider();;public static MarketDataDistributor getTestDistributor(MarketDataSenderFactory factory) {;static MarketDataDistributor getTestDistributor(MarketDataSenderFactory factory) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_56e0a_deac4/rev_56e0a-deac4;/src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat;getRecordWriter(org.apache.hadoop.fs.FileSystem,org.apache.hadoop.mapred.JobConf,String,org.apache.hadoop.util.Progressable);@Deprecated
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress);@Deprecated
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException;@Deprecated @Override
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_56e0a_deac4/rev_56e0a-deac4;/src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat;getRecordWriter(TaskAttemptContext);public ColumnFamilyRecordWriter getRecordWriter(final TaskAttemptContext context) throws InterruptedException;@Override
    public ColumnFamilyRecordWriter getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException;@Override
    public ColumnFamilyRecordWriter getRecordWriter(final TaskAttemptContext context) throws InterruptedException
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_56f35_26bcb/rev_56f35-26bcb;/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthorizationException;read(org.apache.thrift.protocol.TProtocol);    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else {
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();;    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();;    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_58a27_20fb5/rev_58a27-20fb5;/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester;lookup(CharSequence,boolean,int);            spare.grow(output.output2.length);
            UnicodeUtil.UTF8toUTF16(output.output2, spare);
            if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {
              // We found exact match, which means we should
              // have already found it in the first search:
              assert results.size() == 1;
              return false;
            } else {
              return true;
            };            spare.grow(output.output2.length);
            UnicodeUtil.UTF8toUTF16(output.output2, spare);
            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;;            return !utf8Key.bytesEquals(output.output2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition,T);    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future, T data) {
      return "InterestRateFutureSecurity2";;    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future, T data) {
      return "InterestRateFutureSecurity1";;    public String visitInterestRateFutureSecurityDefinition(final InterestRateFutureSecurityDefinition future, final T data) {
      return "InterestRateFutureSecurity1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition);    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity1";;    public String visitInterestRateFutureSecurityDefinition(InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity2";;    public String visitInterestRateFutureSecurityDefinition(final InterestRateFutureSecurityDefinition future) {
      return "InterestRateFutureSecurity2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition,T);    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future, T data) {
      return "InterestRateFutureTransaction2";;    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future, T data) {
      return "InterestRateFutureTransaction1";;    public String visitInterestRateFutureTransactionDefinition(final InterestRateFutureTransactionDefinition future, final T data) {
      return "InterestRateFutureTransaction1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition);    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction1";;    public String visitInterestRateFutureTransactionDefinition(InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction2";;    public String visitInterestRateFutureTransactionDefinition(final InterestRateFutureTransactionDefinition future) {
      return "InterestRateFutureTransaction2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureSecurityDefinition(BondFutureSecurityDefinition,T);    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond, T data) {
      return "BondFutureSecurity2";;    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond, T data) {
      return "BondFutureSecurity1";;    public String visitBondFutureSecurityDefinition(final BondFutureSecurityDefinition bond, final T data) {
      return "BondFutureSecurity1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureSecurityDefinition(BondFutureSecurityDefinition);    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity1";;    public String visitBondFutureSecurityDefinition(BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity2";;    public String visitBondFutureSecurityDefinition(final BondFutureSecurityDefinition bond) {
      return "BondFutureSecurity2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureTransactionDefinition(BondFutureTransactionDefinition,T);    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond, T data) {
      return "BondFutureTransaction2";;    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond, T data) {
      return "BondFutureTransaction1";;    public String visitBondFutureTransactionDefinition(final BondFutureTransactionDefinition bond, final T data) {
      return "BondFutureTransaction1";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_61a88_d8125/rev_61a88-d8125;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/FixedIncomeInstrumentDefinitionVisitorTest;visitBondFutureTransactionDefinition(BondFutureTransactionDefinition);    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction1";;    public String visitBondFutureTransactionDefinition(BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction2";;    public String visitBondFutureTransactionDefinition(final BondFutureTransactionDefinition bond) {
      return "BondFutureTransaction2";
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_61ada_3b25d/rev_61ada-3b25d;/src/java/org/apache/cassandra/db/commitlog/CommitLog;recover(File[]);                                Table.open(newRm.getTable()).apply(newRm, null, false);
                                tablesRecovered.add(table);;                                Table.open(newRm.getTable()).apply(newRm, null, false);;                                Table.open(newRm.getTable()).apply(newRm, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_64c0d_a7b80/rev_64c0d-a7b80;/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement;announceMigration();                cd.setIndexType(IndexType.CUSTOM, props.getOptions());
            }
            catch (SyntaxException e)
            {
                throw new AssertionError(); // can't happen after validation.;                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");
                if (logger.isDebugEnabled())
                    logger.debug("Updating column {} definition for index {}", columnName, indexName);

                if (cd.getValidator().isCollection())
                    throw new InvalidRequestException("Indexes on collections are no yet supported");

                if (cfDef.isComposite)
                {
                    CompositeType composite = (CompositeType)cfm.comparator;
                    Map<String, String> opts = new HashMap<String, String>();
                    opts.put(CompositesIndex.PREFIX_SIZE_OPTION, String.valueOf(composite.types.size() - (cfDef.hasCollections ? 2 : 1)));
                    cd.setIndexType(IndexType.COMPOSITES, opts);
                }
                else
                {
                    cd.setIndexType(IndexType.KEYS, Collections.<String, String>emptyMap());
                }
                cd.setIndexName(indexName);
                columnExists = true;
                break;;                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");

                if (cd.type == ColumnDefinition.Type.PARTITION_KEY && (cd.componentIndex == null || cd.componentIndex == 0))
                    throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", columnName));

                // TODO: we could lift that limitation
                if (cfDef.isCompact && cd.type != ColumnDefinition.Type.REGULAR)
                    throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));

                if (cd.getValidator().isCollection())
                    throw new InvalidRequestException("Indexes on collections are no yet supported");

                if (logger.isDebugEnabled())
                    logger.debug("Updating column {} definition for index {}", columnName, indexName);

                if (cfDef.isComposite)
                {
                    cd.setIndexType(IndexType.COMPOSITES, Collections.<String, String>emptyMap());
                }
                else
                {
                    cd.setIndexType(IndexType.KEYS, Collections.<String, String>emptyMap());
                }
                cd.setIndexName(indexName);
                columnExists = true;
                break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_65a58_79dd4/rev_65a58-79dd4;/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLUpdate;result(Object);          coll.add(v);
          updatedRecords.add(record);;    // BIND VALUES TO ADD
    Collection<Object> coll;
    Object fieldValue;
    for (OPair<String, Object> entry : addEntries) {
      coll = null;
      if (!record.containsField(entry.getKey())) {
        // GET THE TYPE IF ANY
        if (record.getSchemaClass() != null) {
          OProperty prop = record.getSchemaClass().getProperty(entry.getKey());
          if (prop != null && prop.getType() == OType.LINKSET)
            // SET TYPE
            coll = new HashSet<Object>();;    // BIND VALUES TO ADD
    Collection<Object> coll = null;
    ORidBag bag = null;
    Object fieldValue;
    for (OPair<String, Object> entry : addEntries) {
      coll = null;
      if (!record.containsField(entry.getKey())) {
        // GET THE TYPE IF ANY
        if (record.getSchemaClass() != null) {
          OProperty prop = record.getSchemaClass().getProperty(entry.getKey());
          if (prop != null && prop.getType() == OType.LINKSET)
            // SET TYPE
            coll = new HashSet<Object>();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_65a58_79dd4/rev_65a58-79dd4;/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLUpdate;result(Object);      Map<String, Object> map;
      OPair<String, Object> pair;;        if (coll == null)
          // IN ALL OTHER CASES USE A LIST
          coll = new ArrayList<Object>();

        record.field(entry.getKey(), coll);
      } else {
        fieldValue = record.field(entry.getKey());

        if (fieldValue instanceof Collection<?>)
          coll = (Collection<Object>) fieldValue;
        else
          continue;
      }

      v = entry.getValue();

      if (v instanceof OSQLFilterItem)
        v = ((OSQLFilterItem) v).getValue(record, null, context);
      else if (v instanceof OSQLFunctionRuntime)
        v = ((OSQLFunctionRuntime) v).execute(record, record, null, context);
      else if (v instanceof OCommandRequest)
        v = ((OCommandRequest) v).execute(record, null, context);

      coll.add(v);
      updatedRecords.add(record);
    };        if (coll == null)
          // IN ALL OTHER CASES USE A LIST
          coll = new ArrayList<Object>();

        record.field(entry.getKey(), coll);
      } else {
        fieldValue = record.field(entry.getKey());

        if (fieldValue instanceof Collection<?>)
          coll = (Collection<Object>) fieldValue;
        else if (fieldValue instanceof ORidBag)
          bag = (ORidBag) fieldValue;
        else
          continue;
      }

      v = entry.getValue();

      if (v instanceof OSQLFilterItem)
        v = ((OSQLFilterItem) v).getValue(record, null, context);
      else if (v instanceof OSQLFunctionRuntime)
        v = ((OSQLFunctionRuntime) v).execute(record, record, null, context);
      else if (v instanceof OCommandRequest)
        v = ((OCommandRequest) v).execute(record, null, context);

      if (coll != null)
        coll.add(v);
      else {
        if (!(v instanceof OIdentifiable))
          throw new OCommandExecutionException("Only links or records can be added to LINKBAG");

        bag.add((OIdentifiable) v);
      }

      updatedRecords.add(record);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_65a58_79dd4/rev_65a58-79dd4;/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLUpdate;result(Object);            if (fieldValue instanceof Collection<?>) {
              coll = (Collection<Object>) fieldValue;
              if (coll.remove(v))
                updatedRecords.add(record);
            } else if (fieldValue instanceof Map<?, ?>) {
              map = (Map<String, Object>) fieldValue;
              if (map.remove(v) != null)
                updatedRecords.add(record);
            }
          };        if (fieldValue instanceof Collection<?>) {
          coll = (Collection<Object>) fieldValue;
          if (coll.remove(v))
            updatedRecords.add(record);
        } else if (fieldValue instanceof Map<?, ?>) {
          map = (Map<String, Object>) fieldValue;
          if (map.remove(v) != null)
            updatedRecords.add(record);;        if (fieldValue instanceof Collection<?>) {
          coll = (Collection<Object>) fieldValue;
          if (coll.remove(v))
            updatedRecords.add(record);
        } else if (fieldValue instanceof Map<?, ?>) {
          map = (Map<String, Object>) fieldValue;
          if (map.remove(v) != null)
            updatedRecords.add(record);
        } else if (fieldValue instanceof ORidBag) {
          bag = (ORidBag) fieldValue;

          if (!(v instanceof OIdentifiable))
            throw new OCommandExecutionException("Only links or records can be removed from LINKBAG");

          bag.remove((OIdentifiable) v);
          if (record.isDirty())
            updatedRecords.add(record);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_65daa_4f2fd/rev_65daa-4f2fd;/src/java/org/apache/cassandra/service/MigrationManager;resetLocalSchema();            logger.debug("Truncating schema tables...");;            if (logger.isDebugEnabled())
                logger.debug("Truncating schema tables...");;            if (logger.isDebugEnabled())
                logger.debug("Requesting schema from " + node);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_65daa_4f2fd/rev_65daa-4f2fd;/src/java/org/apache/cassandra/service/MigrationManager;resetLocalSchema();            // truncate schema tables
            FBUtilities.waitOnFutures(new ArrayList<Future<?>>(3)
            {{
                SystemTable.schemaCFS(SystemTable.SCHEMA_KEYSPACES_CF).truncate();
                SystemTable.schemaCFS(SystemTable.SCHEMA_COLUMNFAMILIES_CF).truncate();
                SystemTable.schemaCFS(SystemTable.SCHEMA_COLUMNS_CF).truncate();
            }});

            logger.debug("Clearing local schema keyspace definitions...");

            Schema.instance.clear();

            Set<InetAddress> liveEndpoints = Gossiper.instance.getLiveMembers();
            liveEndpoints.remove(FBUtilities.getBroadcastAddress());;            // truncate schema tables
            FBUtilities.waitOnFutures(new ArrayList<Future<?>>(3)
            {{
                SystemTable.schemaCFS(SystemTable.SCHEMA_KEYSPACES_CF).truncate();
                SystemTable.schemaCFS(SystemTable.SCHEMA_COLUMNFAMILIES_CF).truncate();
                SystemTable.schemaCFS(SystemTable.SCHEMA_COLUMNS_CF).truncate();
            }});

            if (logger.isDebugEnabled())
                logger.debug("Clearing local schema keyspace definitions...");

            Schema.instance.clear();

            Set<InetAddress> liveEndpoints = Gossiper.instance.getLiveMembers();
            liveEndpoints.remove(FBUtilities.getBroadcastAddress());;            FBUtilities.waitOnFuture(StageManager.getStage(Stage.MIGRATION).submit(new MigrationTask(node)));
            break;
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_65dce_1ade3/rev_65dce-1ade3;/src/java/org/apache/cassandra/tools/NodeCmd;main(String[]);            case RING            : complainNonzeroArgs(arguments, command); nodeCmd.printRing(System.out); break;
            case INFO            : complainNonzeroArgs(arguments, command); nodeCmd.printInfo(System.out); break;
            case CFSTATS         : complainNonzeroArgs(arguments, command); nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : complainNonzeroArgs(arguments, command); probe.decommission(); break;
            case LOADBALANCE     : complainNonzeroArgs(arguments, command); probe.loadBalance(); break;
            case CLEARSNAPSHOT   : complainNonzeroArgs(arguments, command); probe.clearSnapshot(); break;
            case TPSTATS         : complainNonzeroArgs(arguments, command); nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : complainNonzeroArgs(arguments, command); nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : complainNonzeroArgs(arguments, command); nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : complainNonzeroArgs(arguments, command); probe.stopGossiping(); break;
            case ENABLEGOSSIP    : complainNonzeroArgs(arguments, command); probe.startGossiping(); break;
            case DISABLETHRIFT   : complainNonzeroArgs(arguments, command); probe.stopThriftServer(); break;
            case ENABLETHRIFT    : complainNonzeroArgs(arguments, command); probe.startThriftServer(); break;;            case RING            : nodeCmd.printRing(System.out); break;
            case INFO            : nodeCmd.printInfo(System.out); break;
            case CFSTATS         : nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : probe.decommission(); break;
            case LOADBALANCE     : probe.loadBalance(); break;
            case CLEARSNAPSHOT   : probe.clearSnapshot(); break;
            case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : probe.stopGossiping(); break;
            case ENABLEGOSSIP    : probe.startGossiping(); break;
            case DISABLETHRIFT   : probe.stopThriftServer(); break;
            case ENABLETHRIFT    : probe.startThriftServer(); break;;            case RING            : nodeCmd.printRing(System.out); break;
            case INFO            : nodeCmd.printInfo(System.out); break;
            case CFSTATS         : nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : probe.decommission(); break;
            case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : probe.stopGossiping(); break;
            case ENABLEGOSSIP    : probe.startGossiping(); break;
            case DISABLETHRIFT   : probe.stopThriftServer(); break;
            case ENABLETHRIFT    : probe.startThriftServer(); break;
            case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_65e50_27632/rev_65e50-27632;/lucene/src/java/org/apache/lucene/index/IndexWriter;IndexWriter(Directory,IndexWriterConfig);      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);
      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),
          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);;      fieldInfos = getCurrentFieldInfos();
      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(),
          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);;      fieldInfos = getCurrentFieldInfos();
      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(),
          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_67b0c_724d9/rev_67b0c-724d9;/subprojects/core/src/main/groovy/org/gradle/util/Jvm;getToolsJar();        return getToolsJar(getJavaHome());;        File javaHome = getEffectiveJavaHome();
        File toolsJar = new File(javaHome, "lib/tools.jar");
        if (toolsJar.exists()) {
            return toolsJar;
        }
        if (javaHome.getName().equalsIgnoreCase("jre")) {
            javaHome = javaHome.getParentFile();
            toolsJar = new File(javaHome, "lib/tools.jar");
            if (toolsJar.exists()) {
                return toolsJar;
            }
        }
        if (javaHome.getName().matches("jre\\d+") && os.isWindows()) {
            javaHome = new File(javaHome.getParentFile(), String.format("jdk%s", System.getProperty("java.version")));
            toolsJar = new File(javaHome, "lib/tools.jar");
            if (toolsJar.exists()) {
                return toolsJar;
            }
        }

        return null;;        File javaHome = getEffectiveJavaHome();
        File toolsJar = new File(javaHome, "lib/tools.jar");
        if (toolsJar.exists()) {
            return toolsJar;
        }
        if (javaHome.getName().equalsIgnoreCase("jre")) {
            javaHome = javaHome.getParentFile();
            toolsJar = new File(javaHome, "lib/tools.jar");
            if (toolsJar.exists()) {
                return toolsJar;
            }
        }
        if (javaHome.getName().matches("jre\\d+") && os.isWindows()) {
            javaHome = new File(javaHome.getParentFile(), String.format("jdk%s", SystemProperties.getJavaVersion()));
            toolsJar = new File(javaHome, "lib/tools.jar");
            if (toolsJar.exists()) {
                return toolsJar;
            }
        }

        return null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_67dec_76ada/rev_67dec-76ada;/src/java/org/apache/cassandra/db/Memtable;getLiveSize();        // 25% fudge factor on the base throughput * liveRatio calculation.  (Based on observed
        // pre-slabbing behavior -- not sure what accounts for this. May have changed with introduction of slabbing.)
        return (long) (currentSize.get() * cfs.liveRatio * 1.25);;        // 25% fudge factor on the base throughput * liveRatio calculation.  (Based on observed
        // pre-slabbing behavior -- not sure what accounts for this. May have changed with introduction of slabbing.)
        return (long) (currentThroughput.get() * cfs.liveRatio * 1.25);;        return (long) (currentThroughput.get() * cfs.liveRatio);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_68a6d_d0e2a/rev_68a6d-d0e2a;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/GradlePomModuleDescriptorParser;doParsePom(DescriptorParseContext,GradlePomModuleDescriptorBuilder,PomReader);                // add plugins from parent
                List<PomPluginElement> plugins = parentDescr.getPlugins();
                for(PomPluginElement plugin : plugins) {
                    mdBuilder.addPlugin(plugin);
                };                // add dependency management info from parent
                Set<PomDependencyMgt> depMgt = parentDescr.getDependencyMgt();
                for (PomDependencyMgt aDepMgt : depMgt) {
                    mdBuilder.addDependencyMgt(aDepMgt);
                }

                // add plugins from parent
                List<PomPluginElement> plugins = parentDescr.getPlugins();
                for(PomPluginElement plugin : plugins) {
                    mdBuilder.addPlugin(plugin);
                }
            }

            for (Object o : pomReader.getDependencyMgt()) {
                PomDependencyMgt dep = (PomDependencyMgt) o;
                if ("import".equals(dep.getScope())) {
                    ModuleRevisionId importModRevID = ModuleRevisionId.newInstance(
                            dep.getGroupId(),
                            dep.getArtifactId(),
                            dep.getVersion());
                    PomReader importDescr = parseOtherPom(parserSettings, importModRevID);
                    // add dependency management info from imported module
                    Set<PomDependencyMgt> depMgt = importDescr.getDependencyMgt();
                    pomReader.addDependencyMgts(depMgt);

                    for (PomDependencyMgt aDepMgt : depMgt) {
                        mdBuilder.addDependencyMgt(aDepMgt);
                    };                // add dependency management info from parent
                Set<PomDependencyMgt> depMgt = parentDescr.getDependencyMgt();
                for (PomDependencyMgt aDepMgt : depMgt) {
                    mdBuilder.addDependencyMgt(aDepMgt);
                }
            }

            for (Object o : pomReader.getDependencyMgt()) {
                PomDependencyMgt dep = (PomDependencyMgt) o;
                if ("import".equals(dep.getScope())) {
                    ModuleRevisionId importModRevID = ModuleRevisionId.newInstance(
                            dep.getGroupId(),
                            dep.getArtifactId(),
                            dep.getVersion());
                    PomReader importDescr = parseOtherPom(parserSettings, importModRevID);
                    // add dependency management info from imported module
                    Set<PomDependencyMgt> depMgt = importDescr.getDependencyMgt();
                    pomReader.addDependencyMgts(depMgt);

                    for (PomDependencyMgt aDepMgt : depMgt) {
                        mdBuilder.addDependencyMgt(aDepMgt);
                    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_69f05_bc6b5/rev_69f05-bc6b5;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;prepare();                stmt.isKeyRange = true;
                boolean hasEq = false;
                Set<ByteBuffer> indexedNames = new HashSet<ByteBuffer>();
                for (ColumnDefinition cfdef : cfm.getColumn_metadata().values());                stmt.isKeyRange = true;
                boolean hasEq = false;
                Set<ByteBuffer> indexedNames = new HashSet<ByteBuffer>();
                indexedNames.add(cfm.getKeyName());
                for (ColumnDefinition cfdef : cfm.getColumn_metadata().values());                CFDefinition.Name cname = iter.next();
                Restriction restriction = stmt.columnRestrictions[i];

                if (restriction == null)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_69f53_610f7/rev_69f53-610f7;/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest;scriptKill();	try {
	    jedis.scriptKill();
	} catch (JedisDataException e) {
	    assertTrue(e.getMessage().contains(
		    "No scripts in execution right now."));;		try {
			jedis.scriptKill();
		}
		catch(JedisDataException e) {
			assertEquals("ERR No scripts in execution right now.", e.getMessage());
		};		try {
			jedis.scriptKill();
		}
		catch(JedisDataException e) {
			assertTrue(e.getMessage().contains("No scripts in execution right now."));
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_70b05_3b8e2/rev_70b05-3b8e2;/subprojects/core/src/main/groovy/org/gradle/api/internal/file/copy/CopyActionImpl;CopyActionImpl(FileResolver,CopySpecVisitor);        this(resolver, visitor, false);;        this.resolver = resolver;
        root = new CopySpecImpl(resolver);
        mainContent = root.addChild();
        this.visitor = new MappingCopySpecVisitor(new NormalizingCopySpecVisitor(visitor), FileSystems.getDefault());;        this.resolver = resolver;
        root = new CopySpecImpl(resolver);
        mainContent = root.addChild();
        this.visitor = new MappingCopySpecVisitor(
                           new DuplicateHandlingCopySpecVisitor(
                               new NormalizingCopySpecVisitor(visitor)),
                           FileSystems.getDefault());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_72ab5_8c9d5/rev_72ab5-8c9d5;/projects/OG-Analytics/tests/unit/com/opengamma/financial/equity/variance/VarianceSwapStaticReplicationTest;testVolSurface();    BlackVolatilitySurfaceDelta surfaceDelta = new BlackVolatilitySurfaceDelta(FunctionalDoublesSurface.from(surf), FORWARD_CURVE);
    BlackVolatilitySurfaceLogMoneyness surfaceLogMoneyness = BlackVolatilitySurfaceConverter.toLogMoneynessSurface(surfaceDelta);
    BlackVolatilitySurfaceMoneyness surfaceMoneyness = BlackVolatilitySurfaceConverter.toMoneynessSurface(surfaceLogMoneyness);
    BlackVolatilitySurfaceStrike surfaceStrike = BlackVolatilitySurfaceConverter.toStrikeSurface(surfaceLogMoneyness);;    BlackVolatilitySurfaceDelta surfaceDelta = new BlackVolatilitySurfaceDelta(FunctionalDoublesSurface.from(surf), FORWARD_CURVE);
    BlackVolatilitySurfaceStrike surfaceStrike = BlackVolatilitySurfaceConverter.toStrikeSurface(surfaceDelta);;    final BlackVolatilitySurfaceDelta surfaceDelta = new BlackVolatilitySurfaceDelta(FunctionalDoublesSurface.from(surf), FORWARD_CURVE);
    final BlackVolatilitySurfaceStrike surfaceStrike = BlackVolatilitySurfaceConverter.toStrikeSurface(surfaceDelta);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_72ab5_8c9d5/rev_72ab5-8c9d5;/projects/OG-Analytics/tests/unit/com/opengamma/financial/equity/variance/VarianceSwapStaticReplicationTest;testMixedLogNormalVolSurface();    double expected = w * sigma1 * sigma1 + (1 - w) * sigma2 * sigma2;
    assertEquals(expected, compVar, TEST_TOL);;    double expected = w * sigma1 * sigma1 + (1 - w) * sigma2 * sigma2;
    assertEquals(expected, compVar, 1e-7);;    final double expected = w * sigma1 * sigma1 + (1 - w) * sigma2 * sigma2;
    assertEquals(expected, compVar, 1e-7);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_73c69_b21a5/rev_73c69-b21a5;/src/com/opengamma/id/UniqueIdentifier;toFudgeMsg(FudgeMessageFactory);    msg.add(SCHEME_FUDGE_FIELD_NAME, getScheme());
    msg.add(VALUE_FUDGE_FIELD_NAME, getValue());
    if (getVersion() != null) {
      msg.add(VERSION_FUDGE_FIELD_NAME, getVersion());
    };    msg.add(SCHEME_FUDGE_FIELD_NAME, getScheme());
    msg.add(VALUE_FUDGE_FIELD_NAME, getValue());
    msg.add(VERSION_FUDGE_FIELD_NAME, null, StringFieldType.INSTANCE, getVersion());;    msg.add(SCHEME_FUDGE_FIELD_NAME, _scheme);
    msg.add(VALUE_FUDGE_FIELD_NAME, _value);
    if (_version != null) {
      msg.add(VERSION_FUDGE_FIELD_NAME, _version);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_73eb6_4b6d6/rev_73eb6-4b6d6;/src/java/org/apache/cassandra/locator/SimpleSeedProvider;getSeeds();            logger.warn("Could not refresh seeds from configuration file: {}", e);;            throw new AssertionError(e);
        }
        org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
        TypeDescription seedDesc = new TypeDescription(SeedProviderDef.class);
        seedDesc.putMapPropertyType("parameters", String.class, String.class);
        constructor.addTypeDescription(seedDesc);
        Yaml yaml = new Yaml(new Loader(constructor));
        Config conf = (Config)yaml.load(input);
        String[] hosts = conf.seed_provider.parameters.get("seeds").split(",", -1);
        List<InetAddress> seeds = new ArrayList<InetAddress>(hosts.length);
        for (String host : hosts)
        {
            try
            {
                seeds.add(InetAddress.getByName(host.trim()));
            }
            catch (UnknownHostException ex)
            {
                // not fatal... DD will bark if there end up being zero seeds.
                logger.warn("Seed provider couldn't lookup host " + host);
            };            throw new AssertionError(e);
        }
        String[] hosts = conf.seed_provider.parameters.get("seeds").split(",", -1);
        List<InetAddress> seeds = new ArrayList<InetAddress>(hosts.length);
        for (String host : hosts)
        {
            try
            {
                seeds.add(InetAddress.getByName(host.trim()));
            }
            catch (UnknownHostException ex)
            {
                // not fatal... DD will bark if there end up being zero seeds.
                logger.warn("Seed provider couldn't lookup host " + host);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_73f50_1d6f6/rev_73f50-1d6f6;/src/com/opengamma/engine/security/DefaultSecurity;getIdentityKey();  public String getIdentityKey() {
    return _identityKey;;  public SecurityKey getIdentityKey() {
    return new SecurityKeyImpl(_identifiers);;  public SecurityKey getIdentityKey() {
    return new SecurityKeyImpl(_identifiers.getIdentifiers());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_74b52_6c686/rev_74b52-6c686;/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler;discoverClusterNodesAndSlots(Jedis);	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));

	    HostAndPort targetNode = clusterNodeInfo.getNode();
	    setNodeIfNotExist(targetNode);
	    assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);;	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
	    setNodeIfNotExist(node);
	    
	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);;	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
        setNodeIfNotExist(node);

	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_74b52_6c686/rev_74b52-6c686;/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler;setNodeIfNotExist(HostAndPort);
	JedisPool nodePool = new JedisPool(node.getHost(), node.getPort());;	
	JedisPool nodePool = new JedisPool(node.getHost(), node.getPort());;	
	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_74e0d_e4f51/rev_74e0d-e4f51;/src/java/voldemort/server/jmx/JmxService;startInner();            registerBean(store,
                         JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                   store.getName()));
            if(store instanceof BdbStorageEngine) {
                // Temp hack for now
                BdbStorageEngine bdbStore = (BdbStorageEngine) store;
                registerBean(bdbStore.getBdbEnvironmentStats(),
                             JmxUtils.createObjectName(JmxUtils.getPackageName(BdbEnvironmentStats.class),
                                                       store.getName()));
            };            registerBean(store,
                         JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                   store.getName()));;            if(server.getVoldemortConfig().isEnableJmxClusterName())
                registerBean(store,
                             JmxUtils.createObjectName(this.cluster.getName()
                                                               + "."
                                                               + JmxUtils.getPackageName(store.getClass()),
                                                       store.getName()));
            else
                registerBean(store,
                             JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                       store.getName()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_75ff5_fc33c/rev_75ff5-fc33c;/src/java/org/apache/cassandra/triggers/TriggerExecutor;execute(ByteBuffer,ColumnFamily);        List<RowMutation> intermediate = executeInternal(key, updates);
        if (intermediate == null)
            return updates;

        validateForSinglePartition(updates.metadata().getKeyValidator(), updates.id(), key, intermediate);

        for (RowMutation mutation : intermediate)
            for (ColumnFamily cf : mutation.getColumnFamilies())
                updates.addAll(cf, HeapAllocator.instance);

        return updates;;        Map<String,TriggerDefinition> triggers = columnFamily.metadata().getTriggers();
        if (triggers.isEmpty())
            return null;
        List<RowMutation> tmutations = Lists.newLinkedList();
        Thread.currentThread().setContextClassLoader(customClassLoader);
        try
        {
            for (TriggerDefinition td : triggers.values())
            {
                ITrigger trigger = cachedTriggers.get(td.classOption);
                if (trigger == null)
                {
                    trigger = loadTriggerInstance(td.classOption);
                    cachedTriggers.put(td.classOption, trigger);
                }
                Collection<RowMutation> temp = trigger.augment(key, columnFamily);
                if (temp != null)
                    tmutations.addAll(temp);
            }
            return tmutations;
        }
        catch (Exception ex)
        {
            throw new RuntimeException(String.format("Exception while creating trigger on CF with ID: %s", columnFamily.id()), ex);
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(parent);
        };        Map<String,TriggerDefinition> triggers = columnFamily.metadata().getTriggers();
        if (triggers.isEmpty())
            return null;
        List<Mutation> tmutations = Lists.newLinkedList();
        Thread.currentThread().setContextClassLoader(customClassLoader);
        try
        {
            for (TriggerDefinition td : triggers.values())
            {
                ITrigger trigger = cachedTriggers.get(td.classOption);
                if (trigger == null)
                {
                    trigger = loadTriggerInstance(td.classOption);
                    cachedTriggers.put(td.classOption, trigger);
                }
                Collection<Mutation> temp = trigger.augment(key, columnFamily);
                if (temp != null)
                    tmutations.addAll(temp);
            }
            return tmutations;
        }
        catch (Exception ex)
        {
            throw new RuntimeException(String.format("Exception while creating trigger on CF with ID: %s", columnFamily.id()), ex);
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(parent);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_76c84_4eac8/rev_76c84-4eac8;/transport/src/main/java/io/netty/channel/socket/nio/NioWorker;registerTask(AbstractNioChannel,ChannelFuture);                if (channel instanceof NioSocketChannel) {
                    ((NioSocketChannel) channel).setConnected();
                };                ((NioSocketChannel) channel).setConnected();;
                ((NioSocketChannel) channel).setConnected();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_clojure/revisions/rev_77be1_07f05/rev_77be1-07f05;/src/jvm/clojure/lang/Util;equiv(Object,Object);			return Numbers.equiv(k1, k2);
		else if(k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
			return pcequiv(k1,k2);;			return Numbers.equiv(k1, k2);
		else if(k1 instanceof IPersistentCollection && k2 instanceof IPersistentCollection)
			return ((IPersistentCollection)k1).equiv(k2);;			return Numbers.equal((Number)k1, (Number)k2);
		else if(k1 instanceof IPersistentCollection && k2 instanceof IPersistentCollection)
			return ((IPersistentCollection)k1).equiv(k2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_clojure/revisions/rev_77be1_07f05/rev_77be1-07f05;/src/jvm/clojure/lang/Compiler;InvokeExpr(String,int,Symbol,Expr,IPersistentVector);//			else if(pvar == null && VAR_CALLSITES.isBound()
//			        && fvar.ns.name.name.startsWith("clojure")
//					&& !RT.booleanCast(RT.get(RT.meta(fvar),dynamicKey))
//					)
//				{
//				//todo - more specific criteria for binding these
//				this.isDirect = true;
//				this.siteIndex = registerVarCallsite(((VarExpr) fexpr).var);
//				};			else if(pvar == null && VAR_CALLSITES.isBound()
			        && fvar.ns.name.name.startsWith("clojure")
					&& !RT.booleanCast(RT.get(RT.meta(fvar),dynamicKey))
//			        && !fvar.sym.name.equals("report")
//			        && fvar.isBound() && fvar.get() instanceof IFn
					)
				{
				//todo - more specific criteria for binding these
				this.isDirect = true;
				this.siteIndex = registerVarCallsite(((VarExpr) fexpr).var);
				};			else if(pvar == null && VAR_CALLSITES.isBound()
			        && fvar.ns.name.name.startsWith("clojure")
					&& !RT.booleanCast(RT.get(RT.meta(fvar),dynamicKey))
//			        && !fvar.sym.name.equals("report")
//			        && fvar.isBound() && fvar.get() instanceof IFn
					)
				{
				//todo - more specific criteria for binding these
//				this.isDirect = true;
//				this.siteIndex = registerVarCallsite(((VarExpr) fexpr).var);
				}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_78f3a_6c79a/rev_78f3a-6c79a;/lucene/src/java/org/apache/lucene/index/DocumentsWriter;initFlushState(boolean);    final SegmentCodecs info = SegmentCodecs.build(docFieldProcessor.fieldInfos, writer.codecs);
    flushState = new SegmentWriteState(infoStream, directory, segment, docFieldProcessor.fieldInfos,
                                       docStoreSegment, numDocsInRAM, numDocsInStore, writer.getConfig().getTermIndexInterval(), info);;    flushState = new SegmentWriteState(infoStream, directory, segment, docFieldProcessor.fieldInfos,
                                       docStoreSegment, numDocsInRAM, numDocsInStore, writer.getConfig().getTermIndexInterval(),
                                       writer.codecs);;    flushState = segWriteState();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_78f3a_6c79a/rev_78f3a-6c79a;/lucene/src/java/org/apache/lucene/index/FieldInfos;read(IndexInput,String);      final FieldInfo addInternal = addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
      addInternal.codecId = codecId;;      
      addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);;      
      FieldInfo fi = addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);
      if (format <= FORMAT_INDEX_VALUES) {
        final byte b = input.readByte();
        switch(b) {
        case 0:
          fi.docValues = null;
          break;
        case 1:
          fi.docValues = Values.PACKED_INTS;
          break;
        case 2:
          fi.docValues = Values.SIMPLE_FLOAT_4BYTE;
          break;
        case 3:
          fi.docValues = Values.SIMPLE_FLOAT_8BYTE;
          break;
        case 4:
          fi.docValues = Values.BYTES_FIXED_STRAIGHT;
          break;
        case 5:
          fi.docValues = Values.BYTES_FIXED_DEREF;
          break;
        case 6:
          fi.docValues = Values.BYTES_FIXED_SORTED;
          break;
        case 7:
          fi.docValues = Values.BYTES_VAR_STRAIGHT;
          break;
        case 8:
          fi.docValues = Values.BYTES_VAR_DEREF;
          break;
        case 9:
          fi.docValues = Values.BYTES_VAR_SORTED;
          break;
        case 10:
          fi.docValues = Values.PACKED_INTS_FIXED;
          break;
        default:
          throw new IllegalStateException("unhandled indexValues type " + b);
        }
      }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_079ae_d0dc5/rev_079ae-d0dc5;/src/java/org/apache/cassandra/io/sstable/SSTableReader;open(Descriptor,Set<Component>,CFMetaData,IPartitioner,boolean);        long start = System.currentTimeMillis();
        SSTableMetadata sstableMetadata = openMetadata(descriptor, components, partitioner);;        assert partitioner != null;
        // Minimum components without which we can't do anything
        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
        assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;

        long start = System.currentTimeMillis();
        logger.info("Opening {} ({} bytes)", descriptor, new File(descriptor.filenameFor(COMPONENT_DATA)).length());

        SSTableMetadata sstableMetadata = SSTableMetadata.serializer.deserialize(descriptor);

        // Check if sstable is created using same partitioner.
        // Partitioner can be null, which indicates older version of sstable or no stats available.
        // In that case, we skip the check.
        String partitionerName = partitioner.getClass().getCanonicalName();
        if (sstableMetadata.partitioner != null && !partitionerName.equals(sstableMetadata.partitioner))
        {
            logger.error(String.format("Cannot open %s; partitioner %s does not match system partitioner %s.  Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading.",
                                       descriptor, sstableMetadata.partitioner, partitionerName));
            System.exit(1);
        };        assert partitioner != null;
        // Minimum components without which we can't do anything
        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
        assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;

        long start = System.nanoTime();
        logger.info("Opening {} ({} bytes)", descriptor, new File(descriptor.filenameFor(COMPONENT_DATA)).length());

        SSTableMetadata sstableMetadata = SSTableMetadata.serializer.deserialize(descriptor);

        // Check if sstable is created using same partitioner.
        // Partitioner can be null, which indicates older version of sstable or no stats available.
        // In that case, we skip the check.
        String partitionerName = partitioner.getClass().getCanonicalName();
        if (sstableMetadata.partitioner != null && !partitionerName.equals(sstableMetadata.partitioner))
        {
            logger.error(String.format("Cannot open %s; partitioner %s does not match system partitioner %s.  Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading.",
                                       descriptor, sstableMetadata.partitioner, partitionerName));
            System.exit(1);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_079ae_d0dc5/rev_079ae-d0dc5;/src/java/org/apache/cassandra/io/sstable/SSTableReader;load(boolean);        boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder);
        if (recreatebloom || !summaryLoaded)
            buildSummary(recreatebloom, ibuilder, dbuilder, summaryLoaded);;        // try to load summaries from the disk and check if we need
        // to read primary index because we should re-create a BloomFilter or pre-load KeyCache
        final boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder);
        final boolean readIndex = recreatebloom || !summaryLoaded;
        try
        {
            long indexSize = primaryIndex.length();
            long histogramCount = sstableMetadata.estimatedRowSize.count();
            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()
                               ? histogramCount
                               : estimateRowsFromIndex(primaryIndex); // statistics is supposed to be optional
            if (recreatebloom)
                bf = LegacyBloomFilter.getFilter(estimatedKeys, 15);;        // try to load summaries from the disk and check if we need
        // to read primary index because we should re-create a BloomFilter or pre-load KeyCache
        final boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder, metadata);
        final boolean readIndex = recreateBloomFilter || !summaryLoaded;
        try
        {
            long indexSize = primaryIndex.length();
            long histogramCount = sstableMetadata.estimatedRowSize.count();
            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()
                               ? histogramCount
                               : estimateRowsFromIndex(primaryIndex); // statistics is supposed to be optional

            if (recreateBloomFilter)
                bf = FilterFactory.getFilter(estimatedKeys, metadata.getBloomFilterFpChance(), true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_079ae_d0dc5/rev_079ae-d0dc5;/src/java/org/apache/cassandra/db/ColumnFamilyStore;ColumnFamilyStore(Table,String,IPartitioner,int,CFMetaData,Directories,boolean);            Collection<SSTableReader> sstables = SSTableReader.openAll(sstableFiles.list().entrySet(), metadata, this.partitioner);
            if (metadata.getDefaultValidator().isCommutative())
            {
                // Filter non-compacted sstables, remove compacted ones
                Set<Integer> compactedSSTables = new HashSet<Integer>();
                for (SSTableReader sstable : sstables)
                    compactedSSTables.addAll(sstable.getAncestors());

                Set<SSTableReader> liveSSTables = new HashSet<SSTableReader>();
                for (SSTableReader sstable : sstables)
                {
                    if (compactedSSTables.contains(sstable.descriptor.generation))
                    {
                        logger.info("{} is already compacted and will be removed.", sstable);
                        sstable.markCompacted(); // we need to mark as compacted to be deleted
                        sstable.releaseReference(); // this amount to deleting the sstable
                    }
                    else
                    {
                        liveSSTables.add(sstable);
                    }
                }
                data.addInitialSSTables(liveSSTables);
            }
            else
            {
                data.addInitialSSTables(sstables);
            };            Collection<SSTableReader> sstables = SSTableReader.batchOpen(sstableFiles.list().entrySet(), metadata, this.partitioner);
            if (metadata.getDefaultValidator().isCommutative())
            {
                // Filter non-compacted sstables, remove compacted ones
                Set<Integer> compactedSSTables = new HashSet<Integer>();
                for (SSTableReader sstable : sstables)
                    compactedSSTables.addAll(sstable.getAncestors());

                Set<SSTableReader> liveSSTables = new HashSet<SSTableReader>();
                for (SSTableReader sstable : sstables)
                {
                    if (compactedSSTables.contains(sstable.descriptor.generation))
                    {
                        logger.info("{} is already compacted and will be removed.", sstable);
                        sstable.markCompacted(); // we need to mark as compacted to be deleted
                        sstable.releaseReference(); // this amount to deleting the sstable
                    }
                    else
                    {
                        liveSSTables.add(sstable);
                    }
                }
                data.addInitialSSTables(liveSSTables);
            }
            else
            {
                data.addInitialSSTables(sstables);
            };            Collection<SSTableReader> sstables = SSTableReader.batchOpen(sstableFiles.list().entrySet(), metadata, this.partitioner);
            data.addInitialSSTables(sstables);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_79deb_e6938/rev_79deb-e6938;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/PlotViewManifestation;updateFromFeed(Map<String,List<Map<String,String>>>);		plotDataFedUpdateHandler.updateFromFeed(data, false);
		for (Runnable r : feedCallbacks) {
			SwingUtilities.invokeLater(r);
		};		plotDataFedUpdateHandler.updateFromFeed(data, false);;		plotDataFeedUpdateHandler.updateFromFeed(data, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jsoup/revisions/rev_83ad1_514dc/rev_83ad1-514dc;/src/main/java/org/jsoup/helper/HttpConnection;createConnection(Connection.Request);            if (req.method().hasBody());            if (req.method() == Method.POST);
            if (conn instanceof HttpsURLConnection) {
                if (!req.isValidateSSLCertificates()) {
                    initUnSecureSSL();
                    ((HttpsURLConnection)conn).setSSLSocketFactory(sslSocketFactory);
                    ((HttpsURLConnection)conn).setHostnameVerifier(getInsecureVerifier());
                }
            }

            if (req.method() == Method.POST)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_83b75_1a2f3/rev_83b75-1a2f3;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;SSTableMetadata();             defaultTombstoneDropTimeHistogram());;             Collections.<Integer>emptySet(),
             defaultTombstoneDropTimeHistogram());;             Collections.<Integer>emptySet(),
             defaultTombstoneDropTimeHistogram(),
             0,
             Collections.<ByteBuffer>emptyList(),
             Collections.<ByteBuffer>emptyList());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_83f9f_273c5/rev_83f9f-273c5;/src/java/org/apache/cassandra/tools/NodeCmd;main(String[]);            case RING            : complainNonzeroArgs(arguments, command); nodeCmd.printRing(System.out); break;
            case INFO            : complainNonzeroArgs(arguments, command); nodeCmd.printInfo(System.out); break;
            case CFSTATS         : complainNonzeroArgs(arguments, command); nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : complainNonzeroArgs(arguments, command); probe.decommission(); break;
            case LOADBALANCE     : complainNonzeroArgs(arguments, command); probe.loadBalance(); break;
            case CLEARSNAPSHOT   : complainNonzeroArgs(arguments, command); probe.clearSnapshot(); break;
            case TPSTATS         : complainNonzeroArgs(arguments, command); nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : complainNonzeroArgs(arguments, command); nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : complainNonzeroArgs(arguments, command); nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : complainNonzeroArgs(arguments, command); probe.stopGossiping(); break;
            case ENABLEGOSSIP    : complainNonzeroArgs(arguments, command); probe.startGossiping(); break;
            case DISABLETHRIFT   : complainNonzeroArgs(arguments, command); probe.stopThriftServer(); break;
            case ENABLETHRIFT    : complainNonzeroArgs(arguments, command); probe.startThriftServer(); break;;            case RING            : nodeCmd.printRing(System.out); break;
            case INFO            : nodeCmd.printInfo(System.out); break;
            case CFSTATS         : nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : probe.decommission(); break;
            case LOADBALANCE     : probe.loadBalance(); break;
            case CLEARSNAPSHOT   : probe.clearSnapshot(); break;
            case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : probe.stopGossiping(); break;
            case ENABLEGOSSIP    : probe.startGossiping(); break;
            case DISABLETHRIFT   : probe.stopThriftServer(); break;
            case ENABLETHRIFT    : probe.startThriftServer(); break;;            case RING            : nodeCmd.printRing(System.out); break;
            case INFO            : nodeCmd.printInfo(System.out); break;
            case CFSTATS         : nodeCmd.printColumnFamilyStats(System.out); break;
            case DECOMMISSION    : probe.decommission(); break;
            case TPSTATS         : nodeCmd.printThreadPoolStats(System.out); break;
            case VERSION         : nodeCmd.printReleaseVersion(System.out); break;
            case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out); break;
            case DISABLEGOSSIP   : probe.stopGossiping(); break;
            case ENABLEGOSSIP    : probe.startGossiping(); break;
            case DISABLETHRIFT   : probe.stopThriftServer(); break;
            case ENABLETHRIFT    : probe.startThriftServer(); break;
            case STATUSTHRIFT    : nodeCmd.printIsThriftServerRunning(System.out); break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_85d02_50193/rev_85d02-50193;/src/com/opengamma/financial/batch/BatchJob;createView(BatchJobRun);
    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionRepository(), new DefaultFunctionResolver(
        getFunctionRepository()), positionSource, securitySource, cacheFactory, jobDispatcher, viewProcessorQueryReceiver, getFunctionCompilationContext(), executor, dependencyGraphExecutorFactory,
        new DefaultViewPermissionProvider(), new DiscardingGraphStatisticsGathererProvider());

    ViewImpl view = new ViewImpl(_viewDefinitionConfig.getValue(), vpc);;    
    ViewProcessingContext vpc = new ViewProcessingContext(
        new PermissiveLiveDataEntitlementChecker(), 
        snapshotProvider, 
        snapshotProvider, 
        getFunctionRepository(), 
        new DefaultFunctionResolver(getFunctionRepository()), 
        positionSource, 
        securitySource, 
        cacheFactory, 
        jobDispatcher, 
        viewProcessorQueryReceiver, 
        getFunctionCompilationContext(), 
        executor,
        dependencyGraphExecutorFactory,
        new DefaultViewPermissionProvider());
    
    ViewImpl view = new ViewImpl(_viewDefinitionConfig.getValue(), vpc);;    
    ViewProcessingContext vpc = new ViewProcessingContext(
        new PermissiveLiveDataEntitlementChecker(), 
        snapshotProvider, 
        snapshotProvider, 
        getFunctionRepository(), 
        new DefaultFunctionResolver(getFunctionRepository()), 
        positionSource, 
        securitySource, 
        cacheFactory, 
        jobDispatcher, 
        viewProcessorQueryReceiver, 
        getFunctionCompilationContext(), 
        executor,
        dependencyGraphExecutorFactory,
        new DefaultViewPermissionProvider());
    
    ViewImpl view = new ViewImpl(_viewDefinitionConfig.getValue(), vpc, new Timer("Batch view timer"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_86a07_41ef8/rev_86a07-41ef8;/src/java/org/apache/cassandra/config/KSMetaData;toSchema(long);        RowMutation rm = new RowMutation(Table.SYSTEM_KS, SystemTable.getSchemaKSKey(name));
        ColumnFamily cf = rm.addOrGet(CFMetaData.SchemaKeyspacesCf);;        RowMutation rm = new RowMutation(Table.SYSTEM_KS, SystemTable.getSchemaKSKey(name));
        ColumnFamily cf = rm.addOrGet(SystemTable.SCHEMA_KEYSPACES_CF);;        RowMutation rm = new RowMutation(Keyspace.SYSTEM_KS, SystemKeyspace.getSchemaKSKey(name));
        ColumnFamily cf = rm.addOrGet(SystemKeyspace.SCHEMA_KEYSPACES_CF);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_88b65_63adc/rev_88b65-63adc;/projects/OG-Analytics/src/com/opengamma/financial/equity/varswap/pricing/VarSwapStaticReplication;presentValue(VarianceSwap,VarianceSwapDataBundle);    // TODO Can we assert that we are double counting days?
    final double realizedVar = new RealizedVariance().evaluate(deriv); // Realized variance of log returns already observed
    final double remainingVar = impliedVariance(deriv, market); // Remaining variance implied by option prices
    final double finalPayment = deriv.getVarNotional() * (realizedVar + remainingVar - deriv.getVarStrike());
    // FIXME Case !!! Confirm relative scaling of past vs future var, and annualization;    // TODO Can we assert that we are double counting days?
    double realizedVar = new RealizedVariance().evaluate(deriv); // Realized variance of log returns already observed
    double remainingVar = impliedVariance(deriv, market); // Remaining variance implied by option prices
    double finalPayment = deriv.getVarNotional() * (realizedVar + remainingVar - deriv.getVarStrike());
    // FIXME Case !!! Confirm relative scaling of past vs future var, and annualization;    if (deriv.getTimeToSettlement() < 0) {
      return 0.0; // All payments have been settled
    }

    // Compute contribution from past realizations
    double realizedVar = new RealizedVariance().evaluate(deriv); // Realized variance of log returns already observed
    // Compute contribution from future realizations
    double remainingVar = impliedVariance(deriv, market); // Remaining variance implied by option prices

    // Compute weighting
    double nObsExpected = deriv.getObsExpected(); // Expected number as of trade inception
    double nObsDisrupted = deriv.getObsDisrupted(); // Number of observations missed due to market disruption
    double nObsActual = 0;

    if (deriv.getTimeToObsStart() <= 0) {
      Validate.isTrue(deriv.getObservations().length > 0, "presentValue requested after first observation date, yet no observations have been provided.");
      nObsActual = deriv.getObservations().length - 1; // From observation start until valuation
    }

    double totalVar = realizedVar * (nObsActual / nObsExpected) + remainingVar * (nObsExpected - nObsActual - nObsDisrupted) / nObsExpected;
    double finalPayment = deriv.getVarNotional() * (totalVar - deriv.getVarStrike());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_089f9_0cc0d/rev_089f9-0cc0d;/src/java/org/apache/cassandra/tools/SSTableExport;export(Descriptor,PrintStream,Collection<String>,String[]);            serializeRow(row, decoratedKey, outs);;            i++;;            checkStream(outs);
            i++;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_93aae_4d2db/rev_93aae-4d2db;/src/java/org/apache/cassandra/cli/CliClient;updateCfDefAttributes(Tree,CfDef);                if (chance > 1)
                    throw new RuntimeException("Error: read_repair_chance should not be greater than 1.");;                if (chance > 1)
                    throw new RuntimeException("Error: read_repair_chance / 100 should not be greater than 1.");;                if (chance < 0 || chance > 1)
                    throw new RuntimeException("Error: read_repair_chance must be between 0 and 1.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.memtableDataSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableDataSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableLiveDataSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);        }); 
        allMemtablesDataSize = createKeyspaceGauge("AllMemtablesDataSize", new MetricValue();        });
        allMemtablesDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesDataSize"), new Gauge<Long>();        });
        memtableOnHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOnHeapDataSize"), new Gauge<Long>()
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;KeyspaceMetrics(Keyspace);                return metric.allMemtablesDataSize.value();;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesDataSize.value();
                }
                return total;;                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOnHeapSize.value();
                }
                return total;
            }
        });
        memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOffHeapDataSize"), new Gauge<Long>()
        {
            public Long value()
            {
                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.memtableOffHeapSize.value();
                }
                return total;
            }
        });
        allMemtablesLiveDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesLiveDataSize"), new Gauge<Long>()
        {
            public Long value()
            {
                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesLiveDataSize.value();
                }
                return total;
            }
        });
        allMemtablesOnHeapDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesOnHeapDataSize"), new Gauge<Long>()
        {
            public Long value()
            {
                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOnHeapSize.value();
                }
                return total;
            }
        });
        allMemtablesOffHeapDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesOffHeapDataSize"), new Gauge<Long>()
        {
            public Long value()
            {
                long total = 0;
                for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
                {
                    total += cf.metric.allMemtablesOffHeapSize.value();
                }
                return total;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics;ColumnFamilyMetrics(ColumnFamilyStore);        readLatency = new LatencyMetrics(factory, "Read", cfs.keyspace.metric.readLatency, globalReadLatency);
        writeLatency = new LatencyMetrics(factory, "Write", cfs.keyspace.metric.writeLatency, globalWriteLatency);
        rangeLatency = new LatencyMetrics(factory, "Range", cfs.keyspace.metric.rangeLatency, globalRangeLatency);
        pendingCompactions = createColumnFamilyGauge("PendingCompactions", new Gauge<Integer>();        readLatency = new LatencyMetrics(factory, "Read");
        writeLatency = new LatencyMetrics(factory, "Write");
        rangeLatency = new LatencyMetrics(factory, "Range");
        pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>();        readLatency = new LatencyMetrics(factory, "Read");
        writeLatency = new LatencyMetrics(factory, "Write");
        rangeLatency = new LatencyMetrics(factory, "Range");
        pendingFlushes = Metrics.newCounter(factory.createMetricName("PendingFlushes"));
        pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics;ColumnFamilyMetrics(ColumnFamilyStore);        pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
        {
            public Integer value()
            {
                // TODO this actually isn't a good measure of pending tasks
                return Keyspace.switchLock.getQueueLength();
            }
        });
        liveSSTableCount = createColumnFamilyGauge("LiveSSTableCount", new Gauge<Integer>();        pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
        {
            public Integer value()
            {
                // TODO this actually isn't a good measure of pending tasks
                return Keyspace.switchLock.getQueueLength();
            }
        });
        liveSSTableCount = Metrics.newGauge(factory.createMetricName("LiveSSTableCount"), new Gauge<Integer>();        liveSSTableCount = Metrics.newGauge(factory.createMetricName("LiveSSTableCount"), new Gauge<Integer>()
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/test/unit/org/apache/cassandra/db/KeyspaceTest;testLimitSSTables();        cfStore.metric.sstablesPerReadHistogram.cf.clear();
        ColumnFamily cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes(""), ByteBufferUtil.bytes("col1499"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        ColumnFamily cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes(""), ByteBufferUtil.bytes("col1499"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        ColumnFamily cf = cfStore.getColumnFamily(key, Composites.EMPTY, cellname("col1499"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/test/unit/org/apache/cassandra/db/KeyspaceTest;testLimitSSTables();        cfStore.metric.sstablesPerReadHistogram.cf.clear();
        cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1500"), ByteBufferUtil.bytes("col2000"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1500"), ByteBufferUtil.bytes("col2000"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        cf = cfStore.getColumnFamily(key, cellname("col1500"), cellname("col2000"), false, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/test/unit/org/apache/cassandra/db/KeyspaceTest;testLimitSSTables();        cfStore.metric.sstablesPerReadHistogram.cf.clear();
        cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col2000"), ByteBufferUtil.bytes("col1500"), true, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col2000"), ByteBufferUtil.bytes("col1500"), true, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);;        cfStore.metric.sstablesPerReadHistogram.clear();
        cf = cfStore.getColumnFamily(key, cellname("col2000"), cellname("col1500"), true, 1000, System.currentTimeMillis());
        assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_94ff6_e2bef/rev_94ff6-e2bef;/test/unit/org/apache/cassandra/db/KeyspaceTest;testLimitSSTablesComposites();        ByteBuffer start = ct.builder().add(ByteBufferUtil.bytes("a5")).add(ByteBufferUtil.bytes(85)).build();
        ByteBuffer finish = ct.builder().add(ByteBufferUtil.bytes("a5")).buildAsEndOfRange();
        cfs.metric.sstablesPerReadHistogram.cf.clear();;        ByteBuffer start = ct.builder().add(ByteBufferUtil.bytes("a5")).add(ByteBufferUtil.bytes(85)).build();
        ByteBuffer finish = ct.builder().add(ByteBufferUtil.bytes("a5")).buildAsEndOfRange();
        cfs.metric.sstablesPerReadHistogram.clear();;        Composite start = type.builder().add(ByteBufferUtil.bytes("a5")).add(ByteBufferUtil.bytes(85)).build();
        Composite finish = type.builder().add(ByteBufferUtil.bytes("a5")).build().end();
        cfs.metric.sstablesPerReadHistogram.clear();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_95f6c_c396c/rev_95f6c-c396c;/src/main/java/org/junit/rules/TemporaryFolder;newFolder(String);public File newFolder(String folderName) {
		File file= new File(getRoot(), folderName);
		file.mkdir();;public File newFolder(String folderName) {
		File file= new File(folder, folderName);
		file.mkdir();;public File newFolder(String... folderNames) {
		File file = folder;
		for (String folderName : folderNames) {
			file = new File(file, folderName);
			file.mkdir();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_96de4_5a689/rev_96de4-5a689;/src/com/opengamma/financial/user/rest/RemoteClient;forNewClient(RestTarget,String);    // Just use a GUID for the client name
    String clientName = GUIDGenerator.generate().toString();
    RestTarget uri = usersUri.resolveBase(username).resolveBase("clients").resolveBase(clientName);
    return new RemoteClient(fudgeContext, uri, usersUri.resolveBase("..").resolveBase(ClientResource.LIVEDATA_PATH));;    // Just use a GUID for the client name
    String clientName = GUIDGenerator.generate().toString();
    RestTarget uri = usersUri.resolveBase(username).resolveBase("clients").resolveBase(clientName);
    return new RemoteClient(fudgeContext, uri);;    // Just use a GUID for the client ID
    String clientId = GUIDGenerator.generate().toString();
    RestTarget uri = usersUri.resolveBase(username).resolveBase("clients").resolveBase(clientId);
    return new RemoteClient(clientId, fudgeContext, uri);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_96f43_1dea9/rev_96f43-1dea9;/src/java/org/apache/cassandra/service/paxos/PaxosState;commit(Commit);        long start = System.nanoTime();
        try
        {
            // There is no guarantee we will see commits in the right order, because messages
            // can get delayed, so a proposal can be older than our current most recent ballot/commit.
            // Committing it is however always safe due to column timestamps, so always do it. However,
            // if our current in-progress ballot is strictly greater than the proposal one, we shouldn't
            // erase the in-progress update.
            Tracing.trace("Committing proposal {}", proposal);
            RowMutation rm = proposal.makeMutation();
            Keyspace.open(rm.getKeyspaceName()).apply(rm, true);;        // There is no guarantee we will see commits in the right order, because messages
        // can get delayed, so a proposal can be older than our current most recent ballot/commit.
        // Committing it is however always safe due to column timestamps, so always do it. However,
        // if our current in-progress ballot is strictly greater than the proposal one, we shouldn't
        // erase the in-progress update.
        Tracing.trace("Committing proposal {}", proposal);
        RowMutation rm = proposal.makeMutation();
        Keyspace.open(rm.getKeyspaceName()).apply(rm, true);;        // There is no guarantee we will see commits in the right order, because messages
        // can get delayed, so a proposal can be older than our current most recent ballot/commit.
        // Committing it is however always safe due to column timestamps, so always do it. However,
        // if our current in-progress ballot is strictly greater than the proposal one, we shouldn't
        // erase the in-progress update.
        Tracing.trace("Committing proposal {}", proposal);
        Mutation mutation = proposal.makeMutation();
        Keyspace.open(mutation.getKeyspaceName()).apply(mutation, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_97d32_459ce/rev_97d32-459ce;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;testNewton();    doHotSpot(rootFinder, "default Newton, finite difference", SINGLE_CURVE_FINDER);
    rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, SINGLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "default Newton, single curve", SINGLE_CURVE_FINDER);

    rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, "default Newton, double curve, finite difference", DOUBLE_CURVE_FINDER);
    rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "default Newton, double curve", DOUBLE_CURVE_FINDER);;    doHotSpot(rootFinder, "default Newton, finite difference", func);
    JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "default Newton, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "default Newton, double curve", func1);;    doHotSpot(rootFinder, "default Newton, finite difference", func);
    final JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "default Newton, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "default Newton, double curve", func1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_97d32_459ce/rev_97d32-459ce;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;testShermanMorrison();    doHotSpot(rootFinder, "Sherman Morrison, finite difference", SINGLE_CURVE_FINDER);
    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, SINGLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "Sherman Morrison, single curve", SINGLE_CURVE_FINDER);

    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, "Sherman Morrisonn, double curve, finite difference", DOUBLE_CURVE_FINDER);
    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "Sherman Morrison, double curve", DOUBLE_CURVE_FINDER);;    doHotSpot(rootFinder, "Sherman-Morrison, finite difference", func);
    JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "Sherman-Morrison, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "Sherman-Morrison, double curve", func1);;    doHotSpot(rootFinder, "Sherman-Morrison, finite difference", func);
    final JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "Sherman-Morrison, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "Sherman-Morrison, double curve", func1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_97d32_459ce/rev_97d32-459ce;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;testBroyden();    doHotSpot(rootFinder, "Broyden, finite difference", SINGLE_CURVE_FINDER);
    rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS, SINGLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "Broyden, single curve", SINGLE_CURVE_FINDER);

    rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    doHotSpot(rootFinder, "Broyden, double curve, finite difference", DOUBLE_CURVE_FINDER);
    rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS, DOUBLE_CURVE_JACOBIAN);
    doHotSpot(rootFinder, "Broyden, double curve", DOUBLE_CURVE_FINDER);;    doHotSpot(rootFinder, "Broyden, finite difference", func);
    JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "Broyden, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "Broyden, double curve", func1);;    doHotSpot(rootFinder, "Broyden, finite difference", func);
    final JacobianCalculator jac = new SingleCurveJacobian(SWAPS, SPOT_RATE, TIME_GRID, CUBIC_WITH_SENSITIVITY);
    rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS, jac);
    doHotSpot(rootFinder, "Broyden, single curve", func);
    final double[] fwdTimes = new double[] {0.5, 1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    final double[] fundTimes = new double[] {1.0, 2.0, 5.0, 10.0, 20.0, 31.0};
    // final Function1D<DoubleMatrix1D, DoubleMatrix1D> func1 = new DoubleCurveFinder(SWAPS, SWAP_VALUES, SPOT_RATE, fwdTimes, fundTimes, null, null, CUBIC, CUBIC);
    // jac = new DoubleCurveJacobian(SWAPS, SPOT_RATE, fwdTimes, fundTimes, CUBIC_WITH_SENSITIVITY, CUBIC_WITH_SENSITIVITY);
    // rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS, jac);
    // doHotSpot(rootFinder, "Broyden, double curve", func1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_97d32_459ce/rev_97d32-459ce;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;doTest(VectorRootFinder,Function1D<DoubleMatrix1D,DoubleMatrix1D>);private void doTest(final VectorRootFinder rootFinder, Function1D<DoubleMatrix1D, DoubleMatrix1D> functor) {
    if (functor.getClass().equals(SingleCurveFinder.class)) {
      doTestForSingleCurve(rootFinder, (SingleCurveFinder) functor);
    } else if (functor.getClass().equals(DoubleCurveFinder.class)) {
      doTestForDoubleCurve(rootFinder, (DoubleCurveFinder) functor);
    } else {
      throw new IllegalArgumentException("functor must be a SingleCurveFinder or DoubleCurveFinder");;private void doTest(final VectorRootFinder rootFinder, Function1D<DoubleMatrix1D, DoubleMatrix1D> functor) {
    final DoubleMatrix1D yieldCurveNodes = rootFinder.getRoot(functor, X0);
    final YieldAndDiscountCurve curve = makeYieldCurve(yieldCurveNodes.getData(), TIME_GRID, CUBIC);
    for (int i = 0; i < SWAP_VALUES.length; i++) {
      assertEquals(SWAP_VALUES[i], SWAP_RATE_CALCULATOR.getRate(curve, curve, SWAPS.get(i)), 1e-3);// TODO change this back to EPS;private void doTest(final VectorRootFinder rootFinder, final Function1D<DoubleMatrix1D, DoubleMatrix1D> functor) {
    final DoubleMatrix1D yieldCurveNodes = rootFinder.getRoot(functor, X0);
    final YieldAndDiscountCurve curve = makeYieldCurve(yieldCurveNodes.getData(), TIME_GRID, CUBIC);
    for (int i = 0; i < SWAP_VALUES.length; i++) {
      assertEquals(SWAP_VALUES[i], SWAP_RATE_CALCULATOR.getRate(curve, curve, SWAPS.get(i)), 1e-3);// TODO change this back to EPS
/home/ines/gjcc/fpfnanalysis/samplerpl/java_dropwizard/rev_97e4b_e5566/rev_97e4b-e5566;/dropwizard-core/src/main/java/com/yammer/dropwizard/config/ServerFactory;configureSslContext(SslContextFactory);        factory.setIncludeProtocols(config.getSslConfiguration()
                                          .getSupportedProtocols()
                                          .toArray(new String[config.getSslConfiguration()
                                                                    .getSupportedProtocols()
                                                                    .size()]));;        factory.setIncludeProtocols(config.getSslConfiguration().getSupportedProtocols());;        for (String type : config.getSslConfiguration().getTrustStoreType().asSet()) {
            factory.setTrustStoreType(type);
        }

        for (Boolean needClientAuth : config.getSslConfiguration().getNeedClientAuth().asSet()) {
            factory.setNeedClientAuth(needClientAuth);
        }
        
        factory.setIncludeProtocols(config.getSslConfiguration().getSupportedProtocols());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_98aaa_2d549/rev_98aaa-2d549;/src/java/org/apache/cassandra/net/MessagingService;listen(InetAddress);public void listen(InetAddress localEp) throws IOException, ConfigurationException
    {        
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        final ServerSocket ss = serverChannel.socket();
        ss.setReuseAddress(true);
        InetSocketAddress address = new InetSocketAddress(localEp, DatabaseDescriptor.getStoragePort());
        try
        {
            ss.bind(address);
        }
        catch (BindException e)
        {
            if (e.getMessage().contains("in use"))
                throw new ConfigurationException(address + " is in use by another process.  Change listen_address:storage_port in cassandra.yaml to values that do not conflict with other services");
            else if (e.getMessage().contains("Cannot assign requested address"))
                throw new ConfigurationException("Unable to bind to address " + address + ". Set listen_address in cassandra.yaml to an interface you can bind to, e.g., your private IP address on EC2");
            else
                throw e;
        }
        socketThread = new SocketThread(ss, "ACCEPT-" + localEp);;public void listen(InetAddress localEp) throws IOException
    {        
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        final ServerSocket ss = serverChannel.socket();
        ss.setReuseAddress(true);
        ss.bind(new InetSocketAddress(localEp, DatabaseDescriptor.getStoragePort()));
        socketThread = new SocketThread(ss, "ACCEPT-" + localEp);;public void listen(InetAddress localEp) throws IOException
    {
        socketThread = new SocketThread(getServerSocket(localEp), "ACCEPT-" + localEp);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_117d9_ae91d/rev_117d9-ae91d;/src/java/org/apache/cassandra/service/ClientState;hasColumnFamilySchemaAccess(String,Permission);        preventSystemKSModification(keyspace, perm);;        // hardcode disallowing messing with system keyspace
        if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && (perm != Permission.USE))
            throw new InvalidRequestException("system keyspace is not user-modifiable");;        // hardcode disallowing messing with system keyspace
        if (keyspace.equalsIgnoreCase(Table.SYSTEM_KS) && (perm != Permission.USE))
            throw new InvalidRequestException("system keyspace is not user-modifiable");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_137e1_a5b4d/rev_137e1-a5b4d;/src/com/opengamma/financial/analytics/HardCodedBSMEquityOptionVolatilitySurfaceAnalyticFunction;execute(FunctionExecutionContext,AnalyticFunctionInputs,Security);      if(optionDataFields == null) {
        throw new OpenGammaRuntimeException("No data available for option header " + justThisOptionHeader);
      }
      final double price = optionDataFields.getDouble(MarketDataAnalyticValue.INDICATIVE_VALUE_NAME);;      final double price = optionDataFields.getDouble(MarketDataAnalyticValue.INDICATIVE_VALUE_NAME);;      if(optionDataFields == null) {
        throw new NullPointerException("No market data available for " + justThisOptionHeader);
      }
      Double priceObj = optionDataFields.getDouble(MarketDataAnalyticValue.INDICATIVE_VALUE_NAME);
      if(priceObj == null) {
        throw new NullPointerException("Got a market data container, but no indicative value.");
      }
      final double price = priceObj;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_178c9_4f5d0/rev_178c9-4f5d0;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;deserialize(DataInputStream,Descriptor);            if (!desc.metadataIncludesModernReplayPosition)
            {
                // replay position may be "from the future" thanks to older versions generating them with nanotime.
                // make sure we don't omit replaying something that we should.  see CASSANDRA-4782
                replayPosition = ReplayPosition.NONE;
            }
            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp;            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp;            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.version.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_178c9_4f5d0/rev_178c9-4f5d0;/src/java/org/apache/cassandra/io/sstable/Descriptor;Descriptor(String,File,String,String,int,boolean);        assert version != null && directory != null && ksname != null && cfname != null;
        this.version = version;
        this.directory = directory;
        this.ksname = ksname;
        this.cfname = cfname;
        this.generation = generation;
        temporary = temp;
        hashCode = Objects.hashCode(directory, generation, ksname, cfname);

        hasStringsInBloomFilter = version.compareTo("c") < 0;
        hasIntRowSize = version.compareTo("d") < 0;
        hasEncodedKeys = version.compareTo("e") < 0;
        usesOldBloomFilter = version.compareTo("f") < 0;
        metadataIncludesReplayPosition = version.compareTo("g") >= 0;
        tracksMaxTimestamp = version.compareTo("hd") >= 0;
        hasCompressionRatio = version.compareTo("hb") >= 0;
        hasPartitioner = version.compareTo("hc") >= 0;
        hasAncestors = version.compareTo("he") >= 0;
        metadataIncludesModernReplayPosition = version.compareTo("hf") >= 0;
        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;;        assert version != null && directory != null && ksname != null && cfname != null;
        this.version = version;
        this.directory = directory;
        this.ksname = ksname;
        this.cfname = cfname;
        this.generation = generation;
        temporary = temp;
        hashCode = Objects.hashCode(directory, generation, ksname, cfname);

        hasStringsInBloomFilter = version.compareTo("c") < 0;
        hasIntRowSize = version.compareTo("d") < 0;
        hasEncodedKeys = version.compareTo("e") < 0;
        usesOldBloomFilter = version.compareTo("f") < 0;
        metadataIncludesReplayPosition = version.compareTo("g") >= 0;
        tracksMaxTimestamp = version.compareTo("hd") >= 0;
        hasCompressionRatio = version.compareTo("hb") >= 0;
        hasPartitioner = version.compareTo("hc") >= 0;
        hasAncestors = version.compareTo("he") >= 0;
        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;;        this(new Version(version), directory, ksname, cfname, generation, temp);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_0196a_10b4f/rev_0196a-10b4f;/realm-annotations-processor/src/main/java/io/realm/processor/RealmSourceCodeGenerator;generate();        // Emit java writer code in sections: 
        
        //   1. Package Header and imports
        emitPackage();
        
        //   2. class definition
        emitClass();
        
        //   3. public setters and getters for each field
        emitFields();

        // Generate initTable method, which is used to create the datqbase table

        String tableName = this.className.toLowerCase(Locale.getDefault());

        writer.beginMethod("Table", "initTable", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                "ImplicitTransaction", "transaction").
                beginControlFlow("if(!transaction.hasTable(\"" + tableName + "\"))").
                emitStatement("Table table = transaction.getTable(\"" + tableName + "\")");;        // Emit java writer code in sections: 
        
        //   1. Package Header and imports
        emitPackage();
        
        //   2. class definition
        emitClass();
        
        //   3. public setters and getters for each field
        emitFields();

        // Generate initTable method, which is used to create the datqbase table
        writer.beginMethod("Table", "initTable", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                "ImplicitTransaction", "transaction").
                beginControlFlow("if(!transaction.hasTable(\"" + this.className + "\"))").
                emitStatement("Table table = transaction.getTable(\"" + this.className + "\")");;        writer.emitPackage(packageName)
                .emitEmptyLine();

        writer.emitImports(
                "io.realm.internal.ColumnType",
                "io.realm.internal.Table",
                "io.realm.internal.ImplicitTransaction",
                "io.realm.internal.Row",
                "io.realm.internal.LinkView",
                "io.realm.RealmLinkList",
                "io.realm.RealmObject",
                "io.realm.RealmList")
                .emitEmptyLine();

        // Begin the class definition
        writer.beginType(
                qualifiedGeneratedClassName, // full qualified name of the item to generate
                "class",                     // the type of the item
                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                className)                   // class to extend
                .emitEmptyLine();

        // Accessors
        ListIterator<VariableElement> iterator = fields.listIterator();
        while (iterator.hasNext()) {
            int columnNumber = iterator.nextIndex();
            VariableElement field = iterator.next();

            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return (%s) row.get%s(%d)",
                        fieldTypeCanonicalName, realmType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "row.set%s(%d, (%s) value)",
                        realmType, columnNumber, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (realmGetRow().isNullLink(%d))", columnNumber);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, realmGetRow().getLink(%d))",
                        fieldTypeCanonicalName, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("realmGetRow().nullifyLink(%d)", columnNumber);
                writer.endControlFlow();
                writer.emitStatement("realmGetRow().setLink(%d, value.realmGetRow().getIndex())", columnNumber);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmLinkList(%s.class, realmGetRow().getLinkList(%d), realm)",
                        genericType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = realmGetRow().getLinkList(%d)", columnNumber);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.realmGetRow().getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s\")", this.className);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_0196a_10b4f/rev_0196a-10b4f;/realm-annotations-processor/src/main/java/io/realm/processor/RealmSourceCodeGenerator;generate();        for (FieldInfo field : fields) {

            if (field.columnType.equals("ColumnType.LINK")) {
                writer.emitStatement("table.addColumnLink( %s, \"%s\", %s)", field.columnType,
                    field.fieldName.toLowerCase(Locale.getDefault()), "table");
            }
            else {
                writer.emitStatement("table.addColumn( %s, \"%s\" )", field.columnType, field.fieldName.toLowerCase(Locale.getDefault()));
            };        for (FieldInfo field : fields) {
            writer.emitStatement("table.addColumn( %s, \"%s\" )", field.columnType, field.fieldName.toLowerCase(Locale.getDefault()));;        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName.toLowerCase(Locale.getDefault()));
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s\"))",
                        fieldName.toLowerCase(Locale.getDefault()), fieldTypeName.toLowerCase(Locale.getDefault()));
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s\"))",
                        fieldName.toLowerCase(Locale.getDefault()), genericType);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_206be_54601/rev_206be-54601;/projects/OG-Analytics/src/com/opengamma/analytics/financial/model/volatility/smile/fitting/interpolation/ShiftedLogNormalTailExtrapolationFitter;fitVolatilityAndGrad(double,double,double,double,double);
    final double minGrad = (isCall ? -(1 + blackDD) : -blackDD) / blackVega;
    final double maxGrad = (isCall ? -blackDD : 1 - blackDD) / blackVega;

    if (volGrad >= maxGrad || volGrad <= minGrad) {
      throw new IllegalArgumentException("Volatility smile must be in range " + minGrad + " to " + maxGrad + ", but valur is " + volGrad);;    if (isCall && dd >= 0.0) {
      final double maxVolGrad = -blackDD / blackVega;
      throw new IllegalArgumentException("Volatility smile is too steep - implies call prices that are not decreasing with strike. The maximum volGrad is " + maxVolGrad +
          " but value given is " + volGrad);;    if (isCall && dd >= 0.0) {
      final double maxVolGrad = -blackDD / blackVega;
      throw new IllegalArgumentException("At T = " + timeToExpiry + ", volatility smile is too steep - implies call prices that are not decreasing with strike. The maximum slope is " + maxVolGrad +
          " but value given is " + volGrad);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_225cb_6f8d7/rev_225cb-6f8d7;/src/java/org/apache/cassandra/service/CacheService;load(Set<ByteBuffer>,ColumnFamilyStore);                ColumnFamily data = cfs.getTopLevelColumns(QueryFilter.getIdentityFilter(dk, new QueryPath(cfs.columnFamily)), Integer.MIN_VALUE, true);
                if (data != null)
                    rowCache.put(new RowCacheKey(cfs.metadata.cfId, dk), data);;                ColumnFamily data = cfs.getTopLevelColumns(QueryFilter.getIdentityFilter(dk, new QueryPath(cfs.columnFamily)), Integer.MIN_VALUE, true);
                rowCache.put(new RowCacheKey(cfs.metadata.cfId, dk), data);;                ColumnFamily data = cfs.getTopLevelColumns(QueryFilter.getIdentityFilter(dk, cfs.name), Integer.MIN_VALUE, true);
                rowCache.put(new RowCacheKey(cfs.metadata.cfId, dk), data);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356;/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen;generateInitializers(ExpressionCodegen,InstructionAdapter);                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, declaration);
                if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {;                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, (JetProperty) declaration);
                if ((boolean) state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {;                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, (JetProperty) declaration);
                if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356;/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer;visitQualifiedExpression(JetQualifiedExpression,TypeInferenceContext);
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, new TypeInferenceContext(context.trace, context.scope, false, context.dataFlowInfo, NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));

            if (selectorExpression instanceof JetSimpleNameExpression) {
                propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);
            }

            if (receiverType == null) return null;;            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, new TypeInferenceContext(context.trace, context.scope, false, context.dataFlowInfo, NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (receiverType == null) return null;;            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, context.replaceExpectedTypes(NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (selectorExpression == null) return null;
            if (receiverType == null) receiverType = ErrorUtils.createErrorType("Type for " + expression.getText());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;IndexWriter(Directory,IndexWriterConfig);    
    bufferedDeletesStream = new BufferedDeletesStream(messageID);
    bufferedDeletesStream.setInfoStream(infoStream);;    
    bufferedDeletes = new BufferedDeletes(messageID);
    bufferedDeletes.setInfoStream(infoStream);;
    bufferedDeletes = new BufferedDeletes(messageID);
    bufferedDeletes.setInfoStream(infoStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;addIndexes(IndexReader);                                               fieldInfos.newFieldInfosWithGlobalFieldNumberMap());
      ;                                               ((FieldInfos) docWriter.getFieldInfos().clone()));
      ;                                               ((FieldInfos) docWriter.getFieldInfos().clone()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;doFlush(boolean);      if (!applyAllDeletes) {
        // If deletes alone are consuming > 1/2 our RAM
        // buffer, force them all to apply now. This is to
        // prevent too-frequent flushing of a long tail of
        // tiny segments:
        if (flushControl.getFlushDeletes() ||
            (config.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH &&
             bufferedDeletesStream.bytesUsed() > (1024*1024*config.getRAMBufferSizeMB()/2))) {
          applyAllDeletes = true;
          if (infoStream != null) {
            message("force apply deletes bytesUsed=" + bufferedDeletesStream.bytesUsed() + " vs ramBuffer=" + (1024*1024*config.getRAMBufferSizeMB()));;      if (!applyAllDeletes) {
        // If deletes alone are consuming > 1/2 our RAM
        // buffer, force them all to apply now. This is to
        // prevent too-frequent flushing of a long tail of
        // tiny segments:
        if (flushControl.getFlushDeletes() ||
            (config.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH &&
             bufferedDeletes.bytesUsed() > (1024*1024*config.getRAMBufferSizeMB()/2))) {
          applyAllDeletes = true;
          if (infoStream != null) {
            message("force apply deletes bytesUsed=" + bufferedDeletes.bytesUsed() + " vs ramBuffer=" + (1024*1024*config.getRAMBufferSizeMB()));;      boolean maybeMerge = docWriter.flushAllThreads(applyAllDeletes);

      synchronized(this) {
        if (!applyAllDeletes) {
          // If deletes alone are consuming > 1/2 our RAM
          // buffer, force them all to apply now. This is to
          // prevent too-frequent flushing of a long tail of
          // tiny segments:
          if (flushControl.getFlushDeletes() ||
              (config.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH &&
               bufferedDeletes.bytesUsed() > (1024*1024*config.getRAMBufferSizeMB()/2))) {
            applyAllDeletes = true;
            if (infoStream != null) {
              message("force apply deletes bytesUsed=" + bufferedDeletes.bytesUsed() + " vs ramBuffer=" + (1024*1024*config.getRAMBufferSizeMB()));
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_268bd_64808/rev_268bd-64808;/lucene/src/java/org/apache/lucene/index/IndexWriter;doFlush(boolean);      if (applyAllDeletes) {
        if (infoStream != null) {
          message("apply all deletes during flush");
        }
        flushDeletesCount.incrementAndGet();
        final BufferedDeletesStream.ApplyDeletesResult result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos);
        if (result.anyDeletes) {
          checkpoint();;      if (applyAllDeletes) {
        if (infoStream != null) {
          message("apply all deletes during flush");
        }
        flushDeletesCount.incrementAndGet();
        if (bufferedDeletes.applyDeletes(readerPool, segmentInfos, segmentInfos)) {
          checkpoint();;        if (applyAllDeletes) {
          if (infoStream != null) {
            message("apply all deletes during flush");
          }
          flushDeletesCount.incrementAndGet();
          if (bufferedDeletes.applyDeletes(readerPool, segmentInfos, segmentInfos)) {
            checkpoint();
          }
          flushControl.clearDeletes();
        } else if (infoStream != null) {
          message("don't apply deletes now delTermCount=" + bufferedDeletes.numTerms() + " bytesUsed=" + bufferedDeletes.bytesUsed());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_290c6_35d8f/rev_290c6-35d8f;/src/java/org/apache/cassandra/service/AbstractRowResolver;preprocess(Message);            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn));
            if (logger.isDebugEnabled())
                logger.debug("Preprocessed {} response", result.isDigestQuery() ? "digest" : "data");;            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn));;            ReadResponse result = ReadResponse.serializer().deserialize(new DataInputStream(bufIn), message.getVersion());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_296da_b1f3f/rev_296da-b1f3f;/src/java/org/apache/cassandra/net/OutboundTcpConnection;connect();        long start = System.currentTimeMillis();
        while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout());        targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());

        long start = System.currentTimeMillis();
        while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout());        targetVersion = MessagingService.instance().getVersion(poolReference.endPoint());

        long start = System.nanoTime();
        long timeout = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getRpcTimeout());
        while (System.nanoTime() - start < timeout)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_296da_b1f3f/rev_296da-b1f3f;/src/java/org/apache/cassandra/net/OutboundTcpConnection;connect();                    DataInputStream in = new DataInputStream(socket.getInputStream());
                    int maxTargetVersion = handshakeVersion(in);
                    if (maxTargetVersion == NO_VERSION) 
                    {
                        // no version is returned, so disconnect an try again: we will either get
                        // a different target version (targetVersion < MessagingService.VERSION_12)
                        // or if the same version the handshake will finally succeed
                        logger.debug("Target max version is {}; no version information yet, will retry", maxTargetVersion);
                        disconnect();
                        continue;
                    }
                    if (targetVersion > maxTargetVersion)
                    {
                        logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);
                        MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);
                        disconnect();
                        return false;
                    };                    DataInputStream in = new DataInputStream(socket.getInputStream());
                    int maxTargetVersion = in.readInt();
                    if (targetVersion > maxTargetVersion)
                    {
                        logger.debug("Target max version is {}; will reconnect with that version", maxTargetVersion);
                        MessagingService.instance().setVersion(poolReference.endPoint(), maxTargetVersion);
                        disconnect();
                        return false;
                    };                if (targetVersion < maxTargetVersion && targetVersion < MessagingService.current_version)
                {
                    logger.trace("Detected higher max version {} (using {}); will reconnect when queued messages are done",
                                 maxTargetVersion, targetVersion);
                    MessagingService.instance().setVersion(poolReference.endPoint(), Math.min(MessagingService.current_version, maxTargetVersion));
                    softCloseSocket();
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_303ff_baf52/rev_303ff-baf52;/src/java/org/apache/cassandra/db/ColumnFamily;getColumnStats();            RangeTombstone rangeTombstone = it.next();
            tombstones.update(rangeTombstone.getLocalDeletionTime());

            minColumnNamesSeen = ColumnNameHelper.minComponents(minColumnNamesSeen, rangeTombstone.min, metadata.comparator);
            maxColumnNamesSeen = ColumnNameHelper.maxComponents(maxColumnNamesSeen, rangeTombstone.max, metadata.comparator);
        }

        for (Column column : this)
        {
            minTimestampSeen = Math.min(minTimestampSeen, column.minTimestamp());
            maxTimestampSeen = Math.max(maxTimestampSeen, column.maxTimestamp());
            maxLocalDeletionTime = Math.max(maxLocalDeletionTime, column.getLocalDeletionTime());
            int deletionTime = column.getLocalDeletionTime();;            RangeTombstone rangeTombstone = it.next();
            tombstones.update(rangeTombstone.getLocalDeletionTime());
        }

        for (Column column : this)
        {
            minTimestampSeen = Math.min(minTimestampSeen, column.minTimestamp());
            maxTimestampSeen = Math.max(maxTimestampSeen, column.maxTimestamp());
            maxLocalDeletionTime = Math.max(maxLocalDeletionTime, column.getLocalDeletionTime());
            int deletionTime = column.getLocalDeletionTime();;            if (deletionInfo().getTopLevelDeletion().localDeletionTime < Integer.MAX_VALUE)
                tombstones.update(deletionInfo().getTopLevelDeletion().localDeletionTime);
            Iterator<RangeTombstone> it = deletionInfo().rangeIterator();
            while (it.hasNext())
            {
                RangeTombstone rangeTombstone = it.next();
                tombstones.update(rangeTombstone.getLocalDeletionTime());
            }
            minTimestampSeen = Math.min(minTimestampSeen, cell.timestamp());
            maxTimestampSeen = Math.max(maxTimestampSeen, cell.timestamp());
            maxLocalDeletionTime = Math.max(maxLocalDeletionTime, cell.getLocalDeletionTime());
            int deletionTime = cell.getLocalDeletionTime();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_304a2_78473/rev_304a2-78473;/src/java/org/apache/cassandra/io/sstable/Descriptor;Version(String);            hasRowLevelBF = version.compareTo("ic") < 0;;            hasBloomFilterSizeInHeader = version.compareTo("ia") < 0;;            hasBloomFilterSizeInHeader = version.compareTo("ia") < 0;
            hasSuperColumns = version.compareTo("ja") < 0;
            hasBloomFilterFPChance = version.compareTo("ja") >= 0;
            hasRowLevelBF = version.compareTo("ja") < 0;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_326b8_6d39c/rev_326b8-6d39c;/handler/src/main/java/io/netty/handler/ssl/SslHandler;unwrap(ChannelHandlerContext,Channel,ChannelBuffer,int,int);                ChannelBuffer frame = ctx.getChannel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());
                // Transfer the bytes to the new ChannelBuffer using some safe method that will also
                // work with "non" heap buffers
                //
                // See https://github.com/netty/netty/issues/329
                frame.writeBytes(outAppBuf);;                ChannelBuffer frame = ctx.getChannel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());
                frame.writeBytes(outAppBuf.array(), 0, frame.capacity());;                ChannelBuffer frame = ctx.channel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());
                frame.writeBytes(outAppBuf.array(), 0, frame.capacity());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_326b8_6d39c/rev_326b8-6d39c;/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler;handleDownstream(ChannelHandlerContext,ChannelEvent);        final Channel channel = ctx.getChannel();
        // call flush if the channel is writable or not connected. flush(..) will take care of the rest

        if (channel.isWritable() || !channel.isConnected()) {;        final Channel channel = ctx.getChannel();
        if (channel.isWritable()) {;        final Channel channel = ctx.channel();
        if (channel.isWritable()) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_326b8_6d39c/rev_326b8-6d39c;/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler;flush(ChannelHandlerContext,boolean);private void flush(ChannelHandlerContext ctx, boolean fireNow) throws Exception {
        boolean acquired = false;
        final Channel channel = ctx.getChannel();;private synchronized void flush(ChannelHandlerContext ctx, boolean fireNow) throws Exception {
        final Channel channel = ctx.getChannel();
        if (!channel.isConnected()) {
            discard(ctx, fireNow);
        };private synchronized void flush(ChannelHandlerContext ctx, boolean fireNow) throws Exception {
        final Channel channel = ctx.channel();
        if (!channel.isConnected()) {
            discard(ctx, fireNow);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_326b8_6d39c/rev_326b8-6d39c;/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler;flush(ChannelHandlerContext,boolean);                            ctx.sendDownstream(currentEvent);;                            closeInput(chunks);
                            writeFuture = currentEvent.getFuture();
                        } else {
                            writeFuture = future(channel);
                            writeFuture.addListener(new ChannelFutureListener() {
                                @Override
                                public void operationComplete(ChannelFuture future)
                                        throws Exception {
                                    if (!future.isSuccess()) {
                                        currentEvent.getFuture().setFailure(future.getCause());
                                        closeInput((ChunkedInput) currentEvent.getMessage());
                                    }
                                }
                            });;                            closeInput(chunks);
                            writeFuture = currentEvent.getFuture();
                        } else {
                            writeFuture = future(channel);
                            writeFuture.addListener(new ChannelFutureListener() {
                                @Override
                                public void operationComplete(ChannelFuture future)
                                        throws Exception {
                                    if (!future.isSuccess()) {
                                        currentEvent.getFuture().setFailure(future.cause());
                                        closeInput((ChunkedInput) currentEvent.getMessage());
                                    }
                                }
                            });
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_331ab_64b1e/rev_331ab-64b1e;/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin;getParentDoc(IndexReader,Filter,int);private Document getParentDoc(IndexReader reader, Filter parents, int childDocID) throws IOException {
    final List<AtomicReaderContext> leaves = reader.leaves();;private Document getParentDoc(IndexReader reader, Filter parents, int childDocID) throws IOException {
    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();;private StoredDocument getParentDoc(IndexReader reader, Filter parents, int childDocID) throws IOException {
    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_351c0_8a8e1/rev_351c0-8a8e1;/src/java/org/apache/cassandra/db/ColumnFamilyStore;scan(IndexClause,AbstractBounds,IFilter);                        extraFilter = getExtraFilter(clause);;                        NamesQueryFilter extraFilter = getExtraFilter(clause);;                        // Note: for counters we must be carefull to not add a column that was already there (to avoid overcount). That is
                        // why we do the dance of avoiding to query any column we already have (it's also more efficient anyway)
                        NamesQueryFilter extraFilter = getExtraFilter(clause);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_366a1_819cc/rev_366a1-819cc;/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract;release(DB);			pool.returnResource(iDatabase);
			this.notifyEvictor(dbPooledName, iDatabase);;      pool.returnResource(iDatabase);;      pool.returnResource(iDatabase);
      this.notifyEvictor(dbPooledName, iDatabase);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_366a1_819cc/rev_366a1-819cc;/core/src/main/java/com/orientechnologies/orient/core/db/ODatabasePoolAbstract;close();			if (this.evictionTask != null) {
				this.evictionTask.cancel();
			};      for (Entry<String, OResourcePool<String, DB>> pool : pools.entrySet()) {
        for (DB db : pool.getValue().getResources()) {
          pool.getValue().close();
          try {
            OLogManager.instance().debug(this, "Closing pooled database '%s'...", db.getName());
            ((ODatabasePooled) db).forceClose();
            OLogManager.instance().debug(this, "OK", db.getName());
          } catch (Exception e) {
            OLogManager.instance().debug(this, "Error: %d", e.toString());
          }
        }
      };      if (this.evictionTask != null) {
        this.evictionTask.cancel();
      }

      for (Entry<String, OResourcePool<String, DB>> pool : pools.entrySet()) {
        for (DB db : pool.getValue().getResources()) {
          pool.getValue().close();
          try {
            OLogManager.instance().debug(this, "Closing pooled database '%s'...", db.getName());
            ((ODatabasePooled) db).forceClose();
            OLogManager.instance().debug(this, "OK", db.getName());
          } catch (Exception e) {
            OLogManager.instance().debug(this, "Error: %d", e.toString());
          }
        }
      }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_366a1_819cc/rev_366a1-819cc;/core/src/main/java/com/orientechnologies/orient/core/fetch/OFetchHelper;processRecordRidMap(ORecordSchemaAware<?>,Map<String,Integer>,int,int,int,Map<ORID,Integer>,String,OFetchContext);          final boolean isEmbedded = fieldValue instanceof ODocument
              && (((ODocument) fieldValue).isEmbedded() || !((ODocument) fieldValue).getIdentity().isValid());

          if (!(isEmbedded && iContext.fetchEmbeddedDocuments()) && !iFetchPlan.containsKey(fieldPath.toUpperCase())
              && depthLevel > -1 && iCurrentLevel >= depthLevel);          final boolean isEmbedded = fieldValue instanceof ODocument
              && (((ODocument) fieldValue).isEmbedded() || !((ODocument) fieldValue).getIdentity().isValid());

          if (!(isEmbedded && iContext.fetchEmbeddedDocuments()) && !iFetchPlan.containsKey(fieldPath) && depthLevel > -1
              && iCurrentLevel >= depthLevel);          final boolean isEmbedded = isEmbedded(fieldValue);
          if (!(isEmbedded && iContext.fetchEmbeddedDocuments()) && !iFetchPlan.containsKey(fieldPath.toUpperCase())
              && depthLevel > -1 && iCurrentLevel >= depthLevel)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_366a1_819cc/rev_366a1-819cc;/commons/src/main/java/com/orientechnologies/common/serialization/types/OStringSerializer;serializeNative(String,byte[],int,Object);    int pos = startPosition + OIntegerSerializer.INT_SIZE;

    byte[] binaryData = new byte[length * 2];
    char[] stringContent = new char[length];

    object.getChars(0, length, stringContent, 0);

    int counter = 0;
    for (char character : stringContent) {
      binaryData[counter] = (byte) character;
      counter++;

      binaryData[counter] = (byte) (character >>> 8);
      counter++;;    int pos = startPosition + OIntegerSerializer.INT_SIZE;
    for (int i = 0; i < length; i++) {
      final char strChar = object.charAt(i);
      CONVERTER.putChar(stream, pos, strChar, ByteOrder.nativeOrder());
      pos += 2;;    startPosition += OIntegerSerializer.INT_SIZE;
    char[] stringContent = new char[length];

    object.getChars(0, length, stringContent, 0);

    for (char character : stringContent) {
      stream[startPosition] = (byte) character;
      startPosition++;

      stream[startPosition] = (byte) (character >>> 8);
      startPosition++;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412;/src/java/voldemort/client/SocketStoreClientFactory;SocketStoreClientFactory(ClientConfig);            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));
        _config = config;;            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));;            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412;/src/java/voldemort/client/AbstractStoreClientFactory;AbstractStoreClientFactory(ClientConfig);                                                         config.getRoutingTimeout(TimeUnit.MILLISECONDS));
        this.sequencer = new AtomicInteger(0);;                                                         config.getRoutingTimeout(TimeUnit.MILLISECONDS));;                                                         config.getTimeoutConfig());

        this.sequencer = new AtomicInteger(0);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412;/src/java/voldemort/client/AbstractStoreClientFactory;jmxId();private String jmxId() {
        return jmxId == 0 ? "" : "." + Integer.toString(jmxId);;private String jmxId() {
        return jmxId == 0 ? "" : Integer.toString(jmxId);;public String jmxId() {
        return jmxId == 0 ? "" : Integer.toString(jmxId);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_367c7_8602f/rev_367c7-8602f;/test/unit/org/apache/cassandra/db/compaction/CompactionsTest;testSingleSSTableCompaction(String);        long timestamp = populate(KEYSPACE1, STANDARD1, 0, 9, 3); //ttl=3s;        long timestamp = System.currentTimeMillis();
        for (int i = 0; i < 10; i++)
        {
            DecoratedKey key = Util.dk(Integer.toString(i));
            RowMutation rm = new RowMutation(KEYSPACE1, key.key);
            for (int j = 0; j < 10; j++)
                rm.add("Standard1", ByteBufferUtil.bytes(Integer.toString(j)),
                       ByteBufferUtil.EMPTY_BYTE_BUFFER,
                       timestamp,
                       j > 0 ? 3 : 0); // let first column never expire, since deleting all columns does not produce sstable
            rm.apply();
        };        long timestamp = System.currentTimeMillis();
        for (int i = 0; i < 10; i++)
        {
            DecoratedKey key = Util.dk(Integer.toString(i));
            Mutation rm = new Mutation(KEYSPACE1, key.getKey());
            for (int j = 0; j < 10; j++)
                rm.add("Standard1", Util.cellname(Integer.toString(j)),
                       ByteBufferUtil.EMPTY_BYTE_BUFFER,
                       timestamp,
                       j > 0 ? 3 : 0); // let first column never expire, since deleting all columns does not produce sstable
            rm.apply();
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_368c0_ff746/rev_368c0-ff746;/core/src/test/java/com/orientechnologies/orient/core/index/sbtree/local/SBTreeWAL;createActualSBTree();    sbTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, true);
    sbTree.create("actualSBTree", OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, actualStorage);;    sbTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, false);
    sbTree.create("actualSBTree", OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, actualStorage);;    sbTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, false);
    sbTree.create("actualSBTree", 0, OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, actualStorage);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_368c0_ff746/rev_368c0-ff746;/core/src/test/java/com/orientechnologies/orient/core/index/sbtree/local/SBTreeWAL;createExpectedSBTree();    expectedSBTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, true);
    expectedSBTree.create("expectedSBTree", OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, expectedStorage);;    expectedSBTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, false);
    expectedSBTree.create("expectedSBTree", OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, expectedStorage);;    expectedSBTree = new OSBTree<Integer, OIdentifiable>(".sbt", 1, false);
    expectedSBTree.create("expectedSBTree", 0, OIntegerSerializer.INSTANCE, OLinkSerializer.INSTANCE, expectedStorage);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_368c0_ff746/rev_368c0-ff746;/core/src/test/java/com/orientechnologies/orient/core/index/sbtree/local/SBTreeCompositeKeyTest;beforeClass();    localSBTree.create("localSBTreeCompositeKeyTest", OCompositeKeySerializer.INSTANCE, OLinkSerializer.INSTANCE,
        (OStorageLocalAbstract) databaseDocumentTx.getStorage().getUnderlying());;    localSBTree.create("localSBTreeCompositeKeyTest", OCompositeKeySerializer.INSTANCE, OLinkSerializer.INSTANCE,
        (OStorageLocalAbstract) databaseDocumentTx.getStorage());;    localSBTree.create("localSBTreeCompositeKeyTest", 0, OCompositeKeySerializer.INSTANCE, OLinkSerializer.INSTANCE,
        (OStorageLocalAbstract) databaseDocumentTx.getStorage());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_374fa_6f65c/rev_374fa-6f65c;/src/java/org/apache/cassandra/config/KSMetaData;systemKeyspace();                                                CFMetaData.SchemaColumnsCf);
        return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, Collections.<String, String>emptyMap(), true, cfDefs);;                                                CFMetaData.SchemaColumnsCf);
        return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, optsWithRF(1), true, cfDefs);;                                                CFMetaData.SchemaColumnsCf,
                                                CFMetaData.HostIdCf);
        return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, optsWithRF(1), true, cfDefs);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_377cc_b77df/rev_377cc-b77df;/projects/OG-MasterDB/src/com/opengamma/masterdb/historicaltimeseries/DbHistoricalTimeSeriesMaster;getTimeSeries(ObjectIdentifiable,VersionCorrection,LocalDate,LocalDate);    if (toDateInclusive == null || fromDateInclusive == null || !toDateInclusive.isBefore(fromDateInclusive)) {
      LocalDateDoubleTimeSeries series = namedJdbc.query(sqlSelectDataPoints(), args, new DataPointsExtractor());
      result.setTimeSeries(series);
    } else {
      //TODO: this is a hack, most of the places that call with this condition want some kind of metadata, which it would be cheaper for us to expose specifically
      result.setTimeSeries(new ArrayLocalDateDoubleTimeSeries());
    }
    return result;;    LocalDateDoubleTimeSeries series = namedJdbc.query(sqlSelectDataPoints(), args, new DataPointsExtractor());
    result.setTimeSeries(series);
    return result;;    
    // Get actual data points
    LocalDateDoubleTimeSeries series = namedJdbc.query(sqlSelectDataPoints(), args, new DataPointsExtractor());
    result.setTimeSeries(series);
    return result;  
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_384de_de8a4/rev_384de-de8a4;/src/java/org/apache/cassandra/db/HintedHandOffManager;doDeliverHintsToEndpoint(InetAddress);            for (final Column hint : hintsPage);            Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
            for (final Column hint : hintsPage);            Map<UUID, Long> truncationTimesCache = new HashMap<UUID, Long>();
            for (final Cell hint : hintsPage)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_384de_de8a4/rev_384de-de8a4;/src/java/org/apache/cassandra/db/HintedHandOffManager;doDeliverHintsToEndpoint(InetAddress);                for (UUID cfId : rm.getColumnFamilyIds());                truncationTimesCache.clear();
                for (UUID cfId : ImmutableSet.copyOf((rm.getColumnFamilyIds())));                truncationTimesCache.clear();
                for (UUID cfId : ImmutableSet.copyOf((mutation.getColumnFamilyIds())))
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueConventionArbitrage();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final double rate360 = 0.0360;
    final CMSIndex index360 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/360"), INDEX, ANNUITY_TENOR);
    final SwapFixedIborDefinition swap360 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index360, NOTIONAL, rate360, FIXED_IS_PAYER);
    final SwaptionPhysicalFixedIborDefinition swaption360Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap360, IS_LONG);
    final SwaptionPhysicalFixedIbor swaption360 = swaption360Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    final double rate365 = 0.0365;
    final CMSIndex index365 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/365"), INDEX, ANNUITY_TENOR);
    final SwapFixedIborDefinition swap365 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index365, NOTIONAL, rate365, FIXED_IS_PAYER);
    final SwaptionPhysicalFixedIborDefinition swaption365Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap365, IS_LONG);
    final SwaptionPhysicalFixedIbor swaption365 = swaption365Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    final double price360 = PVC.visit(swaption360, sabrBundle);
    final double price365 = PVC.visit(swaption365, sabrBundle);;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    double rate360 = 0.0360;
    CMSIndex index360 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/360"), INDEX, ANNUITY_TENOR);
    SwapFixedIborDefinition swap360 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index360, NOTIONAL, rate360, FIXED_IS_PAYER);
    SwaptionPhysicalFixedIborDefinition swaption360Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap360, IS_LONG);
    SwaptionPhysicalFixedIbor swaption360 = swaption360Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    double rate365 = 0.0365;
    CMSIndex index365 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/365"), INDEX, ANNUITY_TENOR);
    SwapFixedIborDefinition swap365 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index365, NOTIONAL, rate365, FIXED_IS_PAYER);
    SwaptionPhysicalFixedIborDefinition swaption365Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap365, IS_LONG);
    SwaptionPhysicalFixedIbor swaption365 = swaption365Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    double price360 = PVC.visit(swaption360, sabrBundle);
    double price365 = PVC.visit(swaption365, sabrBundle);;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    double rate360 = 0.0360;
    CMSIndex index360 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/360"), IBOR_INDEX, ANNUITY_TENOR);
    SwapFixedIborDefinition swap360 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index360, NOTIONAL, rate360, FIXED_IS_PAYER);
    SwaptionPhysicalFixedIborDefinition swaption360Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap360, IS_LONG);
    SwaptionPhysicalFixedIbor swaption360 = swaption360Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    double rate365 = 0.0365;
    CMSIndex index365 = new CMSIndex(FIXED_PAYMENT_PERIOD, DayCountFactory.INSTANCE.getDayCount("Actual/365"), IBOR_INDEX, ANNUITY_TENOR);
    SwapFixedIborDefinition swap365 = SwapFixedIborDefinition.from(SETTLEMENT_DATE, index365, NOTIONAL, rate365, FIXED_IS_PAYER);
    SwaptionPhysicalFixedIborDefinition swaption365Definition = SwaptionPhysicalFixedIborDefinition.from(EXPIRY_DATE, swap365, IS_LONG);
    SwaptionPhysicalFixedIbor swaption365 = swaption365Definition.toDerivative(REFERENCE_DATE, CURVES_NAME);
    double price360 = PVC.visit(swaption360, sabrBundle);
    double price365 = PVC.visit(swaption365, sabrBundle);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueSensitivity();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueSABRSensitivity();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueSABRSensitivity();    final SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shift);
    final SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    final double pvLongPayerAlphaBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleAlphaBumped);
    final double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shift);
    SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    double pvLongPayerAlphaBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleAlphaBumped);
    double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shift);
    SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    double pvLongPayerAlphaBumped = METHOD.presentValue(SWAPTION_LONG_PAYER, sabrBundleAlphaBumped);
    double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shift;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueSABRSensitivity();    final SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped(shift);
    final SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    final double pvLongPayerRhoBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleRhoBumped);
    final double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped(shift);
    SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    double pvLongPayerRhoBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleRhoBumped);
    double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped(shift);
    SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    double pvLongPayerRhoBumped = METHOD.presentValue(SWAPTION_LONG_PAYER, sabrBundleRhoBumped);
    double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPresentValueSABRSensitivity();    final SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped(shift);
    final SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    final double pvLongPayerNuBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleNuBumped);
    final double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped(shift);
    SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    double pvLongPayerNuBumped = method.presentValue(SWAPTION_LONG_PAYER, sabrBundleNuBumped);
    double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped(shift);
    SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    double pvLongPayerNuBumped = METHOD.presentValue(SWAPTION_LONG_PAYER, sabrBundleNuBumped);
    double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/SwaptionPhysicalFixedIborSABRMethodTest;testPerformance();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    SwaptionPhysicalFixedIborSABRMethod method = new SwaptionPhysicalFixedIborSABRMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueRateSensitivitySABRParameters();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final CouponCMSSABRReplicationMethod method = new CouponCMSSABRReplicationMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    CouponCMSSABRReplicationMethod method = new CouponCMSSABRReplicationMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueRateSensitivitySABRParameters();      final SABRInterestRateDataBundle sabrBundleBumped = new SABRInterestRateDataBundle(sabrParameter, curvesBumped);
      final double bumpedpv = method.presentValue(cmsBumpedFunding, sabrBundleBumped);;      SABRInterestRateDataBundle sabrBundleBumped = new SABRInterestRateDataBundle(sabrParameter, curvesBumped);
      final double bumpedpv = method.presentValue(cmsBumpedFunding, sabrBundleBumped);;      SABRInterestRateDataBundle sabrBundleBumped = new SABRInterestRateDataBundle(sabrParameter, curvesBumped);
      final double bumpedpv = METHOD.presentValue(cmsBumpedFunding, sabrBundleBumped);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueSABRSensitivitySABRParameters();    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    final SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    final CouponCMSSABRReplicationMethod method = new CouponCMSSABRReplicationMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
    CouponCMSSABRReplicationMethod method = new CouponCMSSABRReplicationMethod();;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    SABRInterestRateParameter sabrParameter = TestsDataSets.createSABR1();
    SABRInterestRateDataBundle sabrBundle = new SABRInterestRateDataBundle(sabrParameter, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueSABRSensitivitySABRParameters();    final SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shiftAlpha);
    final SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    final double pvLongPayerAlphaBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleAlphaBumped);
    final double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shiftAlpha;;    SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shiftAlpha);
    SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    double pvLongPayerAlphaBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleAlphaBumped);
    double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shiftAlpha;;    SABRInterestRateParameter sabrParameterAlphaBumped = TestsDataSets.createSABR1AlphaBumped(shiftAlpha);
    SABRInterestRateDataBundle sabrBundleAlphaBumped = new SABRInterestRateDataBundle(sabrParameterAlphaBumped, curves);
    double pvLongPayerAlphaBumped = METHOD.presentValue(CMS_COUPON_RECEIVER, sabrBundleAlphaBumped);
    double expectedAlphaSensi = (pvLongPayerAlphaBumped - pvLongPayer) / shiftAlpha;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueSABRSensitivitySABRParameters();    final SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped();
    final SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    final double pvLongPayerRhoBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleRhoBumped);
    final double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped();
    SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    double pvLongPayerRhoBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleRhoBumped);
    double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterRhoBumped = TestsDataSets.createSABR1RhoBumped();
    SABRInterestRateDataBundle sabrBundleRhoBumped = new SABRInterestRateDataBundle(sabrParameterRhoBumped, curves);
    double pvLongPayerRhoBumped = METHOD.presentValue(CMS_COUPON_RECEIVER, sabrBundleRhoBumped);
    double expectedRhoSensi = (pvLongPayerRhoBumped - pvLongPayer) / shift;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_399fe_136db/rev_399fe-136db;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/CouponCMSSABRReplicationMethodTest;testPresentValueSABRSensitivitySABRParameters();    final SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped();
    final SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    final double pvLongPayerNuBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleNuBumped);
    final double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped();
    SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    double pvLongPayerNuBumped = method.presentValue(CMS_COUPON_RECEIVER, sabrBundleNuBumped);
    double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;;    SABRInterestRateParameter sabrParameterNuBumped = TestsDataSets.createSABR1NuBumped();
    SABRInterestRateDataBundle sabrBundleNuBumped = new SABRInterestRateDataBundle(sabrParameterNuBumped, curves);
    double pvLongPayerNuBumped = METHOD.presentValue(CMS_COUPON_RECEIVER, sabrBundleNuBumped);
    double expectedNuSensi = (pvLongPayerNuBumped - pvLongPayer) / shift;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addEUFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 3m"), Identifier.of(OG_SYNTHETIC_TICKER, "EURLIBORP3M")), "EUR LIBOR 3m", act360, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 3m")), "EUR LIBOR 3m", act360, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0003M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 3m")), "EUR LIBOR 3m", act360, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addEUFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 6m"), Identifier.of(OG_SYNTHETIC_TICKER, "EURLIBORP6M")), "EUR LIBOR 6m", act360, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 6m")), "EUR LIBOR 6m", act360, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0006M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 6m")), "EUR LIBOR 6m", act360, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addEUFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 12m"), Identifier.of(OG_SYNTHETIC_TICKER, "EURLIBORP6M")), "EUR LIBOR 12m", act360, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 12m")), "EUR LIBOR 12m", act360, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("EU0012M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "EUR LIBOR 12m")), "EUR LIBOR 12m", act360, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addJPFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 3m"), Identifier.of(OG_SYNTHETIC_TICKER, "JPYLIBORP3M")), "JPY LIBOR 3m", act360, following,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 3m")), "JPY LIBOR 3m", act360, following,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0003M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 3m")), "JPY LIBOR 3m", act360, following,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addJPFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 6m"), Identifier.of(OG_SYNTHETIC_TICKER, "JPYLIBORP6M")), "JPY LIBOR 6m", act360, following,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 6m")), "JPY LIBOR 6m", act360, following,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0006M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 6m")), "JPY LIBOR 6m", act360, following,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addJPFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 12m"), Identifier.of(OG_SYNTHETIC_TICKER, "JPYLIBORP12M")), "JPY LIBOR 12m", act360, following,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 12m")), "JPY LIBOR 12m", act360, following,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("JY0012M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "JPY LIBOR 12m")), "JPY LIBOR 12m", act360, following,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addGBFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 3m"), Identifier.of(OG_SYNTHETIC_TICKER, "GBPLIBORP3M")), "GBP LIBOR 3m", act365, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0003M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 3m")), "GBP LIBOR 3m", act365, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0003M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 3m")), "GBP LIBOR 3m", act365, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addGBFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 6m"), Identifier.of(OG_SYNTHETIC_TICKER, "GBPLIBORP6M")), "GBP LIBOR 6m", act365, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 6m")), "GBP LIBOR 6m", act365, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0006M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 6m")), "GBP LIBOR 6m", act365, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addGBFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 12m"), Identifier.of(OG_SYNTHETIC_TICKER, "GBPLIBORP12M")), "GBP LIBOR 12m", act365, modified,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0012M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 12m")), "GBP LIBOR 12m", act365, modified,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("BP0012M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "GBP LIBOR 12m")), "GBP LIBOR 12m", act365, modified,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_412e2_f4b6f/rev_412e2-f4b6f;/projects/OG-Financial/src/com/opengamma/financial/convention/InMemoryConventionBundleMaster;addCHFixedIncomeInstruments();        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("SF0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "CHF LIBOR 6m"), Identifier.of(OG_SYNTHETIC_TICKER, "CHFLIBORP6M")), "CHF LIBOR 6m", act360, following,;        IdentifierBundle.of(SecurityUtils.bloombergTickerSecurityId("SF0006M Index"),
            Identifier.of(SIMPLE_NAME_SCHEME, "CHF LIBOR 6m")), "CHF LIBOR 6m", act360, following,;        ExternalIdBundle.of(SecurityUtils.bloombergTickerSecurityId("SF0006M Index"),
            ExternalId.of(SIMPLE_NAME_SCHEME, "CHF LIBOR 6m")), "CHF LIBOR 6m", act360, following,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_422d2_371e7/rev_422d2-371e7;/test/unit/org/apache/cassandra/db/KeyCacheTest;testKeyCacheLoad();        readData(TABLE1, COLUMN_FAMILY2, 0, 100);
        assertKeyCacheSize(100, TABLE1, COLUMN_FAMILY2);;        readData(TABLE1, COLUMN_FAMILY2, 0, 100);
        assertEquals(100, CacheService.instance.keyCache.size());;        readData(KEYSPACE1, COLUMN_FAMILY2, 0, 100);
        assertEquals(100, CacheService.instance.keyCache.size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_442a7_f9100/rev_442a7-f9100;/src/java/org/apache/cassandra/service/StorageService;joinTokenRing(int);
        // gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)
        Schema.instance.updateVersion(); // Ensure we know our own actual Schema UUID in preparation for updates
        MigrationManager.passiveAnnounce(Schema.emptyVersion);;        // gossip schema version when gossiper is running
        Schema.instance.updateVersionAndAnnounce();;        // gossip network proto version
        Gossiper.instance.addLocalApplicationState(ApplicationState.NET_VERSION, valueFactory.networkVersion());
        Gossiper.instance.addLocalApplicationState(ApplicationState.HOST_ID, valueFactory.hostId(SystemTable.getLocalHostId()));
        // gossip snitch infos (local DC and rack)
        gossipSnitchInfo();
        // gossip schema version when gossiper is running
        Schema.instance.updateVersionAndAnnounce();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_783ce/rev_446e3-783ce;/src/java/org/apache/cassandra/thrift/CassandraServer;multigetSliceInternal(String,List<ByteBuffer>,ColumnParent,SlicePredicate,ConsistencyLevel);        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);;        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);;        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family);
        ThriftValidation.validateColumnParent(metadata, column_parent);
        ThriftValidation.validatePredicate(metadata, column_parent, predicate);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_783ce/rev_446e3-783ce;/src/java/org/apache/cassandra/thrift/CassandraServer;get(ByteBuffer,ColumnPath,ConsistencyLevel);        ThriftValidation.validateColumnPath(keyspace, column_path);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);

        QueryPath path = new QueryPath(column_path.column_family, column_path.column == null ? null : column_path.super_column);
        List<ByteBuffer> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
        ThriftValidation.validateKey(key);
        ReadCommand command = new SliceByNamesReadCommand(keyspace, key, path, nameAsList);

        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(Arrays.asList(command), consistency_level);

        ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));

        if (cf == null)
            throw new NotFoundException();
        List<ColumnOrSuperColumn> tcolumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, false);
        if (tcolumns.isEmpty())
            throw new NotFoundException();
        assert tcolumns.size() == 1;
        return tcolumns.get(0);;        ThriftValidation.validateColumnPath(keyspace, column_path);

        QueryPath path = new QueryPath(column_path.column_family, column_path.column == null ? null : column_path.super_column);
        List<ByteBuffer> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
        ThriftValidation.validateKey(key);
        ReadCommand command = new SliceByNamesReadCommand(keyspace, key, path, nameAsList);

        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(Arrays.asList(command), consistency_level);

        ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));

        if (cf == null)
            throw new NotFoundException();
        List<ColumnOrSuperColumn> tcolumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, false);
        if (tcolumns.isEmpty())
            throw new NotFoundException();
        assert tcolumns.size() == 1;
        return tcolumns.get(0);;        return internal_get(key, column_path, consistency_level);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_783ce/rev_446e3-783ce;/src/java/org/apache/cassandra/thrift/CassandraServer;get_indexed_slices(ColumnParent,IndexClause,SlicePredicate,ConsistencyLevel);        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);;        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);;        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, false);
        ThriftValidation.validateColumnParent(metadata, column_parent);
        ThriftValidation.validatePredicate(metadata, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(metadata, index_clause);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_fed37/rev_446e3-fed37;/src/java/org/apache/cassandra/thrift/CassandraServer;multigetSliceInternal(String,List<ByteBuffer>,ColumnParent,SlicePredicate,ConsistencyLevel);        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);;        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);;        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family);
        ThriftValidation.validateColumnParent(metadata, column_parent);
        ThriftValidation.validatePredicate(metadata, column_parent, predicate);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_fed37/rev_446e3-fed37;/src/java/org/apache/cassandra/thrift/CassandraServer;get(ByteBuffer,ColumnPath,ConsistencyLevel);        ThriftValidation.validateColumnPath(keyspace, column_path);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);

        QueryPath path = new QueryPath(column_path.column_family, column_path.column == null ? null : column_path.super_column);
        List<ByteBuffer> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
        ThriftValidation.validateKey(key);
        ReadCommand command = new SliceByNamesReadCommand(keyspace, key, path, nameAsList);

        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(Arrays.asList(command), consistency_level);

        ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));

        if (cf == null)
            throw new NotFoundException();
        List<ColumnOrSuperColumn> tcolumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, false);
        if (tcolumns.isEmpty())
            throw new NotFoundException();
        assert tcolumns.size() == 1;
        return tcolumns.get(0);;        ThriftValidation.validateColumnPath(keyspace, column_path);

        QueryPath path = new QueryPath(column_path.column_family, column_path.column == null ? null : column_path.super_column);
        List<ByteBuffer> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
        ThriftValidation.validateKey(key);
        ReadCommand command = new SliceByNamesReadCommand(keyspace, key, path, nameAsList);

        Map<DecoratedKey, ColumnFamily> cfamilies = readColumnFamily(Arrays.asList(command), consistency_level);

        ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));

        if (cf == null)
            throw new NotFoundException();
        List<ColumnOrSuperColumn> tcolumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, false);
        if (tcolumns.isEmpty())
            throw new NotFoundException();
        assert tcolumns.size() == 1;
        return tcolumns.get(0);;        return internal_get(key, column_path, consistency_level);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_446e3_fed37/rev_446e3-fed37;/src/java/org/apache/cassandra/thrift/CassandraServer;get_indexed_slices(ColumnParent,IndexClause,SlicePredicate,ConsistencyLevel);        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);
        ThriftValidation.validateConsistencyLevel(keyspace, consistency_level);;        ThriftValidation.validateColumnParent(keyspace, column_parent);
        ThriftValidation.validatePredicate(keyspace, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);;        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, false);
        ThriftValidation.validateColumnParent(metadata, column_parent);
        ThriftValidation.validatePredicate(metadata, column_parent, column_predicate);
        ThriftValidation.validateIndexClauses(metadata, index_clause);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_479de_4b99c/rev_479de-4b99c;/transport-sctp/src/main/java/io/netty/channel/sctp/SctpClientChannel;newChannael();                    if (logger.isWarnEnabled()) {
                        logger.warn(
                                "Failed to close a partially initialized socket.",
                                e);
                    };                    logger.warn(
                            "Failed to close a partially initialized socket.",
                            e);;                    logger.warn(
                            "Failed to close a partially initialized sctp channel.",
                            e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_netty/rev_479de_4b99c/rev_479de-4b99c;/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelImpl;SctpServerChannelImpl(ChannelFactory,ChannelPipeline,ChannelSink);                if (logger.isWarnEnabled()) {
                    logger.warn(
                            "Failed to close a partially initialized socket.", e2);
                };                logger.warn(
                        "Failed to close a partially initialized socket.", e2);;                logger.warn(
                        "Failed to close a partially initialized sctp channel.", e2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_488f8_52ecf/rev_488f8-52ecf;/src/java/org/apache/cassandra/cli/CliOptions;processArgs(CliSessionState,String[]);            // Look to see if frame has been specified
            if (cmd.hasOption(UNFRAME_OPTION))
            {
                css.framed = false;
            }

            // Look to see if frame has been specified;            // Look to see if frame has been specified
            if (cmd.hasOption(UNFRAME_OPTION))
            {
                if (cmd.hasOption(TRANSPORT_FACTORY))
                    throw new IllegalArgumentException("--unframed and --transport-factory options should not be fixed.");

                css.framed = false;
                css.transportFactory = new SimpleTransportFactory();
            }

            if (cmd.hasOption(TRANSPORT_FACTORY))
                css.transportFactory = validateAndSetTransportFactory(cmd.getOptionValue(TRANSPORT_FACTORY));

            // Look to see if frame has been specified;            if (cmd.hasOption(TRANSPORT_FACTORY))
                css.transportFactory = validateAndSetTransportFactory(cmd.getOptionValue(TRANSPORT_FACTORY));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_497c4_6c05f/rev_497c4-6c05f;/test/unit/voldemort/cluster/failuredetector/ThresholdFailureDetectorTest;createFailureDetector();                                                                                 .setBannagePeriod(BANNAGE_MILLIS)
                                                                                 .setAsyncRecoveryInterval(250)
                                                                                 .setThresholdInterval(500);                                                                                 .setBannagePeriod(BANNAGE_MILLIS);                                                                                 .setThresholdInterval(1000)
                                                                                 .setAsyncRecoveryInterval(250)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeFixingOnStartFixed();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9) }, new double[] {fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9)}, new double[] {fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9)}, new double[] {fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeFixingMiddleNotYetFixed();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12) }, new double[] {fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12)}, new double[] {fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12)}, new double[] {fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeFixingMiddleFixed();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13) }, new double[] {fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13)}, new double[] {fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13)}, new double[] {fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeFixingSecondLastFixed();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15) }, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeFixingLast();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15) }, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeAfterLast();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15) }, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeJustAfterPayment();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15) }, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeAfterPayment();    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15) }, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate });;    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});;    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(new ZonedDateTime[] {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8),
        DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12), DateUtils.getUTCDate(2011, 9, 13), DateUtils.getUTCDate(2011, 9, 14), DateUtils.getUTCDate(2011, 9, 15)}, new double[] {
        fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate, fixingRate});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_600e6_621fe/rev_600e6-621fe;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/instrument/payment/CouponOISDefinitionTest;toDerivativeUSDFixingOnFirst();    final ZonedDateTime[] fixingZDTs = {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8), DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12) };
    final double[] fixingRates = {0.01, 0.011, 0.012, 0.13 };
    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(fixingZDTs, fixingRates);;    final ZonedDateTime[] fixingZDTs = {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8), DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12)};
    final double[] fixingRates = {0.01, 0.011, 0.012, 0.13};
    final DoubleTimeSeries<ZonedDateTime> fixingTS = new ArrayZonedDateTimeDoubleTimeSeries(fixingZDTs, fixingRates);;    final ZonedDateTime[] fixingZDTs = {DateUtils.getUTCDate(2011, 9, 7), DateUtils.getUTCDate(2011, 9, 8), DateUtils.getUTCDate(2011, 9, 9), DateUtils.getUTCDate(2011, 9, 12)};
    final double[] fixingRates = {0.01, 0.011, 0.012, 0.13};
    final DoubleTimeSeries<ZonedDateTime> fixingTS = ImmutableZonedDateTimeDoubleTimeSeries.ofUTC(fixingZDTs, fixingRates);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0627c_681e2/rev_0627c-681e2;/src/java/org/apache/cassandra/db/ColumnFamilyStore;initRowCache();        AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;

        // results are sorted on read (via treeset) because there are few reads and many writes and reads only happen at startup
        int cachedRowsRead = 0;
        for (DecoratedKey key : rowCache.readSaved(table.name, columnFamily, partitioner))
        {
            ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)),
                                                   Integer.MIN_VALUE,
                                                   true);
            CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
            cachedRowsRead++;
        };        AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;

        // results are sorted on read (via treeset) because there are few reads and many writes and reads only happen at startup
        int cachedRowsRead = 0;
        for (DecoratedKey key : rowCache.readSaved(table.name, columnFamily))
        {
            ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)),
                                                   Integer.MIN_VALUE,
                                                   true);
            CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
            cachedRowsRead++;
        };        int cachedRowsRead = CacheService.instance.rowCache.loadSaved(this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_636e4_10b3d/rev_636e4-10b3d;/src/java/org/apache/cassandra/cql/QueryProcessor;process(String,ClientState);        
        CQLStatement statement = getStatement(queryString);
        
        return process(statement, clientState);;        
        CQLStatement statement = getStatement(queryString);
        String keyspace = null;
        
        // Some statements won't have (or don't need) a keyspace (think USE, or CREATE).
        if (statement.type != StatementType.SELECT && StatementType.requiresKeyspace.contains(statement.type))
            keyspace = clientState.getKeyspace();

        CqlResult result = new CqlResult();
        
        logger.debug("CQL statement type: {}", statement.type.toString());
        CFMetaData metadata;
        switch (statement.type)
        {
            case SELECT:
                SelectStatement select = (SelectStatement)statement.statement;

                final String oldKeyspace = clientState.getRawKeyspace();

                if (select.isSetKeyspace())
                {
                    keyspace = CliUtils.unescapeSQLString(select.getKeyspace());
                    ThriftValidation.validateTable(keyspace);
                }
                else if (oldKeyspace == null)
                    throw new InvalidRequestException("no keyspace has been specified");
                else
                    keyspace = oldKeyspace;

                clientState.hasColumnFamilyAccess(keyspace, select.getColumnFamily(), Permission.READ);
                metadata = validateColumnFamily(keyspace, select.getColumnFamily());

                // need to do this in here because we need a CFMD.getKeyName()
                select.extractKeyAliasFromColumns(metadata);

                if (select.getKeys().size() > 0)
                    validateKeyAlias(metadata, select.getKeyAlias());

                validateSelect(keyspace, select);

                List<org.apache.cassandra.db.Row> rows;

                // By-key
                if (!select.isKeyRange() && (select.getKeys().size() > 0))
                {
                    rows = getSlice(metadata, select);
                }
                else
                {
                    // Range query
                    if ((select.getKeyFinish() != null) || (select.getColumnRelations().size() == 0))
                    {
                        rows = multiRangeSlice(metadata, select);
                    }
                    // Index scan
                    else
                    {
                        rows = getIndexedSlices(metadata, select);
                    }
                }

                // count resultset is a single column named "count"
                result.type = CqlResultType.ROWS;
                if (select.isCountOperation())
                {
                    validateCountOperation(select);

                    ByteBuffer countBytes = ByteBufferUtil.bytes("count");
                    result.schema = new CqlMetadata(Collections.<ByteBuffer, String>emptyMap(),
                                                    Collections.<ByteBuffer, String>emptyMap(),
                                                    "AsciiType",
                                                    "LongType");
                    List<Column> columns = Collections.singletonList(new Column(countBytes).setValue(ByteBufferUtil.bytes((long) rows.size())));
                    result.rows = Collections.singletonList(new CqlRow(countBytes, columns));
                    return result;
                }

                // otherwise create resultset from query results
                result.schema = new CqlMetadata(new HashMap<ByteBuffer, String>(),
                                                new HashMap<ByteBuffer, String>(),
                                                TypeParser.getShortName(metadata.comparator),
                                                TypeParser.getShortName(metadata.getDefaultValidator()));
                List<CqlRow> cqlRows = new ArrayList<CqlRow>();
                for (org.apache.cassandra.db.Row row : rows)
                {
                    List<Column> thriftColumns = new ArrayList<Column>();
                    if (select.isColumnRange())
                    {
                        if (select.isWildcard())
                        {
                            // prepend key
                            thriftColumns.add(new Column(metadata.getKeyName()).setValue(row.key.key).setTimestamp(-1));
                            result.schema.name_types.put(metadata.getKeyName(), TypeParser.getShortName(AsciiType.instance));
                            result.schema.value_types.put(metadata.getKeyName(), TypeParser.getShortName(metadata.getKeyValidator()));
                        }

                        // preserve comparator order
                        if (row.cf != null)
                        {
                            for (IColumn c : row.cf.getSortedColumns())
                            {
                                if (c.isMarkedForDelete())
                                    continue;

                                ColumnDefinition cd = metadata.getColumnDefinition(c.name());
                                if (cd != null)
                                    result.schema.value_types.put(c.name(), TypeParser.getShortName(cd.getValidator()));

                                thriftColumns.add(thriftify(c));
                            }
                        }
                    }
                    else
                    {
                        String keyString = getKeyString(metadata);

                        // order columns in the order they were asked for
                        for (Term term : select.getColumnNames())
                        {
                            if (term.getText().equalsIgnoreCase(keyString))
                            {
                                // preserve case of key as it was requested
                                ByteBuffer requestedKey = ByteBufferUtil.bytes(term.getText());
                                thriftColumns.add(new Column(requestedKey).setValue(row.key.key).setTimestamp(-1));
                                result.schema.name_types.put(requestedKey, TypeParser.getShortName(AsciiType.instance));
                                result.schema.value_types.put(requestedKey, TypeParser.getShortName(metadata.getKeyValidator()));
                                continue;
                            }

                            if (row.cf == null)
                                continue;

                            ByteBuffer name;
                            try
                            {
                                name = term.getByteBuffer(metadata.comparator);
                            }
                            catch (InvalidRequestException e)
                            {
                                throw new AssertionError(e);
                            }

                            ColumnDefinition cd = metadata.getColumnDefinition(name);
                            if (cd != null)
                                result.schema.value_types.put(name, TypeParser.getShortName(cd.getValidator()));
                            IColumn c = row.cf.getColumn(name);
                            if (c == null || c.isMarkedForDelete())
                                thriftColumns.add(new Column().setName(name));
                            else
                                thriftColumns.add(thriftify(c));
                        }
                    }

                    // Create a new row, add the columns to it, and then add it to the list of rows
                    CqlRow cqlRow = new CqlRow();
                    cqlRow.key = row.key.key;
                    cqlRow.columns = thriftColumns;
                    if (select.isColumnsReversed())
                        Collections.reverse(cqlRow.columns);
                    cqlRows.add(cqlRow);
                }

                result.rows = cqlRows;
                return result;

            case INSERT: // insert uses UpdateStatement
            case UPDATE:
                UpdateStatement update = (UpdateStatement)statement.statement;
                batchUpdate(clientState, Collections.singletonList(update), update.getConsistencyLevel());
                result.type = CqlResultType.VOID;
                return result;
                
            case BATCH:
                BatchStatement batch = (BatchStatement) statement.statement;

                if (batch.getTimeToLive() != 0)
                    throw new InvalidRequestException("Global TTL on the BATCH statement is not supported.");

                for (AbstractModification up : batch.getStatements())
                {
                    if (up.isSetConsistencyLevel())
                        throw new InvalidRequestException(
                                "Consistency level must be set on the BATCH, not individual statements");

                    if (batch.isSetTimestamp() && up.isSetTimestamp())
                        throw new InvalidRequestException(
                                "Timestamp must be set either on BATCH or individual statements");
                }

                try
                {
                    StorageProxy.mutate(batch.getMutations(keyspace, clientState), batch.getConsistencyLevel());
                }
                catch (org.apache.cassandra.thrift.UnavailableException e)
                {
                    throw new UnavailableException();
                }
                catch (TimeoutException e)
                {
                    throw new TimedOutException();
                }

                result.type = CqlResultType.VOID;
                return result;
                
            case USE:
                clientState.setKeyspace(CliUtils.unescapeSQLString((String) statement.statement));
                result.type = CqlResultType.VOID;
                
                return result;
            
            case TRUNCATE:
                Pair<String, String> columnFamily = (Pair<String, String>)statement.statement;
                keyspace = columnFamily.left == null ? clientState.getKeyspace() : columnFamily.left;

                validateColumnFamily(keyspace, columnFamily.right);
                clientState.hasColumnFamilyAccess(keyspace, columnFamily.right, Permission.WRITE);
                
                try
                {
                    StorageProxy.truncateBlocking(keyspace, columnFamily.right);
                }
                catch (TimeoutException e)
                {
                    throw (UnavailableException) new UnavailableException().initCause(e);
                }
                catch (IOException e)
                {
                    throw (UnavailableException) new UnavailableException().initCause(e);
                }
                
                result.type = CqlResultType.VOID;
                return result;
            
            case DELETE:
                DeleteStatement delete = (DeleteStatement)statement.statement;

                keyspace = delete.keyspace == null ? clientState.getKeyspace() : delete.keyspace;

                try
                {
                    StorageProxy.mutate(delete.prepareRowMutations(keyspace, clientState), delete.getConsistencyLevel());
                }
                catch (TimeoutException e)
                {
                    throw new TimedOutException();
                }
                
                result.type = CqlResultType.VOID;
                return result;
                
            case CREATE_KEYSPACE:
                CreateKeyspaceStatement create = (CreateKeyspaceStatement)statement.statement;
                create.validate();
                ThriftValidation.validateKeyspaceNotSystem(create.getName());
                clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
                validateSchemaAgreement();
                
                try
                {
                    KsDef ksd = new KsDef(create.getName(),
                                          create.getStrategyClass(),
                                          Collections.<CfDef>emptyList())
                                .setStrategy_options(create.getStrategyOptions());
                    ThriftValidation.validateKsDef(ksd);
                    ThriftValidation.validateKeyspaceNotYetExisting(create.getName());
                    applyMigrationOnStage(new AddKeyspace(KSMetaData.fromThrift(ksd)));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                
                result.type = CqlResultType.VOID;
                return result;
               
            case CREATE_COLUMNFAMILY:
                CreateColumnFamilyStatement createCf = (CreateColumnFamilyStatement)statement.statement;
                clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
                validateSchemaAgreement();
                CFMetaData cfmd = createCf.getCFMetaData(keyspace);
                ThriftValidation.validateCfDef(cfmd.toThrift(), null);

                try
                {
                    applyMigrationOnStage(new AddColumnFamily(cfmd));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }
                
                result.type = CqlResultType.VOID;
                return result;
                
            case CREATE_INDEX:
                CreateIndexStatement createIdx = (CreateIndexStatement)statement.statement;
                clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
                validateSchemaAgreement();
                CFMetaData oldCfm = Schema.instance.getCFMetaData(keyspace, createIdx.getColumnFamily());
                if (oldCfm == null)
                    throw new InvalidRequestException("No such column family: " + createIdx.getColumnFamily());

                boolean columnExists = false;
                ByteBuffer columnName = createIdx.getColumnName().getByteBuffer();
                // mutating oldCfm directly would be bad, but mutating a Thrift copy is fine.  This also
                // sets us up to use validateCfDef to check for index name collisions.
                CfDef cf_def = oldCfm.toThrift();
                for (ColumnDef cd : cf_def.column_metadata)
                {
                    if (cd.name.equals(columnName))
                    {
                        if (cd.index_type != null)
                            throw new InvalidRequestException("Index already exists");
                        logger.debug("Updating column {} definition for index {}", oldCfm.comparator.getString(columnName), createIdx.getIndexName());
                        cd.setIndex_type(IndexType.KEYS);
                        cd.setIndex_name(createIdx.getIndexName());
                        columnExists = true;
                        break;
                    }
                }
                if (!columnExists)
                    throw new InvalidRequestException("No column definition found for column " + oldCfm.comparator.getString(columnName));

                CFMetaData.addDefaultIndexNames(cf_def);
                ThriftValidation.validateCfDef(cf_def, oldCfm);
                try
                {
                    org.apache.cassandra.db.migration.avro.CfDef result1;
                    try
                    {
                        result1 = CFMetaData.fromThrift(cf_def).toAvro();
                    }
                    catch (Exception e)
                    {
                        throw new RuntimeException(e);
                    }
                    applyMigrationOnStage(new UpdateColumnFamily(result1));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }
                
                result.type = CqlResultType.VOID;
                return result;

            case DROP_INDEX:
                DropIndexStatement dropIdx = (DropIndexStatement)statement.statement;
                clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
                validateSchemaAgreement();

                try
                {
                    applyMigrationOnStage(dropIdx.generateMutation(clientState.getKeyspace()));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.toString());
                    ex.initCause(e);
                    throw ex;
                }

                result.type = CqlResultType.VOID;
                return result;

            case DROP_KEYSPACE:
                String deleteKeyspace = (String)statement.statement;
                ThriftValidation.validateKeyspaceNotSystem(deleteKeyspace);
                clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
                validateSchemaAgreement();
                
                try
                {
                    applyMigrationOnStage(new DropKeyspace(deleteKeyspace));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                
                result.type = CqlResultType.VOID;
                return result;
            
            case DROP_COLUMNFAMILY:
                String deleteColumnFamily = (String)statement.statement;
                clientState.hasColumnFamilySchemaAccess(Permission.WRITE);
                validateSchemaAgreement();
                    
                try
                {
                    applyMigrationOnStage(new DropColumnFamily(keyspace, deleteColumnFamily));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                
                result.type = CqlResultType.VOID;
                return result;

            case ALTER_TABLE:
                AlterTableStatement alterTable = (AlterTableStatement) statement.statement;

                validateColumnFamily(keyspace, alterTable.columnFamily);
                clientState.hasColumnFamilyAccess(alterTable.columnFamily, Permission.WRITE);
                validateSchemaAgreement();

                try
                {
                    applyMigrationOnStage(new UpdateColumnFamily(alterTable.getCfDef(keyspace)));
                }
                catch (ConfigurationException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }
                catch (IOException e)
                {
                    InvalidRequestException ex = new InvalidRequestException(e.getMessage());
                    ex.initCause(e);
                    throw ex;
                }

                result.type = CqlResultType.VOID;
                return result;
        }
        
        return null;    // We should never get here.;        return processStatement(getStatement(queryString), clientState, new ArrayList<ByteBuffer>());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_0651e_148c1/rev_0651e-148c1;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/inflation/method/CapFloorYearOnYearCalibrationObjectiveTest;calibration();public void calibration() {

    final InflationYearOnYearCapFloorParameters parameters = new InflationYearOnYearCapFloorParameters(expiryTimes, strikes, volatilities, PRICE_INDEX_EUR);;@Test
  /**
   * Tests the correctness of INFLATION YEAR ON YEAR CAP/FLOOR calibration to market prices.
   */
  public void calibration() {

    final InflationYearOnYearCapFloorParameters parameters = new InflationYearOnYearCapFloorParameters(expiryTimes, strikes, volatilities, PRICE_INDEX_EUR);;@Test
  /**
   * Tests the correctness of INFLATION YEAR ON YEAR CAP/FLOOR calibration to market prices.
   */
  public void calibration() {
    
    for (int loopexp = 0; loopexp < STRIKES.length; loopexp++) {
     CAP_DEFINITIONS[loopexp] = AnnuityCapFloorInflationYearOnYearMonthlyDefinition.from(PRICE_INDEX_EUR, SETTLEMENT_DATE, NOTIONAL,
        COUPON_TENOR, COUPON_PAYMENT_TENOR, BUSINESS_DAY, CALENDAR, IS_EOM, 3, 3, LAST_KNOWN_FIXING_DATE, STRIKES[loopexp], IS_CAP);
     CAPS[loopexp]  = CAP_DEFINITIONS[loopexp] .toDerivative(REFERENCE_DATE, CURVES_NAME);
    
    }
    for (int loopexp = 0; loopexp < CAPS[0].getNumberOfPayments(); loopexp++) {  
      expiryTimes1[loopexp]=CAPS[0].getNthPayment(loopexp).getPaymentTime();
    }
    final InflationYearOnYearCapFloorParameters parameters = new InflationYearOnYearCapFloorParameters(expiryTimes1, strikes, volatilities, PRICE_INDEX_EUR);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_698df_bd764/rev_698df-bd764;/core/src/main/java/com/orientechnologies/orient/core/command/script/OCommandExecutorScript;executeInContext(OCommandContext,Map<Object,Object>);    if (language.equalsIgnoreCase("SQL"))
      // SPECIAL CASE: EXECUTE THE COMMANDS IN SEQUENCE
      return executeSQL();
    else
      return executeJsr223Script(language, iContext, iArgs);;    ODatabaseRecord db = ODatabaseRecordThreadLocal.INSTANCE.getIfDefined();
    if (db != null && !(db instanceof ODatabaseRecordTx))
      db = db.getUnderlying();

    final OScriptManager scriptManager = Orient.instance().getScriptManager();
    CompiledScript compiledScript = request.getCompiledScript();

    if (compiledScript == null) {
      ScriptEngine scriptEngine = scriptManager.getEngine(language);
      // COMPILE FUNCTION LIBRARY
      String lib = scriptManager.getLibrary(db, language);
      if (lib == null)
        lib = "";

      parserText = lib + parserText;

      Compilable c = (Compilable) scriptEngine;
      try {
        compiledScript = c.compile(parserText);
      } catch (ScriptException e) {
        scriptManager.getErrorMessage(e, parserText);
      }

      request.setCompiledScript(compiledScript);
    }

    final Bindings binding = scriptManager.bind(compiledScript.getEngine().createBindings(), (ODatabaseRecordTx) db, iContext,
        iArgs);

    try {
      return compiledScript.eval(binding);

    } catch (ScriptException e) {
      throw new OCommandScriptException("Error on execution of the script", request.getText(), e.getColumnNumber(), e);

    } finally {
      scriptManager.unbind(binding);
    };    ODatabaseRecord db = ODatabaseRecordThreadLocal.INSTANCE.getIfDefined();
    if (db != null && !(db instanceof ODatabaseRecordTx))
      db = db.getUnderlying();

    final OScriptManager scriptManager = Orient.instance().getScriptManager();
    CompiledScript compiledScript = request.getCompiledScript();

    if (compiledScript == null) {
      ScriptEngine scriptEngine = scriptManager.getEngine(language);
      scriptEngine.put("engine", scriptEngine);
      // COMPILE FUNCTION LIBRARY
      String lib = scriptManager.getLibrary(db, language);
      if (lib == null)
        lib = "";

      parserText = lib + parserText;

      Compilable c = (Compilable) scriptEngine;
      try {
        compiledScript = c.compile(parserText);
      } catch (ScriptException e) {
        scriptManager.getErrorMessage(e, parserText);
      }

      request.setCompiledScript(compiledScript);
    }

    final Bindings binding = scriptManager.bind(compiledScript.getEngine().createBindings(), (ODatabaseRecordTx) db, iContext,
        iArgs);

    try {
      return compiledScript.eval(binding);

    } catch (ScriptException e) {
      throw new OCommandScriptException("Error on execution of the script", request.getText(), e.getColumnNumber(), e);

    } finally {
      scriptManager.unbind(binding);
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mockito/rev_699c0_79e54/rev_699c0-79e54;/src/org/mockito/internal/configuration/DefaultInjectionEngine;injectMockCandidate(Class<?>,Set<Object>,Object);private void injectMockCandidate(Class<?> awaitingInjectionClazz,
			Set<Object> mocks, Object fieldInstance) {
		for (Field field : awaitingInjectionClazz.getDeclaredFields()) {
			mockCandidateFilter.filterCandidate(mocks, field, fieldInstance)
					.thenInject();
		}
	};private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
        for(Field field : awaitingInjectionClazz.getDeclaredFields()) {
            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
        }
    };private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
            mocks.remove(injected);
        }
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_709c9_f6a4a/rev_709c9-f6a4a;/realm-annotations-processor/src/main/java/io/realm/processor/RealmSourceCodeGenerator;generate();                writer.beginControlFlow("if (!transaction.hasTable(\"%s\"))", fieldTypeName);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", fieldTypeName);;                writer.beginControlFlow("if (!transaction.hasTable(\"%s\"))", fieldTypeName);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", fieldTypeCanonicalName);;                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", table_prefix, fieldTypeName);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", fieldTypeCanonicalName);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_709c9_f6a4a/rev_709c9-f6a4a;/realm-annotations-processor/src/main/java/io/realm/processor/RealmSourceCodeGenerator;generate();                writer.beginControlFlow("if (!transaction.hasTable(\"%s\"))", genericType);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", genericType);;                writer.beginControlFlow("if (!transaction.hasTable(\"%s\"))", genericType);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", genericCanonicalType);;                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", table_prefix, genericType);
                writer.emitStatement("%sRealmProxy.initTable(transaction)", genericCanonicalType);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_713bb_37452/rev_713bb-37452;/src/java/org/apache/cassandra/service/StorageService;handleStateBootstrap(InetAddress,String[]);        tokenMetadata_.addBootstrapToken(token, endpoint);
        PendingRangeCalculatorService.instance.update();;        tokenMetadata_.addBootstrapToken(token, endpoint);
        calculatePendingRanges();;        tokenMetadata.addBootstrapTokens(tokens, endpoint);
        calculatePendingRanges();

        if (Gossiper.instance.usesHostId(endpoint))
            tokenMetadata.updateHostId(Gossiper.instance.getHostId(endpoint), endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_713bb_37452/rev_713bb-37452;/src/java/org/apache/cassandra/service/StorageService;handleStateNormal(InetAddress,String[]);        if (tokenMetadata_.isMoving(endpoint)) // if endpoint was moving to a new token
            tokenMetadata_.removeFromMoving(endpoint);

        PendingRangeCalculatorService.instance.update();;        if (tokenMetadata_.isMoving(endpoint)) // if endpoint was moving to a new token
            tokenMetadata_.removeFromMoving(endpoint);

        calculatePendingRanges();;        calculatePendingRanges();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_713bb_37452/rev_713bb-37452;/src/java/org/apache/cassandra/service/StorageService;handleStateLeaving(InetAddress,String[]);        tokenMetadata_.addLeavingEndpoint(endpoint);
        PendingRangeCalculatorService.instance.update();;        tokenMetadata_.addLeavingEndpoint(endpoint);
        calculatePendingRanges();;        tokenMetadata.addLeavingEndpoint(endpoint);
        calculatePendingRanges();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_713bb_37452/rev_713bb-37452;/src/java/org/apache/cassandra/service/StorageService;handleStateRemoving(InetAddress,String[]);                tokenMetadata_.addLeavingEndpoint(endpoint);
                PendingRangeCalculatorService.instance.update();;                tokenMetadata_.addLeavingEndpoint(endpoint);
                calculatePendingRanges();;                tokenMetadata.addLeavingEndpoint(endpoint);
                calculatePendingRanges();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_763d4_4c6d8/rev_763d4-4c6d8;/tightdb-java-test/src/test/java/com/tightdb/JNITransactions;mustFailOnWriteInReadTransactions(); 		long cnt = t.getTableCount();
 		for (int i=0; i< cnt; ++i)
 			System.out.println(i  + ":" + t.getTableName(i));
 		TableBase table = t.getTable("EmployeeTable");; 		long cnt = t.getTableCount();
 		for (int i=0; i< cnt; ++i)
 			System.out.println(i  + ":" + t.getTableName(i));
 		TableBase table = t.getTable("com.tightdb.EmployeeTable");; 		TableBase table = t.getTable("EmployeeTable");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_763d4_4c6d8/rev_763d4-4c6d8;/tightdb-java-test/src/test/java/com/tightdb/lib/GroupTest;shouldCreateTablesInGroup();				group.getTable(TestEmployeeTable.class.getSimpleName()).size());;				group.getTable(TestEmployeeTable.class.getCanonicalName()).size());;				group.getTable(TestEmployeeTable.class.getCanonicalName()).size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_777f4_4cd64/rev_777f4-4cd64;/tightdb-java-test/src/test/java/com/tightdb/typed/GroupTest;shouldCreateTablesInGroup();@Test(enabled = true)
	public void shouldCreateTablesInGroup() {
		//util.setDebugLevel(2);
		Group group = new Group();

		TestEmployeeTable employees = new TestEmployeeTable(group);
		employees.add(NAME0, "Doe", 10000, true, new byte[] { 1, 2, 3 },
				new Date(), "extra", null);
		employees.add(NAME2, "B. Good", 20000, true, new byte[] { 1, 2, 3 },
				new Date(), true, null);
		employees.insert(1, NAME1, "Mihajlovski", 30000, false, new byte[] { 4,
				5 }, new Date(), 1234, null);

		byte[] data = group.writeToMem();
		
		// check table info retrieval
		assertEquals(1, group.size());
		assertEquals(TestEmployeeTable.class.getSimpleName(),
				group.getTableName(0));
		assertTrue(group.hasTable(TestEmployeeTable.class.getSimpleName()));
		assertFalse(group.hasTable("xxxxxx"));

		// check table retrieval
		assertEquals(employees.size(),
				group.getTable(TestEmployeeTable.class.getSimpleName()).size());
		employees.clear();
		group.close();

		// Make new group based on same data.
		Group group2 = new Group(data);
		TestEmployeeTable employees2 = new TestEmployeeTable(group2);
		assertEquals(3, employees2.size());
		assertEquals(NAME0, employees2.get(0).getFirstName());
		assertEquals(NAME1, employees2.get(1).getFirstName());
		assertEquals(NAME2, employees2.get(2).getFirstName());
		employees2.clear();
		group2.close();

		// Make new empty group
		Group group3 = new Group();
		TestEmployeeTable employees3 = new TestEmployeeTable(group3);
		assertEquals(0, employees3.size());
		employees3.clear();
		group3.close();

	};@Test(enabled = true)
	public void shouldCreateTablesInGroup() {
		//util.setDebugLevel(2);
		Group group = new Group();

		TestEmployeeTable employees = new TestEmployeeTable(group);
		employees.add(NAME0, "Doe", 10000, true, new byte[] { 1, 2, 3 },
				new Date(), "extra", null);
		employees.add(NAME2, "B. Good", 20000, true, new byte[] { 1, 2, 3 },
				new Date(), true, null);
		employees.insert(1, NAME1, "Mihajlovski", 30000, false, new byte[] { 4,
				5 }, new Date(), 1234, null);

		byte[] data = group.writeToMem();
		
		// check table info retrieval
		assertEquals(1, group.size());
		assertEquals(TestEmployeeTable.class.getSimpleName(),
				group.getTableName(0));
		assertTrue(group.hasTable(TestEmployeeTable.class.getSimpleName()));
		assertFalse(group.hasTable("xxxxxx"));

		// check table retrieval
		assertEquals(employees.size(),
				group.getTable(TestEmployeeTable.class.getSimpleName()).size());
		employees.clear();
		group.close();

		// Make new group based on same data.
		Group group2 = new Group(data);
		TestEmployeeTable employees2 = new TestEmployeeTable(group2);
		assertEquals(3, employees2.size());
		assertEquals(NAME0, employees2.at(0).getFirstName());
		assertEquals(NAME1, employees2.at(1).getFirstName());
		assertEquals(NAME2, employees2.at(2).getFirstName());
		employees2.clear();
		group2.close();

		// Make new empty group
		Group group3 = new Group();
		TestEmployeeTable employees3 = new TestEmployeeTable(group3);
		assertEquals(0, employees3.size());
		employees3.clear();
		group3.close();

	};@Test(enabled = true)
    public void shouldCreateTablesInGroup() {
        //util.setDebugLevel(2);
        Group group = new Group();

        TestEmployeeTable employees = new TestEmployeeTable(group);
        employees.add(NAME0, "Doe", 10000, true, new byte[] { 1, 2, 3 },
                new Date(), "extra", null);
        employees.add(NAME2, "B. Good", 20000, true, new byte[] { 1, 2, 3 },
                new Date(), true, null);
        employees.insert(1, NAME1, "Mihajlovski", 30000, false, new byte[] { 4,
                5 }, new Date(), 1234, null);

        byte[] data = group.writeToMem();

        // check table info retrieval
        assertEquals(1, group.size());
        assertEquals(TestEmployeeTable.class.getSimpleName(),
                group.getTableName(0));
        assertTrue(group.hasTable(TestEmployeeTable.class.getSimpleName()));
        assertFalse(group.hasTable("xxxxxx"));

        // check table retrieval
        assertEquals(employees.size(),
                group.getTable(TestEmployeeTable.class.getSimpleName()).size());
        employees.clear();
        group.close();

        // Make new group based on same data.
        Group group2 = new Group(data);
        TestEmployeeTable employees2 = new TestEmployeeTable(group2);
        assertEquals(3, employees2.size());
        assertEquals(NAME0, employees2.at(0).getFirstName());
        assertEquals(NAME1, employees2.at(1).getFirstName());
        assertEquals(NAME2, employees2.at(2).getFirstName());
        employees2.clear();
        group2.close();

        // Make new empty group
        Group group3 = new Group();
        TestEmployeeTable employees3 = new TestEmployeeTable(group3);
        assertEquals(0, employees3.size());
        employees3.clear();
        group3.close();

    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_777f4_4cd64/rev_777f4-4cd64;/examples/intro-example/src/com/tightdb/examples/showcase/Showcase;showLongExample();		// 2 ways to set the value
		employees.get(2).lastName.set("NewName");
		employees.get(2).setLastName("NewName");;		// 2 ways to set the value
		employees.at(2).lastName.set("NewName");
		employees.at(2).setLastName("NewName");;        // 2 ways to get the value
        System.out.println("name1: " + john.firstName.get());
        System.out.println("name2: " + john.getFirstName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_777f4_4cd64/rev_777f4-4cd64;/examples/intro-example/src/com/tightdb/examples/tutorial/tutorial;main(String[]);    String name2 = peopleTable.get(2).name.get();
    ;    String name2 = peopleTable.at(2).name.get();
    ;    String name2 = peopleTable.at(2).name.get();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_777f4_4cd64/rev_777f4-4cd64;/examples/intro-example/src/com/tightdb/examples/tutorial/tutorial;main(String[]);    
    System.out.println("get(2).getName -> " + name + " or " + name2);
    System.out.println("get(2).setName('NewName') -> " + peopleTable.get(2).getName());
    
    // @@Example: last_row @@   ;    
    System.out.println("at(2).getName -> " + name + " or " + name2);
    System.out.println("at(2).setName('NewName') -> " + peopleTable.at(2).getName());
    
    // @@Example: last_row @@   ;
    System.out.println("at(2).getName -> " + name + " or " + name2);
    System.out.println("at(2).setName('NewName') -> " + peopleTable.at(2).getName());

    // @@Example: last_row @@
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_790f2_ec2ba/rev_790f2-ec2ba;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/PlotSettingsControlPanel;setupApplyResetListeners();		nonTimeMinFixedMode.addActionListener(buttonListener);
		nonTimeMinSemiFixedMode.addActionListener(buttonListener);;		nonTimeMinFixedMode.addActionListener(buttonListener);;		nonTimeMinFixedMode.addActionListener(buttonListener);
		nonTimeMinSemiFixedMode.addActionListener(buttonListener);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_790f2_ec2ba/rev_790f2-ec2ba;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/PlotSettingsControlPanel;setupApplyResetListeners();		nonTimeMaxFixedMode.addActionListener(buttonListener);
		nonTimeMaxSemiFixedMode.addActionListener(buttonListener);;		nonTimeMaxFixedMode.addActionListener(buttonListener);;		nonTimeMaxFixedMode.addActionListener(buttonListener);
		nonTimeMaxSemiFixedMode.addActionListener(buttonListener);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_828f2_bbead/rev_828f2-bbead;/subprojects/plugins/src/main/groovy/org/gradle/api/tasks/compile/Compile;compile(IncrementalTaskInputs);        incrementalCompilation.compilationComplete(compileOptions,
                new ClassDependencyInfoExtractor(getDestinationDir()),
                getDependencyInfoSerializer(), Collections.<JarArchive>emptyList());;        incrementalCompilation.compilationComplete(compileOptions,
                new ClassDependencyInfoExtractor(getDestinationDir()),
                getDependencyInfoSerializer(), jarsOnClasspath());;
        SingleMessageLogger.incubatingFeatureUsed("Incremental java compilation");

        //bunch of services that enable incremental java compilation. Should be pushed out to services/factories.
        ClassDependenciesAnalyzer analyzer = new ClassDependenciesAnalyzer(); //TODO SF needs caching
        ClassDependencyInfoExtractor extractor = new ClassDependencyInfoExtractor(analyzer);
        JarSnapshotCache jarSnapshotCache = new JarSnapshotCache(new File(getProject().getRootProject().getProjectDir(), ".gradle/jar-snapshot-cache.bin")); //TODO SF cannot be global
        JarSnapshotFeeder jarSnapshotFeeder = new JarSnapshotFeeder(jarSnapshotCache, new JarSnapshotter(new ClassSnapshotter(new DefaultHasher(), analyzer)));
        ClassDependencyInfoSerializer dependencyInfoSerializer = new ClassDependencyInfoSerializer(new File(getProject().getBuildDir(), "class-info.bin"));
        CompilationSourceDirs sourceDirs = new CompilationSourceDirs(source);
        SourceToNameConverter sourceToNameConverter = new SourceToNameConverter(sourceDirs); //can be replaced with converter that parses input source class
        RecompilationSpecProvider recompilationSpecProvider = new RecompilationSpecProvider(sourceToNameConverter, dependencyInfoSerializer, (FileOperations) getProject(), jarSnapshotFeeder);
        IncrementalCompilationSupport incrementalSupport = new IncrementalCompilationSupport(jarSnapshotFeeder, dependencyInfoSerializer, (FileOperations) getProject(),
                extractor, (CleaningJavaCompiler) cleaningCompiler, getPath(), recompilationSpecProvider);
        Compiler<JavaCompileSpec> compiler = incrementalSupport.prepareCompiler(inputs, sourceDirs);
        performCompilation(compiler);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_840de_d6746/rev_840de-d6746;/projects/OG-Financial/src/main/java/com/opengamma/financial/fudgemsg/ConventionBuilders;buildObject(FudgeDeserializer,FudgeMsg);      final Tenor resetTenor = new Tenor(Period.parse(message.getString(RESET_TENOR_FIELD)));
      final int settlementDays = message.getInt(SETTLEMENT_DAYS_FIELD);
      final boolean isEOM = message.getBoolean(IS_EOM_FIELD);
      final boolean exchangeNotional = message.getBoolean(EXCHANGE_NOTIONAL_FIELD);
      final VanillaIborLegConvention convention = new VanillaIborLegConvention(name, externalIdBundle, iborIndexConvention, isAdvanceFixing, interpolatorName,
          resetTenor, settlementDays, isEOM, stubType, exchangeNotional);;      final Tenor resetTenor = new Tenor(Period.parse(message.getString(RESET_TENOR_FIELD)));
      final VanillaIborLegConvention convention = new VanillaIborLegConvention(name, externalIdBundle, iborIndexConvention, isAdvanceFixing, stubType, interpolatorName,
          resetTenor);;      final Tenor resetTenor = Tenor.of(Period.parse(message.getString(RESET_TENOR_FIELD)));
      final VanillaIborLegConvention convention = new VanillaIborLegConvention(name, externalIdBundle, iborIndexConvention, isAdvanceFixing, stubType, interpolatorName,
          resetTenor);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_850b3_de885/rev_850b3-de885;/projects/OG-Financial/src/com/opengamma/financial/view/rest/DataViewClientResource;getLatestResult();    FudgeSerializationContext context = getFudgeSerializationContext();
    MutableFudgeMsg msg = context.newMessage();
    context.addToMessage(msg, PATH_LATEST_RESULT, null, getViewClient().getLatestResult());
    return Response.ok(new FudgeMsgEnvelope(msg)).build();;    FudgeSerializationContext context = getFudgeSerializationContext();
    MutableFudgeMsg msg = context.newMessage();
    context.objectToFudgeMsg(msg, PATH_LATEST_RESULT, null, getViewClient().getLatestResult());
    return Response.ok(new FudgeMsgEnvelope(msg)).build();;    return Response.ok(getViewClient().getLatestResult()).build();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_853a7_1bfb6/rev_853a7-1bfb6;/src/java/org/apache/cassandra/db/compaction/CompactionManager;submitBackground(ColumnFamilyStore);        logger.debug("Scheduling a background task check for {}.{} with {}",
                     new Object[] {cfs.table.name,
                                   cfs.columnFamily,
                                   cfs.getCompactionStrategy().getClass().getSimpleName()});
        Callable<Integer> callable = new Callable<Integer>();        Callable<Integer> callable = new Callable<Integer>();        Runnable runnable = new WrappedRunnable()
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_853a7_1bfb6/rev_853a7-1bfb6;/src/java/org/apache/cassandra/db/compaction/CompactionManager;submitBackground(ColumnFamilyStore);                    logger.debug("Checking {}.{}", cfs.table.name, cfs.columnFamily); // log after we get the lock so we can see delays from that if any
                    if (!cfs.isValid())
                    {
                        logger.debug("Aborting compaction for dropped CF");
                        return 0;
                    };                    if (!cfs.isValid())
                        return 0;;                    AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
                    AbstractCompactionTask task = strategy.getNextBackgroundTask(getDefaultGcBefore(cfs));
                    if (task == null || !task.markSSTablesForCompaction())
                        return;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_853a7_1bfb6/rev_853a7-1bfb6;/src/java/org/apache/cassandra/db/compaction/CompactionManager;submitBackground(ColumnFamilyStore);                    boolean taskExecuted = false;
                    AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
                    List<AbstractCompactionTask> tasks = strategy.getBackgroundTasks(getDefaultGcBefore(cfs));
                    logger.debug("{} minor compaction tasks available", tasks.size());
                    for (AbstractCompactionTask task : tasks);                    boolean taskExecuted = false;
                    AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
                    List<AbstractCompactionTask> tasks = strategy.getBackgroundTasks(getDefaultGcBefore(cfs));
                    for (AbstractCompactionTask task : tasks);                    try
                    {
                        task.execute(executor);
                    }
                    finally
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_853a7_1bfb6/rev_853a7-1bfb6;/src/java/org/apache/cassandra/db/compaction/CompactionManager;submitBackground(ColumnFamilyStore);                        if (!task.markSSTablesForCompaction())
                        {
                            logger.debug("Skipping {}; sstables are busy", task);
                            continue;
                        }

                        taskExecuted = true;
                        try
                        {
                            task.execute(executor);
                        }
                        finally
                        {
                            task.unmarkSSTables();
                        };                        if (!task.markSSTablesForCompaction())
                            continue;

                        taskExecuted = true;
                        try
                        {
                            task.execute(executor);
                        }
                        finally
                        {
                            task.unmarkSSTables();
                        };                        task.unmarkSSTables();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_855d9_1d9bd/rev_855d9-1d9bd;/src/java/org/apache/cassandra/service/StorageProxy;mutate(List<RowMutation>,ConsistencyLevel);        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        StorageService ss = StorageService.instance;
        String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());
        
        try
        {
            for (RowMutation rm : mutations)
            {
                mostRecentRowMutation = rm;
                String table = rm.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                
                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistency_level);
                
                // exit early if we can't fulfill the CL at this time
                responseHandler.assureSufficientLiveNodes();
                
                responseHandlers.add(responseHandler);
                
                // Multimap that holds onto all the messages and addresses meant for a specific datacenter
                Map<String, Multimap<Message, InetAddress>> dcMessages = new HashMap<String, Multimap<Message, InetAddress>>(hintedEndpoints.size());

                for (Map.Entry<InetAddress, Collection<InetAddress>> entry : hintedEndpoints.asMap().entrySet())
                {
                    InetAddress destination = entry.getKey();
                    Collection<InetAddress> targets = entry.getValue();

                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);

                    if (targets.size() == 1 && targets.iterator().next().equals(destination))
                    {
                        // unhinted writes
                        if (destination.equals(FBUtilities.getLocalAddress()))
                        {
                            insertLocalMessage(rm, responseHandler);
                        }
                        else
                        {
                            // belongs on a different server
                            Message unhintedMessage = rm.makeRowMutationMessage();
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + unhintedMessage.getMessageId() + "@" + destination);
                            
                            Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                            if (messages == null)
                            {
                               messages = HashMultimap.create();
                               dcMessages.put(dc, messages);
                            }
                            
                            messages.put(unhintedMessage, destination);
                        }
                    }
                    else
                    {
                        // hinted
                        Message hintedMessage = rm.makeRowMutationMessage();
                        for (InetAddress target : targets)
                        {
                            if (!target.equals(destination))
                            {
                                addHintHeader(hintedMessage, target);
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + hintedMessage.getMessageId() + "@" + destination + " for " + target);
                            }
                        }
                        // (non-destination hints are part of the callback and count towards consistency only under CL.ANY)
                        // (non-destination hints are part of the callback and count towards consistency only under CL.ANY)
                        if (writeEndpoints.contains(destination) || consistency_level == ConsistencyLevel.ANY)
                            MessagingService.instance().sendRR(hintedMessage, destination, responseHandler);
                        else
                            MessagingService.instance().sendOneWay(hintedMessage, destination);

                        Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                        
                        if (messages == null)
                        {
                           messages = HashMultimap.create();
                           dcMessages.put(dc, messages);
                        }

                        messages.put(hintedMessage, destination);
                    }
                }

                sendMessages(localDataCenter, dcMessages, responseHandler);
            }
                        
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
                responseHandler.get();
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentRowMutation.key()), e);
        }
        finally
        {
            writeStats.addNano(System.nanoTime() - startTime);
        };        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        StorageService ss = StorageService.instance;
        String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());
        
        try
        {
            for (RowMutation rm : mutations)
            {
                mostRecentRowMutation = rm;
                String table = rm.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                
                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistency_level);
                
                // exit early if we can't fulfill the CL at this time
                responseHandler.assureSufficientLiveNodes();
                
                responseHandlers.add(responseHandler);
                
                // Multimap that holds onto all the messages and addresses meant for a specific datacenter
                Map<String, Multimap<Message, InetAddress>> dcMessages = new HashMap<String, Multimap<Message, InetAddress>>(hintedEndpoints.size());
                Message unhintedMessage = null;

                for (Map.Entry<InetAddress, Collection<InetAddress>> entry : hintedEndpoints.asMap().entrySet())
                {
                    InetAddress destination = entry.getKey();
                    Collection<InetAddress> targets = entry.getValue();

                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);

                    if (targets.size() == 1 && targets.iterator().next().equals(destination))
                    {
                        // unhinted writes
                        if (destination.equals(FBUtilities.getLocalAddress()))
                        {
                            insertLocalMessage(rm, responseHandler);
                        }
                        else
                        {
                            // belongs on a different server
                            if (unhintedMessage == null)
                            {
                                unhintedMessage = rm.makeRowMutationMessage();
                                MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                            }
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + unhintedMessage.getMessageId() + "@" + destination);
                            
                            
                            Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                            if (messages == null)
                            {
                               messages = HashMultimap.create();
                               dcMessages.put(dc, messages);
                            }
                            
                            messages.put(unhintedMessage, destination);
                        }
                    }
                    else
                    {
                        // hinted
                        Message hintedMessage = rm.makeRowMutationMessage();
                        for (InetAddress target : targets)
                        {
                            if (!target.equals(destination))
                            {
                                addHintHeader(hintedMessage, target);
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + hintedMessage.getMessageId() + "@" + destination + " for " + target);
                            }
                        }
                        responseHandler.addHintCallback(hintedMessage, destination);

                        Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                        
                        if (messages == null)
                        {
                           messages = HashMultimap.create();
                           dcMessages.put(dc, messages);
                        }

                        messages.put(hintedMessage, destination);
                    }
                }

                sendMessages(localDataCenter, dcMessages);
            }
                        
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
                responseHandler.get();
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentRowMutation.key()), e);
        }
        finally
        {
            writeStats.addNano(System.nanoTime() - startTime);
        };        write(mutations, consistency_level, standardWritePerformer, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_864d6_12716/rev_864d6-12716;/src/java/voldemort/store/routed/RoutedStore;get(ByteArray);        };
        return get(key, VERSIONED_OP, readRepairFunction);;        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                List<Versioned<byte[]>> fetched = innerStores.get(node.getId()).get(key);
                retrieved.addAll(fetched);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                ++successes;
                node.getStatus().setAvailable();
            } catch(UnreachableStoreException e) {
                failures.add(e);
                markUnavailable(node, e);
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(nodeValues));

        repairReads(nodeValues);

        if(successes >= this.storeDef.getRequiredReads())
            return retrieved;
        else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);;        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                List<Versioned<byte[]>> fetched = innerStores.get(node.getId()).get(key);
                retrieved.addAll(fetched);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                ++successes;
                failureDetector.recordSuccess(node);
            } catch(UnreachableStoreException e) {
                failures.add(e);
                failureDetector.recordException(node, e);
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(nodeValues));

        repairReads(nodeValues);

        if(successes >= this.storeDef.getRequiredReads())
            return retrieved;
        else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_864d6_12716/rev_864d6-12716;/src/java/voldemort/store/routed/RoutedStore;call();                fetched = fetcher.execute(innerStores.get(node.getId()), key);
                node.getStatus().setAvailable();;                fetched = innerStores.get(node.getId()).get(key);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                node.getStatus().setAvailable();;                fetched = innerStores.get(node.getId()).get(key);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                failureDetector.recordSuccess(node);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_870c7_e3cc3/rev_870c7-e3cc3;/projects/OG-Financial/src/com/opengamma/financial/batch/BatchJob;createView(BatchJobRun);    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionCompilationService(), new DefaultFunctionResolver(
        getFunctionCompilationService()), positionSource, securitySource, new DefaultCachingComputationTargetResolver(new DefaultComputationTargetResolver(securitySource, positionSource),
        cacheManager), computationCache, jobDispatcher, viewProcessorQueryReceiver, dependencyGraphExecutorFactory, new DefaultViewPermissionProvider(),;    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionRepository(), new DefaultFunctionResolver(
        getFunctionRepository()), positionSource, securitySource, new DefaultCachingComputationTargetResolver(new DefaultComputationTargetResolver(securitySource, positionSource), cacheManager),
        computationCache, jobDispatcher, viewProcessorQueryReceiver, getFunctionCompilationContext(), executor, dependencyGraphExecutorFactory, new DefaultViewPermissionProvider(),;    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionRepository(), new DefaultFunctionResolver(
        getFunctionRepository()), positionSource, securitySource, new DefaultCachingComputationTargetResolver(new DefaultComputationTargetResolver(securitySource, positionSource), cacheManager),
        computationCache, jobDispatcher, viewProcessorQueryReceiver, functionCompilationContext, executor, dependencyGraphExecutorFactory, new DefaultViewPermissionProvider(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0906b_94585/rev_0906b-94585;/src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader;decompressChunk(CompressionMetadata.Chunk);        if (channel.read(compressed) != chunk.length)
            throw new IOException(String.format("(%s) failed to read %d bytes from offset %d.", getPath(), chunk.length, chunk.offset));
        // technically flip() is unnecessary since all the remaining work uses the raw array, but if that changes
        // in the future this will save a lot of hair-pulling
        compressed.flip();
        validBufferBytes = metadata.compressor().uncompress(compressed.array(), 0, chunk.length, buffer, 0);;        if (source.read(compressed, 0, chunk.length) != chunk.length)
            throw new IOException(String.format("(%s) failed to read %d bytes from offset %d.", getPath(), chunk.length, chunk.offset));

        validBufferBytes = metadata.compressor().uncompress(compressed, 0, chunk.length, buffer, 0);;        if (source.read(compressed, 0, chunk.length) != chunk.length)
            throw new CorruptBlockException(getPath(), chunk);

        try
        {
            validBufferBytes = metadata.compressor().uncompress(compressed, 0, chunk.length, buffer, 0);
        }
        catch (IOException e)
        {
            throw new CorruptBlockException(getPath(), chunk);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0906b_94585/rev_0906b-94585;/src/java/org/apache/cassandra/tools/NodeCmd;optionalKSandCFs(NodeCommand,ToolCommandLine,String[],NodeProbe);                    boolean primaryRange = cmd.hasOption(PRIMARY_RANGE_OPT.left);
                    probe.forceRepairAsync(System.out, keyspace, snapshot, primaryRange, columnFamilies);;                    if (cmd.hasOption(PRIMARY_RANGE_OPT.left))
                        probe.forceTableRepairPrimaryRange(keyspace, snapshot, columnFamilies);
                    else
                        probe.forceTableRepair(keyspace, snapshot, columnFamilies);;                    boolean localDC = cmd.hasOption(LOCAL_DC_REPAIR_OPT.left);
                    if (cmd.hasOption(PRIMARY_RANGE_OPT.left))
                        probe.forceTableRepairPrimaryRange(keyspace, snapshot, localDC, columnFamilies);
                    else
                        probe.forceTableRepair(keyspace, snapshot, localDC, columnFamilies);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_913b8_fee69/rev_913b8-fee69;/tightdb-java-test/src/test/java/com/tightdb/JNITransactions;mustAllowDoubleCommitAndRollback();    	{
	    	WriteTransaction trans = db.beginWrite();
		    Table tbl = trans.getTable("EmployeeTable");
		    tbl.addColumn(ColumnType.ColumnTypeString, "name");
		    tbl.addColumn(ColumnType.ColumnTypeInt, "number");
	
		    // allow commit before any changes
		    assertEquals(0, tbl.size());
	        tbl.add("Hello", 1);
		    trans.commit();
    	}
    	{
	    	WriteTransaction trans = db.beginWrite();
		    Table tbl = trans.getTable("EmployeeTable");
		    // allow double rollback
	        tbl.add("Hello", 2);
	        assertEquals(2, tbl.size());
	        trans.rollback();
	        trans.rollback();
	        trans.rollback();
	        trans.rollback();
    	}
    	{
    		ReadTransaction trans = db.beginRead();
    		Table tbl = trans.getTable("EmployeeTable");
	        assertEquals(1, tbl.size());
	        trans.endRead();
    	};	    WriteTransaction trans = db.beginWrite();
	    Table tbl = trans.getTable("EmployeeTable");
	    tbl.addColumn(ColumnType.ColumnTypeString, "name");
	    tbl.addColumn(ColumnType.ColumnTypeInt, "number");;	    WriteTransaction trans = db.beginWrite();
	    Table tbl = trans.getTable("EmployeeTable");
	    tbl.addColumn(ColumnType.STRING, "name");
	    tbl.addColumn(ColumnType.INTEGER, "number");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673;/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat;fetchPartitionEntries(int,String,List<Integer>,VoldemortFilter);                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response = VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);;                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response =
                            VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);;                    VAdminProto.FetchPartitionEntriesResponse response =
                            responseFromStream(inputStream, size);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_retrofit/revisions/rev_941ae_2ef7c/rev_941ae-2ef7c;/retrofit/src/test/java/retrofit/http/RequestBuilderTest;build();      methodInfo.restMethod = restMethod;
      methodInfo.path = path;
      methodInfo.pathParams = pathParams;
      methodInfo.pathQueryParams = queryParams.toArray(new QueryParam[queryParams.size()]);
      methodInfo.headers = methodHeaders;
      methodInfo.headerParams = headerParams.toArray(new String[headerParams.size()]);
      methodInfo.namedParams = namedParams.toArray(new String[namedParams.size()]);
      methodInfo.singleEntityArgumentIndex = singleEntityArgumentIndex;
      methodInfo.isMultipart = isMultipart;;      methodInfo.restMethod = restMethod;
      methodInfo.path = path;
      methodInfo.pathParams = pathParams;
      methodInfo.pathQueryParams = queryParams.toArray(new QueryParam[queryParams.size()]);
      methodInfo.namedParams = namedParams.toArray(new String[namedParams.size()]);
      methodInfo.singleEntityArgumentIndex = singleEntityArgumentIndex;
      methodInfo.isMultipart = isMultipart;;      methodInfo.requestMethod = this.method;
      methodInfo.requestHasBody = hasBody;
      methodInfo.requestType = requestType;
      methodInfo.requestUrl = path;
      methodInfo.requestUrlParamNames = RestMethodInfo.parsePathParameters(path);
      methodInfo.requestQuery = query;
      methodInfo.hasQueryParams = hasQueryParams;
      methodInfo.requestUrlParam = pathParams.toArray(new String[pathParams.size()]);
      methodInfo.requestQueryName = queryParams.toArray(new String[queryParams.size()]);
      methodInfo.requestFormPair = pairParams.toArray(new String[pairParams.size()]);
      methodInfo.requestMultipartPart = partParams.toArray(new String[partParams.size()]);
      methodInfo.bodyIndex = bodyIndex;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_retrofit/revisions/rev_941ae_2ef7c/rev_941ae-2ef7c;/retrofit/src/main/java/retrofit/http/RestMethodInfo;parseMethodAnnotations();          throw new RuntimeException("Failed to extract URI path.", e);
        }
        if (!path.startsWith("/")) {
          throw new IllegalArgumentException("URL path must be prefixed with '/'.");
        }
        pathParams = parsePathParameters(path);
        restMethod = methodInfo;
      } else if (annotationType == Headers.class) {
        String[] headersToParse = ((Headers) methodAnnotation).value();
        if (headersToParse.length == 0) {
          throw new IllegalStateException("Headers annotation was empty.");
        }
        headers = parseHeaders(headersToParse);
      } else if (annotationType == QueryParams.class) {
        if (pathQueryParams != null) {
          throw new IllegalStateException(
              "QueryParam and QueryParams annotations are mutually exclusive.");
        }
        pathQueryParams = ((QueryParams) methodAnnotation).value();
        if (pathQueryParams.length == 0) {
          throw new IllegalStateException("QueryParams annotation was empty.");
        }
      } else if (annotationType == QueryParam.class) {
        if (pathQueryParams != null) {
          throw new IllegalStateException(
              "QueryParam and QueryParams annotations are mutually exclusive.");
        }
        pathQueryParams = new QueryParam[] { (QueryParam) methodAnnotation };;          throw new RuntimeException("Failed to extract URI path.", e);
        }
        if (!path.startsWith("/")) {
          throw new IllegalArgumentException("URL path must be prefixed with '/'.");
        }
        pathParams = parsePathParameters(path);
        restMethod = methodInfo;
      } else if (annotationType == QueryParams.class) {
        if (pathQueryParams != null) {
          throw new IllegalStateException(
              "QueryParam and QueryParams annotations are mutually exclusive.");
        }
        pathQueryParams = ((QueryParams) methodAnnotation).value();
        if (pathQueryParams.length == 0) {
          throw new IllegalStateException("QueryParams annotation was empty.");
        }
      } else if (annotationType == QueryParam.class) {
        if (pathQueryParams != null) {
          throw new IllegalStateException(
              "QueryParam and QueryParams annotations are mutually exclusive.");
        }
        pathQueryParams = new QueryParam[] { (QueryParam) methodAnnotation };;          throw new RuntimeException("Failed to extract path from "
              + annotationType.getSimpleName()
              + " annotation on "
              + method.getName()
              + ".", e);
        }
        parsePath(path);
        requestMethod = methodInfo.value();
        requestHasBody = methodInfo.hasBody();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_retrofit/revisions/rev_941ae_2ef7c/rev_941ae-2ef7c;/retrofit/src/main/java/retrofit/http/RestMethodInfo;parseParameters();    String[] namedParams = new String[count];
    String[] headerParams = new String[count];;    String[] namedParams = new String[count];;    String[] urlParam = new String[count];
    String[] queryName = new String[count];
    String[] formValue = new String[count];
    String[] multipartPart = new String[count];
    boolean gotPair = false;
    boolean gotPart = false;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_retrofit/revisions/rev_941ae_2ef7c/rev_941ae-2ef7c;/retrofit/src/main/java/retrofit/http/RestMethodInfo;parseParameters();    this.namedParams = namedParams;
    this.headerParams = headerParams;;    this.namedParams = namedParams;;
    requestUrlParam = urlParam;
    requestQueryName = queryName;
    requestFormPair = formValue;
    requestMultipartPart = multipartPart;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_retrofit/revisions/rev_941ae_2ef7c/rev_941ae-2ef7c;/retrofit/src/main/java/retrofit/http/RequestBuilder;build();    List<HeaderPair> headers = new ArrayList<HeaderPair>();
    if (this.headers != null) {
      headers.addAll(this.headers);
    }
    if (methodInfo.headers != null) {
      headers.addAll(methodInfo.headers);
    }
    // RFC 2616: Field names are case-insensitive
    List<String> lcHeadersToRemove = new ArrayList<String>();
    if (methodInfo.headerParams != null) {
      for (int i = 0; i < methodInfo.headerParams.length; i++) {
        String name = methodInfo.headerParams[i];
        if (name == null) continue;
        Object arg = args[i];
        if (arg != null) {
          headers.add(new HeaderPair(name, arg.toString()));
        } else {
          lcHeadersToRemove.add(name.toLowerCase());
        }
      }
    }
    for (Iterator<HeaderPair> header = headers.iterator(); header.hasNext();) {
      // RFC 2616: Field names are case-insensitive
      if (lcHeadersToRemove.contains(header.next().getName().toLowerCase()))
        header.remove();
    }
    return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);;    return new Request(methodInfo.restMethod.value(), url.toString(), headers, body);;    return new Request(methodInfo.requestMethod, url.toString(), headers, buildBody());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_1798d_83832/rev_1798d-83832;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InterestRateDerivativeVisitorTest;test();    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(IR_FUT_SECURITY.accept(VISITOR), InterestRateFutureSecurity.class);
    assertEquals(IR_FUT_TRANSACTION.accept(VISITOR), InterestRateFutureTransaction.class);
    assertEquals(BNDFUT_SECURITY.accept(VISITOR), BondFutureSecurity.class);
    assertEquals(BNDFUT_TRANSACTION.accept(VISITOR), BondFutureTransaction.class);;    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);;    assertEquals(CM.accept(VISITOR), CouponOIS.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_02074_3a9d5/rev_02074-3a9d5;/projects/OG-Financial/src/com/opengamma/financial/analytics/conversion/SwapSecurityConverter;getTenor(Frequency);      throw new OpenGammaRuntimeException(
          "Can only handle annual, semi-annual, quarterly and monthly frequencies for floating swap legs, not " + freq.getConventionName());;      throw new OpenGammaRuntimeException(
          "Can only handle annual, semi-annual, quarterly and monthly frequencies for floating swap legs");;      throw new OpenGammaRuntimeException("Can only handle annual, semi-annual, quarterly and monthly frequencies for floating swap legs");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2170a_3ba39/rev_2170a-3ba39;/src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter;getColumnFamily();
            // Since this new CF will be written by the next sync(), count its header. And a CF header
            // on disk is:
            //   - the row key: 2 bytes size + key size bytes
            //   - the row level deletion infos: 4 + 8 bytes
            currentSize += 14 + currentKey.key.remaining();;        }
        else
        {
            // We will reuse a CF that we have counted already. But because it will be easier to add the full size
            // of the CF in the next writeRow call than to find out the delta, we just remove the size until that next call
            currentSize -= currentKey.key.remaining() + ColumnFamily.serializer.serializedSize(previous, MessagingService.current_version) * 1.2;;        }
        else
        {
            // We will reuse a CF that we have counted already. But because it will be easier to add the full size
            // of the CF in the next writeRow call than to find out the delta, we just remove the size until that next call
            currentSize -= currentKey.getKey().remaining() + ColumnFamily.serializer.serializedSize(previous, MessagingService.current_version) * 1.2;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2188d_cf96b/rev_2188d-cf96b;/src/java/org/apache/cassandra/io/sstable/SSTableReader;open(Descriptor,Set<Component>,CFMetaData,IPartitioner,boolean);        long start = System.currentTimeMillis();;        assert partitioner != null;
        // Minimum components without which we can't do anything
        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
        assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;

        long start = System.currentTimeMillis();;        assert partitioner != null;
        // Minimum components without which we can't do anything
        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
        assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;

        long start = System.nanoTime();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2188d_cf96b/rev_2188d-cf96b;/src/java/org/apache/cassandra/io/sstable/SSTableReader;load(boolean);        boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder);
        if (recreatebloom || !summaryLoaded)
            buildSummary(recreatebloom, ibuilder, dbuilder, summaryLoaded);;        // try to load summaries from the disk and check if we need
        // to read primary index because we should re-create a BloomFilter or pre-load KeyCache
        final boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder);
        final boolean readIndex = recreatebloom || !summaryLoaded;
        try
        {
            long indexSize = primaryIndex.length();
            long histogramCount = sstableMetadata.estimatedRowSize.count();
            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()
                               ? histogramCount
                               : estimateRowsFromIndex(primaryIndex); // statistics is supposed to be optional
            if (recreatebloom)
                bf = LegacyBloomFilter.getFilter(estimatedKeys, 15);;        // try to load summaries from the disk and check if we need
        // to read primary index because we should re-create a BloomFilter or pre-load KeyCache
        final boolean summaryLoaded = loadSummary(this, ibuilder, dbuilder, metadata);
        final boolean readIndex = recreateBloomFilter || !summaryLoaded;
        try
        {
            long indexSize = primaryIndex.length();
            long histogramCount = sstableMetadata.estimatedRowSize.count();
            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()
                               ? histogramCount
                               : estimateRowsFromIndex(primaryIndex); // statistics is supposed to be optional

            if (recreateBloomFilter)
                bf = FilterFactory.getFilter(estimatedKeys, metadata.getBloomFilterFpChance(), true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_02220_d9ccf/rev_02220-d9ccf;/src/java/org/apache/cassandra/db/commitlog/CommitLog;recover(File[]);                                Table.open(newRm.getTable()).apply(newRm, null, false);
                                tablesRecovered.add(table);;                                Table.open(newRm.getTable()).apply(newRm, null, false);;                                Table.open(newRm.getTable()).apply(newRm, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_2248f_1d54f/rev_2248f-1d54f;/server/src/main/java/com/orientechnologies/orient/server/OClientConnectionManager;disconnect(OClientConnection);    acquireExclusiveLock();
    try {
      metricActiveConnections--;

      for (Entry<Integer, OClientConnection> entry : new HashMap<Integer, OClientConnection>(connections).entrySet()) {
        if (entry.getValue().equals(connection))
          connections.remove(entry.getKey());
      };    acquireExclusiveLock();
    try {
      for (Entry<Integer, OClientConnection> entry : new HashMap<Integer, OClientConnection>(connections).entrySet()) {
        if (entry.getValue().equals(connection))
          connections.remove(entry.getKey());
      };    for (Entry<Integer, OClientConnection> entry : new HashMap<Integer, OClientConnection>(connections).entrySet()) {
      if (entry.getValue().equals(connection))
        connections.remove(entry.getKey());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_02346_48812/rev_02346-48812;/src/java/org/apache/cassandra/net/MessagingService;waitForStreaming();        streamExecutor_.shutdown();
        streamExecutor_.awaitTermination(24, TimeUnit.HOURS);;        streamExecutor_.awaitTermination(24, TimeUnit.HOURS);;        while (true)
        {
            boolean stillWaiting = false;

            streamExecutorsLock.lock();
            try
            {
                for (DebuggableThreadPoolExecutor e : streamExecutors.values())
                {
                    if (!e.isTerminated())
                    {
                        stillWaiting = true;
                        break;
                    }
                }
            }
            finally
            {
                streamExecutorsLock.unlock();
            }
            if (stillWaiting)
            {
                // Up to a second of unneeded delay is acceptable, relative to the amount of time a typical stream
                // takes.
                Thread.sleep(1000);
            }
            else
            {
                break;
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_2397b_26018/rev_2397b-26018;/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement;validate(ClientState);        switch (name.kind)
        {
            case KEY_ALIAS:
            case COLUMN_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on PRIMARY KEY part %s", columnName));
            case VALUE_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on column %s of compact CF", columnName));
            case COLUMN_METADATA:
                ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);
                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");
                if (isCustom && indexClass == null)
                    throw new InvalidRequestException("CUSTOM index requires specifiying the index class");
                if (!isCustom && indexClass != null)
                    throw new InvalidRequestException("Cannot specify index class for a non-CUSTOM index");
                if (cd.getValidator().isCollection() && !isCustom)
                    throw new InvalidRequestException("Indexes on collections are no yet supported");
                break;
            default:
                throw new AssertionError();
        };        switch (name.kind)
        {
            case KEY_ALIAS:
            case COLUMN_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on PRIMARY KEY part %s", columnName));
            case VALUE_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on column %s of compact CF", columnName));
            case COLUMN_METADATA:
                ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);

                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");

                if (cd.getValidator().isCollection() && !isCustom)
                    throw new InvalidRequestException("Indexes on collections are no yet supported");

                props.validate(isCustom);
                break;
            default:
                throw new AssertionError();
        };        if (cd.getIndexType() != null)
            throw new InvalidRequestException("Index already exists");

        // TODO: we could lift that limitation
        if (cfm.getCfDef().isCompact && cd.type != ColumnDefinition.Type.REGULAR)
            throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));

        if (cd.getValidator().isCollection() && !isCustom)
            throw new InvalidRequestException("Indexes on collections are no yet supported");

        if (cd.type == ColumnDefinition.Type.PARTITION_KEY && (cd.componentIndex == null || cd.componentIndex == 0))
            throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", columnName));

        props.validate(isCustom);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mockito/rev_2881a_5a241/rev_2881a-5a241;/src/org/mockito/internal/util/MockUtil;resetMock(T);        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());
        ((Factory) mock).setCallback(0, newFilter);;        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, 
                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));
        ((Factory) mock).setCallback(0, newFilter);;        InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);
        MockCreationSettings settings = oldHandler.getMockSettings();
        InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(
                new MockHandlerImpl<T>(settings), settings);
        mockMaker.resetMock(mock, newHandler, settings);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_3298c_85409/rev_3298c-85409;/src/java/org/apache/cassandra/thrift/ThriftValidation;validateKeyRange(CFMetaData,ByteBuffer,KeyRange);            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0 && !stop.isMinimum())
                throw new InvalidRequestException("Start key's token sorts after end token");;            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
                throw new InvalidRequestException("Start key's token sorts after end token");;            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
                throw new org.apache.cassandra.exceptions.InvalidRequestException("Start key's token sorts after end token");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_03647_297eb/rev_03647-297eb;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;testTickingSwapRates();    final NormalDistribution normDist = new NormalDistribution(0, 1.0, RANDOM);
    final VectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    final double[] swapRates = SWAP_VALUES.clone();;    NormalDistribution normDist = new NormalDistribution(0, 1.0, RANDOM);
    final VectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    double[] swapRates = SWAP_VALUES.clone();;    NormalDistribution normDist = new NormalDistribution(0, 1.0, RANDOM);
    final VectorRootFinder rootFinder = new NewtonVectorRootFinder(EPS, EPS, STEPS);
    double[] swapRates = SWAP_VALUES.clone();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_03647_297eb/rev_03647-297eb;/tests/unit/com/opengamma/math/rootfinding/YieldCurveBootStrapTest;testTickingSwapRates();    final double sigma = 0.03;;    double sigma = 0.03;;    YieldAndDiscountCurve curve;
    double sigma = 0.03;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_4032d_08bee/rev_4032d-08bee;/graylog2-radio/src/main/java/org/graylog2/radio/Main;main(String[]);        Radio radio = new Radio();
        radio.setLifecycle(Lifecycle.STARTING);
        radio.initialize(configuration, metrics);;        Radio radio = new Radio();
        radio.initialize(configuration, metrics);;        Radio radio = injector.getInstance(Radio.class);
        radio.initialize();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_4090c_c5b8f/rev_4090c-c5b8f;/graylog2-server/src/main/java/org/graylog2/Main;main(String[]);        Core server = new Core();
        server.setLifecycle(Lifecycle.STARTING);

        server.initialize(configuration, metrics);;        Core server = new Core();
        server.initialize(configuration, metrics);;        Core server = injector.getInstance(Core.class);
        server.setLifecycle(Lifecycle.STARTING);

        server.initialize();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_4090c_c5b8f/rev_4090c-c5b8f;/graylog2-server/src/main/java/org/graylog2/Core;run();        inputs().launchPersisted();;        inputs().launchPersisted();

        /*
        // Initialize all registered inputs.
        for (MessageInput input : this.inputs) {
            try {
                // This is a plugin. Initialize with custom config from Mongo.
                input.initialize(PluginConfiguration.load(this, input.getClass().getCanonicalName()), this);
                LOG.debug("Initialized input: {}", input.getName());
            } catch (MessageInputConfigurationException e) {
                LOG.error("Could not initialize input <{}>.", input.getClass().getCanonicalName(), e);
            }
        }}
        */;        inputs().launchAllPersisted();

        /*
        // Initialize all registered inputs.
        for (MessageInput input : this.inputs) {
            try {
                // This is a plugin. Initialize with custom config from Mongo.
                input.initialize(PluginConfiguration.load(this, input.getClass().getCanonicalName()), this);
                LOG.debug("Initialized input: {}", input.getName());
            } catch (MessageInputConfigurationException e) {
                LOG.error("Could not initialize input <{}>.", input.getClass().getCanonicalName(), e);
            }
        }}
        */
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_4469c_f32ac/rev_4469c-f32ac;/lucene/src/java/org/apache/lucene/store/CompoundFileWriter;close();    } catch (IOException e) {
      priorException = e;
    } finally {
      IOUtils.closeSafely(priorException, dataOut);
    }
    try {
      entryTableOut = directory.createOutput(entryTableName);;      entryTableOut = directory.createOutput(entryTableName);;      entryTableOut = directory.createOutput(entryTableName, IOContext.DEFAULT);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_5238a_e07a0/rev_5238a-e07a0;/tightdb-java-test/src/test/java/com/tightdb/experiment/GroupToStringTest;groupToJson();        table.addColumn(ColumnType.ColumnTypeBinary, "binary");     // 0
        table.addColumn(ColumnType.ColumnTypeBool, "boolean");      // 1
        table.addColumn(ColumnType.ColumnTypeDate, "date");         // 2
        table.addColumn(ColumnType.ColumnTypeInt, "long");          // 3
        table.addColumn(ColumnType.ColumnTypeMixed, "mixed");       // 4
        table.addColumn(ColumnType.ColumnTypeString, "string");     // 5
        table.addColumn(ColumnType.ColumnTypeTable, "table");       // 6;        table.addColumn(ColumnType.ColumnTypeBinary, "binary");     // 0
        table.addColumn(ColumnType.ColumnTypeBool, "boolean");      // 1
        table.addColumn(ColumnType.ColumnTypeDate, "date");         // 2
        table.addColumn(ColumnType.ColumnTypeDouble, "double");     // 3
        table.addColumn(ColumnType.ColumnTypeFloat, "float");       // 4
        table.addColumn(ColumnType.ColumnTypeInt, "long");          // 5
        table.addColumn(ColumnType.ColumnTypeMixed, "mixed");       // 6
        table.addColumn(ColumnType.ColumnTypeString, "string");     // 7
        table.addColumn(ColumnType.ColumnTypeTable, "table");       // 8;        table.addColumn(ColumnType.BINARY, "binary");     // 0
        table.addColumn(ColumnType.BOOLEAN, "boolean");   // 1
        table.addColumn(ColumnType.DATE, "date");         // 2
        table.addColumn(ColumnType.DOUBLE, "double");     // 3
        table.addColumn(ColumnType.FLOAT, "float");       // 4
        table.addColumn(ColumnType.INTEGER, "long");      // 5
        table.addColumn(ColumnType.MIXED, "mixed");       // 6
        table.addColumn(ColumnType.STRING, "string");     // 7
        table.addColumn(ColumnType.TABLE, "table");       // 8
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_05440_d5715/rev_05440-d5715;/src/java/org/apache/cassandra/gms/Gossiper;start(int);        maybeInitializeLocalState(generationNbr);
        EndpointState localState = endpointStateMap_.get(localEndpoint_);;        EndpointState localState = endpointStateMap_.get(localEndpoint_);
        if ( localState == null )
        {
            HeartBeatState hbState = new HeartBeatState(generationNbr);
            localState = new EndpointState(hbState);
            localState.isAlive(true);
            localState.isAGossiper(true);
            endpointStateMap_.put(localEndpoint_, localState);
        };        EndpointState localState = endpointStateMap.get(FBUtilities.getLocalAddress());
        if ( localState == null )
        {
            HeartBeatState hbState = new HeartBeatState(generationNbr);
            localState = new EndpointState(hbState);
            localState.markAlive();
            endpointStateMap.put(FBUtilities.getLocalAddress(), localState);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared;createClassTrigger();    OClass classTrigger = db.getMetadata().getSchema().getClass(OClassTrigger.CLASSNAME);
    if (classTrigger == null)
      classTrigger = db.getMetadata().getSchema().createAbstractClass(OClassTrigger.CLASSNAME);
    if (!classTrigger.existsProperty(OClassTrigger.ONBEFORE_CREATED)) // before create
      classTrigger.createProperty(OClassTrigger.ONBEFORE_CREATED, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONAFTER_CREATED)) // after create
      classTrigger.createProperty(OClassTrigger.ONAFTER_CREATED, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONBEFORE_READ)) // before read
      classTrigger.createProperty(OClassTrigger.ONBEFORE_READ, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONAFTER_READ)) // after read
      classTrigger.createProperty(OClassTrigger.ONAFTER_READ, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONBEFORE_UPDATED)) // before update
      classTrigger.createProperty(OClassTrigger.ONBEFORE_UPDATED, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONAFTER_UPDATED)) // after update
      classTrigger.createProperty(OClassTrigger.ONAFTER_UPDATED, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONBEFORE_DELETE)) // before delete
      classTrigger.createProperty(OClassTrigger.ONBEFORE_DELETE, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
    if (!classTrigger.existsProperty(OClassTrigger.ONAFTER_DELETE)) // after delete
      classTrigger.createProperty(OClassTrigger.ONAFTER_DELETE, OType.LINK,
          db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));;	  OClass classTrigger = db.getMetadata().getSchema().getClass(OClassTrigger.CLASSNAME);
	  if(classTrigger == null)
		  classTrigger = db.getMetadata().getSchema().createAbstractClass(OClassTrigger.CLASSNAME);
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_CREATE))     //before create
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_CREATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_CREATE))    //after create
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_CREATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_READ))    //before read
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_READ, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_READ))    //after read
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_READ, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_UPDATE))    //before update
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_UPDATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_UPDATE))    //after update
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_UPDATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_DELETE))    //before delete
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_DELETE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_DELETE))    //after delete
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_DELETE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  //classTrigger.setSuperClass(db.getMetadata().getSchema().getClass(RESTRICTED_CLASSNAME));;	  OClass classTrigger = db.getMetadata().getSchema().getClass(OClassTrigger.CLASSNAME);
	  if(classTrigger == null)
		  classTrigger = db.getMetadata().getSchema().createAbstractClass(OClassTrigger.CLASSNAME);
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_CREATE))     //before create
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_CREATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_CREATE))    //after create
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_CREATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_READ))    //before read
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_READ, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_READ))    //after read
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_READ, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_UPDATE))    //before update
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_UPDATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_UPDATE))    //after update
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_UPDATE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_BEFORE_DELETE))    //before delete
		  classTrigger.createProperty(OClassTrigger.PROP_BEFORE_DELETE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  if(!classTrigger.existsProperty(OClassTrigger.PROP_AFTER_DELETE))    //after delete
		  classTrigger.createProperty(OClassTrigger.PROP_AFTER_DELETE, OType.LINK, db.getMetadata().getSchema().getClass(OFunction.CLASS_NAME));
	  classTrigger.setSuperClass(db.getMetadata().getSchema().getClass(RESTRICTED_CLASSNAME));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordBeforeCreate(ODocument);  public RESULT onRecordBeforeCreate(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONBEFORE_CREATED);
    return this.executeFunction(iDocument, func);
  };	public RESULT onRecordBeforeCreate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_CREATE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_CREATED, PROP_BEFORE_CREATE);
		return this.executeFunction(iDocument, func);
	};	public RESULT onRecordBeforeCreate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_CREATE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_CREATED);
		return this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordAfterCreate(ODocument);  public void onRecordAfterCreate(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONAFTER_CREATED);
    this.executeFunction(iDocument, func);
  };	public void onRecordAfterCreate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_CREATE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_CREATED, PROP_AFTER_CREATE);
		this.executeFunction(iDocument, func);
	};	public void onRecordAfterCreate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_CREATE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_CREATED);
		this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordBeforeRead(ODocument);  public RESULT onRecordBeforeRead(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONBEFORE_READ);
    return this.executeFunction(iDocument, func);
  };	public RESULT onRecordBeforeRead(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_READ);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_READ, PROP_BEFORE_READ);
		return this.executeFunction(iDocument, func);
	};	public RESULT onRecordBeforeRead(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_READ);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_READ);
		return this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordAfterRead(ODocument);  public void onRecordAfterRead(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONAFTER_READ);
    this.executeFunction(iDocument, func);
  };	public void onRecordAfterRead(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_READ);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_READ, PROP_AFTER_READ);
		this.executeFunction(iDocument, func);
	};	public void onRecordAfterRead(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_READ);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_READ);
		this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordBeforeUpdate(ODocument);  public RESULT onRecordBeforeUpdate(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONBEFORE_UPDATED);
    return this.executeFunction(iDocument, func);
  };	public RESULT onRecordBeforeUpdate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_UPDATE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_UPDATED, PROP_BEFORE_UPDATE);
		return this.executeFunction(iDocument, func);
	};	public RESULT onRecordBeforeUpdate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_UPDATE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_UPDATED);
		return this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordAfterUpdate(ODocument);  public void onRecordAfterUpdate(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONAFTER_UPDATED);
    this.executeFunction(iDocument, func);
  };	public void onRecordAfterUpdate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_UPDATE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_UPDATED, PROP_AFTER_UPDATE);
		this.executeFunction(iDocument, func);
	};	public void onRecordAfterUpdate(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_UPDATE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_UPDATED);
		this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordBeforeDelete(ODocument);  public RESULT onRecordBeforeDelete(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONBEFORE_DELETE);
    return this.executeFunction(iDocument, func);
  };	public RESULT onRecordBeforeDelete(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_DELETE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_DELETE, PROP_BEFORE_DELETE);
		return this.executeFunction(iDocument, func);
	};	public RESULT onRecordBeforeDelete(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_BEFORE_DELETE);
		OFunction func = this.checkClzAttribute(iDocument, ONBEFORE_DELETE);
		return this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;onRecordAfterDelete(ODocument);  public void onRecordAfterDelete(final ODocument iDocument) {
    OFunction func = this.getClassFunction(iDocument, ONAFTER_DELETE);
    this.executeFunction(iDocument, func);
  };	public void onRecordAfterDelete(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_DELETE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_DELETE, PROP_AFTER_DELETE);
		this.executeFunction(iDocument, func);
	};	public void onRecordAfterDelete(final ODocument iDocument) {
		//ODocument funcDoc = iDocument.field(PROP_AFTER_DELETE);
		OFunction func = this.checkClzAttribute(iDocument, ONAFTER_DELETE);
		this.executeFunction(iDocument, func);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_6287a_3e608/rev_6287a-3e608;/core/src/main/java/com/orientechnologies/orient/core/db/record/OClassTrigger;executeFunction(ODocument,OFunction);    boolean isSuccess = false;
    try {
      if (func.getLanguage() == null)
        throw new OConfigurationException("Database function '" + func.getName() + "' has no language");
      final String funcStr = scriptManager.getFunctionDefinition(func);
      if (funcStr != null) {
        try {
          scriptEngine.eval(funcStr);
        } catch (ScriptException e) {
          scriptManager.getErrorMessage(e, funcStr);
        }
      }
      if (scriptEngine instanceof Invocable) {
        final Invocable invocableEngine = (Invocable) scriptEngine;
        Object[] EMPTY = new Object[0];
        isSuccess = (Boolean) invocableEngine.invokeFunction(func.getName(), EMPTY);
      }
    } catch (ScriptException e) {
      throw new OCommandScriptException("Error on execution of the script", func.getName(), e.getColumnNumber(), e);
    } catch (NoSuchMethodException e) {
      throw new OCommandScriptException("Error on execution of the script", func.getName(), 0, e);
    } catch (OCommandScriptException e) {
      // PASS THROUGH
      throw e;

    } finally {
      scriptManager.unbind(binding);
    }
    if (isSuccess) {
      return RESULT.RECORD_CHANGED;
    }
    return RESULT.RECORD_NOT_CHANGED;
  };	    } finally {
	      scriptManager.unbind(binding);
	    }
	    if(isSuccess) {
	    	return RESULT.RECORD_CHANGED;
	    }
	    return RESULT.RECORD_NOT_CHANGED;
	};	    } finally {
	      scriptManager.unbind(binding);
	    }
	    if(result == null) {
	    	return RESULT.RECORD_NOT_CHANGED;
	    }
	    return RESULT.valueOf(result);//result;
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6407c_48812/rev_6407c-48812;/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;setStoreLocation(String,Job);        if (System.getenv(PIG_USE_SECONDARY) != null)
            usePartitionFilter = Boolean.valueOf(System.getenv(PIG_USE_SECONDARY));;        usePartitionFilter = DEFAULT_USE_SECONDARY;
        if (System.getenv() != null)
            usePartitionFilter = Boolean.valueOf(System.getenv(PIG_USE_SECONDARY));;        usePartitionFilter = DEFAULT_USE_SECONDARY;
        if (System.getenv() != null)
            usePartitionFilter = Boolean.parseBoolean(System.getenv(PIG_USE_SECONDARY));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6554b_57cec/rev_6554b-57cec;/src/java/org/apache/cassandra/service/PendingRangeCalculatorService;calculatePendingRanges(AbstractReplicationStrategy,String);        TokenMetadata tm = StorageService.instance.getTokenMetadata();
        Multimap<Range<Token>, InetAddress> pendingRanges = HashMultimap.create();
        BiMultiValMap<Token, InetAddress> bootstrapTokens = tm.getBootstrapTokens();
        Set<InetAddress> leavingEndpoints = tm.getLeavingEndpoints();

        if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty())
        {
            if (logger.isDebugEnabled())
                logger.debug("No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}", keyspaceName);
            tm.setPendingRanges(keyspaceName, pendingRanges);
            return;
        }

        Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges();

        // Copy of metadata reflecting the situation after all leave operations are finished.
        TokenMetadata allLeftMetadata = tm.cloneAfterAllLeft();

        // get all ranges that will be affected by leaving nodes
        Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>();
        for (InetAddress endpoint : leavingEndpoints)
            affectedRanges.addAll(addressRanges.get(endpoint));

        // for each of those ranges, find what new nodes will be responsible for the range when
        // all leaving nodes are gone.
        for (Range<Token> range : affectedRanges)
        {
            Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, tm.cloneOnlyTokenMap()));
            Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata));
            pendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints));
        }

        // At this stage pendingRanges has been updated according to leave operations. We can
        // now continue the calculation by checking bootstrapping nodes.

        // For each of the bootstrapping nodes, simply add and remove them one by one to
        // allLeftMetadata and check in between what their ranges would be.
        Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse();
        for (InetAddress endpoint : bootstrapAddresses.keySet())
        {
            Collection<Token> tokens = bootstrapAddresses.get(endpoint);

            allLeftMetadata.updateNormalTokens(tokens, endpoint);
            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);
        }

        // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.
        // We can now finish the calculation by checking moving and relocating nodes.

        // For each of the moving nodes, we do the same thing we did for bootstrapping:
        // simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.
        for (Pair<Token, InetAddress> moving : tm.getMovingEndpoints())
        {
            InetAddress endpoint = moving.right; // address of the moving node

            //  moving.left is a new token of the endpoint
            allLeftMetadata.updateNormalToken(moving.left, endpoint);

            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
            {
                pendingRanges.put(range, endpoint);
            }

            allLeftMetadata.removeEndpoint(endpoint);
        }

        tm.setPendingRanges(keyspaceName, pendingRanges);

        if (logger.isDebugEnabled())
            logger.debug("Pending ranges:\n" + (pendingRanges.isEmpty() ? "<empty>" : tm.printPendingRanges()));;        TokenMetadata tm = StorageService.instance.getTokenMetadata();
        Multimap<Range<Token>, InetAddress> pendingRanges = HashMultimap.create();
        BiMultiValMap<Token, InetAddress> bootstrapTokens = tm.getBootstrapTokens();
        Set<InetAddress> leavingEndpoints = tm.getLeavingEndpoints();

        if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty() && tm.getRelocatingRanges().isEmpty())
        {
            if (logger.isDebugEnabled())
                logger.debug("No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}", keyspaceName);
            tm.setPendingRanges(keyspaceName, pendingRanges);
            return;
        }

        Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges();

        // Copy of metadata reflecting the situation after all leave operations are finished.
        TokenMetadata allLeftMetadata = tm.cloneAfterAllLeft();

        // get all ranges that will be affected by leaving nodes
        Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>();
        for (InetAddress endpoint : leavingEndpoints)
            affectedRanges.addAll(addressRanges.get(endpoint));

        // for each of those ranges, find what new nodes will be responsible for the range when
        // all leaving nodes are gone.
        for (Range<Token> range : affectedRanges)
        {
            Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, tm.cloneOnlyTokenMap()));
            Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata));
            pendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints));
        }

        // At this stage pendingRanges has been updated according to leave operations. We can
        // now continue the calculation by checking bootstrapping nodes.

        // For each of the bootstrapping nodes, simply add and remove them one by one to
        // allLeftMetadata and check in between what their ranges would be.
        Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse();
        for (InetAddress endpoint : bootstrapAddresses.keySet())
        {
            Collection<Token> tokens = bootstrapAddresses.get(endpoint);

            allLeftMetadata.updateNormalTokens(tokens, endpoint);
            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);
        }

        // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.
        // We can now finish the calculation by checking moving and relocating nodes.

        // For each of the moving nodes, we do the same thing we did for bootstrapping:
        // simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.
        for (Pair<Token, InetAddress> moving : tm.getMovingEndpoints())
        {
            InetAddress endpoint = moving.right; // address of the moving node

            //  moving.left is a new token of the endpoint
            allLeftMetadata.updateNormalToken(moving.left, endpoint);

            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
            {
                pendingRanges.put(range, endpoint);
            }

            allLeftMetadata.removeEndpoint(endpoint);
        }

        // Ranges being relocated.
        for (Map.Entry<Token, InetAddress> relocating : tm.getRelocatingRanges().entrySet())
        {
            InetAddress endpoint = relocating.getValue(); // address of the moving node
            Token token = relocating.getKey();

            allLeftMetadata.updateNormalToken(token, endpoint);

            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);

            allLeftMetadata.removeEndpoint(endpoint);
        }

        tm.setPendingRanges(keyspaceName, pendingRanges);

        if (logger.isDebugEnabled())
            logger.debug("Pending ranges:\n" + (pendingRanges.isEmpty() ? "<empty>" : tm.printPendingRanges()));;        StorageService.instance.getTokenMetadata().calculatePendingRanges(strategy, keyspaceName);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6679d_b7cb2/rev_6679d-b7cb2;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getCash(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<Identifier,Double>);private CashSecurity getCash(InterpolatedYieldCurveSpecification spec, FixedIncomeStripWithIdentifier strip, Map<Identifier, Double> marketValues) {
//    CashSecurity sec = new CashSecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                                        new DateTimeWithZone(spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00)));
    CashSecurity sec = new CashSecurity(spec.getCurrency(), spec.getRegion(), 
        spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00).atZone(TimeZone.UTC), marketValues.get(strip.getSecurity()), 1.0d);;private CashSecurity getCash(InterpolatedYieldCurveSpecification spec, FixedIncomeStripWithIdentifier strip, Map<Identifier, Double> marketValues) {
//    CashSecurity sec = new CashSecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                                        new DateTimeWithZone(spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00)));
    CashSecurity sec = new CashSecurity(spec.getCurrency(), spec.getRegion(), 
        new DateTimeWithZone(spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00)), marketValues.get(strip.getSecurity()), 1.0d);;private CashSecurity getCash(InterpolatedYieldCurveSpecification spec, FixedIncomeStripWithIdentifier strip,
      Map<Identifier, Double> marketValues) {
    //    CashSecurity sec = new CashSecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
    //                                        new DateTimeWithZone(spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00)));
    CashSecurity sec = new CashSecurity(spec.getCurrency(), spec.getRegion(),
        new DateTimeWithZone(spec.getCurveDate().plus(strip.getMaturity().getPeriod()).atTime(11, 00)),
        marketValues.get(strip.getSecurity()), 1.0d);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6679d_b7cb2/rev_6679d-b7cb2;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getFRA(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<Identifier,Double>);//    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    return new FRASecurity(spec.getCurrency(), spec.getRegion(), 
        startDate.atTime(11, 00).atZone(TimeZone.UTC), endDate.atTime(11, 00).atZone(TimeZone.UTC), marketValues.get(strip.getSecurity()), 1.0d);;//    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    return new FRASecurity(spec.getCurrency(), spec.getRegion(), 
        new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)), marketValues.get(strip.getSecurity()), 1.0d);;    //    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
    //                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    return new FRASecurity(spec.getCurrency(), spec.getRegion(),
        new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)),
        marketValues.get(strip.getSecurity()), 1.0d);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6679d_b7cb2/rev_6679d-b7cb2;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getSwap(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<Identifier,Double>);    ZonedDateTime tradeDate = curveDate.atTime(11, 00).atZone(TimeZone.UTC);
    ZonedDateTime effectiveDate = DateUtil.previousWeekDay(curveDate.plusDays(3)).atTime(11, 00).atZone(TimeZone.UTC);
    ZonedDateTime maturityDate = curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00).atZone(TimeZone.UTC);
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_SWAP"));;    DateTimeWithZone tradeDate = new DateTimeWithZone(curveDate.atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone effectiveDate = new DateTimeWithZone(DateUtil.previousWeekDay(curveDate.plusDays(3)).atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone maturityDate = new DateTimeWithZone(curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00).atZone(TimeZone.UTC));
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_SWAP"));;    DateTimeWithZone tradeDate = new DateTimeWithZone(curveDate.atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone effectiveDate = new DateTimeWithZone(DateUtil.previousWeekDay(curveDate.plusDays(3))
        .atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone maturityDate = new DateTimeWithZone(curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00)
        .atZone(TimeZone.UTC));
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(
        InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_SWAP"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6679d_b7cb2/rev_6679d-b7cb2;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getTenorSwap(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<Identifier,Double>);    ZonedDateTime tradeDate = curveDate.atTime(11, 00).atZone(TimeZone.UTC);
    ZonedDateTime effectiveDate = DateUtil.previousWeekDay(curveDate.plusDays(3)).atTime(11, 00).atZone(TimeZone.UTC);
    ZonedDateTime maturityDate = curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00).atZone(TimeZone.UTC);
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_TENOR_SWAP"));;    DateTimeWithZone tradeDate = new DateTimeWithZone(curveDate.atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone effectiveDate = new DateTimeWithZone(DateUtil.previousWeekDay(curveDate.plusDays(3)).atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone maturityDate = new DateTimeWithZone(curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00).atZone(TimeZone.UTC));
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_TENOR_SWAP"));;    DateTimeWithZone tradeDate = new DateTimeWithZone(curveDate.atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone effectiveDate = new DateTimeWithZone(DateUtil.previousWeekDay(curveDate.plusDays(3))
        .atTime(11, 00).atZone(TimeZone.UTC));
    DateTimeWithZone maturityDate = new DateTimeWithZone(curveDate.plus(strip.getMaturity().getPeriod()).atTime(11, 00)
        .atZone(TimeZone.UTC));
    ConventionBundle convention = _conventionBundleSource.getConventionBundle(Identifier.of(
        InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, spec.getCurrency().getCode() + "_TENOR_SWAP"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_6679d_b7cb2/rev_6679d-b7cb2;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        if (strip.getInstrumentType() == StripInstrumentType.SWAP) {
          //derivative = financialSecurity.accept(instrumentAdapter).toDerivative(localNow, _fundingCurveDefinitionName,
          //    _forwardCurveDefinitionName);
          derivative = swapConverter.getSwap((SwapSecurity) strip.getSecurity(), _fundingCurveDefinitionName,
              _forwardCurveDefinitionName, marketValue / 100., 0.0, now);
        } else if (strip.getInstrumentType() == StripInstrumentType.CASH) {          
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.FRA) {
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _fundingCurveDefinitionName,
              _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.FUTURE) {
          derivative = financialSecurity.accept(futureAdapter).toDerivative(now, marketValue,
              _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.LIBOR) {
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.TENOR_SWAP) {
          derivative = tenorSwapConverter.getSwap((SwapSecurity) strip.getSecurity(), _fundingCurveDefinitionName,
              _fundingCurveDefinitionName, _forwardCurveDefinitionName, marketValue / 10000., now);;        if (strip.getInstrumentType() == StripInstrumentType.SWAP) {
          //derivative = financialSecurity.accept(instrumentAdapter).toDerivative(localNow, _fundingCurveDefinitionName,
          //    _forwardCurveDefinitionName);
          derivative = swapConverter.getSwap((SwapSecurity) strip.getSecurity(), _fundingCurveDefinitionName,
              _forwardCurveDefinitionName, marketValue / 100., 0.0, now);
        } else if (strip.getInstrumentType() == StripInstrumentType.CASH) {
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.FRA) {
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _fundingCurveDefinitionName,
              _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.FUTURE) {
          derivative = financialSecurity.accept(futureAdapter).toDerivative(now, marketValue,
              _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.LIBOR) {
          derivative = financialSecurity.accept(instrumentAdapter).toDerivative(now, _forwardCurveDefinitionName);
        } else if (strip.getInstrumentType() == StripInstrumentType.TENOR_SWAP) {
          derivative = tenorSwapConverter.getSwap((SwapSecurity) strip.getSecurity(), _fundingCurveDefinitionName,
              _fundingCurveDefinitionName, _forwardCurveDefinitionName, marketValue / 10000., now);;        String[] curveNames = FixedIncomeInstrumentCurveExposureHelper.getCurveNamesForForwardCurveInstrument(strip
            .getInstrumentType(), _fundingCurveDefinitionName, _forwardCurveDefinitionName);
        if (strip.getInstrumentType() == StripInstrumentType.FUTURE) {
          derivative = financialSecurity.accept(_futureAdapter).toDerivative(now, marketValue, curveNames);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6850c_72ca5/rev_6850c-72ca5;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                List<InetAddress> endpoints = getLiveSortedEndpoints(table, command.key);
                CFMetaData cfm = Schema.instance.getCFMetaData(command.getKeyspace(), command.getColumnFamilyName());

                ReadRepairDecision rrDecision = cfm.newReadRepairDecision();
                endpoints = consistency_level.filterForQuery(table, endpoints, rrDecision);
                
                if (rrDecision != ReadRepairDecision.NONE) {
                    ReadRepairMetrics.attempted.mark();
                }

                RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
                ReadCallback<ReadResponse, Row> handler = new ReadCallback(resolver, consistency_level, command, endpoints);
                handler.assureSufficientLiveNodes();
                assert !endpoints.isEmpty();
                readCallbacks[i] = handler;

                // The data-request message is sent to dataPoint, the node that will actually get the data for us
                InetAddress dataPoint = endpoints.get(0);
                if (dataPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                {
                    logger.trace("reading data locally");
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
                }
                else
                {
                    logger.trace("reading data from {}", dataPoint);
                    MessagingService.instance().sendRR(command.createMessage(), dataPoint, handler);
                };                List<InetAddress> endpoints = getLiveSortedEndpoints(table, command.key);
                CFMetaData cfm = Schema.instance.getCFMetaData(command.getKeyspace(), command.getColumnFamilyName());
                endpoints = consistency_level.filterForQuery(table, endpoints, cfm.newReadRepairDecision());

                RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
                ReadCallback<ReadResponse, Row> handler = new ReadCallback(resolver, consistency_level, command, endpoints);
                handler.assureSufficientLiveNodes();
                assert !endpoints.isEmpty();
                readCallbacks[i] = handler;

                // The data-request message is sent to dataPoint, the node that will actually get the data for us
                InetAddress dataPoint = endpoints.get(0);
                if (dataPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                {
                    logger.trace("reading data locally");
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
                }
                else
                {
                    logger.trace("reading data from {}", dataPoint);
                    MessagingService.instance().sendRR(command.createMessage(), dataPoint, handler);
                };                AbstractReadExecutor exec = AbstractReadExecutor.getReadExecutor(command, consistency_level);
                exec.executeAsync();
                readExecutors[i] = exec;
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_6850c_72ca5/rev_6850c-72ca5;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                    logger.debug("Digest mismatch: {}", ex.toString());
                    
                    ReadRepairMetrics.repairedBlocking.mark();
                    ;                    logger.debug("Digest mismatch: {}", ex.toString());;                    logger.trace("Digest mismatch: {}", ex);
                    
                    ReadRepairMetrics.repairedBlocking.mark();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_6936d_adffb/rev_6936d-adffb;/src/main/java/com/tightdb/example/Example;main(String[]);		int rowArg = 250000;
		if (args.length > 0) {
		    try {
		        rowArg = Integer.parseInt(args[0]);
		    } catch (NumberFormatException e) {
		        System.err.println("Argument" + " must be an integer");
		        System.exit(1);
		    };		EmployeeTable employees = new EmployeeTable();

		/****************************** BASIC OPERATIONS *****************************/

		Employee john = employees.add("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(), "extra");
		Employee johny = employees.add("Johny", "Goe", 20000, true, new byte[] { 1, 2, 3 }, new Date(), true);
		Employee nikolche = employees.insert(1, "Nikolche", "Mihajlovski", 30000, false, new byte[] { 4, 5 }, new Date(), 1234.56);

		TightDB.print("Employees", employees);

		TightDB.print("Johny", johny);

		System.out.println("first record: " + john);
		System.out.println("second record: " + nikolche);
		System.out.println("some column: " + john.firstName);

		/****************************** GETTERS AND SETTERS *****************************/

		// 2 ways to get the value
		System.out.println("name1: " + john.firstName.get());
		System.out.println("name2: " + john.getFirstName());

		// 2 ways to set the value
		employees.at(2).lastName.set("NewName");
		employees.at(2).setLastName("NewName");

		Employee niko = employees.firstName.startsWith("Nik").findUnique();
		System.out.println("Unique Niko: " + niko);

		/****************************** MANIPULATION OF ALL RECORDS *****************************/

		// using explicit OR
		TightDB.print("Search example", employees.firstName.is("Johnny").or().lastName.is("Mihajlovski").findFirst());

		// using implicit AND
		TightDB.print("Search example 2", employees.firstName.is("Johnny").lastName.startsWith("B").findLast());

		employees.firstName.is("John").findLast().salary.set(30000);

		/****************************** ITERATION OF ALL RECORDS *****************************/

		// lazy iteration over the table
		for (Employee employee : employees) {
			System.out.println("iterating: " + employee);;		EmployeeTable employees = new EmployeeTable();

		/****************************** BASIC OPERATIONS *****************************/

		Employee john = employees.add("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(), "extra");
		Employee johny = employees.add("Johny", "Goe", 20000, true, new byte[] { 1, 2, 3 }, new Date(), true);
		Employee nikolche = employees.insert(1, "Nikolche", "Mihajlovski", 30000, false, new byte[] { 4, 5 }, new Date(), 1234.56);

		TightDB.print("Employees", employees);

		TightDB.print("Johny", johny);

		System.out.println("first record: " + john);
		System.out.println("second record: " + nikolche);
		System.out.println("some column: " + john.firstName);

		/****************************** GETTERS AND SETTERS *****************************/

		// 2 ways to get the value
		System.out.println("name1: " + john.firstName.get());
		System.out.println("name2: " + john.getFirstName());

		// 2 ways to set the value
		employees.at(2).lastName.set("NewName");
		employees.at(2).setLastName("NewName");

		/****************************** MANIPULATION OF ALL RECORDS *****************************/

		// using explicit OR
		TightDB.print("Search example", employees.firstName.is("Johnny").or().lastName.is("Mihajlovski").findFirst());

		// using implicit AND
		TightDB.print("Search example 2", employees.firstName.is("Johnny").lastName.startsWith("B").findLast());

		employees.firstName.is("John").findLast().salary.set(30000);

		/****************************** ITERATION OF ALL RECORDS *****************************/

		// lazy iteration over the table
		for (Employee employee : employees) {
			System.out.println("iterating: " + employee);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_06955_e17ef/rev_06955-e17ef;/multiColumnTables/src/main/java/org/acme/example/view/MultiColTableModel;setValue(String,Object);				fireTableCellUpdated(row, settings.getIndexForColumn(ColumnType.VALUE)); 
				fireTableCellUpdated(row, settings.getIndexForColumn(ColumnType.RAW)); ;				fireTableCellUpdated(row, ColumnType.VALUE.ordinal()); 
				fireTableCellUpdated(row, ColumnType.RAW.ordinal()); ;				fireTableCellUpdated(row, ColumnType.VALUE.ordinal()); 
				fireTableCellUpdated(row, ColumnType.RAW.ordinal()); 
				fireTableCellUpdated(row, ColumnType.ERT.ordinal()); 
				fireTableCellUpdated(row, ColumnType.SCET.ordinal()); 
				fireTableCellUpdated(row, ColumnType.SCLK.ordinal()); 
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_7105a_603f9/rev_7105a-603f9;/src/java/org/apache/cassandra/thrift/CassandraServer;insert(ByteBuffer,ColumnParent,Column,ConsistencyLevel);        state().hasColumnFamilyAccess(column_parent.column_family, Permission.WRITE);

        ThriftValidation.validateKey(key);
        ThriftValidation.validateColumnParent(state().getKeyspace(), column_parent);
        // SuperColumn field is usually optional, but not when we're inserting
        if (DatabaseDescriptor.getColumnFamilyType(state().getKeyspace(), column_parent.column_family) == ColumnFamilyType.Super
            && column_parent.super_column == null)
        {
            throw new InvalidRequestException("missing mandatory super column name for super CF " + column_parent.column_family);
        }
        ThriftValidation.validateColumnNames(state().getKeyspace(), column_parent, Arrays.asList(column.name));
        ThriftValidation.validateColumnData(state().getKeyspace(), column_parent.column_family, column);

        RowMutation rm = new RowMutation(state().getKeyspace(), key);
        try
        {
            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, column.timestamp, column.ttl);
        }
        catch (MarshalException e)
        {
            throw new InvalidRequestException(e.getMessage());
        }
        doInsert(consistency_level, Arrays.asList(rm));;        state().hasColumnFamilyAccess(column_parent.column_family, Permission.WRITE);

        ThriftValidation.validateKey(key);
        ThriftValidation.validateColumnParent(state().getKeyspace(), column_parent);
        ThriftValidation.validateColumnNames(state().getKeyspace(), column_parent, Arrays.asList(column.name));
        ThriftValidation.validateColumnData(state().getKeyspace(), column_parent.column_family, column);

        RowMutation rm = new RowMutation(state().getKeyspace(), key);
        try
        {
            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, column.timestamp, column.ttl);
        }
        catch (MarshalException e)
        {
            throw new InvalidRequestException(e.getMessage());
        }
        doInsert(consistency_level, Arrays.asList(rm));;        internal_insert(key, column_parent, column, consistency_level);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_7121a_855e2/rev_7121a-855e2;/realm/src/main/java/io/realm/Realm;initialValue();        protected SoftReference<Realm> initialValue() {
            Realm realm = new Realm(absolutePath, key);
            key = null;
            return new SoftReference<Realm>(realm);;        protected SoftReference<Realm> initialValue() {
            Realm realm = new Realm(absolutePath);
            return new SoftReference<Realm>(realm);;        protected Map<String, Realm> initialValue() {
            return new HashMap<String, Realm>();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7650f_65f09/rev_7650f-65f09;/tests/unit/com/opengamma/engine/security/server/RESTMethodTest;configureService();    DefaultSecurity sec1 = new DefaultSecurity("t1", new IdentifierBundle(secId1));
    securitySource.addSecurity(sec1);
    DefaultSecurity sec2 = new DefaultSecurity("t2", new IdentifierBundle(secId2));
    securitySource.addSecurity(sec2);
    getSecuritySourceService().setSecuritySource(securitySource);;    DefaultSecurity sec1 = new DefaultSecurity("t1", new IdentifierBundle(secId1));
    secMaster.addSecurity(sec1);
    DefaultSecurity sec2 = new DefaultSecurity("t2", new IdentifierBundle(secId2));
    secMaster.addSecurity(sec2);
    getSecurityMasterService ().setSecurityMaster (secMaster);;    DefaultSecurity sec1 = new DefaultSecurity("t1");
    sec1.setIdentifiers (new IdentifierBundle(secId1));
    secMaster.addSecurity(sec1);
    DefaultSecurity sec2 = new DefaultSecurity("t2");
    sec2.setIdentifiers (new IdentifierBundle(secId2));
    secMaster.addSecurity(sec2);
    getSecurityMasterService ().setSecurityMaster (secMaster);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be;/src/java/voldemort/store/routed/RoutedStore;delete(ByteArray,Version);                        failureDetector.recordException(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;;                        markUnavailable(node, e);;                        markUnavailable(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be;/src/java/voldemort/store/routed/RoutedStore;getAll(Iterable<ByteArray>);                            failureDetector.recordException(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;;                            markUnavailable(node, e);;                            markUnavailable(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be;/src/java/voldemort/store/routed/RoutedStore;get(ByteArray,StoreOp<R>,Function<List<GetResult<R>>,Void>);                failureDetector.recordException(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;;                markUnavailable(node, e);;                markUnavailable(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_7817d_852ba/rev_7817d-852ba;/esc/src/main/java/org/cloudifysource/esc/installer/AgentlessInstaller;remoteExecuteAgentOnServer(InstallationDetails,long,String);				.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? "true" : "false")
				.exportVar(MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp() : details.getPublicIp());				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp());				.exportVar(CloudifyConstants.SPRING_BEANS_PROFILE_ENV_VAR, "nonsecure")
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/tool/ExampleDatabasePopulator;loadFutures(Set<ExternalIdBundle>);    SecurityMaster secMaster = getToolContext().getSecurityMaster();
    ReferenceDataProvider referenceDataProvider = getBloombergToolContext().getBloombergReferenceDataProvider();
    ExchangeDataProvider exchangeDataProvider = new DefaultExchangeDataProvider();
    BloombergBulkSecurityLoader bulkSecurityLoader = new BloombergBulkSecurityLoader(referenceDataProvider, exchangeDataProvider);
    BloombergSecurityLoader securityLoader = new BloombergSecurityLoader(secMaster, bulkSecurityLoader);;    SecurityMaster secMaster = getToolContext().getSecurityMaster();
    ReferenceDataProvider referenceDataProvider = ((BloombergToolContext) getToolContext()).getBloombergReferenceDataProvider();
    ExchangeDataProvider exchangeDataProvider = new DefaultExchangeDataProvider();
    BloombergBulkSecurityLoader bulkSecurityLoader = new BloombergBulkSecurityLoader(referenceDataProvider, exchangeDataProvider);
    BloombergSecurityLoader securityLoader = new BloombergSecurityLoader(secMaster, bulkSecurityLoader);;    SecurityMaster securityMaster = getToolContext().getSecurityMaster();
    SecurityProvider securityProvider = getToolContext().getSecurityProvider();
    BloombergSecurityLoader securityLoader = new BloombergSecurityLoader(securityProvider, securityMaster);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/loader/DemoEquityOptionCollarPortfolioLoader;getOptionChain(ExternalId);    }    
    ReferenceDataProvider referenceDataProvider = getBloombergToolContext().getBloombergReferenceDataProvider();;    }    
    ReferenceDataProvider referenceDataProvider = ((BloombergToolContext) getToolContext()).getBloombergReferenceDataProvider();;    }
    ReferenceDataProvider referenceDataProvider = getBloombergToolContext().getBloombergReferenceDataProvider();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_7907b_c4257/rev_7907b-c4257;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/loader/DemoEquityOptionCollarPortfolioLoader;loadTimeSeries(ExternalIdBundle);private HistoricalTimeSeriesInfoDocument loadTimeSeries(ExternalIdBundle idBundle) {    
    ReferenceDataProvider referenceDataProvider = getBloombergToolContext().getBloombergReferenceDataProvider();;private HistoricalTimeSeriesInfoDocument loadTimeSeries(ExternalIdBundle idBundle) {    
    ReferenceDataProvider referenceDataProvider = ((BloombergToolContext) getToolContext()).getBloombergReferenceDataProvider();;private HistoricalTimeSeriesInfoDocument loadTimeSeries(ExternalIdBundle idBundle) {
    ReferenceDataProvider referenceDataProvider = getBloombergToolContext().getBloombergReferenceDataProvider();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_7957f_43161/rev_7957f-43161;/subprojects/gradle-launcher/src/main/java/org/gradle/launcher/Main;execute();        } catch (Throwable e) {
            new BuildExceptionReporter(new StreamingStyledTextOutputFactory(System.err), new StartParameter()).reportException(e);
            buildCompleter.exit(e);;        }

        if (startParameter.isLaunchGUI()) {
            try {
                BlockingApplication.launchAndBlock();
            } catch (Throwable e) {
                logger.error("Failed to run the UI.", e);
                buildCompleter.exit(e);
            }

            buildCompleter.exit(null);
        }

        BuildListener resultLogger = new BuildLogger(logger, buildTimeClock, startParameter);
        try {
            GradleLauncher gradleLauncher = GradleLauncher.newInstance(startParameter);

            gradleLauncher.useLogger(resultLogger);

            BuildResult buildResult = gradleLauncher.run();
            if (buildResult.getFailure() != null) {
                buildCompleter.exit(buildResult.getFailure());
            }
        } catch (Throwable e) {
            resultLogger.buildFinished(new BuildResult(null, e));
            buildCompleter.exit(e);;        }

        try {
            if (startParameter.isLaunchGUI()) {
                BlockingApplication.launchAndBlock();
            } else if (startParameter.isForeground()) {
                new GradleDaemon().run(args);
            } else if (startParameter.isNoDaemon()) {
                new GradleDaemon().build(new File(System.getProperty("user.dir")), args);
            } else if (startParameter.isStopDaemon()) {
                new GradleDaemon().stop();
            } else {
                new GradleDaemon().clientMain(new File(System.getProperty("user.dir")), args);
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            buildCompleter.exit(throwable);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_7957f_43161/rev_7957f-43161;/subprojects/gradle-core/src/main/groovy/org/gradle/logging/internal/DefaultColorMap;DefaultColorMap();        addDefault(Info, "yellow");
        addDefault(Error, "default");
        addDefault(Header, "default");
        addDefault(Description, "yellow");
        addDefault(ProgressStatus, "yellow");
        addDefault(Identifier, "green");
        addDefault(UserInput, "bold");
        addDefault(Success, "default");
        addDefault(Failure, "red");
        addDefault(STATUSBAR, "bold");;//        addDefault(Header, DEFAULT);
        addDefault(Info, YELLOW);
        addDefault(Description, YELLOW);
        addDefault(ProgressStatus, YELLOW);
        addDefault(Identifier, GREEN);
        addDefault(UserInput, GREEN);
        addDefault(Failure, RED);
//        addDefault(Error, RED);
        defaults.put(STATUSBAR, BOLD);;//        addDefault(Header, DEFAULT);
        addDefault(Info, YELLOW);
        addDefault(Description, YELLOW);
        addDefault(ProgressStatus, YELLOW);
        addDefault(Identifier, GREEN);
        addDefault(UserInput, GREEN);
        addDefault(Failure, RED);
        addDefault(Error, RED);
        defaults.put(STATUSBAR, BOLD);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_8442d_3190c/rev_8442d-3190c;/src/com/opengamma/financial/analytics/ircurve/DiscountCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);    @SuppressWarnings("unchecked")
    YieldAndDiscountCurve discountCurve = new InterpolatedDiscountCurve(timeInYearsToRates, _interpolator);;    YieldAndDiscountCurve discountCurve = new InterpolatedDiscountCurve(timeInYearsToRates, _interpolator);;    YieldAndDiscountCurve yieldCurve = new InterpolatedYieldCurve(timeInYearsToRates, _interpolator);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_8476d_7702d/rev_8476d-7702d;/lucene/src/java/org/apache/lucene/index/DocFieldProcessorPerThread;processDocument();    ArrayUtil.quickSort(fields, 0, fieldCount, fieldsComp);;    quickSort(fields, 0, fieldCount-1);;    quickSort(fields, 0, fieldCount-1);
   
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9083c_ae0d5/rev_9083c-ae0d5;/src/java/org/apache/cassandra/service/StorageService;initServer();        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap
        setToken(token);;        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap
        setToken(token);
        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));
        setMode("Normal", false);;        if(!bootstrapped)
            setToken(token);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_9236a_4cbc5/rev_9236a-4cbc5;/src/main/java/com/tightdb/example/FailureExample;main(String[]);		employees.at(0).phones.get();

		try {
			group.writeToFile("employees.tdb");
		} catch (IOException e) {
			throw new RuntimeException("Couldn't save the data!", e);
		}

		employees.clear();;		// This works:
		PhoneTable tbl = john.phones.get();
		PhoneTable tbl2 = john.phones.get();
		PhoneTable tbl3 = john.phones.get();
		
		
		// and this works:
		john.phones.get();
		john.phones.get();
				
		john.phones.get();
		john.phones.get();

		// Enable below to compare Tightdb performance against a Java ArrayList
		Performance.TestTightdb(250000);
		
//		System.out.println(a);
//		System.out.println(b);;		// This works:
		PhoneTable tbl = john.phones.get();
		tbl.add("test", "123");
		TightDB.print(tbl);
		
		PhoneTable tbl2 = john.phones.get();
		TightDB.print(tbl2);
		
		//john.phones.get().add("home", "222");
		//john.getPhones().add("home2", "333");
				
				
/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_9284d_166ec/rev_9284d-166ec;/query/src/test/java/org/infinispan/query/blackbox/KeyTypeTest;createCacheManager();         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      cacheManager = TestCacheManagerFactory.createCacheManager(c, true);;         .addProperty("hibernate.search.default.directory_provider", "ram");
      cacheManager = TestCacheManagerFactory.createCacheManager(c, true);;         .addProperty("hibernate.search.default.directory_provider", "ram");
      cacheManager = TestCacheManagerFactory.createCacheManager(c);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_9511c_71af7/rev_9511c-71af7;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;log(OWALRecord);public OLogSequenceNumber log(OWALRecord record) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      final byte[] serializedForm = OWALRecordsFactory.INSTANCE.toStream(record);

      LogSegment last = logSegments.get(logSegments.size() - 1);
      long lastSize = last.filledUpTo();

      final OLogSequenceNumber lsn = last.logRecord(serializedForm);
      record.setLsn(lsn);

      if (record.isUpdateMasterRecord()) {
        lastCheckpoint = lsn;
        if (useFirstMasterRecord) {
          firstMasterRecord = lsn;
          writeMasterRecord(0, firstMasterRecord);
          useFirstMasterRecord = false;
        } else {
          secondMasterRecord = lsn;
          writeMasterRecord(1, secondMasterRecord);
          useFirstMasterRecord = true;
        }
      }

      final long sizeDiff = last.filledUpTo() - lastSize;
      logSize += sizeDiff;

      if (logSize >= maxLogSize) {
        final LogSegment first = removeHeadSegmentFromList();

				if (first != null) {
					first.stopFlush(false);

					logSize -= first.filledUpTo();

					first.delete(false);
					fixMasterRecords();
				}
      }

      if (last.filledUpTo() >= maxSegmentSize) {
        last.stopFlush(true);

        last = new LogSegment(new File(walLocation, getSegmentName(last.getOrder() + 1)), maxPagesCacheSize);
        last.init();
        last.startFlush();

        logSegments.add(last);
      }

      return lsn;
    }
  };public OLogSequenceNumber log(OWALRecord record) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      final byte[] serializedForm = OWALRecordsFactory.INSTANCE.toStream(record);

      LogSegment last = logSegments.get(logSegments.size() - 1);
      long lastSize = last.filledUpTo();

      final OLogSequenceNumber lsn = last.logRecord(serializedForm);
      record.setLsn(lsn);

      if (record.isUpdateMasterRecord()) {
        lastCheckpoint = lsn;
        if (useFirstMasterRecord) {
          firstMasterRecord = lsn;
          writeMasterRecord(0, firstMasterRecord);
          useFirstMasterRecord = false;
        } else {
          secondMasterRecord = lsn;
          writeMasterRecord(1, secondMasterRecord);
          useFirstMasterRecord = true;
        }
      }

      final long sizeDiff = last.filledUpTo() - lastSize;
      logSize += sizeDiff;

      if (logSize >= maxLogSize) {
        LogSegment first = logSegments.get(0);
        first.stopFlush(false);

        logSize -= first.filledUpTo();

        first.delete(false);
        logSegments.remove(0);

        fixMasterRecords();
      }

      if (last.filledUpTo() >= maxSegmentSize) {
        last.stopFlush(true);

        last = new LogSegment(new File(walLocation, getSegmentName(last.getOrder() + 1)), maxPagesCacheSize);
        last.init();
        last.startFlush();

        logSegments.add(last);
      }

      return lsn;
    }
  };OLogSequenceNumber log(OWALRecord record) throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_9511c_71af7/rev_9511c-71af7;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;cutTill(OLogSequenceNumber);public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size() - 1; i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = removeHeadSegmentFromList();
        if (logSegment != null)
          logSegment.delete(false);
      }
    }
  };public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size() - 1; i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = logSegments.remove(0);
        logSegment.delete(false);
      }
    }
  };void cutTill(OLogSequenceNumber lsn) throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_09692_6df06/rev_09692-6df06;/subprojects/plugins/src/main/groovy/org/gradle/api/internal/tasks/testing/junit/result/AggregateTestResultsProvider;visitClasses(Action<?superTestClassResult>);        for (final TestResultsProvider provider : providers) {;        for (File dir : binaryResultDirs) {
            final BinaryResultBackedTestResultsProvider provider = new BinaryResultBackedTestResultsProvider(dir);;        for (File dir : binaryResultDirs) {
            final BinaryResultBackedTestResultsProvider provider = new BinaryResultBackedTestResultsProvider(dir, new TestOutputStore(dir).reader());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9793d_5d821/rev_9793d-5d821;/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader;computeNext();            Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> next = wideColumns.next();
            lastColumn = next.right.values().iterator().next().name().duplicate();;            Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> next = wideColumns.next();
            lastColumn = next.right.values().iterator().next().name();;            Pair<ByteBuffer, SortedMap<ByteBuffer, Column>> next = wideColumns.next();
            lastColumn = next.right.values().iterator().next().name();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_9828c_0d30c/rev_9828c-0d30c;/src/java/org/apache/cassandra/db/compaction/CompactionTask;execute(CompactionExecutorStatsCollector);        // The collection of sstables passed may be empty (but not null); even if
        // it is not empty, it may compact down to nothing if all rows are deleted.
        assert sstables != null;

        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);
        if (!isCompactionInteresting(toCompact))
            return 0;

        File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
        if (compactionFileLocation == null && partialCompactionsAcceptable())
        {
            // If the compaction file path is null that means we have no space left for this compaction.
            // Try again w/o the largest one.
            while (compactionFileLocation == null && toCompact.size() > 1)
            {
                logger.warn("insufficient space to compact all requested files " + StringUtils.join(toCompact, ", "));
                // Note that we have removed files that are still marked as compacting.
                // This suboptimal but ok since the caller will unmark all the sstables at the end.
                toCompact.remove(cfs.getMaxSizeFile(toCompact));
                compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
            }
        }

        if (compactionFileLocation == null)
        {
            logger.warn("insufficient space to compact; aborting compaction");
            return 0;
        }

        if (DatabaseDescriptor.isSnapshotBeforeCompaction())
            cfs.snapshotWithoutFlush(System.currentTimeMillis() + "-" + "compact-" + cfs.columnFamily);

        // sanity check: all sstables must belong to the same cfs
        for (SSTableReader sstable : toCompact)
            assert sstable.descriptor.cfname.equals(cfs.columnFamily);

        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);
        // new sstables from flush can be added during a compaction, but only the compaction can remove them,
        // so in our single-threaded compaction world this is a valid way of determining if we're compacting
        // all the sstables (that existed when we started)
        logger.info("Compacting {}", toCompact);

        long startTime = System.currentTimeMillis();
        long totalkeysWritten = 0;

        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));
        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / strategy.getMaxSSTableSize());
        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
        if (logger.isDebugEnabled())
            logger.debug("Expected bloom filter size : " + keysPerSSTable);

        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()
                                      ? new ParallelCompactionIterable(compactionType, strategy.getScanners(toCompact), controller)
                                      : new CompactionIterable(compactionType, strategy.getScanners(toCompact), controller);
        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());
        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();

        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to
        // replace the old entries.  Track entries to preheat here until then.
        Map<Descriptor, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<Descriptor, Map<DecoratedKey, Long>>();

        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();

        if (collector != null)
            collector.beginCompaction(ci);
        try
        {
            if (!nni.hasNext())
            {
                // don't mark compacted in the finally block, since if there _is_ nondeleted data,
                // we need to sync it (via closeAndOpen) first, so there is no period during which
                // a crash could cause data loss.
                cfs.markCompacted(toCompact, compactionType);
                return 0;
            }

            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
            writers.add(writer);
            while (nni.hasNext())
            {
                if (ci.isStopRequested())
                    throw new CompactionInterruptedException(ci.getCompactionInfo());

                AbstractCompactedRow row = nni.next();
                if (row.isEmpty())
                {
                    row.close();
                    continue;
                }

                long position = writer.append(row);
                totalkeysWritten++;

                if (DatabaseDescriptor.getPreheatKeyCache())
                {
                    for (SSTableReader sstable : toCompact)
                    {
                        if (sstable.getCachedPosition(row.key, false) != null)
                        {
                            cachedKeys.put(row.key, position);
                            break;
                        }
                    }
                }
                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                {
                    // tmp = false because later we want to query it with descriptor from SSTableReader
                    cachedKeyMap.put(writer.descriptor.asTemporary(false), cachedKeys);
                    if (nni.hasNext())
                    {
                        writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
                        writers.add(writer);
                        cachedKeys = new HashMap<DecoratedKey, Long>();
                    }
                }
            }

            long maxAge = getMaxDataAge(toCompact);
            for (SSTableWriter completedWriter : writers)
                sstables.add(completedWriter.closeAndOpenReader(maxAge));
        }
        catch (Exception e)
        {
            for (SSTableWriter writer : writers)
                writer.abort();
            // also remove already completed SSTables
            for (SSTableReader sstable : sstables)
            {
                sstable.markCompacted();
                sstable.releaseReference();
            }
            throw FBUtilities.unchecked(e);
        }
        finally
        {
            iter.close();
            if (collector != null)
                collector.finishCompaction(ci);
        }

        cfs.replaceCompactedSSTables(toCompact, sstables, compactionType);
        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up
        for (SSTableReader sstable : sstables)
        {
            for (Map.Entry<DecoratedKey, Long> entry : cachedKeyMap.get(sstable.descriptor).entrySet())
               sstable.cacheKey(entry.getKey(), entry.getValue());
        }

        if (logger.isInfoEnabled())
        {
            long dTime = System.currentTimeMillis() - startTime;
            long startsize = SSTable.getTotalBytes(toCompact);
            long endsize = SSTable.getTotalBytes(sstables);
            double ratio = (double)endsize / (double)startsize;

            StringBuilder builder = new StringBuilder();
            builder.append("[");
            for (SSTableReader reader : sstables)
                builder.append(reader.getFilename()).append(",");
            builder.append("]");

            double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;
            logger.info(String.format("Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMB/s.  Time: %,dms.",
                                      builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));
            logger.debug(String.format("CF Total Bytes Compacted: %,d", CompactionTask.addToTotalBytesCompacted(endsize)));
        };        // The collection of sstables passed may be empty (but not null); even if
        // it is not empty, it may compact down to nothing if all rows are deleted.
        assert sstables != null;

        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);
        if (!isCompactionInteresting(toCompact))
            return 0;

        File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
        if (compactionFileLocation == null && partialCompactionsAcceptable())
        {
            // If the compaction file path is null that means we have no space left for this compaction.
            // Try again w/o the largest one.
            while (compactionFileLocation == null && toCompact.size() > 1)
            {
                logger.warn("insufficient space to compact all requested files " + StringUtils.join(toCompact, ", "));
                // Note that we have removed files that are still marked as compacting.
                // This suboptimal but ok since the caller will unmark all the sstables at the end.
                toCompact.remove(cfs.getMaxSizeFile(toCompact));
                compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact, compactionType));
            }
        }

        if (compactionFileLocation == null)
        {
            logger.warn("insufficient space to compact; aborting compaction");
            return 0;
        }

        if (DatabaseDescriptor.isSnapshotBeforeCompaction())
            cfs.snapshotWithoutFlush(System.currentTimeMillis() + "-" + "compact-" + cfs.columnFamily);

        // sanity check: all sstables must belong to the same cfs
        for (SSTableReader sstable : toCompact)
            assert sstable.descriptor.cfname.equals(cfs.columnFamily);

        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);
        // new sstables from flush can be added during a compaction, but only the compaction can remove them,
        // so in our single-threaded compaction world this is a valid way of determining if we're compacting
        // all the sstables (that existed when we started)
        logger.info("Compacting {}", toCompact);

        long startTime = System.currentTimeMillis();
        long totalkeysWritten = 0;

        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));
        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / strategy.getMaxSSTableSize());
        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
        if (logger.isDebugEnabled())
            logger.debug("Expected bloom filter size : " + keysPerSSTable);

        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()
                                      ? new ParallelCompactionIterable(compactionType, strategy.getScanners(toCompact), controller)
                                      : new CompactionIterable(compactionType, strategy.getScanners(toCompact), controller);
        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());
        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();

        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to
        // replace the old entries.  Track entries to preheat here until then.
        Map<Descriptor, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<Descriptor, Map<DecoratedKey, Long>>();

        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();

        if (collector != null)
            collector.beginCompaction(ci);
        try
        {
            if (!nni.hasNext())
            {
                // don't mark compacted in the finally block, since if there _is_ nondeleted data,
                // we need to sync it (via closeAndOpen) first, so there is no period during which
                // a crash could cause data loss.
                cfs.markCompacted(toCompact, compactionType);
                return 0;
            }

            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
            writers.add(writer);
            while (nni.hasNext())
            {
                if (ci.isStopRequested())
                    throw new CompactionInterruptedException(ci.getCompactionInfo());

                AbstractCompactedRow row = nni.next();
                if (row.isEmpty())
                {
                    row.close();
                    continue;
                }

                long position = writer.append(row);
                totalkeysWritten++;

                if (DatabaseDescriptor.getPreheatKeyCache())
                {
                    for (SSTableReader sstable : toCompact)
                    {
                        if (sstable.getCachedPosition(row.key, false) != null)
                        {
                            cachedKeys.put(row.key, position);
                            break;
                        }
                    }
                }
                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                {
                    // tmp = false because later we want to query it with descriptor from SSTableReader
                    cachedKeyMap.put(writer.descriptor.asTemporary(false), cachedKeys);
                    if (nni.hasNext())
                    {
                        writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
                        writers.add(writer);
                        cachedKeys = new HashMap<DecoratedKey, Long>();
                    }
                }
            }

            long maxAge = getMaxDataAge(toCompact);
            for (SSTableWriter completedWriter : writers)
                sstables.add(completedWriter.closeAndOpenReader(maxAge));
        }
        catch (Exception e)
        {
            for (SSTableWriter writer : writers)
                writer.abort();
            // also remove already completed SSTables
            for (SSTableReader sstable : sstables)
            {
                sstable.markCompacted();
                sstable.releaseReference();
            }
            throw FBUtilities.unchecked(e);
        }
        finally
        {
            iter.close();
            if (collector != null)
                collector.finishCompaction(ci);
        }

        cfs.replaceCompactedSSTables(toCompact, sstables, compactionType);
        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up
        for (SSTableReader sstable : sstables)
        {
            for (Map.Entry<DecoratedKey, Long> entry : cachedKeyMap.get(sstable.descriptor).entrySet())
               sstable.cacheKey(entry.getKey(), entry.getValue());
        }

        long dTime = System.currentTimeMillis() - startTime;
        long startsize = SSTable.getTotalBytes(toCompact);
        long endsize = SSTable.getTotalBytes(sstables);
        double ratio = (double)endsize / (double)startsize;

        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (SSTableReader reader : sstables)
            builder.append(reader.getFilename()).append(",");
        builder.append("]");

        double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;
        logger.info(String.format("Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMB/s.  Time: %,dms.",
                                  builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));
        logger.debug(String.format("CF Total Bytes Compacted: %,d", CompactionTask.addToTotalBytesCompacted(endsize)));;        this.collector = collector;
        run();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_9944b_fcf98/rev_9944b-fcf98;/core/src/main/java/com/orientechnologies/orient/core/sql/OCommandExecutorSQLTraverse;execute(Map<Object,Object>);    try {
      // BROWSE ALL THE RECORDS AND COLLECTS RESULT
      final List<OIdentifiable> result = traverse.execute();
      for (OIdentifiable r : result)
        if (!handleResult(r, true))
          // LIMIT REACHED
          break;;    // BROWSE ALL THE RECORDS AND COLLECTS RESULT
    final List<OIdentifiable> result = traverse.execute();
    for (OIdentifiable r : result)
      handleResult(r, true);;    // BROWSE ALL THE RECORDS AND COLLECTS RESULT
    final List<OIdentifiable> result = traverse.execute();
    for (OIdentifiable r : result)
      handleResult(r);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_10527_90d08/rev_10527-90d08;/src/java/org/apache/cassandra/thrift/CassandraServer;system_update_column_family(CfDef);
            /*
             * CASSANDRA-6831: Because thrift updates don't know about aliases,
             * we should copy them from the original CFM
             */
            if (!cf_def.isSetKey_alias())
                cfm.keyAliases(oldCfm.getKeyAliases());
            cfm.columnAliases(oldCfm.getColumnAliases());
            cfm.valueAlias(oldCfm.getValueAlias());

            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions, false);;            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions, false);;            CFMetaData.validateCompactionOptions(cfm.compactionStrategyClass, cfm.compactionStrategyOptions);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_10959_b5d07/rev_10959-b5d07;/src/java/org/apache/cassandra/db/ColumnFamilyStore;forceFlush();            logger.debug("forceFlush requested but everything is clean in {}", columnFamily);
            return Futures.immediateCheckedFuture(null);;            logger.debug("forceFlush requested but everything is clean in {}", columnFamily);
            return null;;            logger.debug("forceFlush requested but everything is clean in {}", name);
            return null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_18102_f458c/rev_18102-f458c;/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest;testPersistentStatisticsFromOlderIndexedSSTable();            File destFile = new File(destDirs[0] + File.separator + srcFile.getName());
            CLibrary.createHardLink(srcFile, destFile);;            File destFile = new File(destDirs[0] + File.separator + srcFile.getName());
            CLibrary.createHardLinkWithExec(srcFile, destFile);;            File destFile = new File(destDir, srcFile.getName());
            CLibrary.createHardLinkWithExec(srcFile, destFile);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_18102_f458c/rev_18102-f458c;/test/unit/org/apache/cassandra/db/ScrubTest;copySSTables();            File destFile = new File(destDirs[0]+File.separator+srcFile.getName());
            CLibrary.createHardLink(srcFile, destFile);;            File destFile = new File(destDirs[0]+File.separator+srcFile.getName());
            CLibrary.createHardLinkWithExec(srcFile, destFile);;            File destFile = new File(destDir, srcFile.getName());
            CLibrary.createHardLinkWithExec(srcFile, destFile);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_19259_1630e/rev_19259-1630e;/src/java/org/apache/cassandra/db/ColumnIndex;add(OnDiskAtom);                if (tombstoneTracker != null)
                {
                    long tombstoneSize = tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                    endPosition += tombstoneSize;
                    openedMarkerSize += tombstoneSize;
                };                if (tombstoneTracker != null)
                    endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);;                endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_19324_500de/rev_19324-500de;/tests/unit/com/opengamma/financial/security/db/HibernateSecurityMasterTest;testEquityOptionSecurityBeans();    Assert.assertEquals (americanUnderlyingIdentifier, american.getUnderlyingSecurity());
    Assert.assertEquals (dollar, american.getCurrency ());;    Assert.assertEquals (americanUnderlyingIdentifier, american.getUnderlyingIdentityKey());
    Assert.assertEquals (dollar, american.getCurrency ());;    Assert.assertEquals (americanUnderlyingIdentifier, american.getUnderlyingIdentityKey());
    Assert.assertEquals (dollar, american.getCurrency ());    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_19576_bda65/rev_19576-bda65;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/swaption/method/SwaptionPhysicalFixedIborHullWhiteMethodTest;performance();    InterestRateCurveSensitivity pvcs = METHOD_HW.presentValueCurveSensitivity(SWAPTION_PAYER_LONG, BUNDLE_HW);
    YieldAndDiscountCurve curve = CURVES.getCurve(FUNDING_CURVE_NAME);;    PresentValueSensitivity pvcs = METHOD_HW.presentValueCurveSensitivity(SWAPTION_PAYER_LONG, BUNDLE_HW);
    YieldAndDiscountCurve curve = CURVES.getCurve(FUNDING_CURVE_NAME);;    PresentValueSensitivity pvcs = METHOD_HW.presentValueCurveSensitivity(SWAPTION_PAYER_LONG, BUNDLE_HW);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_19800_a1c8d/rev_19800-a1c8d;/src/java/org/apache/cassandra/db/SystemTable;writeCurrentLocalNodeId(NodeId,NodeId,long);        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, ALL_LOCAL_NODE_ID_KEY);
        rm.add(cf);;        ColumnFamily cf2 = cf.cloneMe();
        if (oldNodeId != null)
        {
            cf2.addColumn(new DeletedColumn(oldNodeId.bytes(), (int) (now / 1000), now));
        }
        RowMutation rmCurrent = new RowMutation(Table.SYSTEM_TABLE, CURRENT_LOCAL_NODE_ID_KEY);
        RowMutation rmAll = new RowMutation(Table.SYSTEM_TABLE, ALL_LOCAL_NODE_ID_KEY);
        rmCurrent.add(cf2);
        rmAll.add(cf);;        ColumnFamily cf2 = cf.cloneMe();
        if (oldNodeId != null)
        {
            // previously used (int)(now /1000) for the localDeletionTime
            // tests use single digit long values for now, so use actual time.
            cf2.addColumn(new DeletedColumn(oldNodeId.bytes(), (int)(System.currentTimeMillis() / 1000), now));
        }
        RowMutation rmCurrent = new RowMutation(Table.SYSTEM_TABLE, CURRENT_LOCAL_NODE_ID_KEY);
        RowMutation rmAll = new RowMutation(Table.SYSTEM_TABLE, ALL_LOCAL_NODE_ID_KEY);
        rmCurrent.add(cf2);
        rmAll.add(cf);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_20931_f6129/rev_20931-f6129;/core/descriptors/src/org/jetbrains/jet/lang/types/lang/BuiltinsPackageFragment;BuiltinsPackageFragment(StorageManager,ModuleDescriptor);        DeserializationContext context = new DeserializationContext(
                storageManager, new BuiltInsDescriptorFinder(storageManager),
                // TODO: support annotations
                AnnotationLoader.UNSUPPORTED, ConstantLoader.UNSUPPORTED, packageFragmentProvider,
                MemberFilter.ALWAYS_TRUE, nameResolver
        );
        members = new DeserializedPackageMemberScope(this, loadPackage(), context);;        // TODO: support annotations
        members = new DeserializedPackageMemberScope(storageManager, this, Deserializers.UNSUPPORTED, MemberFilter.ALWAYS_TRUE,
                                                     new BuiltInsDescriptorFinder(storageManager), loadPackage(), nameResolver);;        // TODO: support annotations
        members = new DeserializedPackageMemberScope(storageManager, this, Deserializers.UNSUPPORTED,
                                                     new BuiltInsDescriptorFinder(storageManager), new PackageData(nameResolver, loadPackage()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_20931_f6129/rev_20931-f6129;/core/descriptor.loader.java/src/org/jetbrains/jet/lang/resolve/kotlin/DeserializedDescriptorResolver;createKotlinPackageScope(PackageFragmentDescriptor,KotlinJvmBinaryClass);            return new DeserializedPackageMemberScope(descriptor, JavaProtoBufUtil.readPackageDataFrom(data), context);;            return new DeserializedPackageMemberScope(storageManager, descriptor, deserializers,
                                                      memberFilter, javaDescriptorFinder, JavaProtoBufUtil.readPackageDataFrom(data));;            return new DeserializedPackageMemberScope(storageManager, descriptor, deserializers,
                                                      javaDescriptorFinder, JavaProtoBufUtil.readPackageDataFrom(data));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_21875_7108f/rev_21875-7108f;/src/java/org/apache/cassandra/db/filter/QueryFilter;isRelevant(IColumn,IColumnContainer,int);        long maxChange = column.mostRecentNonGCableChangeAt(gcBefore);
        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() >= gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1);        long maxChange = column.mostRecentLiveChangeAt();
        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() >= gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1);        long maxChange = column.mostRecentLiveChangeAt();
        return (column.getLocalDeletionTime() >= gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_25355_1a77d/rev_25355-1a77d;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/PlotDataManager;addData(String,SortedMap<Long,Double>);		}
		if (!plot.plotAbstraction.getTimeAxis().isPinned()) {
			dataSeries.get(feed).updateRegressionLine();
		};		}
		dataSeries.get(feed).updateRegressionLine();;		}
//		if (!plot.plotAbstraction.getTimeAxis().isPinned()) {
			dataSeries.get(feed).updateRegressionLine();
//		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_25982_d2bed/rev_25982-d2bed;/src/java/org/apache/cassandra/service/PendingRangeCalculatorService;calculatePendingRanges(AbstractReplicationStrategy,String);        TokenMetadata tm = StorageService.instance.getTokenMetadata();
        Multimap<Range<Token>, InetAddress> pendingRanges = HashMultimap.create();
        BiMultiValMap<Token, InetAddress> bootstrapTokens = tm.getBootstrapTokens();
        Set<InetAddress> leavingEndpoints = tm.getLeavingEndpoints();

        if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty())
        {
            if (logger.isDebugEnabled())
                logger.debug("No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}", keyspaceName);
            tm.setPendingRanges(keyspaceName, pendingRanges);
            return;
        }

        Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges();

        // Copy of metadata reflecting the situation after all leave operations are finished.
        TokenMetadata allLeftMetadata = tm.cloneAfterAllLeft();

        // get all ranges that will be affected by leaving nodes
        Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>();
        for (InetAddress endpoint : leavingEndpoints)
            affectedRanges.addAll(addressRanges.get(endpoint));

        // for each of those ranges, find what new nodes will be responsible for the range when
        // all leaving nodes are gone.
        TokenMetadata metadata = tm.cloneOnlyTokenMap(); // don't do this in the loop! #7758
        for (Range<Token> range : affectedRanges)
        {
            Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, metadata));
            Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata));
            pendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints));
        }

        // At this stage pendingRanges has been updated according to leave operations. We can
        // now continue the calculation by checking bootstrapping nodes.

        // For each of the bootstrapping nodes, simply add and remove them one by one to
        // allLeftMetadata and check in between what their ranges would be.
        Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse();
        for (InetAddress endpoint : bootstrapAddresses.keySet())
        {
            Collection<Token> tokens = bootstrapAddresses.get(endpoint);

            allLeftMetadata.updateNormalTokens(tokens, endpoint);
            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);
        }

        // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.
        // We can now finish the calculation by checking moving and relocating nodes.

        // For each of the moving nodes, we do the same thing we did for bootstrapping:
        // simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.
        for (Pair<Token, InetAddress> moving : tm.getMovingEndpoints())
        {
            InetAddress endpoint = moving.right; // address of the moving node

            //  moving.left is a new token of the endpoint
            allLeftMetadata.updateNormalToken(moving.left, endpoint);

            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
            {
                pendingRanges.put(range, endpoint);
            }

            allLeftMetadata.removeEndpoint(endpoint);
        }

        tm.setPendingRanges(keyspaceName, pendingRanges);

        if (logger.isDebugEnabled())
            logger.debug("Pending ranges:\n" + (pendingRanges.isEmpty() ? "<empty>" : tm.printPendingRanges()));;        TokenMetadata tm = StorageService.instance.getTokenMetadata();
        Multimap<Range<Token>, InetAddress> pendingRanges = HashMultimap.create();
        BiMultiValMap<Token, InetAddress> bootstrapTokens = tm.getBootstrapTokens();
        Set<InetAddress> leavingEndpoints = tm.getLeavingEndpoints();

        if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty())
        {
            if (logger.isDebugEnabled())
                logger.debug("No bootstrapping, leaving or moving nodes, and no relocating tokens -> empty pending ranges for {}", keyspaceName);
            tm.setPendingRanges(keyspaceName, pendingRanges);
            return;
        }

        Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges();

        // Copy of metadata reflecting the situation after all leave operations are finished.
        TokenMetadata allLeftMetadata = tm.cloneAfterAllLeft();

        // get all ranges that will be affected by leaving nodes
        Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>();
        for (InetAddress endpoint : leavingEndpoints)
            affectedRanges.addAll(addressRanges.get(endpoint));

        // for each of those ranges, find what new nodes will be responsible for the range when
        // all leaving nodes are gone.
        for (Range<Token> range : affectedRanges)
        {
            Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, tm.cloneOnlyTokenMap()));
            Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata));
            pendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints));
        }

        // At this stage pendingRanges has been updated according to leave operations. We can
        // now continue the calculation by checking bootstrapping nodes.

        // For each of the bootstrapping nodes, simply add and remove them one by one to
        // allLeftMetadata and check in between what their ranges would be.
        Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse();
        for (InetAddress endpoint : bootstrapAddresses.keySet())
        {
            Collection<Token> tokens = bootstrapAddresses.get(endpoint);

            allLeftMetadata.updateNormalTokens(tokens, endpoint);
            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);
        }

        // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.
        // We can now finish the calculation by checking moving and relocating nodes.

        // For each of the moving nodes, we do the same thing we did for bootstrapping:
        // simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.
        for (Pair<Token, InetAddress> moving : tm.getMovingEndpoints())
        {
            InetAddress endpoint = moving.right; // address of the moving node

            //  moving.left is a new token of the endpoint
            allLeftMetadata.updateNormalToken(moving.left, endpoint);

            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
            {
                pendingRanges.put(range, endpoint);
            }

            allLeftMetadata.removeEndpoint(endpoint);
        }

        tm.setPendingRanges(keyspaceName, pendingRanges);

        if (logger.isDebugEnabled())
            logger.debug("Pending ranges:\n" + (pendingRanges.isEmpty() ? "<empty>" : tm.printPendingRanges()));;        StorageService.instance.getTokenMetadata().calculatePendingRanges(strategy, keyspaceName);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_26352_99bfa/rev_26352-99bfa;/tightdb-java-test/src/test/java/com/tightdb/JNITransactions;writeOneTransaction(long);        tbl.addColumn(ColumnType.ColumnTypeString, "name");
        tbl.addColumn(ColumnType.ColumnTypeInt, "number");;        TableSpec tableSpec = new TableSpec();
        tableSpec.addColumn(ColumnType.ColumnTypeString, "name");
        tableSpec.addColumn(ColumnType.ColumnTypeInt, "number");
        tbl.updateFromSpec(tableSpec);;        TableSpec tableSpec = new TableSpec();
        tableSpec.addColumn(ColumnType.STRING, "name");
        tableSpec.addColumn(ColumnType.LONG, "number");
        tbl.updateFromSpec(tableSpec);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_27895_ec37c/rev_27895-ec37c;/projects/OG-Analytics/src/com/opengamma/financial/interestrate/payments/method/CapFloorCMSSpreadSABRBinormalMethod;presentValue(CapFloorCMSSpread,SABRInterestRateDataBundle);public CurrencyAmount presentValue(final CapFloorCMSSpread cmsSpread, final SABRInterestRateDataBundle sabrData) {
    double forward1 = PRC.visit(cmsSpread.getUnderlyingSwap1(), sabrData);
    double forward2 = PRC.visit(cmsSpread.getUnderlyingSwap2(), sabrData);
    CouponCMS cmsCoupon1 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap1(), cmsSpread.getSettlementTime());
    CouponCMS cmsCoupon2 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap2(), cmsSpread.getSettlementTime());
    CapFloorCMS cmsCap1 = CapFloorCMS.from(cmsCoupon1, forward1, true);
    CapFloorCMS cmsCap2 = CapFloorCMS.from(cmsCoupon2, forward2, true);
    double cmsCoupon1Price = METHOD_CMS_COUPON.presentValue(cmsCoupon1, sabrData);
    double cmsCoupon2Price = METHOD_CMS_COUPON.presentValue(cmsCoupon2, sabrData);
    double cmsCap1Price = METHOD_CMS_CAP.presentValue(cmsCap1, sabrData).getAmount();
    double cmsCap2Price = METHOD_CMS_CAP.presentValue(cmsCap2, sabrData).getAmount();
    double discountFactorPayment = sabrData.getCurve(cmsSpread.getFundingCurveName()).getDiscountFactor(cmsSpread.getPaymentTime());
    BlackFunctionData dataCap1 = new BlackFunctionData(cmsCoupon1Price / (discountFactorPayment * cmsCap1.getNotional() * cmsCap1.getPaymentYearFraction()), discountFactorPayment;public double presentValue(final CapFloorCMSSpread cmsSpread, final SABRInterestRateDataBundle sabrData) {
    double forward1 = PRC.visit(cmsSpread.getUnderlyingSwap1(), sabrData);
    double forward2 = PRC.visit(cmsSpread.getUnderlyingSwap2(), sabrData);
    CouponCMS cmsCoupon1 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap1(), cmsSpread.getSettlementTime());
    CouponCMS cmsCoupon2 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap2(), cmsSpread.getSettlementTime());
    CapFloorCMS cmsCap1 = CapFloorCMS.from(cmsCoupon1, forward1, true);
    CapFloorCMS cmsCap2 = CapFloorCMS.from(cmsCoupon2, forward2, true);
    double cmsCoupon1Price = METHOD_CMS_COUPON.presentValue(cmsCoupon1, sabrData);
    double cmsCoupon2Price = METHOD_CMS_COUPON.presentValue(cmsCoupon2, sabrData);
    double cmsCap1Price = METHOD_CMS_CAP.presentValue(cmsCap1, sabrData).getAmount();
    double cmsCap2Price = METHOD_CMS_CAP.presentValue(cmsCap2, sabrData).getAmount();
    double discountFactorPayment = sabrData.getCurve(cmsSpread.getFundingCurveName()).getDiscountFactor(cmsSpread.getPaymentTime());
    BlackFunctionData dataCap1 = new BlackFunctionData(cmsCoupon1Price / (discountFactorPayment * cmsCap1.getNotional() * cmsCap1.getPaymentYearFraction()), discountFactorPayment;public double presentValue(final CapFloorCMSSpread cmsSpread, final SABRInterestRateDataBundle sabrData) {
    final double forward1 = PRC.visit(cmsSpread.getUnderlyingSwap1(), sabrData);
    final double forward2 = PRC.visit(cmsSpread.getUnderlyingSwap2(), sabrData);
    final CouponCMS cmsCoupon1 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap1(), cmsSpread.getSettlementTime());
    final CouponCMS cmsCoupon2 = CouponCMS.from(cmsSpread, cmsSpread.getUnderlyingSwap2(), cmsSpread.getSettlementTime());
    final CapFloorCMS cmsCap1 = CapFloorCMS.from(cmsCoupon1, forward1, true);
    final CapFloorCMS cmsCap2 = CapFloorCMS.from(cmsCoupon2, forward2, true);
    final double cmsCoupon1Price = METHOD_CMS_COUPON.presentValue(cmsCoupon1, sabrData);
    final double cmsCoupon2Price = METHOD_CMS_COUPON.presentValue(cmsCoupon2, sabrData);
    final double cmsCap1Price = METHOD_CMS_CAP.presentValue(cmsCap1, sabrData).getAmount();
    final double cmsCap2Price = METHOD_CMS_CAP.presentValue(cmsCap2, sabrData).getAmount();
    final double discountFactorPayment = sabrData.getCurve(cmsSpread.getFundingCurveName()).getDiscountFactor(cmsSpread.getPaymentTime());
    final BlackFunctionData dataCap1 = new BlackFunctionData(cmsCoupon1Price / (discountFactorPayment * cmsCap1.getNotional() * cmsCap1.getPaymentYearFraction()), discountFactorPayment
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_27895_ec37c/rev_27895-ec37c;/projects/OG-Analytics/src/com/opengamma/financial/interestrate/payments/method/CapFloorCMSSpreadSABRBinormalMethod;presentValue(CapFloorCMSSpread,SABRInterestRateDataBundle);    EuropeanVanillaOption optionSpread = new EuropeanVanillaOption(cmsSpread.getStrike(), cmsSpread.getFixingTime(), cmsSpread.isCap());
    Function1D<BlackFunctionData, Double> normalFunction = NORMAL_PRICE.getPriceFunction(optionSpread);
    double cmsSpreadPrice = normalFunction.evaluate(dataSpread);
    return CurrencyAmount.of(cmsSpread.getCurrency(), cmsSpreadPrice);;    EuropeanVanillaOption optionSpread = new EuropeanVanillaOption(cmsSpread.getStrike(), cmsSpread.getFixingTime(), cmsSpread.isCap());
    Function1D<BlackFunctionData, Double> normalFunction = NORMAL_PRICE.getPriceFunction(optionSpread);
    double cmsSpreadPrice = normalFunction.evaluate(dataSpread);
    return cmsSpreadPrice;;    final EuropeanVanillaOption optionSpread = new EuropeanVanillaOption(cmsSpread.getStrike(), cmsSpread.getFixingTime(), cmsSpread.isCap());
    final Function1D<BlackFunctionData, Double> normalFunction = NORMAL_PRICE.getPriceFunction(optionSpread);
    final double cmsSpreadPrice = normalFunction.evaluate(dataSpread);
    return cmsSpreadPrice;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_27895_ec37c/rev_27895-ec37c;/projects/OG-Analytics/src/com/opengamma/financial/interestrate/payments/method/CapFloorCMSSpreadSABRBinormalMethod;evaluate(Double);    public Double evaluate(Double x) {
      CapFloorCMSSpreadSABRBinormalMethod method = new CapFloorCMSSpreadSABRBinormalMethod(new RealPolynomialFunction1D(new double[] {x}));
      return method.presentValue(_cmsSpread, _sabrData).getAmount() - _price;;    public Double evaluate(Double x) {
      CapFloorCMSSpreadSABRBinormalMethod method = new CapFloorCMSSpreadSABRBinormalMethod(new RealPolynomialFunction1D(new double[] {x}));
      return method.presentValue(_cmsSpread, _sabrData) - _price;;    public Double evaluate(final Double x) {
      final CapFloorCMSSpreadSABRBinormalMethod method = new CapFloorCMSSpreadSABRBinormalMethod(new RealPolynomialFunction1D(new double[] {x}));
      return method.presentValue(_cmsSpread, _sabrData) - _price;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_27895_ec37c/rev_27895-ec37c;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/payments/method/CapFloorCMSSpreadSABRBinormalMethodTest;presentValue();    final double cmsSpreadPrice = method.presentValue(CMS_SPREAD, SABR_BUNDLE).getAmount();
    final double discountFactorPayment = CURVES.getCurve(FUNDING_CURVE_NAME).getDiscountFactor(PAYMENT_TIME);
    final CouponCMSSABRReplicationMethod methodCms = new CouponCMSSABRReplicationMethod();
    final CapFloorCMSSABRReplicationMethod methodCmsCap = new CapFloorCMSSABRReplicationMethod();;    final double cmsSpreadPrice = method.presentValue(CMS_SPREAD, sabrBundle);
    final double discountFactorPayment = curves.getCurve(FUNDING_CURVE_NAME).getDiscountFactor(PAYMENT_TIME);
    final CouponCMSSABRReplicationMethod methodCms = new CouponCMSSABRReplicationMethod();
    final CapFloorCMSSABRReplicationMethod methodCmsCap = new CapFloorCMSSABRReplicationMethod();;    final double cmsSpreadPrice = method.presentValue(CMS_SPREAD, sabrBundle);
    final double discountFactorPayment = curves.getCurve(FUNDING_CURVE_NAME).getDiscountFactor(PAYMENT_TIME);
    final CouponCMSSABRReplicationMethod methodCms = CouponCMSSABRReplicationMethod.getDefaultInstance();
    final CapFloorCMSSABRReplicationMethod methodCmsCap = CapFloorCMSSABRReplicationMethod.getDefaultInstance();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_28938_8d783/rev_28938-8d783;/src/main/java/org/junit/Assert;assertThat(String,T,Matcher<?superT>);		if (!matcher.matches(actual)) {
			Description description= new StringDescription();
			description.appendText(reason);
			description.appendText("\nExpected: ");
			description.appendDescriptionOf(matcher);
			description.appendText("\n     got: ");
			description.appendValue(actual);
			description.appendText("\n");
			java.lang.AssertionError assertionError= new java.lang.AssertionError(
					description.toString());
			if (actual instanceof Throwable)
				assertionError.initCause((Throwable) actual);
			throw assertionError;
		};		if (!matcher.matches(actual)) {
			Description description= new StringDescription();
			description.appendText(reason);
			description.appendText("\nExpected: ");
			description.appendDescriptionOf(matcher);
			description.appendText("\n     got: ");
			description.appendValue(actual);
			description.appendText("\n");
			throw new java.lang.AssertionError(description.toString());
		};		MatcherAssert.assertThat(reason, actual, matcher);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_33467_7cb8c/rev_33467-7cb8c;/src/java/org/apache/cassandra/io/sstable/Descriptor;Descriptor(String,File,String,String,int,boolean);        assert version != null && directory != null && ksname != null && cfname != null;
        this.version = version;
        this.directory = directory;
        this.ksname = ksname;
        this.cfname = cfname;
        this.generation = generation;
        temporary = temp;
        hashCode = Objects.hashCode(directory, generation, ksname, cfname, temp);

        hasStringsInBloomFilter = version.compareTo("c") < 0;
        hasIntRowSize = version.compareTo("d") < 0;
        hasEncodedKeys = version.compareTo("e") < 0;
        usesOldBloomFilter = version.compareTo("f") < 0;
        metadataIncludesReplayPosition = version.compareTo("g") >= 0;
        tracksMaxTimestamp = version.compareTo("hd") >= 0;
        hasCompressionRatio = version.compareTo("hb") >= 0;
        hasPartitioner = version.compareTo("hc") >= 0;
        hasAncestors = version.compareTo("he") >= 0;
        metadataIncludesModernReplayPosition = version.compareTo("hf") >= 0;
        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;;        assert version != null && directory != null && ksname != null && cfname != null;
        this.version = version;
        this.directory = directory;
        this.ksname = ksname;
        this.cfname = cfname;
        this.generation = generation;
        temporary = temp;
        hashCode = Objects.hashCode(directory, generation, ksname, cfname);

        hasStringsInBloomFilter = version.compareTo("c") < 0;
        hasIntRowSize = version.compareTo("d") < 0;
        hasEncodedKeys = version.compareTo("e") < 0;
        usesOldBloomFilter = version.compareTo("f") < 0;
        metadataIncludesReplayPosition = version.compareTo("g") >= 0;
        tracksMaxTimestamp = version.compareTo("hd") >= 0;
        hasCompressionRatio = version.compareTo("hb") >= 0;
        hasPartitioner = version.compareTo("hc") >= 0;
        hasAncestors = version.compareTo("he") >= 0;
        metadataIncludesModernReplayPosition = version.compareTo("hf") >= 0;
        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;;        this(new Version(version), directory, ksname, cfname, generation, temp);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_33740_8dd22/rev_33740-8dd22;/projects/OG-Financial/src/main/java/com/opengamma/financial/analytics/model/equity/EquityForwardCurveDefaults;canApplyTo(FunctionCompilationContext,ComputationTarget);    if (target.getType() != ComputationTargetType.PRIMITIVE) {
      return false;
    }
    final String equityId = EquitySecurityUtils.getIndexOrEquityName(target.getUniqueId());;    if (target.getType() != ComputationTargetType.PRIMITIVE) {
      return false;
    }
    final String equityId = target.getUniqueId().getValue();;    final String equityId = target.getUniqueId().getValue();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_35762_2cfa0/rev_35762-2cfa0;/tightdb-java-test/src/test/java/com/tightdb/experiment/GroupToStringTest;groupToJson();        table.addColumn(ColumnType.ColumnTypeBinary, "binary");     // 0
        table.addColumn(ColumnType.ColumnTypeBool, "boolean");      // 1
        table.addColumn(ColumnType.ColumnTypeDate, "date");         // 2
        table.addColumn(ColumnType.ColumnTypeInt, "long");          // 3
        table.addColumn(ColumnType.ColumnTypeMixed, "mixed");       // 4
        table.addColumn(ColumnType.ColumnTypeString, "string");     // 5
        table.addColumn(ColumnType.ColumnTypeTable, "table");       // 6;        table.addColumn(ColumnType.ColumnTypeBinary, "binary");     // 0
        table.addColumn(ColumnType.ColumnTypeBool, "boolean");      // 1
        table.addColumn(ColumnType.ColumnTypeDate, "date");         // 2
        table.addColumn(ColumnType.ColumnTypeDouble, "double");     // 3
        table.addColumn(ColumnType.ColumnTypeFloat, "float");       // 4
        table.addColumn(ColumnType.ColumnTypeInt, "long");          // 5
        table.addColumn(ColumnType.ColumnTypeMixed, "mixed");       // 6
        table.addColumn(ColumnType.ColumnTypeString, "string");     // 7
        table.addColumn(ColumnType.ColumnTypeTable, "table");       // 8;        table.addColumn(ColumnType.BINARY, "binary");     // 0
        table.addColumn(ColumnType.BOOLEAN, "boolean");   // 1
        table.addColumn(ColumnType.DATE, "date");         // 2
        table.addColumn(ColumnType.DOUBLE, "double");     // 3
        table.addColumn(ColumnType.FLOAT, "float");       // 4
        table.addColumn(ColumnType.INTEGER, "long");      // 5
        table.addColumn(ColumnType.MIXED, "mixed");       // 6
        table.addColumn(ColumnType.STRING, "string");     // 7
        table.addColumn(ColumnType.TABLE, "table");       // 8
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNITableTest;immutableInsertNotAllowed();      //  new File(FILENAME).delete();;        new File(FILENAME).delete();;        new File(FILENAME).delete();
        new File(FILENAME + ".lock").delete();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNITableSpecTest;shouldThrowOnUpdateFromTableSpecOnSubtable();        TableSchema addresses = persons.getSubTableSchema(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.STRING, "street");
        addresses.addColumn(ColumnType.INTEGER, "zipcode");
        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;addColumnsToSubtables();        TableSchema addresses = persons.getSubTableSchema(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.STRING, "street");
        addresses.addColumn(ColumnType.INTEGER, "zipcode");
        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;addColumnsToSubtables();        TableSchema phone_numbers = addresses.getSubTableSchema(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.INTEGER, "number");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;removeColumnFromSubtable();        TableSchema addresses = persons.getSubTableSchema(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.STRING, "street");
        addresses.addColumn(ColumnType.INTEGER, "zipcode");
        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;removeColumnFromSubtable();        TableSchema phone_numbers = addresses.getSubTableSchema(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.INTEGER, "number");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;renameColumnInSubtable();        TableSchema addresses = persons.getSubTableSchema(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.STRING, "street");
        addresses.addColumn(ColumnType.INTEGER, "zipcode");
        addresses.addColumn(ColumnType.TABLE , "phone_numbers");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;renameColumnInSubtable();        TableSchema phone_numbers = addresses.getSubTableSchema(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.INTEGER, "number");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;shouldThrowOnGetSubtableDefinitionFromSubtable();        TableSchema addresses = persons.getSubTableSchema(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.ColumnTypeString, "street");
        addresses.addColumn(ColumnType.ColumnTypeInt, "zipcode");
        addresses.addColumn(ColumnType.ColumnTypeTable, "phone_numbers");;        TableDefinition addresses = persons.getSubTableDefinition(2);
        addresses.addColumn(ColumnType.STRING, "street");
        addresses.addColumn(ColumnType.INTEGER, "zipcode");
        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/JNISubtableTest;shouldThrowOnGetSubtableDefinitionFromSubtable();        TableSchema phone_numbers = addresses.getSubTableSchema(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.ColumnTypeInt, "number");;        TableDefinition phone_numbers = addresses.getSubTableDefinition(2);
        phone_numbers.addColumn(ColumnType.INTEGER, "number");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_36612_8eb3b/rev_36612-8eb3b;/tightdb-java-test/src/test/java/com/tightdb/typed/NumbersTest;setAndGetNumbers();        
        // Integer set all columns
        view.longNum.setAll(400);
        assertEquals(new Long(400), view.get(0).longNum.get());
        view.longNum.setAll(-1); 
        assertEquals(new Long(-1), view.get(1).longNum.get());
        
        // Double columns
        view.get(0).doubleNum.set(400d);
        assertEquals(400d, view.get(0).doubleNum.get());
        view.get(1).doubleNum.set(-0.01d);
        assertEquals(-0.01d, view.get(1).doubleNum.get());;        // Double column s
        view.get(0).doubleNum.set(400d);
        assertEquals(400d, view.get(0).doubleNum.get());
        view.get(1).doubleNum.set(-0.01d);
        assertEquals(-0.01d, view.get(1).doubleNum.get());;        // Double column s
        view.get(0).setDoubleNum(400d);
        assertEquals(400d, view.get(0).getDoubleNum());
        view.get(1).setDoubleNum(-0.01d);
        assertEquals(-0.01d, view.get(1).getDoubleNum());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_36638_e6316/rev_36638-e6316;/src/java/org/apache/cassandra/service/AntiEntropyService;prepare(ColumnFamilyStore);            if (tree.partitioner() instanceof RandomPartitioner);            List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
            for (DecoratedKey sample : cfs.allKeySamples())
                keys.add(sample);

            if (keys.isEmpty());            List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
            for (DecoratedKey sample : cfs.keySamples(request.range))
            {
                assert request.range.contains(sample.token);
                keys.add(sample);
            }

            if (keys.isEmpty())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_39066_5774e/rev_39066-5774e;/src/java/org/apache/cassandra/db/compaction/CompactionTask;runWith(File);        CompactionController controller = getCompactionController(toCompact);;        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore);;        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore);
        Set<SSTableReader> actuallyCompact = Sets.difference(toCompact, controller.getFullyExpiredSSTables());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_40669_1d2c1/rev_40669-1d2c1;/src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat;getRecordWriter(org.apache.hadoop.fs.FileSystem,org.apache.hadoop.mapred.JobConf,String,org.apache.hadoop.util.Progressable);@Deprecated
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException;@Deprecated @Override
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException;@Deprecated @Override
    public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_43360_86152/rev_43360-86152;/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient;stop();            try {
                if (stopped.add(connection.getUid())) {
                    new StopDispatcher(idGenerator).dispatch(connection.getConnection());
                    LOGGER.lifecycle("Gradle daemon stopped.");
                }
            } finally {
                connection.getConnection().stop();;            if (stopped.add(connection.getUid())) {
                new StopDispatcher(idGenerator).dispatch(connection.getConnection());
                LOGGER.lifecycle("Gradle daemon stopped.");;            if (stopped.add(connection.getUid())) {
                new StopDispatcher(idGenerator).dispatch(connection);
                LOGGER.lifecycle("Gradle daemon stopped.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45107_d70c8/rev_45107-d70c8;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/SyntheticIdentifierCurveInstrumentProvider;getInstrument(LocalDate,Tenor);    return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + tenor.getPeriod().toString());;    return ExternalId.of(_scheme, _ccy.getCode() + _type.name() + tenor.getPeriod().toString());;    if (_type.equals(StripInstrumentType.SWAP_3M) || _type.equals(_type.equals(StripInstrumentType.SWAP_6M))) {
      return ExternalId.of(_scheme, _ccy.getCode() + "SWAP" + tenor.getPeriod().toString());      
    }
    return ExternalId.of(_scheme, _ccy.getCode() + _type.name() + tenor.getPeriod().toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_45107_d70c8/rev_45107-d70c8;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/SyntheticIdentifierCurveInstrumentProvider;getInstrument(LocalDate,Tenor,int);    return ExternalId.of(_scheme, _ccy.getCode() + _idType.name() + tenor.getPeriod().toString());;    return ExternalId.of(_scheme, _ccy.getCode() + _type.name() + tenor.getPeriod().toString());;    if (_type.equals(StripInstrumentType.SWAP_3M) || _type.equals(_type.equals(StripInstrumentType.SWAP_6M))) {
      return ExternalId.of(_scheme, _ccy.getCode() + "SWAP" + tenor.getPeriod().toString());      
    }
    return ExternalId.of(_scheme, _ccy.getCode() + _type.name() + tenor.getPeriod().toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_50074_52fa1/rev_50074-52fa1;/graylog2-server/src/main/java/org/graylog2/periodical/NodePingThread;run();            final ActivityWriter activityWriter = core.getActivityWriter();
            try {
                // Check that we still have a master node in the cluster, if not, warn the user.
                if (Node.thisNode(core).isAnyMasterPresent()) {
                    boolean removedNotification = Notification.build(core)
                            .addType(Notification.Type.NO_MASTER)
                            .fixed();
                    if (removedNotification) {
                        activityWriter.write(
                            new Activity("Notification condition [" + Notification.Type.NO_MASTER + "] " +
                                                 "has been fixed.", NodePingThread.class));
                    }
                } else {
                    Notification.buildNow(core)
                            .addThisNode()
                            .addType(Notification.Type.NO_MASTER)
                            .addSeverity(Notification.Severity.URGENT)
                            .publishIfFirst();;            final ActivityWriter activityWriter = core.getActivityWriter();
            try {
                // Check that we still have a master node in the cluster, if not, warn the user.
                if (Node.thisNode(core).isAnyMasterPresent()) {
                    boolean removedNotification = Notification.build(core)
                            .addType(Notification.Type.NO_MASTER)
                            .fixed();
                    if (removedNotification) {
                        activityWriter.write(
                            new Activity("Notification condition [" + Notification.Type.NO_MASTER + "] " +
                                                 "has been fixed.", NodePingThread.class));
                    }
                } else {
                    Notification.buildNow(core)
                            .addThisNode()
                            .addType(Notification.Type.NO_MASTER)
                            .addSeverity(Notification.Severity.URGENT)
                            .publishIfFirst();
                    activityWriter.write(
                            new Activity(
                                    "No graylog2 master node available. Check the configuration for is_master=true " +
                                            "on at least one node.",
                                    NodePingThread.class));;            // Check that we still have a master node in the cluster, if not, warn the user.
            if (nodeService.isAnyMasterPresent()) {
                Notification notification = notificationService.build()
                        .addType(Notification.Type.NO_MASTER);
                boolean removedNotification = notificationService.fixed(notification);
                if (removedNotification) {
                    activityWriter.write(
                        new Activity("Notification condition [" + NotificationImpl.Type.NO_MASTER + "] " +
                                             "has been fixed.", NodePingThread.class));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_50074_52fa1/rev_50074-52fa1;/graylog2-server/src/main/java/org/graylog2/indexer/searches/Searches;standardSearchRequest(String,Set<String>,int,int,TimeRange,Sorting);private SearchRequestBuilder standardSearchRequest(String query,
                                                       Set<String> indices,
                                                       int limit,
                                                       int offset,
                                                       TimeRange range,
                                                       Sorting sort) throws IndexHelper.InvalidRangeFormatException {
        return standardSearchRequest(query, indices, limit, offset, range, sort, true);;private SearchRequestBuilder standardSearchRequest(String query, Set<String> indices, int limit, int offset, TimeRange range, Sorting sort) throws IndexHelper.InvalidRangeFormatException {
        if (query == null || query.trim().isEmpty()) {
            query = "*";
        }

        SearchRequestBuilder srb = c.prepareSearch();
        srb.setIndices(indices.toArray(new String[]{}));

        if (query.trim().equals("*")) {
            srb.setQuery(matchAllQuery());
        } else {
            QueryStringQueryBuilder qs = queryString(query);
            qs.allowLeadingWildcard(server.getConfiguration().isAllowLeadingWildcardSearches());
            srb.setQuery(qs);
        }

        srb.setFrom(offset);

        if (limit > 0) {
            srb.setSize(limit);
        }

        if (range != null) {
            srb.setFilter(IndexHelper.getTimestampRangeFilter(range));
        }

        if (sort != null) {
            srb.addSort(sort.getField(), sort.asElastic());
        }

        if (server.getConfiguration().isAllowHighlighting()) {
            srb.setHighlighterRequireFieldMatch(false);
            srb.addHighlightedField("*", 0, 0);
        }

        return srb;;private SearchRequestBuilder standardSearchRequest(String query, Set<String> indices, int limit, int offset, TimeRange range, Sorting sort) throws IndexHelper.InvalidRangeFormatException {
        if (query == null || query.trim().isEmpty()) {
            query = "*";
        }

        SearchRequestBuilder srb = c.prepareSearch();
        srb.setIndices(indices.toArray(new String[]{}));

        if (query.trim().equals("*")) {
            srb.setQuery(matchAllQuery());
        } else {
            QueryStringQueryBuilder qs = queryString(query);
            qs.allowLeadingWildcard(configuration.isAllowLeadingWildcardSearches());
            srb.setQuery(qs);
        }

        srb.setFrom(offset);

        if (limit > 0) {
            srb.setSize(limit);
        }

        if (range != null) {
            srb.setFilter(IndexHelper.getTimestampRangeFilter(range));
        }

        if (sort != null) {
            srb.addSort(sort.getField(), sort.asElastic());
        }

        if (configuration.isAllowHighlighting()) {
            srb.setHighlighterRequireFieldMatch(false);
            srb.addHighlightedField("*", 0, 0);
        }

        return srb;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_52671_44957/rev_52671-44957;/src/java/org/apache/cassandra/service/StorageProxy;asyncRemoveFromBatchlog(Collection<InetAddress>,UUID);        rm.delete(new QueryPath(SystemTable.BATCHLOG_CF), FBUtilities.timestampMicros());
        AbstractWriteResponseHandler handler = new WriteResponseHandler(endpoints,
                                                                        Collections.<InetAddress>emptyList(),
                                                                        ConsistencyLevel.ANY,
                                                                        Table.open(Table.SYSTEM_KS),
                                                                        null,
                                                                        WriteType.SIMPLE);;        rm.delete(new QueryPath(SystemTable.BATCHLOG_CF), FBUtilities.timestampMicros());
        AbstractWriteResponseHandler handler = new WriteResponseHandler(endpoints, Collections.<InetAddress>emptyList(), ConsistencyLevel.ANY, Table.SYSTEM_KS, null, WriteType.SIMPLE);;        rm.delete(SystemTable.BATCHLOG_CF, FBUtilities.timestampMicros());
        AbstractWriteResponseHandler handler = new WriteResponseHandler(endpoints, Collections.<InetAddress>emptyList(), ConsistencyLevel.ANY, Table.SYSTEM_KS, null, WriteType.SIMPLE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_59216_84154/rev_59216-84154;/src/main/java/org/graylog2/forwarders/forwarders/GELFMessageForwarder;forward(GELFMessage);                LOG.info("Forwarding chunked GELF message chunk:" + chunk.toString());
                this.send(chunk.getRaw());;                LOG.info("Fowarding chunked GELF message chunk: <" + chunk.getHash() + ">");
                this.send(chunk.getData());;                LOG.info("Fowarding chunked GELF message chunk: <" + chunk.getHash() + ">");
                this.succeeded = this.send(chunk.getRaw());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_60303_33e0c/rev_60303-33e0c;/projects/OG-Engine/tests/unit/com/opengamma/engine/DefaultComputationTargetResolverTest;test_resolve_trade();    TradeImpl trade = new TradeImpl(position.getUniqueIdentifier(), IdentifierBundle.EMPTY, new BigDecimal(1), new CounterpartyImpl(Identifier.of("CPARTY", "C100")), now.toLocalDate(), now.toOffsetTime());
    trade.setUniqueIdentifier(UniqueIdentifier.of("TradeScheme", "1"));
    position.addTrade(trade);;    TradeImpl trade = new TradeImpl(position.getUniqueIdentifier(), IdentifierBundle.EMPTY, new BigDecimal(1), new CounterpartyImpl(Identifier.of("CPARTY", "C100")), now.toLocalDate(), now.toOffsetTime());
    trade.setUniqueIdentifier(UniqueIdentifier.of("TradeScheme", "1"));
    position.getTrades().add(trade);;    TradeImpl trade = new TradeImpl(position.getUniqueId(), IdentifierBundle.EMPTY, new BigDecimal(1), new CounterpartyImpl(Identifier.of("CPARTY", "C100")), now.toLocalDate(), now.toOffsetTime());
    trade.setUniqueId(UniqueIdentifier.of("TradeScheme", "1"));
    position.getTrades().add(trade);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_61543_889f3/rev_61543-889f3;/src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow;getReduced();                Column reduced = purged.iterator().next();
                container = ArrayBackedSortedColumns.factory.create(emptyColumnFamily.metadata());;                Column reduced = purged.iterator().next();
                container.clear();;
                int localDeletionTime = container.deletionInfo().getTopLevelDeletion().localDeletionTime;
                if (localDeletionTime < Integer.MAX_VALUE)
                    tombstones.update(localDeletionTime);

                Cell reduced = iter.next();
                container.clear();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_61567_9bb34/rev_61567-9bb34;/src/java/org/apache/cassandra/config/CFMetaData;toSchemaNoColumns(RowMutation,long);        Integer oldId = Schema.instance.convertNewCfId(cfId);
        if (oldId != null) // keep old ids (see CASSANDRA-3794 for details)
            cf.addColumn(Column.create(oldId, timestamp, cfName, "id"));;        Integer oldId = Schema.instance.convertNewCfId(cfId);

        if (oldId != null) // keep old ids (see CASSANDRA-3794 for details)
            cf.addColumn(Column.create(oldId, timestamp, cfName, "id"));;        cf.addColumn(Column.create(cfType.toString(), timestamp, cfName, "type"));

        if (isSuper())
        {
            // We need to continue saving the comparator and subcomparator separatly, otherwise
            // we won't know at deserialization if the subcomparator should be taken into account
            // TODO: we should implement an on-start migration if we want to get rid of that.
            CompositeType ct = (CompositeType)comparator;
            cf.addColumn(Column.create(ct.types.get(0).toString(), timestamp, cfName, "comparator"));
            cf.addColumn(Column.create(ct.types.get(1).toString(), timestamp, cfName, "subcomparator"));
        }
        else
        {
            cf.addColumn(Column.create(comparator.toString(), timestamp, cfName, "comparator"));
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_62386_6f1b7/rev_62386-6f1b7;/src/java/org/apache/cassandra/io/sstable/SSTableDeletingTask;SSTableDeletingTask(SSTableReader);        this.desc = referent.descriptor;
        this.components = referent.components;;        this.desc = referent.descriptor;
        this.components = referent.components;
        this.size = referent.bytesOnDisk();;        if (referent.openReason == SSTableReader.OpenReason.EARLY)
        {
            this.desc = referent.descriptor.asType(Descriptor.Type.TEMPLINK);
            this.components = Sets.newHashSet(Component.DATA, Component.PRIMARY_INDEX);
        }
        else
        {
            this.desc = referent.descriptor;
            this.components = referent.components;
        }
        this.size = referent.bytesOnDisk();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_68198_cd85d/rev_68198-cd85d;/src/java/org/apache/cassandra/config/DatabaseDescriptor;loadSchemas();            // we can load tables from local storage if a version is set in the system table and that actually maps to
            // real data in the definitions table.  If we do end up loading from xml, store the definitions so that we
            // don't load from xml anymore.
            UUID uuid = MigrationManager.getLastMigrationId();

            if (uuid == null)
            {
                logger.info("Couldn't detect any schema definitions in local storage.");
                // peek around the data directories to see if anything is there.
                if (hasExistingNoSystemTables())
                    logger.info("Found table data in data directories. Consider using cqlsh to define your schema.");
                else
                    logger.info("To create keyspaces and column families, see 'help create' in cqlsh.");
            };            // we can load tables from local storage if a version is set in the system table and that actually maps to
            // real data in the definitions table.  If we do end up loading from xml, store the definitions so that we
            // don't load from xml anymore.
            UUID uuid = MigrationManager.getLastMigrationId();

            if (uuid == null)
            {
                logger.info("Couldn't detect any schema definitions in local storage.");
                // peek around the data directories to see if anything is there.
                if (hasExistingNoSystemTables())
                    logger.info("Found table data in data directories. Consider using the CLI to define your schema.");
                else
                    logger.info("To create keyspaces and column families, see 'help create keyspace' in the CLI, or set up a schema using the thrift system_* calls.");
            };            logger.info("Couldn't detect any schema definitions in local storage.");
            // peek around the data directories to see if anything is there.
            if (hasExistingNoSystemTables())
                logger.info("Found keyspace data in data directories. Consider using cqlsh to define your schema.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_70297_1ff0d/rev_70297-1ff0d;/src/java/org/apache/cassandra/hadoop/pig/CqlStorage;getNext();                    IColumn column = new Column(cdef.name, columnValue);
                    AbstractType<?> validator = getValidatorMap(cfDef).get(column.name());
                    setTupleValue(tuple, i, cqlColumnToObj(column, cfDef), validator);;                    IColumn column = new Column(cdef.name, columnValue);
                    tuple.set(i, columnToTuple(column, cfDef, UTF8Type.instance));;                    Column column = new Column(cdef.name, columnValue);
                    tuple.set(i, columnToTuple(column, cfDef, UTF8Type.instance));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);    ;    
    List<CalculationJobItem> itemsToExecute = job.getResultWriter().getItemsToExecute(this, job);
    
    s_logger.info("Executing {} items", itemsToExecute.size());
    ;
    List<CalculationJobItem> itemsToExecute = job.getResultWriter().getItemsToExecute(this, job);

    s_logger.info("Executing {} items", itemsToExecute.size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);    
    for (CalculationJobItem jobItem : job.getJobItems()) {
      ;    
    for (CalculationJobItem jobItem : itemsToExecute) {
      ;
    for (CalculationJobItem jobItem : itemsToExecute) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);        
        resultItem = new CalculationJobResultItem(jobItem);
      ;        
        resultItem = new CalculationJobResultItem(jobItem, InvocationResult.SUCCESS);
        resultItem.setResults(result);
      ;
        resultItem = new CalculationJobResultItem(jobItem, InvocationResult.SUCCESS);
        resultItem.setResults(result);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);        resultItem = new CalculationJobResultItem(jobItem, e);
      ;        resultItem = new CalculationJobResultItem(jobItem, InvocationResult.ERROR);
        resultItem.setException(e);
      ;        resultItem = new CalculationJobResultItem(jobItem, InvocationResult.ERROR);
        resultItem.setException(e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);    CalculationJobResult jobResult = new CalculationJobResult(spec, 
        durationNanos, 
        resultItems,
        getNodeId());
    ;    CalculationJobResult jobResult = new CalculationJobResult(spec, durationNanos, resultItems);
    ;    CalculationJobResult jobResult = new CalculationJobResult(spec, durationNanos, resultItems);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_70431_1a706/rev_70431-1a706;/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJob(CalculationJob);    
    return jobResult;;    
    s_logger.info("Writing {}", jobResult);
    job.getResultWriter().write(this, jobResult);
    s_logger.info("Wrote {}", jobResult);

    return jobResult;;
    s_logger.info("Writing {}", jobResult);
    job.getResultWriter().write(this, jobResult);
    s_logger.info("Wrote {}", jobResult);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_74973_42582/rev_74973-42582;/src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler;response(MessageIn);        if (message == null || consistencyLevel.isLocal(message.from))
            if (responses.decrementAndGet() == 0)
                signal();;        if (message == null || DatabaseDescriptor.getLocalDataCenter().equals(snitch.getDatacenter(message.from)))
        {
            if (responses.decrementAndGet() == 0)
                signal();
        };        if (message == null || DatabaseDescriptor.getLocalDataCenter().equals(snitch.getDatacenter(message.from)))
        {
            super.response(message);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_76044_cf9b8/rev_76044-cf9b8;/test/unit/org/apache/cassandra/db/BatchlogManagerTest;testReplay();            long timestamp = i < 500
                           ? (System.currentTimeMillis() - DatabaseDescriptor.getWriteRpcTimeout() * 2) * 1000
                           : Long.MAX_VALUE;
            BatchlogManager.getBatchlogMutationFor(Collections.singleton(mutation), UUIDGen.getTimeUUID(), timestamp).apply();;            long timestamp = System.currentTimeMillis();
            if (i < 500)
                timestamp -= DatabaseDescriptor.getWriteRpcTimeout() * 2;
            BatchlogManager.getBatchlogMutationFor(Collections.singleton(mutation), UUIDGen.getTimeUUID(), timestamp * 1000).apply();;            long timestamp = System.currentTimeMillis();
            if (i < 500)
                timestamp -= DatabaseDescriptor.getWriteRpcTimeout() * 2;
            BatchlogManager.getBatchlogMutationFor(Collections.singleton(mutation),
                                                   UUIDGen.getTimeUUID(),
                                                   MessagingService.current_version,
                                                   timestamp * 1000)
                           .apply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2;/js/js.tests/test/org/jetbrains/k2js/test/rhino/RhinoUtils;runFileWithRhino(String,Context,Scriptable);                                         @NotNull Context context,
                                         @NotNull Scriptable scope) throws Exception {
        context.evaluateString(scope, fileToString(inputFile), inputFile, 1, null);;                                         @NotNull Context context,
                                         @NotNull Scriptable scope) throws Exception {
        FileReader reader = new FileReader(inputFile);
        try {
            context.evaluateReader(scope, reader, inputFile, 1, null);
        } finally {
            reader.close();
        };            @NotNull Context context,
            @NotNull Scriptable scope) throws Exception {
        FileReader reader = new FileReader(inputFile);
        try {
            context.evaluateReader(scope, reader, inputFile, 1, null);
        }
        finally {
            reader.close();
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2;/js/js.tests/test/org/jetbrains/k2js/test/rhino/RhinoFunctionResultChecker;runChecks(Context,Scriptable);        assertResultValid(result, context);;        assertResultValid(result);;        flushSystemOut(context, scope);
        assertResultValid(result);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_77381_8f2c5/rev_77381-8f2c5;/src/java/org/apache/cassandra/db/compaction/CompactionManager;submitBackground(ColumnFamilyStore);                    if (!cfs.isValid())
                        return 0;

                    boolean taskExecuted = false;;                    if (!cfs.isValid())
                        return 0;;                    boolean taskExecuted = false;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_77912_4d6b4/rev_77912-4d6b4;/projects/OG-Financial/src/main/java/com/opengamma/financial/generator/SecurityGenerator;execute(FunctionExecutionContext,CompiledFunctionDefinition,ComputationTarget,ValueRequirement,ComputedValue);    final FunctionInputsImpl functionInputs = new FunctionInputsImpl();
    for (final ComputedValue input : inputs) {
      functionInputs.addValue(input);
    };    final FunctionInputsImpl functionInputs = new FunctionInputsImpl();
    for (ComputedValue input : inputs) {
      functionInputs.addValue(input);
    };    final FunctionInputsImpl functionInputs = new FunctionInputsImpl(null, Arrays.asList(inputs));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_79354_3f7c7/rev_79354-3f7c7;/src/java/org/apache/cassandra/net/IncomingTcpConnection;run();            from = msg.getFrom(); // why? see => CASSANDRA-4099
            if (version > MessagingService.version_);            if (version > MessagingService.version_);            from = msg.getFrom(); // why? see => CASSANDRA-4099
            if (version > MessagingService.current_version)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_83273_b3733/rev_83273-b3733;/subprojects/cpp/src/main/groovy/org/gradle/nativebinaries/plugins/NativeBinariesModelPlugin;apply(Project);        project.getExtensions().create(
                "toolChains",
                DefaultToolChainRegistry.class,
                instantiator
        );;        modelRules.register("toolChains", ToolChainRegistryInternal.class, new ToolChainFactory(instantiator));

        modelRules.rule(new AddDefaultToolchainIfRequired());
        modelRules.rule(new CreateNativeBinaries(instantiator, (ProjectInternal) project));
        modelRules.rule(new CloseBinariesForTasks());;        modelRules.register("toolChains", ToolChainRegistryInternal.class, new ToolChainFactory(instantiator));
        modelRules.register("platforms", PlatformContainer.class, new PlatformFactory(instantiator));
        modelRules.register("buildTypes", BuildTypeContainer.class, new BuildTypeFactory(instantiator));
        modelRules.register("flavors", FlavorContainer.class, new FlavorFactory(instantiator));

        modelRules.rule(new CreateDefaultPlatform());
        modelRules.rule(new CreateDefaultBuildTypes());
        modelRules.rule(new CreateDefaultFlavors());
        modelRules.rule(new AddDefaultToolChainsIfRequired());
        modelRules.rule(new CreateNativeBinaries(instantiator, (ProjectInternal) project));
        modelRules.rule(new CloseBinariesForTasks());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_83273_b3733/rev_83273-b3733;/subprojects/cpp/src/main/groovy/org/gradle/nativebinaries/plugins/NativeBinariesModelPlugin;apply(Project);                new ApplySourceSetConventions(),
                new CreateDefaultToolChain(),
                new CreateDefaultPlatform(),
                new CreateDefaultBuildTypes(),
                new CreateDefaultFlavors(),
                new CreateNativeBinaries(instantiator))
        );;                new ApplySourceSetConventions(),
                new CreateDefaultPlatform(),
                new CreateDefaultBuildTypes(),
                new CreateDefaultFlavors()
        ));;                new ApplySourceSetConventions()
        ));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_84549_e2fce/rev_84549-e2fce;/projects/OG-Financial/src/main/java/com/opengamma/financial/aggregation/SeniorityAggregationFunction;classifyPosition(Position);  public String classifyPosition(final Position position) {

    final Security security = resolveSecurity(position);;  public String classifyPosition(Position position) {

    Security security = resolveSecurity(position);;  public String classifyPosition(Position position) {
    Security security = resolveSecurity(position);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_84549_e2fce/rev_84549-e2fce;/projects/OG-Financial/src/main/java/com/opengamma/financial/aggregation/SeniorityAggregationFunction;resolveSecurity(Position);private Security resolveSecurity(final Position position) {

    final Security security = position.getSecurityLink().getTarget();;private Security resolveSecurity(Position position) {

    Security security = position.getSecurityLink().getTarget();;private Security resolveSecurity(Position position) {
    Security security = position.getSecurityLink().getTarget();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_84549_e2fce/rev_84549-e2fce;/projects/OG-Financial/src/main/java/com/opengamma/financial/aggregation/EntityNameAggregationFunction;classifyPosition(Position);  public String classifyPosition(final Position position) {

    final Security security = resolveSecurity(position);;  public String classifyPosition(Position position) {

    Security security = resolveSecurity(position);;  public String classifyPosition(Position position) {
    Security security = resolveSecurity(position);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_84549_e2fce/rev_84549-e2fce;/projects/OG-Financial/src/main/java/com/opengamma/financial/aggregation/EntityNameAggregationFunction;classifyPosition(Position);      final AbstractCreditDefaultSwapSecurity cds = (AbstractCreditDefaultSwapSecurity) security;
      final String redCode = cds.getReferenceEntity().getValue();
      final Organization organisation = _organizationSource.getOrganizationByRedCode(redCode);
      if (organisation != null) {;      AbstractCreditDefaultSwapSecurity cds = (AbstractCreditDefaultSwapSecurity) security;
      String redCode = cds.getReferenceEntity().getValue();
      Organization organisation = _organizationSource.getOrganizationByRedCode(redCode);
      if(organisation != null);      AbstractCreditDefaultSwapSecurity cds = (AbstractCreditDefaultSwapSecurity) security;
      String redCode = cds.getReferenceEntity().getValue();
      Organization organisation = _organizationSource.getOrganizationByRedCode(redCode);
      if (organisation != null) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_84549_e2fce/rev_84549-e2fce;/projects/OG-Financial/src/main/java/com/opengamma/financial/aggregation/EntityNameAggregationFunction;resolveSecurity(Position);private Security resolveSecurity(final Position position) {

    final Security security = position.getSecurityLink().getTarget();;private Security resolveSecurity(Position position) {

    Security security = position.getSecurityLink().getTarget();;private Security resolveSecurity(Position position) {
    Security security = position.getSecurityLink().getTarget();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_91419_11405/rev_91419-11405;/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter;getExternalApi(String);    public Object getExternalApi(final String apiName) throws InterruptedException,
            ElasticMachineProvisioningException {
        Object externalApi = null;
        // TODO: (adaml) extract the names of the apis to constants.
        if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
            externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
                    getTemplates().get(storageTemplateName));
        } else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
            externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
        };	public Object getExternalApi(final String apiName) throws InterruptedException,
			ElasticMachineProvisioningException {
		Object externalApi = null;
		// TODO: (adaml) extract the names of the apis to constants.
		if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
			externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
					getTemplates().get(storageTemplateName));
		} else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
			externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
		};	public Object getExternalApi(final String apiName) throws InterruptedException,
			ElasticMachineProvisioningException {
		Object externalApi = null;
		if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
			externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
					getTemplates().get(storageTemplateName));
		} else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
			externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_clojure/revisions/rev_96174_30916/rev_96174-30916;/src/jvm/clojure/lang/LockingTransaction;run(Callable);					boolean wasEnsured = ensures.contains(ref);
					//can't upgrade readLock, so release it
					releaseIfEnsured(ref);
					tryWriteLock(ref);;					ref.lock.writeLock().lock();;					if(sets.contains(ref)) continue;

					ref.lock.writeLock().lock();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_clojure/revisions/rev_96174_30916/rev_96174-30916;/src/jvm/clojure/lang/LockingTransaction;run(Callable);					if(!commutes.containsKey(ref))
						{
						tryWriteLock(ref);
						locked.add(ref);
						};					if(!commutes.containsKey(ref))
						{
						ref.lock.writeLock().lock();
						locked.add(ref);
						};					ref.lock.writeLock().lock();
					locked.add(ref);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;insertNode(int[][],int);          int templateLength = template.length;
          int vectorTailLength = template[templateLength-1].length - pivot;;        int templateLength = template.length;
        int vectorTailLength = template[templateLength-1].length - pivot;
        
        int[][] layout = new int[templateLength+1][];
        layout[templateLength-1] = new int[pivot];
        layout[templateLength] = new int[vectorTailLength];;        int templateLength = template.length;
        int vectorTailLength = template[templateLength - 1].length - pivot;

        int[][] layout = new int[templateLength + 1][];
        layout[templateLength - 1] = new int[pivot];
        layout[templateLength] = new int[vectorTailLength];
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;splitLastPartition(int[][],int);          int templateLength = template.length;
          int vectorTailLength = template[templateLength-2].length - pivot;;        int templateLength = template.length;
        int vectorTailLength = template[templateLength-2].length - pivot;;        int templateLength = template.length;
        int vectorTailLength = template[templateLength - 2].length - pivot;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;splitLastPartition(int[][],int);          int[][] layout = new int[templateLength][];
          layout[templateLength-2] = new int[pivot];
          layout[templateLength-1] = new int[vectorTailLength];;        int[][] layout = new int[templateLength][];
        layout[templateLength-2] = new int[pivot];
        layout[templateLength-1] = new int[vectorTailLength];;        int[][] layout = new int[templateLength][];
        layout[templateLength - 2] = new int[pivot];
        layout[templateLength - 1] = new int[vectorTailLength];
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;getPorts(int);private static int[] getPorts(int count) {
          int[] ports = new int[count*3];
          for (int i = 0; i < count; i++) {
              ports[3 * i] = 6665;
              ports[3 * i + 1] = 6666;
              ports[3 * i + 2] = 6667;
          };private int[] getPorts(int count) {
        int[] ports = new int[count*3];
        for (int i = 0; i < count; i++) {
            ports[3 * i] = 6665;
            ports[3 * i + 1] = 6666;
            ports[3 * i + 2] = 6667;
        };private int[] getPorts(int count) {
        int[] ports = new int[count * 3];
        for(int i = 0; i < count; i++) {
            ports[3 * i] = 6665;
            ports[3 * i + 1] = 6666;
            ports[3 * i + 2] = 6667;
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;setUp();        if (logger.isInfoEnabled());        testEntries = ServerTestUtils.createRandomKeyValueString(ec2RebalancingTestConfig.numKeys);
        originalCluster = updateCluster(originalCluster, nodeIds);

        if (logger.isInfoEnabled());        testEntries = ServerTestUtils.createRandomKeyValueString(ec2RebalancingTestConfig.numKeys);
        originalCluster = updateCluster(originalCluster, nodeIds);

        if(logger.isInfoEnabled())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d;/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest;testSingleRebalancing();        if (spareNode)
            targetLayout = splitLastPartition(partitionMap, partitionMap[clusterSize-2].length-2);
        else
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize-1].length-2);;        if (spareNode)
            targetLayout = splitLastPartition(partitionMap, partitionMap[clusterSize-2].length-2);
        else 
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize-1].length-2);;        if(spareNode)
            targetLayout = splitLastPartition(partitionMap,
                                              partitionMap[clusterSize - 2].length - 2);
        else
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize - 1].length - 2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a1a90_46fa2/rev_a1a90-46fa2;/src/com/opengamma/financial/model/interestrate/curve/InterpolatedDiscountCurve;toFudgeMsg(FudgeSerializationContext);    message.add(INTERPOLATOR_FIELD_NAME, Interpolator1DFactory.getInterpolatorName(getInterpolator()));
    context.objectToFudgeMsg(message, RATE_DATA_FIELD_NAME, null, _rateData);
    context.objectToFudgeMsg(message, DF_DATA_FIELD_NAME, null, _dfData);;    message.add(INTERPOLATOR_FIELD_NAME, Interpolator1DFactory.getInterpolatorName(getInterpolator()));
    message.add(RATE_DATA_FIELD_NAME, encodeDoubleDoubleMap(context, _rateData));
    message.add(DF_DATA_FIELD_NAME, encodeDoubleDoubleMap(context, _dfData));;    message.add(INTERPOLATOR_FIELD_NAME, encodeDoubleInterpolator1DMap(context, _interpolators));
    message.add(RATE_DATA_FIELD_NAME, encodeDoubleDoubleMap(context, _rateData));
    message.add(DF_DATA_FIELD_NAME, encodeDoubleDoubleMap(context, _dfData));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_a1c96_7c011/rev_a1c96-7c011;/src/java/voldemort/server/storage/StorageService;registerNodeStores(StoreDefinition,Cluster,int);        routedStore = new RebootstrappingStore(metadata,
                                               storeRepository,
                                               voldemortConfig,
                                               storeFactory,
                                               (RoutedStore) routedStore);;        routedStore = new RebootstrappingStore(metadata,
                                               storeRepository,
                                               voldemortConfig,
                                               socketPool,
                                               (RoutedStore) routedStore);;        store = new RebootstrappingStore(metadata,
                                         storeRepository,
                                         voldemortConfig,
                                         socketPool,
                                         (RoutableStore) store);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_a2a22_21c57/rev_a2a22-21c57;/src/java/org/apache/cassandra/cql/QueryProcessor;processStatement(CQLStatement,ClientState,List<ByteBuffer>);                clientState.hasColumnFamilySchemaAccess(keyspace, Permission.CREATE);
                validateSchemaAgreement();;                clientState.hasColumnFamilySchemaAccess(createCf.getName(), Permission.CREATE);
                validateSchemaAgreement();;                clientState.hasColumnFamilySchemaAccess(createCf.getName(), Permission.CREATE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a3b7c_6bd12/rev_a3b7c-6bd12;/projects/OG-Language/Client/src/com/opengamma/language/client/Loader;initContext(MutableSessionContext);    final StashMessage stash = sessionContext.getStashMessage();
    if (stash != null) {
      final FudgeMsg msg = stash.get();
      if (msg != null) {
        final String clientId = msg.getString(CLIENTID_STASH_FIELD);
        if (clientId != null) {
          s_logger.info("Recovering old remote engine client {}", clientId);
          initClient(sessionContext, RemoteClient.forClient(getConfiguration().getFudgeContext(), target, sessionContext.getUserContext().getUserName(), clientId));
          return;
        };    final FudgeMsg msg = sessionContext.getStashMessage().get();
    if (msg != null) {
      final String clientId = msg.getString(CLIENTID_STASH_FIELD);
      if (clientId != null) {
        s_logger.info("Recovering old remote engine client {}", clientId);
        initClient(sessionContext, RemoteClient.forClient(getConfiguration().getFudgeContext(), target, sessionContext.getUserContext().getUserName(), clientId));
        return;;    final FudgeMsg msg = sessionContext.getStashMessage().get();
    if (msg != null) {
      final String clientId = msg.getString(CLIENTID_STASH_FIELD);
      if (clientId != null) {
        s_logger.info("Recovering old remote engine client {}", clientId);
        initClient(sessionContext, RemoteClient.forClient(getConfiguration().getFudgeContext(), uri, sessionContext.getUserContext().getUserName(), clientId));
        return;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a3b7c_6bd12/rev_a3b7c-6bd12;/projects/OG-Language/Client/src/com/opengamma/language/client/Loader;initContext(MutableSessionContext);    final RemoteClient client = RemoteClient.forNewClient(getConfiguration().getFudgeContext(), target, sessionContext.getUserContext().getUserName());
    if (stash != null) {
      final MutableFudgeMsg msgStash = FudgeContext.GLOBAL_DEFAULT.newMessage();
      msgStash.add(CLIENTID_STASH_FIELD, client.getClientId());
      stash.put(msgStash);
    } else {
      s_logger.warn("Message stash not available - cannot resume client if JVM abends");
    };    final RemoteClient client = RemoteClient.forNewClient(getConfiguration().getFudgeContext(), target, sessionContext.getUserContext().getUserName());
    final MutableFudgeMsg stash = FudgeContext.GLOBAL_DEFAULT.newMessage();
    stash.add(CLIENTID_STASH_FIELD, client.getClientId());
    sessionContext.getStashMessage().put(stash);;    final RemoteClient client = RemoteClient.forNewClient(getConfiguration().getFudgeContext(), uri, sessionContext.getUserContext().getUserName());
    final MutableFudgeMsg stash = FudgeContext.GLOBAL_DEFAULT.newMessage();
    stash.add(CLIENTID_STASH_FIELD, client.getClientId());
    sessionContext.getStashMessage().put(stash);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_a3d12_2f7c7/rev_a3d12-2f7c7;/src/java/org/apache/cassandra/service/StorageProxy;mutate(List<RowMutation>,ConsistencyLevel);        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        StorageService ss = StorageService.instance;
        String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());
        
        try
        {
            for (RowMutation rm : mutations)
            {
                mostRecentRowMutation = rm;
                String table = rm.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                
                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistency_level);
                
                // exit early if we can't fulfill the CL at this time
                responseHandler.assureSufficientLiveNodes();
                
                responseHandlers.add(responseHandler);
                
                // Multimap that holds onto all the messages and addresses meant for a specific datacenter
                Map<String, Multimap<Message, InetAddress>> dcMessages = new HashMap<String, Multimap<Message, InetAddress>>(hintedEndpoints.size());
                Message unhintedMessage = null;

                for (Map.Entry<InetAddress, Collection<InetAddress>> entry : hintedEndpoints.asMap().entrySet())
                {
                    InetAddress destination = entry.getKey();
                    Collection<InetAddress> targets = entry.getValue();

                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);

                    if (targets.size() == 1 && targets.iterator().next().equals(destination))
                    {
                        // unhinted writes
                        if (destination.equals(FBUtilities.getLocalAddress()))
                        {
                            insertLocalMessage(rm, responseHandler);
                        }
                        else
                        {
                            // belongs on a different server
                            if (unhintedMessage == null)
                            {
                                unhintedMessage = rm.makeRowMutationMessage();
                                MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                            }
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + unhintedMessage.getMessageId() + "@" + destination);
                            
                            
                            Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                            if (messages == null)
                            {
                               messages = HashMultimap.create();
                               dcMessages.put(dc, messages);
                            }
                            
                            messages.put(unhintedMessage, destination);
                        }
                    }
                    else
                    {
                        // hinted
                        Message hintedMessage = rm.makeRowMutationMessage();
                        for (InetAddress target : targets)
                        {
                            if (!target.equals(destination))
                            {
                                addHintHeader(hintedMessage, target);
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + hintedMessage.getMessageId() + "@" + destination + " for " + target);
                            }
                        }
                        responseHandler.addHintCallback(hintedMessage, destination);

                        Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                        
                        if (messages == null)
                        {
                           messages = HashMultimap.create();
                           dcMessages.put(dc, messages);
                        }

                        messages.put(hintedMessage, destination);
                    }
                }

                sendMessages(localDataCenter, dcMessages);
            }
                        
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
                responseHandler.get();
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentRowMutation.key()), e);
        }
        finally
        {
            writeStats.addNano(System.nanoTime() - startTime);
        };        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        StorageService ss = StorageService.instance;
        String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());
        
        try
        {
            for (RowMutation rm : mutations)
            {
                mostRecentRowMutation = rm;
                String table = rm.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                
                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistency_level);
                
                // exit early if we can't fulfill the CL at this time
                responseHandler.assureSufficientLiveNodes();
                
                responseHandlers.add(responseHandler);
                
                // Multimap that holds onto all the messages and addresses meant for a specific datacenter
                Map<String, Multimap<Message, InetAddress>> dcMessages = new HashMap<String, Multimap<Message, InetAddress>>(hintedEndpoints.size());
                Message unhintedMessage = null;

                for (Map.Entry<InetAddress, Collection<InetAddress>> entry : hintedEndpoints.asMap().entrySet())
                {
                    InetAddress destination = entry.getKey();
                    Collection<InetAddress> targets = entry.getValue();

                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);

                    if (targets.size() == 1 && targets.iterator().next().equals(destination))
                    {
                        // unhinted writes
                        if (destination.equals(FBUtilities.getLocalAddress()))
                        {
                            insertLocalMessage(rm, responseHandler);
                        }
                        else
                        {
                            // belongs on a different server
                            if (unhintedMessage == null)
                            {
                                unhintedMessage = rm.makeRowMutationMessage();
                                MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                            }
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + unhintedMessage.getMessageId() + "@" + destination);
                            
                            
                            Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                            if (messages == null)
                            {
                               messages = HashMultimap.create();
                               dcMessages.put(dc, messages);
                            }
                            
                            messages.put(unhintedMessage, destination);
                        }
                    }
                    else
                    {
                        // hinted
                        Message hintedMessage = rm.makeRowMutationMessage();
                        for (InetAddress target : targets)
                        {
                            if (!target.equals(destination))
                            {
                                addHintHeader(hintedMessage, target);
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing key " + ByteBufferUtil.bytesToHex(rm.key()) + " to " + hintedMessage.getMessageId() + "@" + destination + " for " + target);
                            }
                        }
                        responseHandler.addHintCallback(hintedMessage, destination);
                        
                        Multimap<Message, InetAddress> messages = dcMessages.get(dc);
                        
                        if (messages == null)
                        {
                           messages = HashMultimap.create();
                           dcMessages.put(dc, messages);
                        }
                        
                        messages.put(hintedMessage, destination);
                    }
                }

                sendMessages(localDataCenter, dcMessages);
            }
                        
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
                responseHandler.get();
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentRowMutation.key()), e);
        }
        finally
        {
            writeStats.addNano(System.nanoTime() - startTime);
        };        write(mutations, consistency_level, standardWritePerformer, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_a7bc6_e1941/rev_a7bc6-e1941;/src/java/org/apache/cassandra/db/ColumnFamilyStore;truncate();        return CompactionManager.instance.submitTruncate(this, truncatedAt);;        Runnable runnable = new WrappedRunnable()
        {
            public void runMayThrow() throws InterruptedException, IOException
            {
                // putting markCompacted on the commitlogUpdater thread ensures it will run
                // after any compactions that were in progress when truncate was called, are finished
                for (ColumnFamilyStore cfs : concatWithIndexes())
                {
                    List<SSTableReader> truncatedSSTables = new ArrayList<SSTableReader>();
                    for (SSTableReader sstable : cfs.getSSTables())
                    {
                        if (!sstable.newSince(truncatedAt))
                            truncatedSSTables.add(sstable);
                    }
                    cfs.markCompacted(truncatedSSTables);
                }

                // Invalidate row cache
                invalidateRowCache();
            }
        };

        return postFlushExecutor.submit(runnable);;        Runnable runnable = new WrappedRunnable()
        {
            public void runMayThrow() throws InterruptedException, IOException
            {
                // putting markCompacted on the commitlogUpdater thread ensures it will run
                // after any compactions that were in progress when truncate was called, are finished
                for (ColumnFamilyStore cfs : concatWithIndexes())
                {
                    List<SSTableReader> truncatedSSTables = new ArrayList<SSTableReader>();
                    for (SSTableReader sstable : cfs.getSSTables())
                    {
                        if (!sstable.newSince(truncatedAt))
                            truncatedSSTables.add(sstable);
                    }
                    cfs.data.markCompacted(truncatedSSTables);
                }

                // Invalidate row cache
                invalidateRowCache();
            }
        };

        return postFlushExecutor.submit(runnable);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_a9c82_0a61b/rev_a9c82-0a61b;/src/java/org/apache/cassandra/thrift/CassandraServer;truncate(String);            logger.debug("... timed out");
            throw (UnavailableException) new UnavailableException().initCause(e);;            throw (UnavailableException) new UnavailableException().initCause(e);;            throw new TimedOutException();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_a12ae_cc01b/rev_a12ae-cc01b;/src/main/java/com/tightdb/example/Example;main(String[]);		showLongExample();;		showLongExample();

		// Enable below to compare Tightdb performance against a Java ArrayList
		// Performance.TestTightdb(250000);
		// Performance.TestJavaArray(250000);;		//showLongExample();

		// Enable below to compare Tightdb performance against a Java ArrayList
		Performance.TestTightdb(250000);
		// Performance.TestJavaArray(250000);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a37de_e434d/rev_a37de-e434d;/projects/OG-Financial/src/com/opengamma/financial/timeseries/db/RowStoreTimeSeriesMaster;searchTimeSeries(TimeSeriesSearchRequest<T>);      Collection<Identifier> requestIdentifiers = request.getIdentifiers();
      Map<Long, List<Identifier>> bundles = searchIdentifierBundles(requestIdentifiers, request.getIdentifierValue());
      
      boolean useBundleIds = (requestIdentifiers != null && !requestIdentifiers.isEmpty()) || request.getIdentifierValue() != null;
      ;      Collection<Identifier> requestIdentifiers = request.getIdentifiers();
      Map<Long, List<Identifier>> bundles = searchIdentifierBundles(requestIdentifiers);;      Set<Identifier> requestIdentifiers = request.getIdentifiers();
      Date currentDate = null;
      if (request.getCurrentDate() != null) {
        currentDate = DbDateUtils.toSqlDate(request.getCurrentDate());
      }
      Map<Long, List<IdentifierWithDates>> bundles = searchIdentifierBundles(requestIdentifiers, currentDate);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a66f4_3773a/rev_a66f4-3773a;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InterestRateDerivativeVisitorTest;test();    assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR, curves), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR, curves), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    assertEquals(VISITOR.visit(CASH), Cash.class);
    assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    assertEquals(SWAPTION_CASH.accept(VISITOR), SwaptionCashFixedIbor.class);
    assertEquals(SWAPTION_PHYS.accept(VISITOR), SwaptionPhysicalFixedIbor.class);;    assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR, curves), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR, curves), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    assertEquals(VISITOR.visit(CASH), Cash.class);
    assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);;    AssertJUnit.assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    AssertJUnit.assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    AssertJUnit.assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    AssertJUnit.assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    AssertJUnit.assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    AssertJUnit.assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    AssertJUnit.assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    AssertJUnit.assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    AssertJUnit.assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    AssertJUnit.assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    AssertJUnit.assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    AssertJUnit.assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    AssertJUnit.assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    AssertJUnit.assertEquals(VISITOR.visit(CASH), Cash.class);
    AssertJUnit.assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    AssertJUnit.assertEquals(BOND.accept(VISITOR), Bond.class);
    AssertJUnit.assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    AssertJUnit.assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    AssertJUnit.assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    AssertJUnit.assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    AssertJUnit.assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    AssertJUnit.assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    AssertJUnit.assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    AssertJUnit.assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    AssertJUnit.assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    AssertJUnit.assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    AssertJUnit.assertEquals(FLOATING_COUPON.accept(VISITOR), CouponFloating.class);
    AssertJUnit.assertEquals(FLOATING_COUPON.accept(VISITOR, curves), CouponFloating.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a84e3_db016/rev_a84e3-db016;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);      //final SwapSecurityConverter swapConverter = new SwapSecurityConverter(holidaySource, conventionSource,
      //    regionSource);
      final FinancialSecurityVisitorAdapter<FixedIncomeInstrumentConverter<?>> instrumentAdapter = FinancialSecurityVisitorAdapter
          .<FixedIncomeInstrumentConverter<?>>builder().cashSecurityVisitor(
              cashConverter).fraSecurityVisitor(fraConverter).create();
      final FinancialSecurityVisitorAdapter<FixedIncomeFutureInstrumentDefinition<?>> futureAdapter = FinancialSecurityVisitorAdapter
          .<FixedIncomeFutureInstrumentDefinition<?>>builder()
          .futureSecurityVisitor(futureConverter).create();
      final TenorSwapSecurityToTenorSwapConverter tenorSwapConverter = new TenorSwapSecurityToTenorSwapConverter(
          holidaySource, regionSource, conventionSource);
      //final LocalDate localNow = now.toLocalDate();;      //final SwapSecurityConverter swapConverter = new SwapSecurityConverter(holidaySource, conventionSource,
      //    regionSource);
      final FinancialSecurityVisitorAdapter<FixedIncomeInstrumentConverter<?>> instrumentAdapter = FinancialSecurityVisitorAdapter.<FixedIncomeInstrumentConverter<?>>builder().cashSecurityVisitor(
          cashConverter).fraSecurityVisitor(fraConverter).create();
      final FinancialSecurityVisitorAdapter<FixedIncomeFutureInstrumentDefinition<?>> futureAdapter = FinancialSecurityVisitorAdapter.<FixedIncomeFutureInstrumentDefinition<?>>builder()
          .futureSecurityVisitor(futureConverter).create();
      final TenorSwapSecurityToTenorSwapConverter tenorSwapConverter = new TenorSwapSecurityToTenorSwapConverter(
          holidaySource, regionSource, conventionSource);
      //final LocalDate localNow = now.toLocalDate();
      
      
      ;      final SwapSecurityConverter swapConverter = new SwapSecurityConverter(holidaySource, conventionSource,
          regionSource);
      final FinancialSecurityVisitorAdapter<FixedIncomeInstrumentConverter<?>> instrumentAdapter =
          FinancialSecurityVisitorAdapter.<FixedIncomeInstrumentConverter<?>> builder()
              .cashSecurityVisitor(cashConverter)
              .fraSecurityVisitor(fraConverter)
              .swapSecurityVisitor(swapConverter)
              .create();
      final FinancialSecurityVisitorAdapter<FixedIncomeFutureInstrumentDefinition<?>> futureAdapter =
          FinancialSecurityVisitorAdapter.<FixedIncomeFutureInstrumentDefinition<?>> builder()
              .futureSecurityVisitor(futureConverter).create();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a84e3_db016/rev_a84e3-db016;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        final Map<Identifier, Double> marketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter,
            futureAdapter, now);;        Map<Identifier, Double> marketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now);;        Map<Identifier, Double> marketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, instrumentAdapter, futureAdapter, now);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a84e3_db016/rev_a84e3-db016;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);      final Map<Identifier, Double> fundingMarketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
      final Map<Identifier, Double> forwardMarketDataMap = _forwardHelper.buildMarketDataMap(inputs).getDataPoints();;      Map<Identifier, Double> fundingMarketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
      Map<Identifier, Double> forwardMarketDataMap = _forwardHelper.buildMarketDataMap(inputs).getDataPoints();
      ;      Map<Identifier, Double> fundingMarketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
      Map<Identifier, Double> forwardMarketDataMap = _forwardHelper.buildMarketDataMap(inputs).getDataPoints();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a84e3_db016/rev_a84e3-db016;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        final double marketValue = fundingMarketValue; //TODO is this right;        double marketValue = fundingMarketValue; //TODO is this right
        
        ;        double marketValue = fundingMarketValue; //TODO is this right
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a84e3_db016/rev_a84e3-db016;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        final double marketValue = forwardMarketValue; //TODO is this right;        double marketValue = forwardMarketValue; //TODO is this right
        ;        double marketValue = forwardMarketValue; //TODO is this right
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_a90cb_776df/rev_a90cb-776df;/lucene/src/java/org/apache/lucene/index/DocumentsWriter;flush(IndexWriter,IndexFileDeleter,MergePolicy,SegmentInfos);      final SegmentWriteState flushState = new SegmentWriteState(infoStream, directory, segment, fieldInfos,
                                                                 numDocs, writer.getConfig().getTermIndexInterval(),
                                                                 SegmentCodecs.build(fieldInfos, writer.codecs),
                                                                 pendingDeletes);
      // Apply delete-by-docID now (delete-byDocID only
      // happens when an exception is hit processing that
      // doc, eg if analyzer has some problem w/ the text):
      if (pendingDeletes.docIDs.size() > 0) {
        flushState.deletedDocs = new BitVector(numDocs);
        for(int delDocID : pendingDeletes.docIDs) {
          flushState.deletedDocs.set(delDocID);
        }
        pendingDeletes.bytesUsed.addAndGet(-pendingDeletes.docIDs.size() * BufferedDeletes.BYTES_PER_DEL_DOCID);
        pendingDeletes.docIDs.clear();
      };      final SegmentWriteState flushState = new SegmentWriteState(infoStream, directory, segment, fieldInfos,
                                                                 numDocs, writer.getConfig().getTermIndexInterval(),
                                                                 SegmentCodecs.build(fieldInfos, writer.codecs));;      final SegmentWriteState flushState = segWriteState();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a401c_cff54/rev_a401c-cff54;/projects/OG-Master/src/com/opengamma/master/portfolio/impl/DataPortfolioResource;uri(URI,ObjectIdentifiable,VersionCorrection);public static URI uri(URI baseUri, ObjectIdentifiable objectId, VersionCorrection versionCorrection) {
    // TODO remove this hack
    UriBuilder b = UriBuilder.fromUri(baseUri);
    if (!baseUri.getPath().endsWith("prtMaster/")) {
      b.path("/prtMaster");
    }
    b.path("/portfolios/{portfolioId}");
    if (versionCorrection != null && versionCorrection.getVersionAsOf() != null) {
      b.queryParam("versionAsOf", versionCorrection.getVersionAsOf());;public static URI uri(URI baseUri, ObjectIdentifiable objectId, VersionCorrection versionCorrection) {
    UriBuilder b = UriBuilder.fromUri(baseUri).path("/prtMaster/portfolios/{portfolioId}");
    if (versionCorrection != null && versionCorrection.getVersionAsOf() != null) {
      b.queryParam("versionAsOf", versionCorrection.getVersionAsOf());;public static URI uri(URI baseUri, ObjectIdentifiable objectId, VersionCorrection vc) {
    UriBuilder bld = UriBuilder.fromUri(baseUri).path("/portfolios/{portfolioId}");
    if (vc != null) {
      bld.queryParam("versionAsOf", vc.getVersionAsOfString());
      bld.queryParam("correctedTo", vc.getCorrectedToString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a1784_fd173/rev_a1784-fd173;/projects/OG-Analytics/src/com/opengamma/financial/instrument/bond/BondDefinition;toDerivative(LocalDate,String);    Validate.notNull(yieldCurveNames, "yield curve names");
    Validate.isTrue(yieldCurveNames.length > 0);
    s_logger.info("Using the first yield curve name as the funding curve name");;    Validate.noNullElements(yieldCurveNames, "yield curve names");;    Validate.isTrue(date.isBefore(_settlementDates[_settlementDates.length - 1]), date + " is after final settlement date (" + _settlementDates[_settlementDates.length - 1] + ")");
    Validate.noNullElements(yieldCurveNames, "yield curve names");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a2619_b8f10/rev_a2619-b8f10;/src/com/opengamma/financial/batch/db/BatchResultWriter;getComputeFailureIds();public Set<Number> getComputeFailureIds() {
      return _computeFailureIds;;public Set<Long> getComputeFailureIds() {
      return _computeFailureIds;;public Set<Long> getComputeFailureIds() {
      return Collections.unmodifiableSet(_computeFailureIds);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_a6236_268de/rev_a6236-268de;/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OAutoshardingPlugin;DHTConfiguration();      clusters.add(OStorage.CLUSTER_DEFAULT_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_INTERNAL_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_INDEX_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_MANUAL_INDEX_NAME.toLowerCase());
      clusters.add(ORole.CLASS_NAME.toLowerCase());
      clusters.add(OUser.CLASS_NAME.toLowerCase());
      clusters.add(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME.toLowerCase());
      clusters.add(OSecurityShared.RESTRICTED_CLASSNAME.toLowerCase());
      clusters.add(OSecurityShared.IDENTITY_CLASSNAME.toLowerCase());
      clusters.add(OFunction.CLASS_NAME.toLowerCase());
      clusters.add(OClassTrigger.CLASSNAME.toLowerCase());;      clusters.add(OStorage.CLUSTER_DEFAULT_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_INTERNAL_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_INDEX_NAME.toLowerCase());
      clusters.add(OMetadata.CLUSTER_MANUAL_INDEX_NAME.toLowerCase());
      clusters.add(ORole.CLASS_NAME.toLowerCase());
      clusters.add(OUser.CLASS_NAME.toLowerCase());
      clusters.add(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME.toLowerCase());
      clusters.add(OSecurityShared.RESTRICTED_CLASSNAME.toLowerCase());
      clusters.add(OSecurityShared.IDENTITY_CLASSNAME.toLowerCase());
      clusters.add(OFunction.CLASS_NAME.toLowerCase());;      undistributableClusters.add(OStorage.CLUSTER_DEFAULT_NAME.toLowerCase());
      undistributableClusters.add(OMetadata.CLUSTER_INTERNAL_NAME.toLowerCase());
      undistributableClusters.add(OMetadata.CLUSTER_INDEX_NAME.toLowerCase());
      undistributableClusters.add(OMetadata.CLUSTER_MANUAL_INDEX_NAME.toLowerCase());
      undistributableClusters.add(ORole.CLASS_NAME.toLowerCase());
      undistributableClusters.add(OUser.CLASS_NAME.toLowerCase());
      undistributableClusters.add(OMVRBTreeRIDProvider.PERSISTENT_CLASS_NAME.toLowerCase());
      undistributableClusters.add(OSecurityShared.RESTRICTED_CLASSNAME.toLowerCase());
      undistributableClusters.add(OSecurityShared.IDENTITY_CLASSNAME.toLowerCase());
      undistributableClusters.add(OFunction.CLASS_NAME.toLowerCase());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a6290_54d8f/rev_a6290-54d8f;/projects/OG-Language/Client/src/com/opengamma/language/convert/ValueConverter;convertValue(ValueConversionContext,Object,JavaTypeInfo<?>);      if (value instanceof Boolean) {
        conversionContext.setResult(1, ValueUtil.of((Boolean) value));
      } else if (value instanceof Integer) {
        conversionContext.setResult(1, ValueUtil.of((Integer) value));
      } else if (value instanceof Double) {
        conversionContext.setResult(1, ValueUtil.of((Double) value));
      } else if (value instanceof String) {
        conversionContext.setResult(1, ValueUtil.of((String) value));
      } else if (value instanceof FudgeMsg) {
        conversionContext.setResult(1, ValueUtil.of((FudgeMsg) value));;      if (value instanceof Boolean) {
        conversionContext.setResult(1, ValueUtil.of((Boolean) value));
      } else if (value instanceof Integer) {
        conversionContext.setResult(1, ValueUtil.of((Integer) value));
      } else if (value instanceof Double) {
        conversionContext.setResult(1, ValueUtil.of((Double) value));
      } else if (value instanceof String) {
        conversionContext.setResult(1, ValueUtil.of((String) value));
      } else if (value instanceof FudgeFieldContainer) {
        conversionContext.setResult(1, ValueUtil.of((FudgeFieldContainer) value));;      if (valueObject instanceof Boolean) {
        conversionContext.setResult(ValueUtil.of((Boolean) valueObject));
      } else if (valueObject instanceof Integer) {
        conversionContext.setResult(ValueUtil.of((Integer) valueObject));
      } else if (valueObject instanceof Double) {
        conversionContext.setResult(ValueUtil.of((Double) valueObject));
      } else if (valueObject instanceof String) {
        conversionContext.setResult(ValueUtil.of((String) valueObject));
      } else if (valueObject instanceof FudgeFieldContainer) {
        conversionContext.setResult(ValueUtil.of((FudgeFieldContainer) valueObject));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_a6290_54d8f/rev_a6290-54d8f;/projects/OG-Language/Client/src/com/opengamma/language/convert/ValueConverter;convertValue(ValueConversionContext,Object,JavaTypeInfo<?>);          conversionContext.setResult(1, valueValue.getStringValue());
        } else if (clazz == FudgeMsg.class) {
          conversionContext.setResult(1, valueValue.getMessageValue());;          conversionContext.setResult(1, valueValue.getStringValue());
        } else if (clazz == FudgeFieldContainer.class) {
          conversionContext.setResult(1, valueValue.getMessageValue());;          if (value.getStringValue() != null) {
            conversionContext.setResult(value.getStringValue());
          } else {
            conversionContext.setFail();
          }
        } else if (clazz == FudgeFieldContainer.class) {
          if (value.getMessageValue() != null) {
            conversionContext.setResult(value.getMessageValue());
          } else {
            conversionContext.setFail();
          }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;setUp();	public void setUp() throws Exception {
		sentinels.add(sentinel1.toString());;    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());;    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;setUp();		sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
	};	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
    };	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
	sentinelJedis2 = new Jedis(sentinel2.getHost(), sentinel2.getPort());
    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;ensureSafeTwiceFailover();		forceFailover(pool);
		forceFailover(pool);;	forceFailover(pool);
	forceFailover(pool);;	forceFailover(pool);
	// after failover sentinel needs a bit of time to stabilize before a new failover
	Thread.sleep(100);
	forceFailover(pool);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;forceFailover(JedisSentinelPool);		// jedis connection should be master
		Jedis jedis = pool.getResource();
		assertEquals("PONG", jedis.ping());;	// jedis connection should be master
	Jedis jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());;	// jedis connection should be master
	Jedis beforeFailoverJedis = pool.getResource();
	assertEquals("PONG", beforeFailoverJedis.ping());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;waitForFailover(JedisSentinelPool,HostAndPort);			throws InterruptedException {
		HostAndPort newMaster = JedisSentinelTestUtil
				.waitForNewPromotedMaster(sentinelJedis1);;	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(sentinelJedis1);;	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(MASTER_NAME, sentinelJedis1, sentinelJedis2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest;waitForJedisSentinelPoolRecognizeNewMaster(JedisSentinelPool,HostAndPort);		while (true) {
			String host = pool.getCurrentHostMaster().getHost();
			int port = pool.getCurrentHostMaster().getPort();;	while (true) {
	    String host = pool.getCurrentHostMaster().getHost();
	    int port = pool.getCurrentHostMaster().getPort();;	while (true) {
	    HostAndPort currentHostMaster = pool.getCurrentHostMaster();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/main/java/redis/clients/jedis/JedisSentinelPool;JedisSentinelPool(String,Set<String>,GenericObjectPoolConfig,int,String,int);			final GenericObjectPoolConfig poolConfig, int timeout,
			final String password, final int database) {
		this.poolConfig = poolConfig;
		this.timeout = timeout;
		this.password = password;
		this.database = database;;	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {
	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;;	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {

	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/main/java/redis/clients/jedis/JedisSentinelPool;initPool(HostAndPort);		if (!master.equals(currentHostMaster)) {
			currentHostMaster = master;
			log.info("Created JedisPool to master at " + master);
			initPool(poolConfig,
					new JedisFactory(master.getHost(), master.getPort(),
							timeout, password, database));
		};	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    log.info("Created JedisPool to master at " + master);
	    initPool(poolConfig,
		    new JedisFactory(master.getHost(), master.getPort(),
			    timeout, password, database));;	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    if (factory == null) {
	        factory = new JedisFactory(master.getHost(), master.getPort(),
	                                   timeout, password, database);
	        initPool(poolConfig, factory);
	    } else {
	        factory.setHostAndPort(currentHostMaster);
	        // although we clear the pool, we still have to check the returned object
	        // in getResource, this call only clears idle instances, not borrowed instances
	        internalPool.clear();
	    }

	    log.info("Created JedisPool to master at " + master);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_ab2f4_53c93/rev_ab2f4-53c93;/src/main/java/redis/clients/jedis/JedisSentinelPool;initSentinels(Set<String>,String);		for (String sentinel : sentinels) {
			final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel
					.split(":")));
			MasterListener masterListener = new MasterListener(masterName,
					hap.getHost(), hap.getPort());
			masterListeners.add(masterListener);
			masterListener.start();;		try {
		    Jedis jedis = new Jedis(hap.getHost(), hap.getPort());

		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			jedis.disconnect();
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");;		Jedis jedis = null;
		try {
		    jedis = new Jedis(hap.getHost(), hap.getPort());

		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");
		} finally {
		    if (jedis != null) {
	        jedis.close();
		    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b0a22_9be93/rev_b0a22-9be93;/tests/unit/com/opengamma/math/interpolation/Extrapolator1DWithSensitivityTest;testSensitivities();      final double t = RANDOM.nextDouble() * (max - min) - min;
      // double t = 0.25;
      final double[] sensitivity_FD = EXTRAPOLATOR_FD.interpolate(MODEL, t).getSensitivities();
      final double[] sensitivity = EXTRAPOLATOR_SENSE.interpolate(MODEL, t).getSensitivities();;      final double t = RANDOM.nextDouble() * (max - min) - min;
      // double t = 0.25;
      double[] sensitivity_FD = EXTRAPOLATOR_FD.interpolate(MODEL, t).getSensitivities();
      double[] sensitivity = EXTRAPOLATOR_SENSE.interpolate(MODEL, t).getSensitivities();;      final double t = RANDOM.nextDouble() * (max - min) + min;

      double[] sensitivity_FD = EXTRAPOLATOR_FD.interpolate(MODEL, t).getSensitivities();
      double[] sensitivity = EXTRAPOLATOR_SENSE.interpolate(MODEL, t).getSensitivities();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_b0b55_c1cec/rev_b0b55-c1cec;/subprojects/gradle-core/src/main/groovy/org/gradle/logging/internal/DefaultColorMap;DefaultColorMap();//        addDefault(Header, DEFAULT);
        addDefault(Info, YELLOW);
        addDefault(Description, YELLOW);
        addDefault(ProgressStatus, YELLOW);
        addDefault(Identifier, GREEN);
        addDefault(UserInput, GREEN);
        addDefault(Failure, RED);
//        addDefault(Error, RED);
        defaults.put(STATUSBAR, BOLD);;        defaults.put(Header, DEFAULT);
        defaults.put(Info, YELLOW);
        defaults.put(Description, YELLOW);
//        defaults.put(ProgressStatus, YELLOW);
        defaults.put(Identifier, GREEN);
        defaults.put(UserInput, GREEN);
//        defaults.put(Error, RED);;        defaults.put(Header, DEFAULT);
        defaults.put(Info, YELLOW);
        defaults.put(Description, YELLOW);
        defaults.put(ProgressStatus, YELLOW);
        defaults.put(Identifier, GREEN);
        defaults.put(UserInput, GREEN);
        defaults.put(Error, RED);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_b01a8_23e60/rev_b01a8-23e60;/src/java/voldemort/client/rebalance/MigratePartitions;migrate();            // Move all nodes in grandfathered state back to normal
            if(donorStates != null && transitionToNormal) {
                changeToNormal();;            if(!(executor.isShutdown() || executor.isTerminated())) {
                try {
                    latch.await();
                } catch(InterruptedException e)  {
                    logger.error(e, e);
                    throw new VoldemortException(e);
                } finally {
                    // Move all nodes in grandfathered state back to normal
                    if(donorStates != null && transitionToNormal) {
                        changeToNormal();
                    }
                    executor.shutdown();
                };            // Move all nodes in grandfathered state back to normal
            if(donorStates != null && transitionToNormal) {
                changeToNormal();
            }
            if(!(executor.isShutdown() || executor.isTerminated())) {
                try {
                    latch.await();
                } catch(InterruptedException e)  {
                    logger.error(e, e);
                } finally {

                    executor.shutdown();
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b1d61_e7e29/rev_b1d61-e7e29;/src/com/opengamma/engine/analytics/yc/DiscountCurveAnalyticFunction;constructDiscountCurveValueDefinition(Currency);    Map<String, Object> map = new HashMap<String, Object>();
    if(currency != null) {
      map.put("Currency", currency);
    }
    map.put("TYPE", "DISCOUNT_CURVE");
    return new AnalyticValueDefinitionImpl<DiscountCurve>(map);;    Map<String, Object> map = new HashMap<String, Object>();
    map.put("Currency", currency);
    map.put("TYPE", "DISCOUNT_CURVE");
    return new AnalyticValueDefinitionImpl<DiscountCurve>(map);;    return new DiscountCurveValueDefinition(currency);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_b1fcd_fc851/rev_b1fcd-fc851;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;cutTill(OLogSequenceNumber);public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size() - 1; i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = logSegments.remove(0);
        logSegment.delete(false);
      }
    }
  };public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size(); i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = logSegments.remove(0);
        logSegment.delete(false);
      }
    }
  };void cutTill(OLogSequenceNumber lsn) throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b2c7c_c8150/rev_b2c7c-c8150;/src/com/opengamma/math/minimization/ConjugateGradientVectorMinimizer;ConjugateGradientVectorMinimizer(ScalarMinimizer,double,int);public ConjugateGradientVectorMinimizer(final ScalarMinimizer minimizer, final double tolerance, final int maxInterations) {
    ArgumentChecker.notNull(minimizer, "minimizer");
    if (tolerance < SMALL || tolerance > 1.0) {
      throw new IllegalArgumentException("Tolerance must be greater than " + SMALL + " and less than 1.0");
    }
    if (maxInterations < 1) {
      throw new IllegalArgumentException("Need at lest one interation");
    }
    _lineSearch = new LineSearch(minimizer);
    _eps = tolerance;
    _maxInterations = maxInterations;;public ConjugateGradientVectorMinimizer(final ScalarMinimizer minimizer, double tolerance, int maxInterations) {
    ArgumentChecker.notNull(minimizer, "minimizer");
    if (tolerance < SMALL || tolerance > 1.0) {
      throw new IllegalArgumentException("Tolerance must be greater than " + SMALL + " and less than 1.0");
    }
    if (maxInterations < 1) {
      throw new IllegalArgumentException("Need at lest one interation");
    }
    _lineSearch = new LineSearch(minimizer);
    _eps = tolerance;
    _maxInterations = maxInterations;;public ConjugateGradientVectorMinimizer(final ScalarMinimizer minimizer, double tolerance, int maxInterations) {
    this(minimizer, tolerance, tolerance, maxInterations);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b2c7c_c8150/rev_b2c7c-c8150;/src/com/opengamma/math/minimization/ConjugateGradientVectorMinimizer;minimize(Function1D<DoubleMatrix1D,Double>,Function1D<DoubleMatrix1D,DoubleMatrix1D>,DoubleMatrix1D);    final String s = "ConjugateGradient Failed to converge after " + _maxInterations + " interations, with a tolerance of " + _eps + " Final position reached was " + x.toString();;    String s = "ConjugateGradient Failed to converge after " + _maxInterations + " interations, with a tolerance of "
        + _eps + " Final position reached was " + x.toString();;    String s = "ConjugateGradient Failed to converge after " + _maxInterations + " interations, with a tolerance of "
        + _relTol + " Final position reached was " + x.toString();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_b3b8a_847c7/rev_b3b8a-847c7;/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer;visitQualifiedExpression(JetQualifiedExpression,TypeInferenceContext);                            autocastResolutionTrace.record(BindingContext.AUTOCAST, receiverExpression, possibleType);
                            autocastResolutionTrace.addAllMyDataTo(context.trace);
                            somethingFound = true;;                            regionToCommit = errorHandler.closeAndReturnCurrentRegion();
                            context.trace.recordAutoCast(receiverExpression, possibleType);;                            regionToCommit = errorHandler.closeAndReturnCurrentRegion();
                            context.trace.recordAutoCast(receiverExpression, possibleType, variableDescriptor);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b4d26_25f5a/rev_b4d26-25f5a;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;SSTableMetadata();             Long.MAX_VALUE,
             Double.MIN_VALUE,;             Long.MIN_VALUE,
             Double.MIN_VALUE,;             Long.MAX_VALUE,
             Long.MIN_VALUE,
             NO_COMPRESSION_RATIO,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b10d5_73f71/rev_b10d5-73f71;/src/java/org/apache/cassandra/locator/TokenMetadata;pendingRangeChanges(InetAddress);        Range sourceRange = getPrimaryRangeFor(getToken(source));
        synchronized (bootstrapTokens)
        {
            for (Token token : bootstrapTokens.keySet())
                if (sourceRange.contains(token))
                    n++;
        };        Range sourceRange = getPrimaryRangeFor(getToken(source));
        for (Token token : bootstrapTokens.keySet())
            if (sourceRange.contains(token))
                n++;;        Range<Token> sourceRange = getPrimaryRangeFor(getToken(source));
        for (Token token : bootstrapTokens.keySet())
            if (sourceRange.contains(token))
                n++;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b10d5_73f71/rev_b10d5-73f71;/src/java/org/apache/cassandra/service/StorageService;calculatePendingRanges(AbstractReplicationStrategy,String);                allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
                for (Range range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                    pendingRanges.put(range, endpoint);
                allLeftMetadata.removeEndpoint(endpoint);
            };            allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
            for (Range range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);;            allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
            for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                pendingRanges.put(range, endpoint);
            allLeftMetadata.removeEndpoint(endpoint);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b11c7_c4571/rev_b11c7-c4571;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/FixedIncomeStripIdentifierAndMaturityBuilder;getFRA(InterpolatedYieldCurveSpecification,FixedIncomeStripWithIdentifier,Map<Identifier,Double>);private FRASecurity getFRA(InterpolatedYieldCurveSpecification spec, FixedIncomeStripWithIdentifier strip, Map<Identifier, Double> marketValues) {
    LocalDate curveDate = spec.getCurveDate(); // quick hack
    LocalDate startDate = curveDate.plus(strip.getMaturity().getPeriod()).minus(Period.ofMonths(3));
    LocalDate endDate = startDate.plusMonths(3); // quick hack, needs to be sorted.
//    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    //REVIEW: yomi 16-jun-2011 How do we get the correct underlying?
    Identifier underlyingIdentifier = getFRAUnderlyingIdentifier(spec.getCurrency(), spec.getRegion());
    return new FRASecurity(spec.getCurrency(), spec.getRegion(), 
        startDate.atTime(11, 00).atZone(TimeZone.UTC), endDate.atTime(11, 00).atZone(TimeZone.UTC), marketValues.get(strip.getSecurity()), 1.0d, underlyingIdentifier);;private FRASecurity getFRA(InterpolatedYieldCurveSpecification spec, FixedIncomeStripWithIdentifier strip, Map<Identifier, Double> marketValues) {
    LocalDate curveDate = spec.getCurveDate(); // quick hack
    LocalDate startDate = curveDate.plus(strip.getMaturity().getPeriod()).minus(Period.ofMonths(3));
    LocalDate endDate = startDate.plusMonths(3); // quick hack, needs to be sorted.
//    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
//                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    return new FRASecurity(spec.getCurrency(), spec.getRegion(), 
        startDate.atTime(11, 00).atZone(TimeZone.UTC), endDate.atTime(11, 00).atZone(TimeZone.UTC), marketValues.get(strip.getSecurity()), 1.0d);;private FRASecurity getFRA(final InterpolatedYieldCurveSpecification spec, final FixedIncomeStripWithIdentifier strip, final Map<Identifier, Double> marketValues) {
    final LocalDate curveDate = spec.getCurveDate(); // quick hack
    final LocalDate startDate = curveDate.plus(strip.getMaturity().getPeriod()).minus(Period.ofMonths(3));
    final LocalDate endDate = startDate.plusMonths(3); // quick hack, needs to be sorted.
    //    return new FRASecurity(spec.getCurrency(), RegionUtils.countryRegionId("US"), 
    //                           new DateTimeWithZone(startDate.atTime(11, 00)), new DateTimeWithZone(endDate.atTime(11, 00)));
    return new FRASecurity(spec.getCurrency(), spec.getRegion(), startDate.atTime(11, 00).atZone(TimeZone.UTC), endDate.atTime(11, 00).atZone(TimeZone.UTC), marketValues.get(strip.getSecurity()),
        1.0d);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_b20e9_943cf/rev_b20e9-943cf;/src/java/voldemort/store/routed/RoutedStore;call();                fillRepairReadsValues(nodeValues, key, node, fetched);
                node.getStatus().setAvailable();;                if(repairReads) {
                    for(Versioned<byte[]> f: fetched)
                        nodeValues.add(new NodeValue<ByteArray, byte[]>(node.getId(), key, f));
                }
                node.getStatus().setAvailable();;                if(repairReads) {
                    for(Versioned<byte[]> f: fetched)
                        nodeValues.add(new NodeValue<ByteArray, byte[]>(node.getId(), key, f));
                }
                failureDetector.recordSuccess(node);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b28cb_695c5/rev_b28cb-695c5;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/cube/fitting/SABRNonLinearLeastSquaresSwaptionCubeFittingFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        final Pair<Tenor, Tenor> tenorPair = Pair.of(swapMaturityEntry.getKey(), swaptionExpiryEntry.getKey());
        if (volatilityCubeData.getStrikes() != null && volatilityCubeData.getStrikes().containsKey(tenorPair)) {
          final double forward = volatilityCubeData.getStrikes().get(tenorPair);;        final Pair<Tenor, Tenor> tenorPair = Pair.of(swapMaturityEntry.getKey(), swaptionExpiryEntry.getKey()); 
        if (volatilityCubeData.getStrikes() != null && volatilityCubeData.getStrikes().containsKey(tenorPair)) {
          final double forward = volatilityCubeData.getStrikes().get(tenorPair);;        final Pair<Tenor, Tenor> tenorPair = Pair.of(swapMaturityEntry.getKey(), swaptionExpiryEntry.getKey()); 
        if (volatilityCubeData.getATMStrikes() != null && volatilityCubeData.getATMStrikes().containsKey(tenorPair)) {
          final double forward = volatilityCubeData.getATMStrikes().get(tenorPair);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b43cc_1693e/rev_b43cc-1693e;/src/java/org/apache/cassandra/tools/NodeCmd;printUsage();        StringBuilder header = new StringBuilder();
        header.append("\nAvailable commands:\n");
        // No args
        addCmdHelp(header, "ring", "Print information about the token ring");
        addCmdHelp(header, "join", "Join the ring");
        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
        addCmdHelp(header, "cfstats", "Print statistics on column families");
        addCmdHelp(header, "version", "Print cassandra version");
        addCmdHelp(header, "tpstats", "Print usage statistics of thread pools");
        addCmdHelp(header, "proxyhistograms", "Print statistic histograms for network operations");
        addCmdHelp(header, "drain", "Drain the node (stop accepting writes and flush all column families)");
        addCmdHelp(header, "decommission", "Decommission the *node I am connecting to*");
        addCmdHelp(header, "compactionstats", "Print statistics on compactions");
        addCmdHelp(header, "disablegossip", "Disable gossip (effectively marking the node dead)");
        addCmdHelp(header, "enablegossip", "Reenable gossip");
        addCmdHelp(header, "disablethrift", "Disable thrift server");
        addCmdHelp(header, "enablethrift", "Reenable thrift server");
        addCmdHelp(header, "statusthrift", "Status of thrift server");
        addCmdHelp(header, "gossipinfo", "Shows the gossip information for the cluster");
        addCmdHelp(header, "invalidatekeycache", "Invalidate the key cache");
        addCmdHelp(header, "invalidaterowcache", "Invalidate the row cache");
        addCmdHelp(header, "resetlocalschema", "Reset node's local schema and resync");

        // One arg
        addCmdHelp(header, "netstats [host]", "Print network information on provided host (connecting node by default)");
        addCmdHelp(header, "move <new token>", "Move node on the token ring to a new token");
        addCmdHelp(header, "removetoken status|force|<token>", "Show status of current token removal, force completion of pending removal or remove providen token");
        addCmdHelp(header, "setcompactionthroughput <value_in_mb>", "Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling.");
        addCmdHelp(header, "setstreamthroughput <value_in_mb>", "Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling.");
        addCmdHelp(header, "describering [keyspace]", "Shows the token ranges info of a given keyspace.");
        addCmdHelp(header, "rangekeysample", "Shows the sampled keys held across all keyspaces.");
        addCmdHelp(header, "rebuild [src-dc-name]", "Rebuild data by streaming from other nodes (similarly to bootstrap)");

        // Two args
        addCmdHelp(header, "snapshot [keyspaces...] -cf [columnfamilyName] -t [snapshotName]", "Take a snapshot of the optionally specified column family of the specified keyspaces using optional name snapshotName");
        addCmdHelp(header, "clearsnapshot [keyspaces...] -t [snapshotName]", "Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name.");
        addCmdHelp(header, "flush [keyspace] [cfnames]", "Flush one or more column family");
        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -pr to repair only the first range returned by the partitioner)");
        addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
        addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
        addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");

        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
        addCmdHelp(header, "getcompactionthreshold <keyspace> <cfname>", "Print min and max compaction thresholds for a given column family");
        addCmdHelp(header, "cfhistograms <keyspace> <cfname>", "Print statistic histograms for a given column family");
        addCmdHelp(header, "refresh <keyspace> <cf-name>", "Load newly placed SSTables to the system without restart.");
        addCmdHelp(header, "rebuild_index <keyspace> <cf-name> <idx1,idx1>", "a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1");
        addCmdHelp(header, "setcachecapacity <key-cache-capacity> <row-cache-capacity>", "Set global key and row cache capacities (in MB units).");

        // Three args
        addCmdHelp(header, "getendpoints <keyspace> <cf> <key>", "Print the end points that owns the key");
        addCmdHelp(header, "getsstables <keyspace> <cf> <key>", "Print the sstable filenames that own the key");

        // Four args
        addCmdHelp(header, "setcompactionthreshold <keyspace> <cfname> <minthreshold> <maxthreshold>", "Set the min and max compaction thresholds for a given column family");
        addCmdHelp(header, "stop <compaction_type>", "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD");;        StringBuilder header = new StringBuilder();
        header.append("\nAvailable commands:\n");
        // No args
        addCmdHelp(header, "ring", "Print information about the token ring");
        addCmdHelp(header, "join", "Join the ring");
        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
        addCmdHelp(header, "cfstats", "Print statistics on column families");
        addCmdHelp(header, "version", "Print cassandra version");
        addCmdHelp(header, "tpstats", "Print usage statistics of thread pools");
        addCmdHelp(header, "drain", "Drain the node (stop accepting writes and flush all column families)");
        addCmdHelp(header, "decommission", "Decommission the *node I am connecting to*");
        addCmdHelp(header, "compactionstats", "Print statistics on compactions");
        addCmdHelp(header, "disablegossip", "Disable gossip (effectively marking the node dead)");
        addCmdHelp(header, "enablegossip", "Reenable gossip");
        addCmdHelp(header, "disablethrift", "Disable thrift server");
        addCmdHelp(header, "enablethrift", "Reenable thrift server");
        addCmdHelp(header, "statusthrift", "Status of thrift server");
        addCmdHelp(header, "gossipinfo", "Shows the gossip information for the cluster");
        addCmdHelp(header, "invalidatekeycache", "Invalidate the key cache");
        addCmdHelp(header, "invalidaterowcache", "Invalidate the row cache");
        addCmdHelp(header, "resetlocalschema", "Reset node's local schema and resync");

        // One arg
        addCmdHelp(header, "netstats [host]", "Print network information on provided host (connecting node by default)");
        addCmdHelp(header, "move <new token>", "Move node on the token ring to a new token");
        addCmdHelp(header, "removetoken status|force|<token>", "Show status of current token removal, force completion of pending removal or remove providen token");
        addCmdHelp(header, "setcompactionthroughput <value_in_mb>", "Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling.");
        addCmdHelp(header, "setstreamthroughput <value_in_mb>", "Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling.");
        addCmdHelp(header, "describering [keyspace]", "Shows the token ranges info of a given keyspace.");
        addCmdHelp(header, "rangekeysample", "Shows the sampled keys held across all keyspaces.");
        addCmdHelp(header, "rebuild [src-dc-name]", "Rebuild data by streaming from other nodes (similarly to bootstrap)");

        // Two args
        addCmdHelp(header, "snapshot [keyspaces...] -cf [columnfamilyName] -t [snapshotName]", "Take a snapshot of the optionally specified column family of the specified keyspaces using optional name snapshotName");
        addCmdHelp(header, "clearsnapshot [keyspaces...] -t [snapshotName]", "Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name.");
        addCmdHelp(header, "flush [keyspace] [cfnames]", "Flush one or more column family");
        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -pr to repair only the first range returned by the partitioner)");
        addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
        addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
        addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");

        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
        addCmdHelp(header, "getcompactionthreshold <keyspace> <cfname>", "Print min and max compaction thresholds for a given column family");
        addCmdHelp(header, "cfhistograms <keyspace> <cfname>", "Print statistic histograms for a given column family");
        addCmdHelp(header, "refresh <keyspace> <cf-name>", "Load newly placed SSTables to the system without restart.");
        addCmdHelp(header, "rebuild_index <keyspace> <cf-name> <idx1,idx1>", "a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1");
        addCmdHelp(header, "setcachecapacity <key-cache-capacity> <row-cache-capacity>", "Set global key and row cache capacities (in MB units).");

        // Three args
        addCmdHelp(header, "getendpoints <keyspace> <cf> <key>", "Print the end points that owns the key");
        addCmdHelp(header, "getsstables <keyspace> <cf> <key>", "Print the sstable filenames that own the key");

        // Four args
        addCmdHelp(header, "setcompactionthreshold <keyspace> <cfname> <minthreshold> <maxthreshold>", "Set the min and max compaction thresholds for a given column family");
        addCmdHelp(header, "stop <compaction_type>", "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD");;        StringBuilder header = new StringBuilder(512);
        header.append("\nAvailable commands\n");
        final NodeToolHelp ntHelp = loadHelp();
        for(NodeToolHelp.NodeToolCommand cmd : ntHelp.commands)
            addCmdHelp(header, cmd);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b48a1_00628/rev_b48a1-00628;/src/java/org/apache/cassandra/transport/Server;run();        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.keepAlive", DatabaseDescriptor.getRpcKeepAlive());;        bootstrap.setOption("child.tcpNoDelay", true);;        ServerBootstrap bootstrap = new ServerBootstrap()
                                    .group(workerGroup)
                                    .channel(NioServerSocketChannel.class)
                                    .childOption(ChannelOption.TCP_NODELAY, true)
                                    .childOption(ChannelOption.ALLOCATOR, CBUtil.allocator)
                                    .childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 32 * 1024)
                                    .childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 8 * 1024);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b55ab_9a842/rev_b55ab-9a842;/src/java/org/apache/cassandra/locator/NetworkTopologyStrategy;calculateNaturalEndpoints(Token,TokenMetadata);            // collect endpoints in this DC
            TokenMetadata dcTokens = new TokenMetadata();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet());            // collect endpoints in this DC
            TokenMetadata dcTokens = new TokenMetadata();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet());            // collect endpoints in this DC; add in bulk to token meta data for computational complexity
            // reasons (CASSANDRA-3831).
            Set<Pair<Token, InetAddress>> dcTokensToUpdate = new HashSet<Pair<Token, InetAddress>>();
            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b70bb_daa2e/rev_b70bb-daa2e;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;MarketInstrumentImpliedYieldCurveFunction(String,String,String);public MarketInstrumentImpliedYieldCurveFunction(final String currency, final String fundingCurveDefinitionName, final String forwardCurveDefinitionName) {
    this(Currency.of(currency), fundingCurveDefinitionName, forwardCurveDefinitionName);;public MarketInstrumentImpliedYieldCurveFunction(final String currency, final String fundingCurveDefinitionName, final String forwardCurveDefinitionName) {
    this(CurrencyUnit.of(currency), fundingCurveDefinitionName, forwardCurveDefinitionName);;public MarketInstrumentImpliedYieldCurveFunction(final String currency, final String fundingCurveDefinitionName,
      final String forwardCurveDefinitionName) {
    this(CurrencyUnit.of(currency), fundingCurveDefinitionName, forwardCurveDefinitionName);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b74b5_4dcc9/rev_b74b5-4dcc9;/tests/unit/com/opengamma/engine/view/calcnode/RemoteNodeJobInvokerTest;simpleInvocation();    final Ready initialMessage = new Ready(1);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(FudgeContext.GLOBAL_DEFAULT);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap(), new FunctionCost ());;    final RemoteCalcNodeReadyMessage initialMessage = new RemoteCalcNodeReadyMessage(1);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(FudgeContext.GLOBAL_DEFAULT);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap());;    final RemoteCalcNodeReadyMessage initialMessage = new RemoteCalcNodeReadyMessage(1);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(s_fudgeContext);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b74b5_4dcc9/rev_b74b5-4dcc9;/tests/unit/com/opengamma/engine/view/calcnode/RemoteNodeJobInvokerTest;saturate();    final Ready initialMessage = new Ready(3);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(FudgeContext.GLOBAL_DEFAULT);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap(), new FunctionCost ());;    final RemoteCalcNodeReadyMessage initialMessage = new RemoteCalcNodeReadyMessage(3);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(FudgeContext.GLOBAL_DEFAULT);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap());;    final RemoteCalcNodeReadyMessage initialMessage = new RemoteCalcNodeReadyMessage(3);
    final DirectFudgeConnection conduit = new DirectFudgeConnection(s_fudgeContext);
    final RemoteNodeJobInvoker jobInvoker = new RemoteNodeJobInvoker(Executors.newCachedThreadPool(), initialMessage, conduit.getEnd1(), new InMemoryIdentifierMap());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b81a4_9dca4/rev_b81a4-9dca4;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/volatility/surface/InterpolatedVolatilitySurfaceFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);      for (int j = 0; j < m; j++) {
        final Double vol = volatilityData.getVolatility(xData[i], yData[j]);
        if (vol != null && !CompareUtils.closeEquals(vol, 0)) {
          //System.out.print("\n" + xData[i] + "," + yData[i] + "," + vol);
          x.add(xData[i]);
          y.add(yData[j]);
          sigma.add(vol);
        };      for (int j = 0; j < m; j++) {
        final Double vol = volatilityData.getVolatility(xData[i], yData[j]);
        if (vol != null && !CompareUtils.closeEquals(vol, 0)) {
          x.add(xData[i]);
          y.add(yData[j]);
          sigma.add(vol);
        };      final Double vol = volatilityData.getVolatility(xData[i], yData[i]);
      if (vol != null && !CompareUtils.closeEquals(vol, 0)) {
        x.add(xData[i]);
        y.add(yData[i]);
        sigma.add(vol);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_b223e_66168/rev_b223e-66168;/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity;onClick(View);        } catch (NumberFormatException ignored) {;        } catch (NumberFormatException e) {;        } catch (NumberFormatException e) {
	        Log.d(TAG, "Age for a person invalid");
	        return;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_b255d_207b9/rev_b255d-207b9;/src/java/voldemort/server/protocol/admin/FetchPartitionFileStreamRequestHandler;FetchPartitionFileStreamRequestHandler(VAdminProto.FetchPartitionFilesRequest,MetadataStore,VoldemortConfig,StoreRepository,StreamStats);        this.replicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());;        HashMap<Integer, List<Integer>> localReplicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());;        ReadOnlyStorageEngine storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                                  storeRepository,
                                                                                                  request.getStore());

        HashMap<Integer, List<Integer>> localReplicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_b255d_207b9/rev_b255d-207b9;/src/java/voldemort/server/protocol/admin/FetchPartitionFileStreamRequestHandler;FetchPartitionFileStreamRequestHandler(VAdminProto.FetchPartitionFilesRequest,MetadataStore,VoldemortConfig,StoreRepository,StreamStats);        this.storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                 storeRepository,
                                                                                 request.getStore());;        // Filter the replica to partition mapping so as to include only till
        // the number of replicas
        this.replicaToPartitionList = Maps.newHashMap();
        for(int replicaType = 0; replicaType < storeDef.getReplicationFactor(); replicaType++) {
            if(localReplicaToPartitionList.containsKey(replicaType)) {
                this.replicaToPartitionList.put(replicaType,
                                                localReplicaToPartitionList.get(replicaType));
            }
        }
        this.storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                 storeRepository,
                                                                                 request.getStore());;        // Filter the replica to partition mapping so as to include only till
        // the number of replicas
        this.replicaToPartitionList = Lists.newArrayList();
        for(int replicaType = 0; replicaType < storeDef.getReplicationFactor(); replicaType++) {
            if(localReplicaToPartitionList.containsKey(replicaType)) {
                List<Integer> partitionList = localReplicaToPartitionList.get(replicaType);
                for(Iterator<Integer> it = partitionList.iterator(); it.hasNext();) {
                    this.replicaToPartitionList.add(new Pair<Integer, Integer>(replicaType,
                                                                               it.next()));
                }
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_b765b_616c8/rev_b765b-616c8;/core/src/main/java/com/orientechnologies/orient/core/index/OIndexAbstract;delete();        removeValuesContainer();;        if (valueContainerAlgorithm.equals(ODefaultIndexFactory.SBTREEBONSAI_VALUE_CONTAINER)) {
          final OStorage storage = getDatabase().getStorage();
          if (storage instanceof OStorageLocal) {
            final ODiskCache diskCache = ((OStorageLocal) storage).getDiskCache();
            try {
              final String fileName = getName() + OIndexRIDContainer.INDEX_FILE_EXTENSION;
              if (diskCache.exists(fileName)) {
                final long fileId = diskCache.openFile(fileName);
                diskCache.deleteFile(fileId);
              }
            } catch (IOException e) {
              OLogManager.instance().error(this, "Can't delete file for value containers", e);
            }
          }
        };        if (valueContainerAlgorithm.equals(ODefaultIndexFactory.SBTREEBONSAI_VALUE_CONTAINER)) {
          final OStorage storage = getDatabase().getStorage();
          if (storage instanceof OLocalPaginatedStorage) {
            final ODiskCache diskCache = ((OLocalPaginatedStorage) storage).getDiskCache();
            try {
              final String fileName = getName() + OIndexRIDContainer.INDEX_FILE_EXTENSION;
              if (diskCache.exists(fileName)) {
                final long fileId = diskCache.openFile(fileName);
                diskCache.deleteFile(fileId);
              }
            } catch (IOException e) {
              OLogManager.instance().error(this, "Can't delete file for value containers", e);
            }
          }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_b803b_9ea76/rev_b803b-9ea76;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/MarketInstrumentImpliedYieldCurveFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);        Map<Identifier, Double> marketDataMap = _fundingHelper.buildMarketDataMap(inputs).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, _fundingCurveDefinitionName).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now, localNow);;        Map<Identifier, Double> marketDataMap = buildMarketDataMap(inputs, _fundingCurveDefinitionName).getDataPoints();
        return getSingleCurveResult(marketDataMap, builder, swapConverter, tenorSwapConverter, instrumentAdapter, futureAdapter, now);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_b1427_83a43/rev_b1427-83a43;/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator;readIndexedColumns(CFMetaData,FileDataInput,SortedSet<ByteBuffer>,List<IndexHelper.IndexInfo>,long,List<OnDiskAtom>);                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
                ByteBuffer columnName = column.name();;                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);;                OnDiskAtom column = atomIterator.next();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ba274_22bf2/rev_ba274-22bf2;/src/java/org/apache/cassandra/tools/NodeCmd;main(String[]);            //print history here after we've already determined we can reasonably call cassandra
            printHistory(args, cmd);
            NodeCommand command = null;;            NodeCommand command = null;;            String username = cmd.getOptionValue(USERNAME_OPT.left);
            String password = cmd.getOptionValue(PASSWORD_OPT.left);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bafa3_9ca13/rev_bafa3-9ca13;/src/java/org/apache/cassandra/db/compaction/CompactionManager;performCleanup(ColumnFamilyStore,NodeId.OneShotRenewer);                doCleanupCompaction(store, sstables, renewer);;                compactionLock.writeLock().lock();
                try 
                {
                    if (!cfStore.isValid())
                        return this;
                    Collection<SSTableReader> tocleanup = cfStore.getDataTracker().markCompacting(cfStore.getSSTables(), 1, Integer.MAX_VALUE);
                    if (tocleanup == null || tocleanup.isEmpty())
                        return this;
                    try
                    {
                        // downgrade the lock acquisition
                        compactionLock.readLock().lock();
                        compactionLock.writeLock().unlock();
                        try
                        {
                            doCleanupCompaction(cfStore, tocleanup, renewer);
                        }
                        finally
                        {
                            compactionLock.readLock().unlock();
                        }
                    }
                    finally
                    {
                        cfStore.getDataTracker().unmarkCompacting(tocleanup);
                    }
                    return this;
                }
                finally 
                {
                    // we probably already downgraded
                    if (compactionLock.writeLock().isHeldByCurrentThread())
                        compactionLock.writeLock().unlock();
                };                compactionLock.writeLock().lock();
                try 
                {
                    Collection<SSTableReader> tocleanup = cfStore.getDataTracker().markCompacting(cfStore.getSSTables(), 1, Integer.MAX_VALUE);
                    if (tocleanup == null || tocleanup.isEmpty())
                        return this;
                    try
                    {
                        // downgrade the lock acquisition
                        compactionLock.readLock().lock();
                        compactionLock.writeLock().unlock();
                        try
                        {
                            doCleanupCompaction(cfStore, tocleanup, renewer);
                        }
                        finally
                        {
                            compactionLock.readLock().unlock();
                        }
                    }
                    finally
                    {
                        cfStore.getDataTracker().unmarkCompacting(tocleanup);
                    }
                    return this;
                }
                finally 
                {
                    // we probably already downgraded
                    if (compactionLock.writeLock().isHeldByCurrentThread())
                        compactionLock.writeLock().unlock();
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bafa3_9ca13/rev_bafa3-9ca13;/src/java/org/apache/cassandra/db/compaction/CompactionManager;performScrub(ColumnFamilyStore);                doScrub(store, sstables);;                // acquire the write lock to schedule all sstables
                compactionLock.writeLock().lock();
                try
                {
                    if (!cfStore.isValid())
                        return this;

                    Collection<SSTableReader> toscrub = cfStore.getDataTracker().markCompacting(cfStore.getSSTables(), 1, Integer.MAX_VALUE);
                    if (toscrub == null || toscrub.isEmpty())
                        return this;
                    try
                    {
                        // downgrade the lock acquisition
                        compactionLock.readLock().lock();
                        compactionLock.writeLock().unlock();
                        try
                        {
                            doScrub(cfStore, toscrub);
                        }
                        finally
                        {
                            compactionLock.readLock().unlock();
                        }
                    }
                    finally
                    {
                        cfStore.getDataTracker().unmarkCompacting(toscrub);
                    }
                    return this;
                }
                finally
                {
                    // we probably already downgraded
                    if (compactionLock.writeLock().isHeldByCurrentThread())
                        compactionLock.writeLock().unlock();
                };                // acquire the write lock to schedule all sstables
                compactionLock.writeLock().lock();
                try
                {
                    Collection<SSTableReader> toscrub = cfStore.getDataTracker().markCompacting(cfStore.getSSTables(), 1, Integer.MAX_VALUE);
                    if (toscrub == null || toscrub.isEmpty())
                        return this;
                    try
                    {
                        // downgrade the lock acquisition
                        compactionLock.readLock().lock();
                        compactionLock.writeLock().unlock();
                        try
                        {
                            doScrub(cfStore, toscrub);
                        }
                        finally
                        {
                            compactionLock.readLock().unlock();
                        }
                    }
                    finally
                    {
                        cfStore.getDataTracker().unmarkCompacting(toscrub);
                    }
                    return this;
                }
                finally
                {
                    // we probably already downgraded
                    if (compactionLock.writeLock().isHeldByCurrentThread())
                        compactionLock.writeLock().unlock();
                }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bbcf9_751ba/rev_bbcf9-751ba;/projects/OG-Web/src/com/opengamma/web/json/ViewDefinitionJSONBuilder;toJSON(ViewDefinition);    JSONObject jsonObject = new JSONObject();
    try {
      jsonObject.put(String.valueOf(0), ViewDefinition.class.getName());
      jsonObject.put(NAME_FIELD, viewDefinition.getName());
      if (viewDefinition.getPortfolioOid() != null) {
        jsonObject.put(IDENTIFIER_FIELD, viewDefinition.getPortfolioOid().toString());
      }
      jsonObject.put(USER_FIELD, toJSONObject(viewDefinition.getMarketDataUser()));
      jsonObject.put(RESULT_MODEL_DEFINITION_FIELD, toJSONObject(viewDefinition.getResultModelDefinition()));
      Currency defaultCurrency = viewDefinition.getDefaultCurrency();
      if (defaultCurrency != null) {
        jsonObject.put(CURRENCY_FIELD, defaultCurrency.getCode());
      }
      if (viewDefinition.getMinDeltaCalculationPeriod() != null) {
        jsonObject.put(MIN_DELTA_CALC_PERIOD_FIELD, viewDefinition.getMinDeltaCalculationPeriod());
      }
      if (viewDefinition.getMaxDeltaCalculationPeriod() != null) {
        jsonObject.put(MAX_DELTA_CALC_PERIOD_FIELD, viewDefinition.getMaxDeltaCalculationPeriod());
      }
      if (viewDefinition.getMinFullCalculationPeriod() != null) {
        jsonObject.put(MIN_FULL_CALC_PERIOD_FIELD, viewDefinition.getMinFullCalculationPeriod());
      }
      if (viewDefinition.getMaxFullCalculationPeriod() != null) {
        jsonObject.put(MAX_FULL_CALC_PERIOD_FIELD, viewDefinition.getMaxFullCalculationPeriod());
      }
      Map<String, ViewCalculationConfiguration> calculationConfigurations = viewDefinition.getAllCalculationConfigurationsByName();
      List<JSONObject> calConfigJSONList = Lists.newArrayList();
      for (ViewCalculationConfiguration calcConfig : calculationConfigurations.values()) {
        JSONObject calcConfigJSON = new JSONObject();
        calcConfigJSON.put(NAME_FIELD, calcConfig.getName());
        List<JSONObject> portfolioRequirementsBySecurityType = Lists.newArrayList();
        for (Map.Entry<String, Set<Pair<String, ValueProperties>>> securityTypeRequirements : calcConfig.getPortfolioRequirementsBySecurityType().entrySet()) {
          JSONObject securityTypeRequirementJSON = new JSONObject();
          securityTypeRequirementJSON.put(SECURITY_TYPE_FIELD, securityTypeRequirements.getKey());
          List<JSONObject> portfolioRequirement = Lists.newArrayList();
          for (Pair<String, ValueProperties> requirement : securityTypeRequirements.getValue()) {
            JSONObject reqJSON = new JSONObject();
            reqJSON.put(PORTFOLIO_REQUIREMENT_REQUIRED_OUTPUT_FIELD, requirement.getFirst());
            reqJSON.put(PORTFOLIO_REQUIREMENT_CONSTRAINTS_FIELD, toJSONObject(requirement.getSecond()));
            portfolioRequirement.add(reqJSON);
          }
          if (!portfolioRequirement.isEmpty()) {
            securityTypeRequirementJSON.put(PORTFOLIO_REQUIREMENT_FIELD, portfolioRequirement);
          }
          portfolioRequirementsBySecurityType.add(securityTypeRequirementJSON);
        }
        if (!portfolioRequirementsBySecurityType.isEmpty()) {
          calcConfigJSON.put(PORTFOLIO_REQUIREMENTS_BY_SECURITY_TYPE_FIELD, portfolioRequirementsBySecurityType);
        }
        List<JSONObject> specificRequirementList = Lists.newArrayList();
        for (ValueRequirement specificRequirement : calcConfig.getSpecificRequirements()) {
          specificRequirementList.add(toJSONObject(specificRequirement));
        }
        if (!specificRequirementList.isEmpty()) {
          calcConfigJSON.put(SPECIFIC_REQUIREMENT_FIELD, specificRequirementList);
        }
        calcConfigJSON.put(DELTA_DEFINITION_FIELD, toJSONObject(calcConfig.getDeltaDefinition()));
        calcConfigJSON.put(DEFAULT_PROPERTIES_FIELD, toJSONObject(calcConfig.getDefaultProperties()));
        calcConfigJSON.put(RESOLUTION_RULE_TRANSFORM_FIELD, toJSONObject(calcConfig.getResolutionRuleTransform(), false));
        calConfigJSONList.add(calcConfigJSON);
      }
      if (!calConfigJSONList.isEmpty()) {
        jsonObject.put(CALCULATION_CONFIGURATION_FIELD, calConfigJSONList);
      }
      if (viewDefinition.getUniqueId() != null) {
        jsonObject.put(UNIQUE_ID_FIELD, viewDefinition.getUniqueId().toString());
      }

    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("unable to convert view definition to JSON", ex);
    }

    return jsonObject.toString();;    JSONObject jsonObject = new JSONObject();
    try {
      jsonObject.put(String.valueOf(0), ViewDefinition.class.getName());
      jsonObject.put(NAME_FIELD, viewDefinition.getName());
      if (viewDefinition.getPortfolioOid() != null) {
        jsonObject.put(IDENTIFIER_FIELD, viewDefinition.getPortfolioOid().toString());
      }
      jsonObject.put(USER_FIELD, toJSONObject(viewDefinition.getMarketDataUser()));
      jsonObject.put(RESULT_MODEL_DEFINITION_FIELD, toJSONObject(viewDefinition.getResultModelDefinition()));
      Currency defaultCurrency = viewDefinition.getDefaultCurrency();
      if (defaultCurrency != null) {
        jsonObject.put(CURRENCY_FIELD, defaultCurrency.getCode());
      }
      if (viewDefinition.getMinDeltaCalculationPeriod() != null) {
        jsonObject.put(MIN_DELTA_CALC_PERIOD_FIELD, viewDefinition.getMinDeltaCalculationPeriod());
      }
      if (viewDefinition.getMaxDeltaCalculationPeriod() != null) {
        jsonObject.put(MAX_DELTA_CALC_PERIOD_FIELD, viewDefinition.getMaxDeltaCalculationPeriod());
      }
      if (viewDefinition.getMinFullCalculationPeriod() != null) {
        jsonObject.put(MIN_FULL_CALC_PERIOD_FIELD, viewDefinition.getMinFullCalculationPeriod());
      }
      if (viewDefinition.getMaxFullCalculationPeriod() != null) {
        jsonObject.put(MAX_FULL_CALC_PERIOD_FIELD, viewDefinition.getMaxFullCalculationPeriod());
      }
      Map<String, ViewCalculationConfiguration> calculationConfigurations = viewDefinition.getAllCalculationConfigurationsByName();
      List<JSONObject> calConfigJSONList = Lists.newArrayList();
      for (ViewCalculationConfiguration calcConfig : calculationConfigurations.values()) {
        JSONObject calcConfigJSON = new JSONObject();
        calcConfigJSON.put(NAME_FIELD, calcConfig.getName());
        List<JSONObject> portfolioRequirementsBySecurityType = Lists.newArrayList();
        for (Map.Entry<String, Set<Pair<String, ValueProperties>>> securityTypeRequirements : calcConfig.getPortfolioRequirementsBySecurityType().entrySet()) {
          JSONObject securityTypeRequirementJSON = new JSONObject();
          securityTypeRequirementJSON.put(SECURITY_TYPE_FIELD, securityTypeRequirements.getKey());
          List<JSONObject> portfolioRequirement = Lists.newArrayList();
          for (Pair<String, ValueProperties> requirement : securityTypeRequirements.getValue()) {
            JSONObject reqJSON = new JSONObject();
            reqJSON.put(PORTFOLIO_REQUIREMENT_REQUIRED_OUTPUT_FIELD, requirement.getFirst());
            reqJSON.put(PORTFOLIO_REQUIREMENT_CONSTRAINTS_FIELD, toJSONObject(requirement.getSecond()));
            portfolioRequirement.add(reqJSON);
          }
          if (!portfolioRequirement.isEmpty()) {
            securityTypeRequirementJSON.put(PORTFOLIO_REQUIREMENT_FIELD, portfolioRequirement);
          }
          portfolioRequirementsBySecurityType.add(securityTypeRequirementJSON);
        }
        if (!portfolioRequirementsBySecurityType.isEmpty()) {
          calcConfigJSON.put(PORTFOLIO_REQUIREMENTS_BY_SECURITY_TYPE_FIELD, portfolioRequirementsBySecurityType);
        }
        List<JSONObject> specificRequirementList = Lists.newArrayList();
        for (ValueRequirement specificRequirement : calcConfig.getSpecificRequirements()) {
          specificRequirementList.add(toJSONObject(specificRequirement));
        }
        if (!specificRequirementList.isEmpty()) {
          calcConfigJSON.put(SPECIFIC_REQUIREMENT_FIELD, specificRequirementList);
        }
        calcConfigJSON.put(DELTA_DEFINITION_FIELD, toJSONObject(calcConfig.getDeltaDefinition()));
        calcConfigJSON.put(DEFAULT_PROPERTIES_FIELD, toJSONObject(calcConfig.getDefaultProperties()));
        calcConfigJSON.put(RESOLUTION_RULE_TRANSFORM_FIELD, toJSONObject(calcConfig.getResolutionRuleTransform(), false));
        calConfigJSONList.add(calcConfigJSON);
      }  
      if (!calConfigJSONList.isEmpty()) {
        jsonObject.put(CALCULATION_CONFIGURATION_FIELD, calConfigJSONList);
      }
      if (viewDefinition.getUniqueId() != null) {
        jsonObject.put(UNIQUE_ID_FIELD, viewDefinition.getUniqueId().toString());
      }
            
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("unable to convert view definition to JSON", ex);
    }
    
    return jsonObject.toString();;    return toJSON(viewDefinition, ViewDefinition.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bbcf9_751ba/rev_bbcf9-751ba;/projects/OG-Web/src/com/opengamma/web/json/ViewDefinitionJSONBuilder;createTemplate();    ViewDefinitionJSONBuilder builder = ViewDefinitionJSONBuilder.INSTANCE;
    String result = null;
    try {
      String s = builder.toJSON(getDummyView());
      JSONObject jsonObject = new JSONObject(s);
      jsonObject.put(CURRENCY_FIELD, "");
      jsonObject.put(CALCULATION_CONFIGURATION_FIELD, new JSONArray());
      result = jsonObject.toString();
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("invalid json produced from dummy view definition", ex);
    }
    return result;;    ViewDefinitionJSONBuilder builder = ViewDefinitionJSONBuilder.INSTANCE; 
    String result = null;
    try {
      JSONObject jsonObject = new JSONObject(builder.toJSON(getDummyView()));
      jsonObject.put(CURRENCY_FIELD, "");
      jsonObject.put(CALCULATION_CONFIGURATION_FIELD, new JSONArray());
      result = jsonObject.toString();
    } catch (JSONException ex) {
      throw new OpenGammaRuntimeException("invalid json produced from dummy view definition", ex);
    }
    return result;;    ViewDefinitionJSONBuilder builder = ViewDefinitionJSONBuilder.INSTANCE; 
    return builder.toJSON(getDummyView());
//    String result = null;
//    try {
//      JSONObject jsonObject = new JSONObject(builder.toJSON(getDummyView()));
//      jsonObject.put(CURRENCY_FIELD, "");
//      jsonObject.put(CALCULATION_CONFIGURATION_FIELD, new JSONArray());
//      result = jsonObject.toString();
//    } catch (JSONException ex) {
//      throw new OpenGammaRuntimeException("invalid json produced from dummy view definition", ex);
//    }
//    return result;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d;/src/java/voldemort/server/VoldemortServer;createServices();        if(voldemortConfig.isSocketServerEnabled())
            services.add(new SocketService(requestHandlerFactory,
                                           identityNode.getSocketPort(),
                                           voldemortConfig.getCoreThreads(),
                                           voldemortConfig.getMaxThreads(),
                                           voldemortConfig.getSocketBufferSize(),
                                           "socket-server",
                                           voldemortConfig.isJmxEnabled()));;        if(voldemortConfig.isSocketServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                           identityNode.getSocketPort(),
                                           voldemortConfig.getCoreThreads(),
                                           voldemortConfig.getMaxThreads(),
                                           voldemortConfig.getSocketBufferSize(),
                                           "client-request-service"));
        if(voldemortConfig.isAdminServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(RequestFormatType.ADMIN_HANDLER),
                                           identityNode.getAdminPort(),
                                           voldemortConfig.getAdminCoreThreads(),
                                           voldemortConfig.getAdminMaxThreads(),
                                           voldemortConfig.getAdminSocketBufferSize(),
                                           "admin-service"));;        if(voldemortConfig.isSocketServerEnabled()) {
            if(voldemortConfig.getUseNioConnector()) {
                logger.info("Using NIO Connector.");
                services.add(new NioSocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                                  identityNode.getSocketPort(),
                                                  voldemortConfig.getSocketBufferSize(),
                                                  voldemortConfig.getNioConnectorSelectors()));
            } else {
                logger.info("Using BIO Connector.");
                services.add(new SocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                               identityNode.getSocketPort(),
                                               voldemortConfig.getCoreThreads(),
                                               voldemortConfig.getMaxThreads(),
                                               voldemortConfig.getSocketBufferSize(),
                                               "client-request-service"));
            }
        }
        if(voldemortConfig.isAdminServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(RequestFormatType.ADMIN_HANDLER),
                                           identityNode.getAdminPort(),
                                           voldemortConfig.getAdminCoreThreads(),
                                           voldemortConfig.getAdminMaxThreads(),
                                           voldemortConfig.getAdminSocketBufferSize(),
                                           "admin-service"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d;/test/unit/voldemort/client/SocketStoreClientFactoryTest;setUp();        server = ServerTestUtils.getSocketServer(getClusterXml(),
                                                 getStoreDefXml(),
                                                 getValidStoreName(),
                                                 getLocalNode().getSocketPort());;        server = ServerTestUtils.getSocketServer(getClusterXml(),
                                                 getStoreDefXml(),
                                                 getValidStoreName(),
                                                 getLocalNode().getSocketPort(),
                                                 RequestFormatType.VOLDEMORT);;        socketService = ServerTestUtils.getSocketService(getClusterXml(),
                                                         getStoreDefXml(),
                                                         getValidStoreName(),
                                                         getLocalNode().getSocketPort(),
                                                         RequestFormatType.VOLDEMORT);
        socketService.start();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d;/test/unit/voldemort/store/socket/AbstractSocketStoreTest;setUp();        socketServer = ServerTestUtils.getSocketServer(VoldemortTestConstants.getOneNodeClusterXml(),
                                                       VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                       "test",
                                                       socketPort);;        socketServer = ServerTestUtils.getSocketServer(VoldemortTestConstants.getOneNodeClusterXml(),
                                                       VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                       "test",
                                                       socketPort,
                                                       requestFormatType);;        socketService = ServerTestUtils.getSocketService(VoldemortTestConstants.getOneNodeClusterXml(),
                                                         VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                         "test",
                                                         socketPort,
                                                         requestFormatType);
        socketService.start();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d;/test/unit/voldemort/server/socket/SocketPoolTest;setUp();        this.dest1 = new SocketDestination("localhost", port, RequestFormatType.VOLDEMORT_V1);
        RequestHandlerFactory handlerFactory = new RequestHandlerFactory(new StoreRepository(),
                                                                         null,
                                                                         null);
        this.server = new SocketServer(port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();;        this.dest1 = new SocketDestination("localhost", port);
        VoldemortNativeRequestHandler requestHandler = new VoldemortNativeRequestHandler(new ErrorCodeMapper(),
                                                                                         new StoreRepository());
        this.server = new SocketServer("test-socket",
                                       port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       requestHandler);
        this.server.start();
        this.server.awaitStartupCompletion();;        this.dest1 = new SocketDestination("localhost", port);
        VoldemortNativeRequestHandler requestHandler = new VoldemortNativeRequestHandler(new ErrorCodeMapper(),
                                                                                         new StoreRepository());
        this.socketService = ServerTestUtils.getSocketService(requestHandler,
                                                              port,
                                                              maxTotalConnections,
                                                              maxTotalConnections + 3,
                                                              10000);
        this.socketService.start();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bc988_5bf1f/rev_bc988-5bf1f;/src/java/org/apache/cassandra/io/sstable/SSTableReader;getBloomFilterSerializedSize();        if (bf instanceof AlwaysPresentFilter)
            return 0;
        return FilterFactory.serializedSize(bf, descriptor.version.filterType);;        return FilterFactory.serializedSize(bf, descriptor.version.filterType);;        return FilterFactory.serializedSize(bf);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_bcfe3_4b4cc/rev_bcfe3-4b4cc;/src/java/org/apache/cassandra/hadoop/cql3/CqlPagingRecordReader;retrieveKeys();        parseKeyValidators(ByteBufferUtil.string(ByteBuffer.wrap(cqlRow.columns.get(2).getValue())));
        
        Column rawComparator = cqlRow.columns.get(3);
        String comparator = ByteBufferUtil.string(ByteBuffer.wrap(rawComparator.getValue()));
        logger.debug("comparator: {}", comparator);
        AbstractType comparatorValidator = parseType(comparator);
        if (comparatorValidator instanceof CompositeType)
        {
            for (int i = 0; i < clusterColumns.size(); i++)
                clusterColumns.get(i).reversed = (((CompositeType) comparatorValidator).types.get(i) instanceof ReversedType);
        }
        else if (comparatorValidator instanceof ReversedType)
        {
            clusterColumns.get(0).reversed = true;
        };        parseKeyValidators(ByteBufferUtil.string(ByteBuffer.wrap(cqlRow.columns.get(2).getValue())));;        Column rawKeyValidator = cqlRow.columns.get(2);
        String validator = ByteBufferUtil.string(ByteBuffer.wrap(rawKeyValidator.getValue()));
        logger.debug("row key validator: {}", validator);
        keyValidator = parseType(validator);

        if (keyValidator instanceof CompositeType)
        {
            List<AbstractType<?>> types = ((CompositeType) keyValidator).types;
            for (int i = 0; i < partitionBoundColumns.size(); i++)
                partitionBoundColumns.get(i).validator = types.get(i);
        }
        else
        {
            partitionBoundColumns.get(0).validator = keyValidator;
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_bd11b_a3d71/rev_bd11b-a3d71;/test/integration/voldemort/performance/RemoteTest;main(String[]);                                                      .setFailureDetectorRequestLengthThreshold(TimeUnit.SECONDS.toMillis(60))
                                                      .setSocketBufferSize(4 * 1024);;                                                      .setSocketBufferSize(4 * 1024);;                                                      .setSocketBufferSize(4 * 1024)
                                                      .setEnablePipelineRoutedStore(options.has("pipeline-routed-store"))
                                                      .setSelectors(selectors);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_bdb0e_c228e/rev_bdb0e-c228e;/lucene/src/java/org/apache/lucene/index/IndexWriterConfig;IndexWriterConfig(Version,Analyzer);    mergePolicy = new TieredMergePolicy();
    maxThreadStates = DEFAULT_MAX_THREAD_STATES;;    mergePolicy = new LogByteSizeMergePolicy();
    maxThreadStates = DEFAULT_MAX_THREAD_STATES;;    mergePolicy = new LogByteSizeMergePolicy();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_bdb0e_c228e/rev_bdb0e-c228e;/lucene/src/test/org/apache/lucene/index/TestIndexWriterConfig;testDefaults();    assertEquals(TieredMergePolicy.class, conf.getMergePolicy().getClass());
    ;    assertEquals(LogByteSizeMergePolicy.class, conf.getMergePolicy().getClass());
    ;    assertEquals(LogByteSizeMergePolicy.class, conf.getMergePolicy().getClass());
    assertEquals(ThreadAffinityDocumentsWriterThreadPool.class, conf.getIndexerThreadPool().getClass());
    assertNull(conf.getFlushPolicy());
    assertEquals(IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB, conf.getRAMPerThreadHardLimitMB());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_bdb0e_c228e/rev_bdb0e-c228e;/lucene/src/test/org/apache/lucene/index/TestRollingUpdates;testRollingUpdates();      doc.getField("docid").setValue(myID);
      w.updateDocument(new Term("docid", myID), doc);;      doc.getField("id").setValue(myID);
      w.updateDocument(new Term("id", myID), doc);;      doc.getField("id").setValue(myID);
      int mode = docIter % 3;
      switch (mode) {
        case 0: {
          w.deleteDocuments(new Term("id", myID));
          w.addDocument(doc);
          break;
        }
        case 1: {
          w.deleteDocuments(new TermQuery(new Term("id", myID)));
          w.addDocument(doc);
          break;
        }
        default : w.updateDocument(new Term("id", myID), doc);
      }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_bdbc6_d44d1/rev_bdbc6-d44d1;/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OClassImpl;truncate();    acquireSchemaReadLock();
    try {
      for (int id : clusterIds) {
        final OStorage storage = getDatabase().getStorage();
        storage.getClusterById(id).truncate();
        storage.getLevel2Cache().freeCluster(id);
      };    getDatabase().getStorage().callInLock(new Callable<Object>() {
      public Object call() throws Exception {
        for (int id : clusterIds) {
          final OStorage storage = getDatabase().getStorage();
          storage.getClusterById(id).truncate();
          storage.getLevel2Cache().freeCluster(id);
        };    getDatabase().getStorage().callInLock(new Callable<Object>() {
      public Object call() throws Exception {
        for (int id : clusterIds) {
          final OStorage storage = getDatabase().getStorage();
          storage.getClusterById(id).truncate();
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_bdbc6_d44d1/rev_bdbc6-d44d1;/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast/OHazelcastDistributedDatabase;onMessage(ODistributedRequest);        if (database != null) {
          database.getLevel1Cache().clear();
          database.setUser(origin);
        };        if (database != null)
          database.getLevel1Cache().clear();;        if (database != null)
          database.getLocalCache().clear();
        if (ODatabaseRecordThreadLocal.INSTANCE.get() != null)
          ODatabaseRecordThreadLocal.INSTANCE.get().setUser(origin);//set back to origin
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_bdbc6_d44d1/rev_bdbc6-d44d1;/tests/src/test/java/com/orientechnologies/orient/test/database/auto/SchemaIndexTest;tearDown();    database.getLevel2Cache().clear();;    database.getLevel2Cache().clear();

    database.close();;
    database.close();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_be370_7ee8b/rev_be370-7ee8b;/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient;stop();        while (connection != null && System.currentTimeMillis() < expiry) {
            if (stopped.add(connection.getUid())) {
                new StopDispatcher(idGenerator).dispatch(connection.getConnection());
                LOGGER.lifecycle("Gradle daemon stopped.");
            };        while (connection != null) {
            new StopDispatcher(idGenerator).dispatch(connection.getConnection());
            LOGGER.lifecycle("Gradle daemon stopped.");;        while (connection != null) {
            new StopDispatcher(idGenerator).dispatch(connection);
            LOGGER.lifecycle("Gradle daemon stopped.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_be989_82fe0/rev_be989-82fe0;/projects/OG-Engine/src/main/java/com/opengamma/engine/depgraph/GetFunctionsStep;run(GraphBuildingContext);      final ValueProperties constraints = getValueRequirement().getConstraints();
      boolean constraintsSatisfied = constraints.isSatisfiedBy(marketDataSpec.getProperties());
      if ((getValueRequirement().getValueName() != marketDataSpec.getValueName());      final ValueProperties constraints = getValueRequirement().getConstraints();
      if ((getValueRequirement().getValueName() != marketDataSpec.getValueName());      final ValueProperties constraints = requirement.getConstraints();
      if ((requirement.getValueName() != marketDataSpec.getValueName())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bf6c9_82237/rev_bf6c9-82237;/src/com/opengamma/engine/view/ViewProcessor;initializeView(String);void initializeView(String viewName);;public void initializeView(String viewName) {
    ArgumentChecker.notNull(viewName, "View name");
    if (_viewsByName.containsKey(viewName)) {
      return;
    }
    ViewDefinition viewDefinition = getViewDefinitionRepository().getDefinition(viewName);
    if (viewDefinition == null) {
      throw new NoSuchElementException("No view available with name \"" + viewName + "\"");
    }
    // NOTE kirk 2010-03-02 -- We construct a bespoke ViewProcessingContext because the resolvers might be based on the
    // view definition (particularly for functions and the like).
    // NOTE jonathan 2010-08-18 -- Same thing as above for the permission provider. At the moment we're using the
    // default for everything, but we could potentially customise this per view, perhaps based on some property of the
    // view definition - it's easy to imagine that there might be different broad types of view permissioning.
    FunctionRepository functionRepository = getFunctionCompilationService().getFunctionRepository();
    InMemoryLKVSnapshotProvider viewLevelLiveData = new InMemoryLKVSnapshotProvider();
    ViewProcessingContext vpc = new ViewProcessingContext(getLiveDataClient(), getLiveDataAvailabilityProvider(), new CombiningLiveDataSnapshotProvider(Arrays.asList(viewLevelLiveData,
        getLiveDataSnapshotProvider())), functionRepository, new DefaultFunctionResolver(functionRepository), getPositionSource(), getSecuritySource(), getComputationCacheSource(),
        getComputationJobDispatcher(), getViewProcessorQueryReceiver(), getFunctionCompilationService().getFunctionCompilationContext(), getExecutorService(), getDependencyGraphExecutorFactory(),
        getViewPermissionProvider());
    View freshView = new View(viewDefinition, vpc, viewLevelLiveData);
    View actualView = _viewsByName.putIfAbsent(viewName, freshView);
    if (actualView == null) {
      actualView = freshView;
    }
    switch (actualView.getCalculationState()) {
      case INITIALIZING:
        // Do nothing, another thread is taking care of this.
        s_logger.debug("Not initializing {} as another thread already doing it.", viewName);
        break;
      case NOT_INITIALIZED:
        // We want to initialize it.
        actualView.init();
        break;
      default:
        // REVIEW kirk 2010-03-02 -- Is this the right thing to do?
        s_logger.warn("Asked to initialize view {} but in state {}. Doing nothing.", viewName, actualView.getCalculationState());
    }
  };public void initializeView(String viewName) {
    ArgumentChecker.notNull(viewName, "View name");
    if (_viewsByName.containsKey(viewName)) {
      return;
    }
    ViewDefinition viewDefinition = getViewDefinitionRepository().getDefinition(viewName);
    if (viewDefinition == null) {
      throw new NoSuchElementException("No view available with name \"" + viewName + "\"");
    }
    // NOTE kirk 2010-03-02 -- We construct a bespoke ViewProcessingContext because the resolvers might be based on the
    // view definition (particularly for functions and the like).
    // NOTE jonathan 2010-08-18 -- Same thing as above for the permission provider. At the moment we're using the
    // default for everything, but we could potentially customise this per view, perhaps based on some property of the
    // view definition - it's easy to imagine that there might be different broad types of view permissioning.
    FunctionRepository functionRepository = getFunctionCompilationService().getFunctionRepository();
    InMemoryLKVSnapshotProvider viewLevelLiveData = new InMemoryLKVSnapshotProvider();
    ViewProcessingContext vpc = new ViewProcessingContext(getLiveDataClient(), getLiveDataAvailabilityProvider(), new CombiningLiveDataSnapshotProvider(Arrays.asList(viewLevelLiveData,
        getLiveDataSnapshotProvider())), functionRepository, new DefaultFunctionResolver(functionRepository), getPositionSource(), getSecuritySource(), getComputationCacheSource(),
        getComputationJobDispatcher(), getViewProcessorQueryReceiver(), getFunctionCompilationService().getFunctionCompilationContext(), getExecutorService(), getDependencyGraphExecutorFactory(),
        getViewPermissionProvider(), getGraphExecutionStatistics());
    View freshView = new View(viewDefinition, vpc, viewLevelLiveData);
    View actualView = _viewsByName.putIfAbsent(viewName, freshView);
    if (actualView == null) {
      actualView = freshView;
    }
    switch (actualView.getCalculationState()) {
      case INITIALIZING:
        // Do nothing, another thread is taking care of this.
        s_logger.debug("Not initializing {} as another thread already doing it.", viewName);
        break;
      case NOT_INITIALIZED:
        // We want to initialize it.
        actualView.init();
        break;
      default:
        // REVIEW kirk 2010-03-02 -- Is this the right thing to do?
        s_logger.warn("Asked to initialize view {} but in state {}. Doing nothing.", viewName, actualView.getCalculationState());
    }
  }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_bf659_0dca1/rev_bf659-0dca1;/src/com/opengamma/financial/user/rest/ClientResource;ClientResource(ClientsResource,String,FudgeContext);    _positionMaster = new InMemoryPositionMaster(new UniqueIdentifierSupplier("UserPos:" + username + ":" + clientName));
    _securityMaster = new InMemoryManageableSecurityMaster(getTemplate(username, clientName, SECURITIES_PATH));;    _positionMaster = new InMemoryManageablePositionMaster(getTemplate(username, clientName, PORTFOLIOS_PATH));
    _securityMaster = new InMemoryManageableSecurityMaster(getTemplate(username, clientName, SECURITIES_PATH));;    _positionMaster = new InMemoryManageablePositionMaster(getTemplate(username, clientName, PORTFOLIOS_PATH));
    _securityMaster = new MasterSecuritySource(new InMemorySecurityMaster(getTemplate(username, clientName, SECURITIES_PATH).createSupplier()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_bfa4a_e4de6/rev_bfa4a-e4de6;/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler;getConnectionFromSlot(int);	currentConnection = connectionPool.getResource();
	return currentConnection;;	currentConnection = connectionPool.getResource();
	return connectionPool.getResource();;	return  connectionPool.getResource();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_bfdc9_fad6a/rev_bfdc9-fad6a;/tightdb-java-test/src/test/java/com/tightdb/JNIQueryTest;columnIndexOutOfBounds();        try { query.equal(9, true);                       assert(false); } catch(ArrayIndexOutOfBoundsException e) {};        try { query.equal(9, true);                       assert(false); } catch(ArrayIndexOutOfBoundsException e) {};        try { query.equalTo(9, true);                       assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1e0f_c146f/rev_c1e0f-c146f;/src/java/org/apache/cassandra/db/compaction/LeveledManifest;getCandidatesFor(int);            if (candidates.size() < 2);            // check overlap with L0 compacting sstables to make sure we are not generating overlap in L1.
            Iterable<SSTableReader> compactingL0 = Iterables.filter(generations[0], Predicates.in(compacting));
            if (candidates.size() < 2 || !Sets.intersection(candidates, compacting).isEmpty() || !overlapping(candidates, compactingL0).isEmpty());            // check overlap with L0 compacting sstables to make sure we are not generating overlap in L1.
            Iterable<SSTableReader> compactingL0 = Iterables.filter(generations[0], Predicates.in(compacting));
            if (candidates.size() < 2 || !overlapping(candidates, compactingL0).isEmpty())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1eb7_4e959/rev_c1eb7-4e959;/test/unit/org/apache/cassandra/triggers/TriggersTest;getColumnForInsert(String,int);        column.setName(Schema.instance.getCFMetaData(ksName, cfName).comparator.fromString(columnName));
        column.setValue(bytes(value));;        column.setName(Schema.instance.getCFMetaData(ksName, cfName).comparator.fromString(columnName));
        column.setValue(ByteBufferUtil.bytes(value));;        column.setName(Schema.instance.getCFMetaData(ksName, cfName).comparator.asAbstractType().fromString(columnName));
        column.setValue(bytes(value));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1eb7_4e959/rev_c1eb7-4e959;/test/unit/org/apache/cassandra/triggers/TriggersTest;augment(ByteBuffer,ColumnFamily);            extraUpdate.addColumn(new Column(update.metadata().comparator.fromString("v2"),
                                             bytes(999)));
            return Collections.singletonList(new RowMutation(ksName, key, extraUpdate));;            extraUpdate.addColumn(new Column(update.metadata().comparator.fromString("v2"),
                                             ByteBufferUtil.bytes(999)));
            RowMutation rm = new RowMutation(ksName, key);
            rm.add(extraUpdate);
            return Collections.singletonList(rm);;            extraUpdate.addColumn(new Cell(update.metadata().comparator.makeCellName(bytes("v2")),
                                           bytes(999)));
            Mutation mutation = new Mutation(ksName, key);
            mutation.add(extraUpdate);
            return Collections.singletonList(mutation);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1eb7_4e959/rev_c1eb7-4e959;/test/unit/org/apache/cassandra/triggers/TriggersTest;augment(ByteBuffer,ColumnFamily);            extraUpdate.addColumn(new Column(update.metadata().comparator.fromString("v2"),
                                             bytes(999)));;            extraUpdate.addColumn(new Column(update.metadata().comparator.fromString("v2"),
                                             ByteBufferUtil.bytes(999)));;            extraUpdate.addColumn(new Cell(update.metadata().comparator.makeCellName(bytes("v2")),
                                           bytes(999)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1eb7_4e959/rev_c1eb7-4e959;/test/unit/org/apache/cassandra/triggers/TriggersTest;augment(ByteBuffer,ColumnFamily);            int newKey = ByteBufferUtil.toInt(key) + 1000;
            return Collections.singletonList(new RowMutation(ksName, bytes(newKey), extraUpdate));;            int newKey = ByteBufferUtil.toInt(key) + 1000;
            RowMutation rm = new RowMutation(ksName, ByteBufferUtil.bytes(newKey));
            rm.add(extraUpdate);
            return Collections.singletonList(rm);;            int newKey = toInt(key) + 1000;
            Mutation mutation = new Mutation(ksName, bytes(newKey));
            mutation.add(extraUpdate);
            return Collections.singletonList(mutation);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c1eb7_4e959/rev_c1eb7-4e959;/test/unit/org/apache/cassandra/triggers/TriggersTest;augment(ByteBuffer,ColumnFamily);            extraUpdate.addColumn(new Column(extraUpdate.metadata().comparator.fromString("v2"),
                                             bytes(999)));
            return Collections.singletonList(new RowMutation(ksName, key, extraUpdate));;            extraUpdate.addColumn(new Column(extraUpdate.metadata().comparator.fromString("v2"),
                                             ByteBufferUtil.bytes(999)));

            RowMutation rm = new RowMutation(ksName, key);
            rm.add(extraUpdate);
            return Collections.singletonList(rm);;            extraUpdate.addColumn(new Cell(extraUpdate.metadata().comparator.makeCellName(bytes("v2")),
                                           bytes(999)));

            Mutation mutation = new Mutation(ksName, key);
            mutation.add(extraUpdate);
            return Collections.singletonList(mutation);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c1edb_18b25/rev_c1edb-18b25;/src/com/opengamma/financial/analytics/model/equity/StandardEquityModelFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);    final double price = (Double) inputs.getValue(new ValueRequirement(MarketDataRequirementNames.MARKET_VALUE, ComputationTargetType.SECURITY, equity.getUniqueIdentifier()));
    return Collections.<ComputedValue>singleton(new ComputedValue(new ValueSpecification(new ValueRequirement(ValueRequirementNames.FAIR_VALUE, ComputationTargetType.SECURITY, equity
        .getUniqueIdentifier())), price));;    final double price = (Double) inputs.getValue(new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, ComputationTargetType.SECURITY, equity.getUniqueIdentifier()));
    return Collections.<ComputedValue>singleton(new ComputedValue(new ValueSpecification(new ValueRequirement(ValueRequirementNames.FAIR_VALUE, ComputationTargetType.SECURITY, equity
        .getUniqueIdentifier())), price));;    final double price = (Double) inputs.getValue(new ValueRequirement(MarketDataRequirementNames.INDICATIVE_VALUE, ComputationTargetType.SECURITY, equity.getUniqueIdentifier()));
    return Collections.<ComputedValue>singleton(new ComputedValue(
        new ValueSpecification(
            new ValueRequirement(
                ValueRequirementNames.FAIR_VALUE, 
                ComputationTargetType.SECURITY, 
                equity.getUniqueIdentifier()),
            getUniqueIdentifier()), 
      price));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2c78_b77c7/rev_c2c78-b77c7;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/CurveDefinitionAndSpecifications;buildStandardCurveDefintions();    forwardDefinitions.put(dkk, buildForwardCurve(dkk, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));
    fundingDefinitions.put(dkk, buildFundingCurve(dkk, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] {20, 25, 30 })));
    singleDefinitions.put(dkk, buildSingleCurve(dkk, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));;    forwardDefinitions.put(dkk, buildForwardCurve(dkk, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));
    fundingDefinitions.put(dkk, buildFundingCurve(dkk, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] { 20, 25, 30 })));
    singleDefinitions.put(dkk, buildSingleCurve(dkk, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));;    Identifier dkkRegion = RegionUtils.countryRegionId("DK");
    forwardDefinitions.put(dkk, buildForwardCurve(dkk, dkkRegion, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));
    fundingDefinitions.put(dkk, buildFundingCurve(dkk, dkkRegion, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] { 20, 25, 30 })));
    singleDefinitions.put(dkk, buildSingleCurve(dkk, dkkRegion, makeShortEnd(false, true, true), null, 0, makeLongEnd(2, 15, new int[] {20, 25, 30, 40, 50 })));
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2c78_b77c7/rev_c2c78-b77c7;/projects/OG-Financial/src/com/opengamma/financial/analytics/ircurve/CurveDefinitionAndSpecifications;buildStandardCurveDefintions();    forwardDefinitions.put(jpy, buildForwardCurve(jpy, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));
    fundingDefinitions.put(jpy, buildFundingCurve(jpy, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] {20, 25, 30, 35, 40, 50 })));
    singleDefinitions.put(jpy, buildSingleCurve(jpy, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));;    forwardDefinitions.put(jpy, buildForwardCurve(jpy, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));
    fundingDefinitions.put(jpy, buildFundingCurve(jpy, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] { 20, 25, 30, 35, 40, 50 })));
    singleDefinitions.put(jpy, buildSingleCurve(jpy, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));;    Identifier jpyRegion = RegionUtils.countryRegionId("JP");
    forwardDefinitions.put(jpy, buildForwardCurve(jpy, jpyRegion, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));
    fundingDefinitions.put(jpy, buildFundingCurve(jpy, jpyRegion, makeShortEnd(false, true, true), makeLongEnd(1, 15, new int[] { 20, 25, 30, 35, 40, 50 })));
    singleDefinitions.put(jpy, buildSingleCurve(jpy, jpyRegion, makeShortEnd(false, true, true), Tenor.ofYears(1), 3, makeLongEnd(2, 15, new int[] {20, 25, 30, 35, 40, 50, 60 })));
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/bridge/TestLegendEntryPopup;setupTest();		Mockito.when(mockLegendEntry.getFullBaseDisplayName()).thenReturn("test");
		Mockito.when(mockLegendEntry.getNumberRegressionPoints()).thenReturn(15);;		Mockito.when(mockLegendEntry.getFullBaseDisplayName()).thenReturn("test");;		Mockito.when(mockLegendEntry.getFullBaseDisplayName()).thenReturn("test");
		Mockito.when(mockLegendEntry.getLineSettings()).thenReturn(new LineSettings());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/test/java/gov/nasa/arc/mct/fastplot/view/TestPlotPersistanceHandler;testMigrateFixed();				NonTimeAxisSubsequentBoundsSetting.FIXED, 0.0, 1.0, new GregorianCalendar(), new GregorianCalendar(), 0.0, 0.0, 0.0, true, false);
		manifestation.getViewProperties().setProperty(PlotConstants.TIME_AXIS_SUBSEQUENT_SETTING, "FIXED");
		manifestation.getViewProperties().setProperty(PlotConstants.REGRESSION_LINE, "isp:123456\tfalse|20\t");
		PlotSettings settings = h.loadPlotSettingsFromPersistance();
		List<Map<String, String>> regSettings = h.loadRegressionSettingsFromPersistence();;				NonTimeAxisSubsequentBoundsSetting.FIXED, 0.0, 1.0, new GregorianCalendar(), new GregorianCalendar(), 0.0, 0.0, 0.0, true, false);
		manifestation.getViewProperties().setProperty(PlotConstants.TIME_AXIS_SUBSEQUENT_SETTING, "FIXED");
		PlotSettings settings = h.loadPlotSettingsFromPersistance();;				NonTimeAxisSubsequentBoundsSetting.FIXED, 0.0, 1.0, new GregorianCalendar(), new GregorianCalendar(), 0.0, 0.0, 0.0, true, false,
				PlotConstants.DEFAULT_PLOT_LINE_DRAW,
				PlotLineConnectionType.STEP_X_THEN_Y);
		manifestation.getViewProperties().setProperty(PlotConstants.TIME_AXIS_SUBSEQUENT_SETTING, "FIXED");
		PlotSettings settings = h.loadPlotSettingsFromPersistance();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/LegendEntry;mouseEntered(MouseEvent);		// Highlight this entry on the plot.
		originalPlotLineColor = linePlot.getForeground();
		originalPlotLineStroke = linePlot.getStroke();
		

		linePlot.setForeground(originalPlotLineColor.brighter().brighter());
		BasicStroke stroke = (BasicStroke) originalPlotLineStroke;
		if(stroke == null) {;		// Highlight this entry on the plot.
		originalPlotLineColor = linePlot.getForeground();
		originalPlotLineStroke = linePlot.getStroke();

		linePlot.setForeground(originalPlotLineColor.brighter().brighter());
		BasicStroke stroke = (BasicStroke) originalPlotLineStroke;
		if(stroke == null) {;		linePlot.setForeground(originalPlotLineColor.brighter());
		
		if(originalPlotLineStroke == null) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/bridge/LegendEntry;mouseEntered(MouseEvent);		}
		if (regressionLine != null) {
			originalRegressionLineStroke = regressionLine.getStroke();
			regressionLine.setForeground(originalPlotLineColor.brighter().brighter());
			stroke = (BasicStroke) regressionLine.getStroke();
			//TODO synch with plot thickness feature changes
			if(stroke == null) {
				regressionLine.setStroke(new BasicStroke(PlotConstants.SLOPE_LINE_WIDTH*2,
		                BasicStroke.CAP_BUTT,
		                BasicStroke.JOIN_MITER,
		                10.0f, PlotConstants.dash1, 0.0f));
			} else {
				regressionLine.setStroke(new BasicStroke(PlotConstants.SLOPE_LINE_WIDTH*2,
		                BasicStroke.CAP_BUTT,
		                BasicStroke.JOIN_MITER,
		                10.0f, PlotConstants.dash1, 0.0f));
			}
		}
				;		}
				;		} //Otherwise, it's a stroke we can't change (ie EMPTY_STROKE)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/PlotViewManifestation;generatePlot();		thePlot.addPopupMenus();
		thePlot.setRegressionPointAssignments(plotPersistanceHandler.loadRegressionSettingsFromPersistence());
		thePlot.setColorAssignments(plotPersistanceHandler.loadColorSettingsFromPersistence());;		thePlot.addPopupMenus();
		thePlot.setColorAssignments(plotPersistanceHandler.loadColorSettingsFromPersistence());;		thePlot.addPopupMenus();
		thePlot.setLineSettings(plotPersistanceHandler.loadLineSettingsFromPersistence());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/LegendEntryPopupMenuFactory;LegendEntryPopup(PlotViewManifestation,LegendEntry);			if (name.isEmpty()) name = legendEntry.getFullBaseDisplayName();
			
			String subMenuText1 = String.format(BUNDLE.getString("SelectColor.label"), 
			                     name);
			String subMenuText2 = String.format(BUNDLE.getString("RegressionPointsLabel"), 
                    name);
			final JMenu subMenu1 = new JMenu(subMenuText1);
			final JMenuItem regressionLineCheckBox = new JCheckBoxMenuItem(BUNDLE.getString("RegressionLineLabel"),false);
			final JMenu regressionMenu = new JMenu(subMenuText2);
			
			
			SpinnerModel pointsModel = new SpinnerNumberModel(legendEntry.getNumberRegressionPoints(), 2, 100, 1);
			final JSpinner spinner = new JSpinner(pointsModel);
			spinner.setPreferredSize(new Dimension(50, 20));
			spinner.setBorder(new EmptyBorder(2,2,2,2));
			spinner.addChangeListener(new ChangeListener() {

				@Override
				public void stateChanged(ChangeEvent e) {
					legendEntry.setNumberRegressionPoints(Integer.parseInt(((JSpinner)e.getSource()).getValue().toString()));
					manifestation.setupRegressionLines();
				}
				
			});
			
			 final JFormattedTextField myTextField = ((NumberEditor) spinner
				        .getEditor()).getTextField();
			
			spinner.addKeyListener(new KeyListener() {

				@Override
				public void keyTyped(KeyEvent e) {
					if ( ! (e.getKeyChar() == KeyEvent.CHAR_UNDEFINED) && 
							(e.getKeyCode() == KeyEvent.VK_UNDEFINED) &&
							// Apparently, backspace has a key char (although it should not)
							(e.getKeyChar() == '0' ||
							 e.getKeyChar() == '1' ||
							 e.getKeyChar() == '2' ||
							 e.getKeyChar() == '3' ||
							 e.getKeyChar() == '4' ||
							 e.getKeyChar() == '5' ||
							 e.getKeyChar() == '6' ||
							 e.getKeyChar() == '7' ||
							 e.getKeyChar() == '8' ||
							 e.getKeyChar() == '9'
									) &&
							Integer.valueOf(myTextField.getValue() + String.valueOf(e.getKeyChar())).compareTo((Integer) 
									((SpinnerNumberModel) spinner.getModel()).getMinimum()) > 0 && 
							Integer.valueOf(myTextField.getValue() + String.valueOf(e.getKeyChar())).compareTo((Integer) 
									((SpinnerNumberModel) spinner.getModel()).getMaximum()) < 0 ) {
						myTextField.setText(myTextField.getValue() + String.valueOf(e.getKeyChar()));
						
					}
				}

				@Override
				public void keyPressed(KeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_DELETE ) {
						((NumberEditor) spinner.getEditor()).getTextField().setText("");
					} 
					myTextField.grabFocus();
				}

				@Override
				public void keyReleased(KeyEvent e) {
				}
				
			});  
				 
			 myTextField.addFocusListener(new FocusListener()
				    {
				 @Override
				 public void focusGained(FocusEvent e) {
					 SwingUtilities.invokeLater(new Runnable() {
				            public void run() {
				            	myTextField.selectAll();
				            }
				     });
				 }

				@Override
				public void focusLost(java.awt.event.FocusEvent e) {
				}
			});
			 
			 final NumberEditor numberEditor = (NumberEditor) spinner.getEditor();
			 
			 numberEditor.addKeyListener(new KeyListener() {

				@Override
				public void keyTyped(KeyEvent e) {
				}

				@Override
				public void keyPressed(KeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_LEFT && 
							numberEditor.getTextField().getCaretPosition() == 0) {
						regressionMenu.setSelected(true);
					} 
				}

				@Override
				public void keyReleased(KeyEvent e) {
				}
			});
			 
			 myTextField.addKeyListener(new KeyListener() {

				@Override
				public void keyTyped(KeyEvent e) {
				}

				@Override
				public void keyPressed(KeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_LEFT && 
							numberEditor.getTextField().getCaretPosition() == 0) {
						regressionMenu.setSelected(true);
						regressionMenu.grabFocus();
						((JPopupMenu) spinner.getParent()).setSelected(regressionMenu);
					} 
				}

				@Override
				public void keyReleased(KeyEvent e) {
				}
				
			});
			 
			regressionMenu.addMenuKeyListener(new MenuKeyListener() {

				@Override
				public void menuKeyTyped(MenuKeyEvent e) {
				}

				@Override
				public void menuKeyPressed(MenuKeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_RIGHT ) {
						spinner.setVisible(true);
						spinner.requestFocus();
						((NumberEditor) spinner.getEditor()).grabFocus();
					} 
				}

				@Override
				public void menuKeyReleased(MenuKeyEvent e) {
				}
				
			});
			;			if (name.isEmpty()) name = legendEntry.getFullBaseDisplayName();
			
			String subMenuText = String.format(BUNDLE.getString("SelectColor.label"), 
			                     name);
			
			JMenu subMenu = new JMenu(subMenuText);;			if (name.isEmpty()) name = legendEntry.getFullBaseDisplayName();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_c07a2_3d41e/rev_c07a2-3d41e;/fastPlotViews/src/main/java/gov/nasa/arc/mct/fastplot/view/LegendEntryPopupMenuFactory;LegendEntryPopup(PlotViewManifestation,LegendEntry);				
				add(subMenu1);
				addSeparator();
				
				regressionLineCheckBox.addActionListener(new ActionListener() {

					@Override
					public void actionPerformed(ActionEvent e) {
						AbstractButton abstractButton = (AbstractButton) e.getSource();
						if (abstractButton.getModel().isSelected()) {
							legendEntry.setHasRegressionLine(true);
						} else {
							legendEntry.setHasRegressionLine(false);
						}
						manifestation.setupRegressionLines();
						
					}
					
				});
				if (legendEntry.hasRegressionLine()) {
					regressionLineCheckBox.setSelected(true);
				} else {
					regressionLineCheckBox.setSelected(false);
				}
				add(regressionLineCheckBox);
				regressionMenu.add(spinner);
				add(regressionMenu);;				
				add(subMenu);;				add(subMenu);
				
				// Thickness submenu
				subMenuText = String.format(BUNDLE.getString("SelectThickness.label"), name);
				subMenu = new JMenu(subMenuText);
				for (int i = 1; i <= PlotConstants.MAX_LINE_THICKNESS; i++) {
					JMenuItem item = new JRadioButtonMenuItem("" + i, 
							(settings.getThickness() == i));
					final int thickness = i;
					item.addActionListener(new ActionListener() {
						@Override
						public void actionPerformed(ActionEvent e) {				
							settings.setThickness(thickness);
							legendEntry.setLineSettings(settings);
							manifestation.persistPlotLineSettings();
						}					
					});
					subMenu.add(item);

				}
				add(subMenu);
				
				// Marker submenu
				if (manifestation.getPlot() != null && 
					manifestation.getPlot().getPlotLineDraw().drawMarkers()) {
					subMenuText = String.format(BUNDLE.getString("SelectMarker.label"), name);
					subMenu = new JMenu(subMenuText);
					for (int i = 0; i < PlotConstants.MAX_NUMBER_OF_DATA_ITEMS_ON_A_PLOT; i++) {
						JMenuItem item = new JRadioButtonMenuItem("",
								new PlotMarkerIcon(PlotLineShapePalette.getShape(i), false),
								(settings.getMarker() == i && !settings.getUseCharacter()));
						item.setForeground(legendEntry.getForeground());
						final int marker = i;
						item.addActionListener(new ActionListener() {
							@Override
							public void actionPerformed(ActionEvent e) {				
								settings.setMarker(marker);
								settings.setUseCharacter(false);
								legendEntry.setLineSettings(settings);
								manifestation.persistPlotLineSettings();
							}					
						});
						subMenu.add(item);
					}
					JMenuItem other = new JRadioButtonMenuItem(BUNDLE.getString("SelectCharacter.label"), 
							settings.getUseCharacter());
					if (!settings.getCharacter().isEmpty()) {
						FontRenderContext frc = ((Graphics2D) manifestation.getGraphics()).getFontRenderContext();
						other.setIcon(new PlotMarkerIcon(
								PlotLineShapePalette.getShape(settings.getCharacter(), frc),
								PlotLineColorPalette.getColor(settings.getColorIndex()),
								false));
					}
					other.addActionListener( new ActionListener() {
						@Override
						public void actionPerformed(ActionEvent arg0) {
							final CharacterDialog dialog = new CharacterDialog();
							dialog.setInitialString(settings.getCharacter());
							dialog.ok.addActionListener( new ActionListener() {
								@Override
								public void actionPerformed(ActionEvent arg0) {
									settings.setCharacter(dialog.field.getText().trim());
									settings.setUseCharacter(true);
									legendEntry.setLineSettings(settings);
									manifestation.persistPlotLineSettings();
								}							
							});
							dialog.setVisible(true);
						}					
					});
					subMenu.add(other);
					add(subMenu);
				}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c7e42_4bf0e/rev_c7e42-4bf0e;/projects/OG-Financial/src/main/java/com/opengamma/financial/livedata/rest/DataLiveDataInjectorResource;put(AddValueRequest);      // [PLAT-3044] Tempoary measure to make sure both the unique ID form and external ID form are injected into the value store for primitives until the identifiers are handled correctly
      final ValueRequirement temp = plat3044Hack(request.getValueRequirement());
      if (temp != null) {
        _injector.addValue(temp, request.getValue());
      }
    } else if (request.getIdentifier() != null && request.getValueName() != null) {
      _injector.addValue(request.getIdentifier(), request.getValueName(), request.getValue());;    } else if (request.getIdentifier() != null && request.getValueName() != null) {
      _injector.addValue(request.getIdentifier(), request.getValueName(), request.getValue());;    } else if (request.getValueSpecification() != null) {
      _injector.addValue(request.getValueSpecification(), request.getValue());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c7e42_4bf0e/rev_c7e42-4bf0e;/projects/OG-Financial/src/main/java/com/opengamma/financial/livedata/rest/DataLiveDataInjectorResource;remove(RemoveValueRequest);      // [PLAT-3044] Tempoary measure to make sure both the unique ID form and external ID form are injected into the value store for primitives until the identifiers are handled correctly
      final ValueRequirement temp = plat3044Hack(request.getValueRequirement());
      if (temp != null) {
        _injector.removeValue(temp);
      }
    } else if (request.getIdentifier() != null && request.getValueName() != null) {
      _injector.removeValue(request.getIdentifier(), request.getValueName());;    } else if (request.getIdentifier() != null && request.getValueName() != null) {
      _injector.removeValue(request.getIdentifier(), request.getValueName());;    } else if (request.getValueSpecification() != null) {
      _injector.removeValue(request.getValueSpecification());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c9cef_79f38/rev_c9cef-79f38;/src/java/org/apache/cassandra/hadoop/cql3/CqlPagingRecordReader;retrieveKeys();        parseKeyValidators(ByteBufferUtil.string(ByteBuffer.wrap(cqlRow.columns.get(2).getValue())));;        parseKeyValidators(ByteBufferUtil.string(ByteBuffer.wrap(cqlRow.columns.get(2).getValue())));
        ;        Column rawKeyValidator = cqlRow.columns.get(2);
        String validator = ByteBufferUtil.string(ByteBuffer.wrap(rawKeyValidator.getValue()));
        logger.debug("row key validator: {}", validator);
        keyValidator = parseType(validator);

        if (keyValidator instanceof CompositeType)
        {
            List<AbstractType<?>> types = ((CompositeType) keyValidator).types;
            for (int i = 0; i < partitionBoundColumns.size(); i++)
                partitionBoundColumns.get(i).validator = types.get(i);
        }
        else
        {
            partitionBoundColumns.get(0).validator = keyValidator;
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c27cd_21734/rev_c27cd-21734;/tests/unit/com/opengamma/math/rootfinding/MultiInstrumentSingleCurveBootStrap;testSingleJacobian();    //    final JacobianCalculator jacobianFD = new FiniteDifferenceJacobianCalculator(1e-8);
    //    final DoubleMatrix2D jacExact = SINGLE_CURVE_JACOBIAN.evaluate(X0, SINGLE_CURVE_FINDER);
    //    final DoubleMatrix2D jacFD = jacobianFD.evaluate(X0, SINGLE_CURVE_FINDER);
    //    //System.out.println("exact: " + jacExact.toString());
    //System.out.println("FD: " + jacFD.toString());;    final JacobianCalculator jacobianFD = new FiniteDifferenceJacobianCalculator(1e-8);
    final DoubleMatrix2D jacExact = SINGLE_CURVE_JACOBIAN.evaluate(X0, SINGLE_CURVE_FINDER);
    final DoubleMatrix2D jacFD = jacobianFD.evaluate(X0, SINGLE_CURVE_FINDER);
    //System.out.println("exact: " + jacExact.toString());
    //System.out.println("FD: " + jacFD.toString());;    final JacobianCalculator jacobianFD = new FiniteDifferenceJacobianCalculator(1e-8);
    final DoubleMatrix2D jacExact = SINGLE_CURVE_JACOBIAN.evaluate(X0, SINGLE_CURVE_FINDER);
    final DoubleMatrix2D jacFD = jacobianFD.evaluate(X0, SINGLE_CURVE_FINDER);
    // System.out.println("exact: " + jacExact.toString());
    // System.out.println("FD: " + jacFD.toString());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c57e7_db058/rev_c57e7-db058;/src/java/org/apache/cassandra/service/ReadResponseResolver;resolve();        if (logger_.isDebugEnabled())
            logger_.debug("digests verified");;		// If there was a digest query compare it with all the data digests
		// If there is a mismatch then throw an exception so that read repair can happen.
        if (digest != null)
        {
            
            for (ColumnFamily cf : versions)
            {
                ByteBuffer digest2 = ColumnFamily.digest(cf);
                if (!digest.equals(digest2))
                    throw new DigestMismatchException(key, digest, digest2);
            }
            if (logger_.isDebugEnabled())
                logger_.debug("digests verified");
        };		// If there was a digest query compare it with all the data digests
		// If there is a mismatch then throw an exception so that read repair can happen.
        if (digest != null)
        {
            
            for (ColumnFamily cf : versions)
            {
                ByteBuffer digest2 = ColumnFamily.digest(cf);
                if (!digest2.equals(digest))
                    throw new DigestMismatchException(key, digest, digest2);
            }
            if (logger_.isDebugEnabled())
                logger_.debug("digests verified");
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c96cc_696fe/rev_c96cc-696fe;/src/java/org/apache/cassandra/db/compaction/PrecompactedRow;merge(List<SSTableIdentityIterator>,CompactionController);        merge(returnCF, data, controller.cfs.indexManager.updaterFor(rows.get(0).getKey(), false));

        return returnCF;;            if (cf == null)
            {
                cf = thisCF;
                indexer = controller.cfs.indexManager.updaterFor(row.getKey(), false); // only init indexer once
            }
            else
            {
                // addAll is ok even if cf is an ArrayBackedSortedColumns
                cf.addAllWithSizeDelta(thisCF, HeapAllocator.instance, Functions.<IColumn>identity(), indexer);
            }
        }
        return cf;;            if (cf == null)
            {
                cf = thisCF;
                indexer = controller.cfs.indexManager.updaterFor(row.getKey(), false); // only init indexer once
            }
            else
            {
                // addAll is ok even if cf is an ArrayBackedSortedColumns
                cf.addAllWithSizeDelta(thisCF, HeapAllocator.instance, Functions.<Column>identity(), indexer);
            }
        }
        return cf;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c96cc_696fe/rev_c96cc-696fe;/src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable;call();                    returnCF.delete(row.cf);
                    data.add(FBUtilities.closeableIterator(row.cf.iterator()));;                    ColumnFamily thisCF = row.cf;
                    if (cf == null)
                    {
                        cf = thisCF;
                    }
                    else
                    {
                        // addAll is ok even if cf is an ArrayBackedSortedColumns
                        SecondaryIndexManager.Updater indexer = controller.cfs.indexManager.updaterFor(row.key, false);
                        cf.addAllWithSizeDelta(thisCF, HeapAllocator.instance, Functions.<IColumn>identity(), indexer);
                    };                    ColumnFamily thisCF = row.cf;
                    if (cf == null)
                    {
                        cf = thisCF;
                    }
                    else
                    {
                        // addAll is ok even if cf is an ArrayBackedSortedColumns
                        SecondaryIndexManager.Updater indexer = controller.cfs.indexManager.updaterFor(row.key, false);
                        cf.addAllWithSizeDelta(thisCF, HeapAllocator.instance, Functions.<Column>identity(), indexer);
                    }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c96cc_696fe/rev_c96cc-696fe;/test/unit/org/apache/cassandra/db/compaction/CompactionsPurgeTest;testMinTimestampPurge();        // we should have both the c1 and c2 tombstones still, since the c2 timestamp is older than the c1 tombstone
        // so it would be invalid to assume we can throw out the c1 entry.
        ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, new QueryPath(cfName)));
        Assert.assertFalse(cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());;        ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, new QueryPath(cfName)));
        Assert.assertTrue(!cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());;        ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, cfName));
        Assert.assertTrue(!cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_c254b_6d65c/rev_c254b-6d65c;/lucene/core/src/java/org/apache/lucene/index/SegmentMerger;mergeDocValues(SegmentWriteState);              toMerge.add(values);;              consumer.mergeSortedField(field, mergeState, toMerge);
            } else {
              throw new AssertionError("type=" + type);;              consumer.mergeSortedField(field, mergeState, toMerge);
            } else if (type == DocValuesType.SORTED_SET) {
              List<SortedSetDocValues> toMerge = new ArrayList<SortedSetDocValues>();
              for (AtomicReader reader : mergeState.readers) {
                SortedSetDocValues values = reader.getSortedSetDocValues(field.name);
                if (values == null) {
                  values = SortedSetDocValues.EMPTY;
                }
                toMerge.add(values);
              }
              consumer.mergeSortedSetField(field, mergeState, toMerge);
            } else {
              throw new AssertionError("type=" + type);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_c327a_33425/rev_c327a-33425;/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen;generatePrimaryConstructor();            if (declaration instanceof JetFunction) {
                overridden.addAll(state.getBindingContext().getFunctionDescriptor((JetFunction) declaration).getOverriddenFunctions());;            if (declaration instanceof JetFunction) {
                overridden.addAll(bindingContext.getFunctionDescriptor((JetFunction) declaration).getOverriddenFunctions());;            if (declaration instanceof JetNamedFunction) {
                overridden.addAll(bindingContext.getFunctionDescriptor((JetNamedFunction) declaration).getOverriddenFunctions());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_c327a_33425/rev_c327a-33425;/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen;generateDelegates(JetClassOrObject,JetClass,OwnerKind,Set<FunctionDescriptor>);            else if (declaration instanceof JetFunction) {
                if (!overriden.contains(state.getBindingContext().getFunctionDescriptor((JetFunction) declaration))) {
                    functionCodegen.gen((JetFunction) declaration, kind);;            else if (declaration instanceof JetFunction) {
                if (!overriden.contains(bindingContext.getFunctionDescriptor((JetFunction) declaration))) {
                    functionCodegen.gen((JetFunction) declaration, kind);;            else if (declaration instanceof JetNamedFunction) {
                if (!overriden.contains(bindingContext.getFunctionDescriptor((JetNamedFunction) declaration))) {
                    functionCodegen.gen((JetNamedFunction) declaration, kind);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c565b_96a46/rev_c565b-96a46;/src/java/org/apache/cassandra/tools/NodeCmd;printUsage();        StringBuilder header = new StringBuilder();
        header.append("\nAvailable commands:\n");
        // No args
        addCmdHelp(header, "join", "Join the ring");
        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
        addCmdHelp(header, "cfstats", "Print statistics on column families");
        addCmdHelp(header, "version", "Print cassandra version");
        addCmdHelp(header, "tpstats", "Print usage statistics of thread pools");
        addCmdHelp(header, "proxyhistograms", "Print statistic histograms for network operations");
        addCmdHelp(header, "drain", "Drain the node (stop accepting writes and flush all column families)");
        addCmdHelp(header, "decommission", "Decommission the *node I am connecting to*");
        addCmdHelp(header, "compactionstats", "Print statistics on compactions");
        addCmdHelp(header, "disablegossip", "Disable gossip (effectively marking the node dead)");
        addCmdHelp(header, "enablegossip", "Reenable gossip");
        addCmdHelp(header, "disablethrift", "Disable thrift server");
        addCmdHelp(header, "enablethrift", "Reenable thrift server");
        addCmdHelp(header, "statusthrift", "Status of thrift server");
        addCmdHelp(header, "gossipinfo", "Shows the gossip information for the cluster");
        addCmdHelp(header, "invalidatekeycache", "Invalidate the key cache");
        addCmdHelp(header, "invalidaterowcache", "Invalidate the row cache");
        addCmdHelp(header, "resetlocalschema", "Reset node's local schema and resync");

        // One arg
        addCmdHelp(header, "ring [keyspace]", "Print information about the token ring for a given keyspace (for all keyspaces if it is not specified)");
        addCmdHelp(header, "netstats [host]", "Print network information on provided host (connecting node by default)");
        addCmdHelp(header, "move <new token>", "Move node on the token ring to a new token");
        addCmdHelp(header, "removetoken status|force|<token>", "Show status of current token removal, force completion of pending removal or remove providen token");
        addCmdHelp(header, "setcompactionthroughput <value_in_mb>", "Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling.");
        addCmdHelp(header, "setstreamthroughput <value_in_mb>", "Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling.");
        addCmdHelp(header, "describering [keyspace]", "Shows the token ranges info of a given keyspace.");
        addCmdHelp(header, "rangekeysample", "Shows the sampled keys held across all keyspaces.");
        addCmdHelp(header, "rebuild [src-dc-name]", "Rebuild data by streaming from other nodes (similarly to bootstrap)");

        // Two args
        addCmdHelp(header, "snapshot [keyspaces...] -cf [columnfamilyName] -t [snapshotName]", "Take a snapshot of the optionally specified column family of the specified keyspaces using optional name snapshotName");
        addCmdHelp(header, "clearsnapshot [keyspaces...] -t [snapshotName]", "Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name.");
        addCmdHelp(header, "flush [keyspace] [cfnames]", "Flush one or more column family");
        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -pr to repair only the first range returned by the partitioner)");
        addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
        addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
        addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");

        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
        addCmdHelp(header, "getcompactionthreshold <keyspace> <cfname>", "Print min and max compaction thresholds for a given column family");
        addCmdHelp(header, "cfhistograms <keyspace> <cfname>", "Print statistic histograms for a given column family");
        addCmdHelp(header, "refresh <keyspace> <cf-name>", "Load newly placed SSTables to the system without restart.");
        addCmdHelp(header, "rebuild_index <keyspace> <cf-name> <idx1,idx1>", "a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1");
        addCmdHelp(header, "setcachecapacity <key-cache-capacity> <row-cache-capacity>", "Set global key and row cache capacities (in MB units).");

        // Three args
        addCmdHelp(header, "getendpoints <keyspace> <cf> <key>", "Print the end points that owns the key");
        addCmdHelp(header, "getsstables <keyspace> <cf> <key>", "Print the sstable filenames that own the key");

        // Four args
        addCmdHelp(header, "setcompactionthreshold <keyspace> <cfname> <minthreshold> <maxthreshold>", "Set the min and max compaction thresholds for a given column family");
        addCmdHelp(header, "stop <compaction_type>", "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD");;        StringBuilder header = new StringBuilder();
        header.append("\nAvailable commands:\n");
        // No args
        addCmdHelp(header, "ring", "Print information about the token ring");
        addCmdHelp(header, "join", "Join the ring");
        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
        addCmdHelp(header, "cfstats", "Print statistics on column families");
        addCmdHelp(header, "version", "Print cassandra version");
        addCmdHelp(header, "tpstats", "Print usage statistics of thread pools");
        addCmdHelp(header, "proxyhistograms", "Print statistic histograms for network operations");
        addCmdHelp(header, "drain", "Drain the node (stop accepting writes and flush all column families)");
        addCmdHelp(header, "decommission", "Decommission the *node I am connecting to*");
        addCmdHelp(header, "compactionstats", "Print statistics on compactions");
        addCmdHelp(header, "disablegossip", "Disable gossip (effectively marking the node dead)");
        addCmdHelp(header, "enablegossip", "Reenable gossip");
        addCmdHelp(header, "disablethrift", "Disable thrift server");
        addCmdHelp(header, "enablethrift", "Reenable thrift server");
        addCmdHelp(header, "statusthrift", "Status of thrift server");
        addCmdHelp(header, "gossipinfo", "Shows the gossip information for the cluster");
        addCmdHelp(header, "invalidatekeycache", "Invalidate the key cache");
        addCmdHelp(header, "invalidaterowcache", "Invalidate the row cache");
        addCmdHelp(header, "resetlocalschema", "Reset node's local schema and resync");

        // One arg
        addCmdHelp(header, "netstats [host]", "Print network information on provided host (connecting node by default)");
        addCmdHelp(header, "move <new token>", "Move node on the token ring to a new token");
        addCmdHelp(header, "removetoken status|force|<token>", "Show status of current token removal, force completion of pending removal or remove providen token");
        addCmdHelp(header, "setcompactionthroughput <value_in_mb>", "Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling.");
        addCmdHelp(header, "setstreamthroughput <value_in_mb>", "Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling.");
        addCmdHelp(header, "describering [keyspace]", "Shows the token ranges info of a given keyspace.");
        addCmdHelp(header, "rangekeysample", "Shows the sampled keys held across all keyspaces.");
        addCmdHelp(header, "rebuild [src-dc-name]", "Rebuild data by streaming from other nodes (similarly to bootstrap)");

        // Two args
        addCmdHelp(header, "snapshot [keyspaces...] -cf [columnfamilyName] -t [snapshotName]", "Take a snapshot of the optionally specified column family of the specified keyspaces using optional name snapshotName");
        addCmdHelp(header, "clearsnapshot [keyspaces...] -t [snapshotName]", "Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name.");
        addCmdHelp(header, "flush [keyspace] [cfnames]", "Flush one or more column family");
        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -pr to repair only the first range returned by the partitioner)");
        addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
        addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
        addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");

        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
        addCmdHelp(header, "getcompactionthreshold <keyspace> <cfname>", "Print min and max compaction thresholds for a given column family");
        addCmdHelp(header, "cfhistograms <keyspace> <cfname>", "Print statistic histograms for a given column family");
        addCmdHelp(header, "refresh <keyspace> <cf-name>", "Load newly placed SSTables to the system without restart.");
        addCmdHelp(header, "rebuild_index <keyspace> <cf-name> <idx1,idx1>", "a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1");
        addCmdHelp(header, "setcachecapacity <key-cache-capacity> <row-cache-capacity>", "Set global key and row cache capacities (in MB units).");

        // Three args
        addCmdHelp(header, "getendpoints <keyspace> <cf> <key>", "Print the end points that owns the key");
        addCmdHelp(header, "getsstables <keyspace> <cf> <key>", "Print the sstable filenames that own the key");

        // Four args
        addCmdHelp(header, "setcompactionthreshold <keyspace> <cfname> <minthreshold> <maxthreshold>", "Set the min and max compaction thresholds for a given column family");
        addCmdHelp(header, "stop <compaction_type>", "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD");;        StringBuilder header = new StringBuilder(512);
        header.append("\nAvailable commands\n");
        final NodeToolHelp ntHelp = loadHelp();
        for(NodeToolHelp.NodeToolCommand cmd : ntHelp.commands)
            addCmdHelp(header, cmd);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c573c_cd806/rev_c573c-cd806;/src/java/org/apache/cassandra/tools/NodeProbe;getCfsProxy(String,String);            Set<ObjectName> beans = mbeanServerConn.queryNames(new ObjectName("org.apache.cassandra.db:type=*ColumnFamilies,keyspace=" + ks + ",columnfamily=" + cf), null);
            if (beans.isEmpty())
                throw new MalformedObjectNameException("couldn't find that bean");
            assert beans.size() == 1;
            for (ObjectName bean : beans)
                cfsProxy = JMX.newMBeanProxy(mbeanServerConn, bean, ColumnFamilyStoreMBean.class);;            cfsProxy = JMX.newMBeanProxy(mbeanServerConn,
                    new ObjectName("org.apache.cassandra.db:type=ColumnFamilies,keyspace="+ks+",columnfamily="+cf), 
                    ColumnFamilyStoreMBean.class);;            cfsProxy = JMX.newMBeanProxy(mbeanServerConn,
                    new ObjectName("org.apache.cassandra.db:type=ColumnFamilies,keyspace="+ks+",columnfamily="+cf),
                    ColumnFamilyStoreMBean.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c710e_ec14b/rev_c710e-ec14b;/src/java/org/apache/cassandra/io/sstable/SSTableReader;getPosition(RowPosition,Operator,boolean);
                            if (logger.isTraceEnabled())
                            {
                                // expensive sanity check!  see CASSANDRA-4687
                                FileDataInput fdi = dfile.getSegment(dataPosition);
                                DecoratedKey keyInDisk = SSTableReader.decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(fdi));
                                if (!keyInDisk.equals(key))
                                    throw new AssertionError(String.format("%s != %s in %s", keyInDisk, key, fdi.getPath()));
                                fdi.close();
                            }

                            if (keyCache != null && keyCache.getCapacity() > 0 && updateCacheAndStats)
                            {
                                // store exact match for the key
                                cacheKey(decoratedKey, dataPosition);
                            };                            // store exact match for the key
                            cacheKey(decoratedKey, dataPosition);;                            // store exact match for the key
                            cacheKey(decoratedKey, indexEntry);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_c785a_6ec46/rev_c785a-6ec46;/subprojects/plugins/src/main/groovy/org/gradle/api/tasks/compile/Compile;maybeCompileIncrementally(IncrementalTaskInputs);        SelectiveCompilation selectiveCompilation = new SelectiveCompilation(inputs, getSource(), getClasspath(), getDestinationDir(),
                dependencyInfoSerializer, getJarSnapshotCache(), compiler, sourceDirs, (FileOperations) getProject());;        SelectiveCompilation selectiveCompilation = new SelectiveCompilation(inputs, getSource(), getClasspath(), getDestinationDir(),
                getDependencyInfoSerializer(), getJarSnapshotCache(), compiler, sourceDirs, (FileOperations) getProject());;        SelectiveCompilation selectiveCompilation = incrementalCompilation.createSelectiveCompilation(
                inputs, getSource(), getClasspath(), getDestinationDir(), compiler, sourceDirs);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c890e_0f69c/rev_c890e-0f69c;/projects/OG-Web/src/com/opengamma/web/server/push/rest/TimeSeriesResolverKeysResource;getResolverKeys();    List<String> keyNames = Lists.newArrayList();
    for (ConfigDocument<HistoricalTimeSeriesRating> doc : ConfigMasterIterator.iterable(_configMaster, request)) {
      keyNames.add(doc.getName());;    ConfigSearchResult<HistoricalTimeSeriesRating> result = _configMaster.search(request);
    List<ConfigDocument<HistoricalTimeSeriesRating>> documents = result.getDocuments();
    List<String> keyNames = Lists.newArrayListWithCapacity(documents.size());
    for (ConfigDocument<HistoricalTimeSeriesRating> document : documents) {
      keyNames.add(document.getName());;    ConfigSearchResult<HistoricalTimeSeriesRating> result = _configMaster.search(request);
    List<ConfigItem<HistoricalTimeSeriesRating>> configItems = result.getValues();
    List<String> keyNames = Lists.newArrayListWithCapacity(configItems.size());
    for (ConfigItem<HistoricalTimeSeriesRating> document : configItems) {
      keyNames.add(document.getName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c890e_0f69c/rev_c890e-0f69c;/projects/OG-Integration/src/com/opengamma/integration/tool/marketdata/CurveHtsResolverTool;getCurveDefinitionNames(ConfigMaster,String);    ConfigSearchRequest<YieldCurveDefinition> request = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    request.setName(nameExpr);
    for (ConfigDocument<YieldCurveDefinition> doc : ConfigMasterIterator.iterable(configMaster, request)) {
      results.add(doc.getValue());;    ConfigSearchRequest<YieldCurveDefinition> searchReq = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    searchReq.setName(nameExpr);
    ConfigSearchResult<YieldCurveDefinition> result = configMaster.search(searchReq);
    for (ConfigDocument<YieldCurveDefinition> document : result.getDocuments()) {
      results.add(document.getValue());;    ConfigSearchRequest<YieldCurveDefinition> searchReq = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    searchReq.setName(nameExpr);
    ConfigSearchResult<YieldCurveDefinition> result = configMaster.search(searchReq);
    for (ConfigItem<YieldCurveDefinition> document : result.getValues()) {
      results.add(document.getValue());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c890e_0f69c/rev_c890e-0f69c;/projects/OG-Integration/src/com/opengamma/integration/tool/marketdata/MarketDataSnapshotTool;doRun();      ConfigSearchRequest<ViewDefinition> request = new ConfigSearchRequest<ViewDefinition>(ViewDefinition.class);
      request.setName(viewDefinitionName);
      for (ConfigDocument<ViewDefinition> doc : ConfigMasterIterator.iterable(configMaster, request)) {
        task = new FutureTask<List<StructuredMarketDataSnapshot>>(new SingleSnapshotter(marketDataSnapshotter, viewProcessor, doc.getValue(), viewExecutionOptions, task));;      ConfigSearchRequest<ViewDefinition> searchRequest = new ConfigSearchRequest<ViewDefinition>(ViewDefinition.class);
      searchRequest.setName(viewDefinitionName);
      ConfigSearchResult<ViewDefinition> searchResult = configMaster.search(searchRequest);
      for (ViewDefinition viewDefinition : searchResult.getValues()) {
        task = new FutureTask<List<StructuredMarketDataSnapshot>>(new SingleSnapshotter(marketDataSnapshotter, viewProcessor, viewDefinition, viewExecutionOptions, task));;      ConfigSearchRequest<ViewDefinition> searchRequest = new ConfigSearchRequest<ViewDefinition>(ViewDefinition.class);
      searchRequest.setName(viewDefinitionName);
      ConfigSearchResult<ViewDefinition> searchResult = configMaster.search(searchRequest);
      for (ConfigItem<ViewDefinition> viewDefinition : searchResult.getValues()) {
        task = new FutureTask<List<StructuredMarketDataSnapshot>>(new SingleSnapshotter(marketDataSnapshotter, viewProcessor, viewDefinition.getValue(), viewExecutionOptions, task));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c890e_0f69c/rev_c890e-0f69c;/projects/OG-BloombergExample/src/com/opengamma/bloombergexample/loader/CurveNodeHistoricalDataLoader;getCurveDefinitionNames(ConfigMaster,String);    ConfigSearchRequest<YieldCurveDefinition> request = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    request.setName(nameExpr);
    for (ConfigDocument<YieldCurveDefinition> doc : ConfigMasterIterator.iterable(configMaster, request)) {
      results.add(doc.getValue());;    ConfigSearchRequest<YieldCurveDefinition> searchReq = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    searchReq.setName(nameExpr);
    ConfigSearchResult<YieldCurveDefinition> result = configMaster.search(searchReq);
    for (ConfigDocument<YieldCurveDefinition> document : result.getDocuments()) {
      results.add(document.getValue());;    ConfigSearchRequest<YieldCurveDefinition> searchReq = new ConfigSearchRequest<YieldCurveDefinition>(YieldCurveDefinition.class);
    searchReq.setName(nameExpr);
    ConfigSearchResult<YieldCurveDefinition> result = configMaster.search(searchReq);
    for (ConfigItem<YieldCurveDefinition> document : result.getValues()) {
      results.add(document.getValue());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2025_4bff2/rev_c2025-4bff2;/projects/OG-Analytics/src/com/opengamma/financial/model/volatility/surface/PiecewiseSABRSurfaceFitter;getSurfaceLinear();  public BlackVolatilitySurfaceMoneyness getSurfaceLinear() {
    Function<Double, Double> surFunc = new Function<Double, Double>() {;  private BlackVolatilitySurfaceStrike getSurfaceLinear() {
    Function<Double, Double> surFunc = new Function<Double, Double>() {;  private BlackVolatilitySurfaceStrike getSurfaceLinear() {
    final Function<Double, Double> surFunc = new Function<Double, Double>() {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c2025_4bff2/rev_c2025-4bff2;/projects/OG-Analytics/src/com/opengamma/financial/model/volatility/surface/PiecewiseSABRSurfaceFitter;getSurfaceLinear();        double dt = times[1] - times[0];
        double logVar = ((times[1] - logT) * sample[0] + (logT - times[0]) * sample[1]) / dt;
        double var = Math.exp(logVar);

        return Math.sqrt(var / t);;        double dt = times[1] - times[0];
        double var = ((times[1] - t) * sample[0] + (t - times[0]) * sample[1]) / dt;;        final double dt = times[1] - times[0];
        final double var = ((times[1] - t) * sample[0] + (t - times[0]) * sample[1]) / dt;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c3157_bd481/rev_c3157-bd481;/src/java/org/apache/cassandra/db/Table;Table(String,boolean);        name = table;
        KSMetaData ksm = Schema.instance.getKSMetaData(table);
        assert ksm != null : "Unknown keyspace " + table;
        createReplicationStrategy(ksm);;        name = table;
        KSMetaData ksm = Schema.instance.getKSMetaData(table);
        assert ksm != null : "Unknown keyspace " + table;
        try
        {
            createReplicationStrategy(ksm);
        }
        catch (ConfigurationException e)
        {
            throw new RuntimeException(e);
        };        metadata = Schema.instance.getKSMetaData(table);
        assert metadata != null : "Unknown keyspace " + table;
        try
        {
            createReplicationStrategy(metadata);
        }
        catch (ConfigurationException e)
        {
            throw new RuntimeException(e);
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c3157_bd481/rev_c3157-bd481;/src/java/org/apache/cassandra/cql/CFPropDefs;validate();        CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionStrategyOptions, false);;        CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionStrategyOptions);;        Integer defaultTimeToLive = getPropertyInt(KW_DEFAULT_TIME_TO_LIVE, null);

        if (defaultTimeToLive != null)
        {
            if (defaultTimeToLive < 0)
                throw new InvalidRequestException(String.format("%s cannot be smaller than %s, (default %s)",
                        KW_DEFAULT_TIME_TO_LIVE,
                        0,
                        CFMetaData.DEFAULT_DEFAULT_TIME_TO_LIVE));
        }

        CFMetaData.validateCompactionOptions(compactionStrategyClass, compactionStrategyOptions);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c4736_d719e/rev_c4736-d719e;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;build();            logger.debug("estimated row count was %s of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, componentsFor(desc, false)));;            logger.debug("estimated row count was %s of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, SSTable.componentsFor(desc)));;            logger.debug("estimated row count was {} of real count", ((double)estimatedRows) / rows);
            return SSTableReader.open(rename(desc, SSTable.componentsFor(desc)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5;/src/java/voldemort/client/SocketStoreClientFactory;SocketStoreClientFactory(ClientConfig);                                                          config.isJmxEnabled(),
                                                          jmxId);;                                                          config.isJmxEnabled());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));;                                                          config.isJmxEnabled());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingFromSwapsTest;YieldCurveFittingFromSwapsTest();    _hotspotWarmupCycles = 0;
    _benchmarkCycles = 1;
    _interolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    _marketValueCalculator = PAR_RATE_DIFFERENCE_CALCULATOR;
    _marketValueSensitivityCalculator = PAR_RATE_SENSITIVITY_CALCULATOR;
    setupExtrapolator();
    setupSingleCurveInstruments();
    setupSingleCurveFinder();
    //setupDoubleCurveInstruments();
    //setupDoubleCurveFinder();;    _hotspotWarmupCycles = 0;
    _benchmarkCycles = 1;
    _interolatorName = Interpolator1DFactory.NATURAL_CUBIC_SPLINE;
    _marketValueCalculator = PAR_RATE_DIFFERENCE_CALCULATOR;
    _marketValueSensitivityCalculator = PAR_RATE_SENSITIVITY_CALCULATOR;
    setupExtrapolator();
    setupSingleCurveInstruments();
    setupSingleCurveFinder();;    _hotspotWarmupCycles = 200;
    _benchmarkCycles = 1000;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingFromSwapsTest;testNewton();    final NewtonVectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "Newton");;    NewtonVectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "Newton");;    NewtonVectorRootFinder rootFinder = new NewtonDefaultVectorRootFinder(EPS, EPS, STEPS);
    YieldCurveFittingTestDataBundle data = getSingleCurveSetup();
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: Newton");
    data.setTestType(TestType.FD_JACOBIAN);
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: Newton (FD Jacobian)");

    data = getDoubleCurveSetup();
    doHotSpot(rootFinder, data, "Double curve, swaps only. Root finder: Newton");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingFromSwapsTest;testShermanMorrison();    final NewtonVectorRootFinder rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "ShermanMorrison");;    NewtonVectorRootFinder rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "ShermanMorrison");;    NewtonVectorRootFinder rootFinder = new ShermanMorrisonVectorRootFinder(EPS, EPS, STEPS);
    YieldCurveFittingTestDataBundle data = getSingleCurveSetup();
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: ShermanMorrison");
    data.setTestType(TestType.FD_JACOBIAN);
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder:ShermanMorrison (FD Jacobian)");

    data = getDoubleCurveSetup();
    doHotSpot(rootFinder, data, "Double curve, swaps only. Root finder: ShermanMorrison");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c6191_9fafc/rev_c6191-9fafc;/tests/unit/com/opengamma/math/rootfinding/YieldCurveFittingFromSwapsTest;testBroyden();    final NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "Broyden");;    NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    testRootFindingMethods(rootFinder, "Broyden");;    NewtonVectorRootFinder rootFinder = new BroydenVectorRootFinder(EPS, EPS, STEPS);
    YieldCurveFittingTestDataBundle data = getSingleCurveSetup();
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: Broyden");
    data.setTestType(TestType.FD_JACOBIAN);
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: Broyden (FD Jacobian)");

    data = getDoubleCurveSetup();
    doHotSpot(rootFinder, data, "Single curve, swaps only. Root finder: Broyden");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c6867_42f85/rev_c6867-42f85;/src/java/org/apache/cassandra/dht/RangeStreamer;fetchAsync();                logger.debug("" + description + "ing from " + source + " ranges " + StringUtils.join(ranges, ", "));
            streamPlan.requestRanges(source, preferred, keyspace, ranges);;                logger.debug("" + description + "ing from " + source + " ranges " + StringUtils.join(ranges, ", "));
            streamPlan.requestRanges(source, keyspace, ranges);;                logger.debug("{}ing from {} ranges {}", description, source, StringUtils.join(ranges, ", "));
            streamPlan.requestRanges(source, keyspace, ranges);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c7260_5185f/rev_c7260-5185f;/projects/OG-Analytics/src/com/opengamma/financial/model/option/pricing/analytic/formula/BlackFunctionData;BlackFunctionData(double,double,double);public BlackFunctionData(final double f, final double df, final double sigma) {
    //    Validate.isTrue(df <= 1 && df > 0, "discount factor must be <= 1 and > 0");
    _f = f;
    _df = df;;public BlackFunctionData(final double f, final double df, final double sigma) {
    Validate.isTrue(df <= 1 && df > 0, "discount factor must be <= 1 and > 0");
    _f = f;
    _df = df;;public BlackFunctionData(final double forward, final double numeraire, final double sigma) {
   // Validate.isTrue(numeraire <= 1 && numeraire > 0, "discount factor must be <= 1 and > 0");
    _f = forward;
    _numeraire = numeraire;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c7260_5185f/rev_c7260-5185f;/projects/OG-Analytics/src/com/opengamma/financial/model/finiteDifference/ExplicitFiniteDifference2D;solve(ConvectionDiffusion2DPDEDataBundle,int,int,int,double,BoundaryCondition,BoundaryCondition,BoundaryCondition,BoundaryCondition,Cube<Double,Double,Double,Double>);
      for (int i = 0; i <= xSteps; i++) {
        vNew[i][0] = v[i][0];
        vNew[i][ySteps] = v[i][ySteps];;      
      for (int i = 0; i <= xSteps; i++) {
        vNew[i][0] = v[i][0];
        vNew[i][ySteps] = v[i][ySteps];;
      // for (int i = 0; i <= xSteps; i++) {
      // vNew[i][0] = v[i][0];
      // vNew[i][ySteps] = v[i][ySteps];
      // }
      // for (int j = 0; j <= ySteps; j++) {
      // vNew[0][j] = v[0][j];
      // vNew[xSteps][j] = v[xSteps][j];
      // }
      
      
      for (int i = 1; i < xSteps; i++) {
        double[] temp = yLowerBoundary.getRightMatrixCondition(pdeData, t);
        sum = 0;
        for (int n = 0; n < temp.length; n++) {
          sum += temp[n] * v[i][n];
        }
        double q = sum + yLowerBoundary.getConstant(pdeData, t);

        sum = 0;
        temp = yLowerBoundary.getLeftMatrixCondition(pdeData, t);
        for (int k1 = 1; k1 < temp.length; k1++) {
          sum += temp[k1] * vNew[i][k1];
        }
        vNew[i][0] = (q - sum) / temp[0];

        temp = yUpperBoundary.getRightMatrixCondition(pdeData, t);
        sum = 0;
        for (int n = 0; n < temp.length; n++) {
          sum += temp[n] * v[i][ySteps + n + 1 - temp.length];
        }
        q = sum + yUpperBoundary.getConstant(pdeData, t);

        sum = 0;
        temp = yUpperBoundary.getLeftMatrixCondition(pdeData, t);
        for (int k1 = 0; k1 < temp.length - 1; k1++) {
          sum += temp[k1] * vNew[i][ySteps + k1 + 1 - temp.length];
        }

        vNew[i][ySteps] = (q - sum) / temp[temp.length - 1];
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_c9499_501ae/rev_c9499-501ae;/src/java/org/apache/cassandra/streaming/IncomingStreamReader;readFile();                    long toRead = Math.min(FileStreamTask.CHUNK_SIZE, length - bytesRead);
                    long lastRead = fc.transferFrom(socketChannel, offset + bytesRead, toRead);
                    // if the other side fails, we will not get an exception, but instead transferFrom will constantly return 0 byte read
                    // and we would thus enter an infinite loop. So intead, if no bytes are tranferred we assume the other side is dead and 
                    // raise an exception (that will be catch belove and 'the right thing' will be done).
                    if (lastRead == 0)
                        throw new IOException("Transfer failed for remote file " + remoteFile);
                    bytesRead += lastRead;
                    remoteFile.progress += lastRead;;                    long toRead = Math.min(FileStreamTask.CHUNK_SIZE, length - bytesRead);
                    long lastRead = fc.transferFrom(socketChannel, offset + bytesRead, toRead);
                    bytesRead += lastRead;
                    remoteFile.progress += lastRead;;                    bytesRead = readnwrite(length, bytesRead, offset, fc);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_c9802_d863a/rev_c9802-d863a;/projects/OG-Engine/src/com/opengamma/engine/view/calcnode/AbstractCalculationNode;executeJobItems(CalculationJob,DelayedViewComputationCache,CompiledFunctionRepository,String);        // litter the logs with stack traces; the inputs missing have also already been
        // written at INFO level
        s_logger.warn("Unable to invoke {} due to missing inputs", jobItem);;        // litter the logs with stack traces.
        s_logger.warn("Unable to invoke {} due to missing inputs: {}", jobItem, e.getMessage());;        // litter the logs with stack traces.
        s_logger.warn("Unable to invoke {} due to {} missing inputs", jobItem, e.getMissingInputs().size());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ca3c7_523e6/rev_ca3c7-523e6;/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement;validate(ClientState);        switch (name.kind)
        {
            case KEY_ALIAS:
            case COLUMN_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on PRIMARY KEY part %s", columnName));
            case VALUE_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on column %s of compact CF", columnName));
            case COLUMN_METADATA:
                ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);

                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");

                if (cd.getValidator().isCollection() && !isCustom)
                    throw new InvalidRequestException("Indexes on collections are no yet supported");

                props.validate(isCustom);
                break;
            default:
                throw new AssertionError();
        };        switch (name.kind)
        {
            case KEY_ALIAS:
            case COLUMN_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on PRIMARY KEY part %s", columnName));
            case VALUE_ALIAS:
                throw new InvalidRequestException(String.format("Cannot create index on column %s of compact CF", columnName));
            case COLUMN_METADATA:
                ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);

                if (cd.getIndexType() != null)
                    throw new InvalidRequestException("Index already exists");

                if (cd.getValidator().isCollection())
                    throw new InvalidRequestException("Indexes on collections are no yet supported");

                props.validate(isCustom);
                break;
            default:
                throw new AssertionError();
        };        if (cd.getIndexType() != null)
            throw new InvalidRequestException("Index already exists");

        // TODO: we could lift that limitation
        if (cfm.getCfDef().isCompact && cd.type != ColumnDefinition.Type.REGULAR)
            throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));

        if (cd.getValidator().isCollection())
            throw new InvalidRequestException("Indexes on collections are no yet supported");

        if (cd.type == ColumnDefinition.Type.PARTITION_KEY && (cd.componentIndex == null || cd.componentIndex == 0))
            throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", columnName));

        props.validate(isCustom);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_cae82_2ad01/rev_cae82-2ad01;/projects/OG-Engine/tests/unit/com/opengamma/engine/function/resolver/DefaultFunctionResolverTest;nonGlobalRuleSelection();    ComputationTarget anotherTarget = new ComputationTarget(UniqueId.of("scheme", "target2"));
    result = _resolver.resolveFunction(new ValueRequirement("req1", anotherTarget.toSpecification()), new DependencyNode(anotherTarget)).next();;    ComputationTarget anotherTarget = new ComputationTarget(UniqueIdentifier.of("scheme", "target2"));
    result = _resolver.resolveFunction(new ValueRequirement("req1", anotherTarget.toSpecification()), new DependencyNode(anotherTarget)).next();;    ComputationTarget anotherTarget = new ComputationTarget(UniqueIdentifier.of("scheme", "target2"));
    result = _resolver.resolveFunction(new ValueRequirement("req1", anotherTarget.toSpecification()), anotherTarget).next();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01;/src/java/voldemort/VoldemortClientShell;main(String[]);        StoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(bootstrapUrl));
        client = null;;        StoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(bootstrapUrl));
        DefaultStoreClient<Object, Object> client = null;;        ClientConfig clientConfig = new ClientConfig().setBootstrapUrls(bootstrapUrl);
        StoreClientFactory factory = new SocketStoreClientFactory(clientConfig);

        DefaultStoreClient<Object, Object> client = null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01;/src/java/voldemort/VoldemortClientShell;main(String[]);        if(fileReader != null) {
            processCommands(fileReader, true);
            fileReader.close();;        for(String line = reader.readLine(); line != null; line = reader.readLine()) {
            if(line.trim().equals(""))
                continue;
            try {
                if(line.toLowerCase().startsWith("put")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("put".length())));
                    client.put(tightenNumericTypes(jsonReader.read()),
                               tightenNumericTypes(jsonReader.read()));
                } else if(line.toLowerCase().startsWith("getall")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("getall".length())));
                    List<Object> keys = new ArrayList<Object>();
                    try {
                        while(true)
                            keys.add(jsonReader.read());
                    } catch(EndOfFileException e) {
                        // this is okay, just means we are done reading
                    }
                    Map<Object, Versioned<Object>> vals = client.getAll(keys);
                    for(Map.Entry<Object, Versioned<Object>> entry: vals.entrySet()) {
                        System.out.print(entry.getKey());
                        System.out.print(" => ");
                        printVersioned(entry.getValue());
                    }
                } else if(line.toLowerCase().startsWith("get")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("get".length())));
                    printVersioned(client.get(tightenNumericTypes(jsonReader.read())));
                } else if(line.toLowerCase().startsWith("delete")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("delete".length())));
                    client.delete(tightenNumericTypes(jsonReader.read()));
                } else if(line.startsWith("locate")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("locate".length())));
                    Object key = tightenNumericTypes(jsonReader.read());
                    printNodeList(client.getResponsibleNodes(key));
                } else if(line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("put key value -- Associate the given value with the key.");
                    System.out.println("get key -- Retrieve the value associated with the key.");
                    System.out.println("delete key -- Remove all values associated with the key.");
                    System.out.println("locate key -- Determine which servers host the give key.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if(line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch(EndOfFileException e) {
                System.err.println("Expected additional token.");
            } catch(SerializationException e) {
                System.err.print("Error serializing values: ");
                e.printStackTrace();
            } catch(VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace(System.err);
            } catch(ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch(Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);;        for(String line = reader.readLine(); line != null; line = reader.readLine()) {
            if(line.trim().equals(""))
                continue;
            try {
                if(line.toLowerCase().startsWith("put")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("put".length())));
                    client.put(tightenNumericTypes(jsonReader.read()),
                               tightenNumericTypes(jsonReader.read()));
                } else if(line.toLowerCase().startsWith("getall")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("getall".length())));
                    List<Object> keys = new ArrayList<Object>();
                    try {
                        while(true)
                            keys.add(jsonReader.read());
                    } catch(EndOfFileException e) {
                        // this is okay, just means we are done reading
                    }
                    Map<Object, Versioned<Object>> vals = client.getAll(keys);
                    for(Map.Entry<Object, Versioned<Object>> entry: vals.entrySet()) {
                        System.out.print(entry.getKey());
                        System.out.print(" => ");
                        printVersioned(entry.getValue());
                    }
                } else if(line.toLowerCase().startsWith("get")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("get".length())));
                    printVersioned(client.get(tightenNumericTypes(jsonReader.read())));
                } else if(line.toLowerCase().startsWith("delete")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("delete".length())));
                    client.delete(tightenNumericTypes(jsonReader.read()));
                } else if(line.startsWith("locate")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("locate".length())));
                    Object key = tightenNumericTypes(jsonReader.read());
                    printNodeList(client.getResponsibleNodes(key),
                                  factory.getFailureDetector());
                } else if(line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("put key value -- Associate the given value with the key.");
                    System.out.println("get key -- Retrieve the value associated with the key.");
                    System.out.println("delete key -- Remove all values associated with the key.");
                    System.out.println("locate key -- Determine which servers host the give key.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if(line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch(EndOfFileException e) {
                System.err.println("Expected additional token.");
            } catch(SerializationException e) {
                System.err.print("Error serializing values: ");
                e.printStackTrace();
            } catch(VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace(System.err);
            } catch(ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch(Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01;/test/unit/voldemort/cluster/TestCluster;setUp();    public void setUp() {
        this.nodes = ImmutableList.of(new Node(1,
                                               "test1",
                                               1,
                                               1,
                                               1,
                                               ImmutableList.of(1, 2, 3),
                                               new NodeStatus(time)),
                                      new Node(2,
                                               "test1",
                                               2,
                                               2,
                                               2,
                                               ImmutableList.of(3, 5, 6),
                                               new NodeStatus(time)),
                                      new Node(3,
                                               "test1",
                                               3,
                                               3,
                                               3,
                                               ImmutableList.of(7, 8, 9),
                                               new NodeStatus(time)),
                                      new Node(4,
                                               "test1",
                                               4,
                                               4,
                                               4,
                                               ImmutableList.of(10, 11, 12),
                                               new NodeStatus(time)));;    public void setUp() {
        this.nodes = ImmutableList.of(new Node(1,
                                               "test1",
                                               1,
                                               1,
                                               ImmutableList.of(1, 2, 3),
                                               new NodeStatus(time)),
                                      new Node(2,
                                               "test1",
                                               2,
                                               2,
                                               ImmutableList.of(3, 5, 6),
                                               new NodeStatus(time)),
                                      new Node(3,
                                               "test1",
                                               3,
                                               3,
                                               ImmutableList.of(7, 8, 9),
                                               new NodeStatus(time)),
                                      new Node(4,
                                               "test1",
                                               4,
                                               4,
                                               ImmutableList.of(10, 11, 12),
                                               new NodeStatus(time)));;    @Before
    public void setUp() throws Exception {
        this.nodes = ImmutableList.of(new Node(1, "test1", 1, 1, ImmutableList.of(1, 2, 3)),
                                      new Node(2, "test1", 2, 2, ImmutableList.of(3, 5, 6)),
                                      new Node(3, "test1", 3, 3, ImmutableList.of(7, 8, 9)),
                                      new Node(4, "test1", 4, 4, ImmutableList.of(10, 11, 12)));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_cb0c2_c891d/rev_cb0c2-c891d;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/bond/BondFixedTransactionDefinitionTest;testGetters();    assertEquals(DateUtils.getUTCDate(2011, 7, 13), BOND_TRANSACTION_DEFINITION.getPreviousAccrualDate());
    assertEquals(DateUtils.getUTCDate(2012, 1, 13), BOND_TRANSACTION_DEFINITION.getNextAccrualDate());
    assertEquals(-PRICE * QUANTITY, BOND_TRANSACTION_DEFINITION.getPaymentAmount());;    assertEquals(DateUtil.getUTCDate(2011, 7, 13), BOND_TRANSACTION_DEFINITION.getPreviousAccrualDate());
    assertEquals(DateUtil.getUTCDate(2012, 1, 13), BOND_TRANSACTION_DEFINITION.getNextAccrualDate());
    assertEquals(-PRICE * QUANTITY, BOND_TRANSACTION_DEFINITION.getPaymentAmount());;    assertEquals(DateUtil.getUTCDate(2011, 7, 13), BOND_TRANSACTION_DEFINITION.getPreviousAccrualDate());
    assertEquals(DateUtil.getUTCDate(2012, 1, 13), BOND_TRANSACTION_DEFINITION.getNextAccrualDate());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_cb0c2_c891d/rev_cb0c2-c891d;/projects/OG-Analytics/tests/unit/com/opengamma/financial/instrument/bond/BondIborTransactionDefinitionTest;testGetters();    assertEquals(DateUtils.getUTCDate(2011, 7, 13), BOND_TRANSACTION.getPreviousAccrualDate());
    assertEquals(DateUtils.getUTCDate(2011, 10, 13), BOND_TRANSACTION.getNextAccrualDate());
    assertEquals(-PRICE * QUANTITY, BOND_TRANSACTION.getPaymentAmount());;    assertEquals(DateUtil.getUTCDate(2011, 7, 13), BOND_TRANSACTION.getPreviousAccrualDate());
    assertEquals(DateUtil.getUTCDate(2011, 10, 13), BOND_TRANSACTION.getNextAccrualDate());
    assertEquals(-PRICE * QUANTITY, BOND_TRANSACTION.getPaymentAmount());;    assertEquals(DateUtil.getUTCDate(2011, 7, 13), BOND_TRANSACTION.getPreviousAccrualDate());
    assertEquals(DateUtil.getUTCDate(2011, 10, 13), BOND_TRANSACTION.getNextAccrualDate());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_cb7a2_eb738/rev_cb7a2-eb738;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;prepare();                if (!stmt.metadataRestrictions.isEmpty())
                    throw new InvalidRequestException("ORDER BY with 2ndary indexes is not supported.");

                if (stmt.isKeyRange());                if (stmt.isKeyRange());                if (stmt.isKeyRange)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_cb35f_a98a4/rev_cb35f-a98a4;/tightdb-java-test/src/test/java/com/tightdb/JNITransactions;mustWriteCommit();		writeOneTransaction();
		;		// Write to DB
		{	
	        WriteTransaction t = db.beginWrite();
	        EmployeeTable employees = new EmployeeTable(t);
	        employees.add("John", "Doe", 10000, true);
			assertEquals(1, employees.size());
	        t.commit();
			// assertEquals(1, employees.size()); must set exception as employees is invalid now.
		}
		// Read from DB;		// Write to DB
		{
			WriteTransaction t = db.beginWrite();
			EmployeeTable employees = new EmployeeTable(t);
			employees.add("John", "Doe", 10000, true);
			assertEquals(1, employees.size());
			t.commit();
			// assertEquals(1, employees.size()); must set exception as
			// employees is invalid now.
		}
		// Read from DB
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_cb35f_a98a4/rev_cb35f-a98a4;/tightdb-java-test/src/test/java/com/tightdb/JNITransactions;mustWriteCommit2();	    }
	    finally {
			clear();
	    }	    ;	    }
	    finally {
	        db.close();
	    }	    ;		} finally {
			db.close();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_cb420_6ee44/rev_cb420-6ee44;/core/src/main/java/com/orientechnologies/orient/core/index/hashindex/local/cache/O2QCache;updateCache(long,long);    try {
      removeColdestPageIfNeeded();
    } catch (OAllLRUListEntriesAreUsedException e) {
      if (OGlobalConfiguration.SERVER_CACHE_2Q_INCREASE_ON_DEMAND.getValueAsBoolean()) {
        maxSize = (int) Math.ceil(maxSize * (1 + OGlobalConfiguration.SERVER_CACHE_2Q_INCREASE_STEP.getValueAsFloat()));
        K_IN = maxSize >> 2;
        K_OUT = maxSize >> 1;
      } else {
        throw e;
      }
    };    try {
      removeColdestPageIfNeeded();
    } catch (OAllLRUListEntriesAreUsed e) {
      if (OGlobalConfiguration.SERVER_CACHE_2Q_INCREASE_ON_DEMAND.getValueAsBoolean()) {
        maxSize = (int) Math.ceil(maxSize * (1 + OGlobalConfiguration.SERVER_CACHE_2Q_INCREASE_STEP.getValueAsFloat()));
        K_IN = maxSize >> 2;
        K_OUT = maxSize >> 1;
      } else {
        throw e;
      }
    };    removeColdestPageIfNeeded();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_cc301_f5cc4/rev_cc301-f5cc4;/src/java/org/apache/cassandra/db/CollationController;collectTimeOrderedData();        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());;        logger.trace("collectTimeOrderedData");
        ColumnFamily container = ColumnFamily.create(cfs.metadata, factory, filter.filter.isReversed());;        logger.trace("collectTimeOrderedData");
        final ColumnFamily container = ArrayBackedSortedColumns.factory.create(cfs.metadata, filter.filter.isReversed());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_cc301_f5cc4/rev_cc301-f5cc4;/src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader;SimpleSliceReader(SSTableReader,RowIndexEntry,FileDataInput,ByteBuffer);        Tracing.trace("Seeking to partition beginning in data file");
        this.sstable = sstable;;        this.sstable = sstable;;        logger.debug("Slicing {}", sstable);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ccd43_dc071/rev_ccd43-dc071;/src/java/org/apache/cassandra/db/compaction/CompactionManager;ValidationCompactionController(ColumnFamilyStore,Collection<SSTableReader>);                  NO_GC,
                  true,
                  null,
                  cfs.getCompactionStrategy().isKeyExistenceExpensive(ImmutableSet.copyOf(sstables)));;                  Integer.MAX_VALUE,
                  true,
                  null,
                  cfs.getCompactionStrategy().isKeyExistenceExpensive(ImmutableSet.copyOf(sstables)));;                  Integer.MAX_VALUE,
                  null);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ccdb6_1b41d/rev_ccdb6-1b41d;/src/java/org/apache/cassandra/thrift/ThriftValidation;validateKeyRange(CFMetaData,ByteBuffer,KeyRange);            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
                throw new InvalidRequestException("Start key's token sorts after end token");;            if (range.start_key != null && RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
                throw new InvalidRequestException("Start key's token sorts after end token");
            if (range.start_token != null && p.getTokenFactory().fromString(range.start_token).maxKeyBound(p).compareTo(stop) > 0)
                throw new InvalidRequestException("Start token sorts after end token");;            if (range.start_key != null && RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
                throw new org.apache.cassandra.exceptions.InvalidRequestException("Start key's token sorts after end token");
            if (range.start_token != null && p.getTokenFactory().fromString(range.start_token).maxKeyBound(p).compareTo(stop) > 0)
                throw new org.apache.cassandra.exceptions.InvalidRequestException("Start token sorts after end token");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_cd12e_da012/rev_cd12e-da012;/src/com/opengamma/financial/position/db/DbPositionMaster;addPortfolioNode(AddPortfolioNodeRequest);    checkIdentifierScheme(parentUid);
    final Instant instant = Instant.now(getTimeSource());;    checkIdentifierScheme(parentUid);;    checkIdentifier(parentUid, TYPE_NODE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_cd12e_da012/rev_cd12e-da012;/src/com/opengamma/financial/position/db/DbPositionMaster;updatePortfolioNode(UpdatePortfolioNodeRequest);    checkIdentifierScheme(nodeUid);
    final Instant instant = Instant.now(getTimeSource());;    checkIdentifierScheme(nodeUid);;    checkIdentifier(nodeUid, TYPE_NODE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015;/query/src/test/java/org/infinispan/query/api/ReplaceTest;createCacheManager();         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c);;         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c, true);;         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      return TestCacheManagerFactory.createCacheManager(c, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015;/query/src/test/java/org/infinispan/query/tx/TransactionalQueryTest;createCacheManager();         .addProperty("hibernate.search.default.directory_provider", "ram");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c);;         .addProperty("hibernate.search.default.directory_provider", "ram");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c, true);;         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015;/query/src/test/java/org/infinispan/query/blackbox/SearchFactoryShutdownTest;testCorrectShutdown();         c.fluent().indexing().indexLocalOnly(false);
         cc = TestCacheManagerFactory.createCacheManager(c);;         c.fluent().indexing().indexLocalOnly(false);
         cc = TestCacheManagerFactory.createCacheManager(c, true);;         c.fluent().indexing().indexLocalOnly(false)
            .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
         cc = TestCacheManagerFactory.createCacheManager(c, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_roboguice/revisions/rev_cd77e_1f910/rev_cd77e-1f910;/roboguice/src/main/java/roboguice/inject/ExtrasListener;hear(TypeLiteral<I>,TypeEncounter<I>);        Class<?> c = typeLiteral.getRawType();
        while (c != null) {
            for (Field field : c.getDeclaredFields()) {
                if (field.isAnnotationPresent(InjectExtra.class));        Class<?> c = typeLiteral.getRawType();
        while (c != null) {
            for (Field field : c.getDeclaredFields()) {
                if (field.isAnnotationPresent(InjectExtra.class)) {;        for( Class<?> c = typeLiteral.getRawType(); c!=Object.class; c=c.getSuperclass() )
            for (Field field : c.getDeclaredFields())
                if (field.isAnnotationPresent(InjectExtra.class))
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_cd606_86f60/rev_cd606-86f60;/src/java/org/apache/cassandra/db/ColumnFamilyStore;truncate();        return CompactionManager.instance.submitTruncate(this, truncatedAt);;        Runnable runnable = new WrappedRunnable()
        {
            public void runMayThrow() throws InterruptedException, IOException
            {
                // putting markCompacted on the commitlogUpdater thread ensures it will run
                // after any compactions that were in progress when truncate was called, are finished
                for (ColumnFamilyStore cfs : concatWithIndexes())
                {
                    List<SSTableReader> truncatedSSTables = new ArrayList<SSTableReader>();
                    for (SSTableReader sstable : cfs.getSSTables())
                    {
                        if (!sstable.newSince(truncatedAt))
                            truncatedSSTables.add(sstable);
                    }
                    cfs.markCompacted(truncatedSSTables);
                }

                // Invalidate row cache
                invalidateRowCache();
            }
        };

        return postFlushExecutor.submit(runnable);;        Runnable runnable = new WrappedRunnable()
        {
            public void runMayThrow() throws InterruptedException, IOException
            {
                // putting markCompacted on the commitlogUpdater thread ensures it will run
                // after any compactions that were in progress when truncate was called, are finished
                for (ColumnFamilyStore cfs : concatWithIndexes())
                {
                    List<SSTableReader> truncatedSSTables = new ArrayList<SSTableReader>();
                    for (SSTableReader sstable : cfs.getSSTables())
                    {
                        if (!sstable.newSince(truncatedAt))
                            truncatedSSTables.add(sstable);
                    }
                    cfs.data.markCompacted(truncatedSSTables);
                }

                // Invalidate row cache
                invalidateRowCache();
            }
        };

        return postFlushExecutor.submit(runnable);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_cf8f4_41af2/rev_cf8f4-41af2;/graylog2-server/src/main/java/org/graylog2/indexer/ranges/RebuildIndexRangesJob;execute();                    emptyIndexRange.put("start", Tools.getUTCTimestamp());;                    LOG.info("Index [{}] is empty but it is the current deflector target. Inserting dummy index range.", index);
                    Map<String, Object> deflectorIndexRange = Maps.newHashMap();
                    deflectorIndexRange.put("index", index);
                    deflectorIndexRange.put("start", Tools.getUTCTimestamp());
                    ranges.add(deflectorIndexRange);;                    LOG.info("Index [{}] is empty but it is the current deflector target. Inserting dummy index range.", index);
                    ranges.add(getDeflectorIndexRange(index));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_d1b9b_f70b3/rev_d1b9b-f70b3;/src/java/voldemort/client/SocketStoreClientFactory;SocketStoreClientFactory(ClientConfig);                                                          config.getSocketKeepAlive());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));;                                                          config.getSocketKeepAlive());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));;                                                          config.getSocketKeepAlive(),
                                                          config.isJmxEnabled());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_d1fb0_4ac2a/rev_d1fb0-4ac2a;/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ClassDescriptorResolver;resolveFunctionDescriptor(DeclarationDescriptor,JetScope,JetNamedFunction);        boolean hasBody = function.getBodyExpression() != null;
        Modality defaultModality = getDefaultModality(containingDescriptor, hasBody);
        Modality modality = resolveModalityFromModifiers(function.getModifierList(), defaultModality);;        Modality defaultModality;
        if (containingDescriptor instanceof ClassDescriptor) {
            boolean isDefinitelyAbstract = ((ClassDescriptor) containingDescriptor).getKind() == ClassKind.TRAIT && function.getBodyExpression() == null;
            defaultModality = isDefinitelyAbstract ? Modality.ABSTRACT : Modality.FINAL;
        } else {
            defaultModality = Modality.FINAL;
        }
        Modality modality = resolveModalityFromModifiers(function.getModifierList(), defaultModality);;        Modality defaultModality;
        if (containingDescriptor instanceof ClassDescriptor) {
            boolean isDefinitelyAbstract = ((ClassDescriptor) containingDescriptor).getKind() == ClassKind.TRAIT && function.getBodyExpression() == null;
            defaultModality = isDefinitelyAbstract ? Modality.ABSTRACT : Modality.FINAL;
        } else {
            defaultModality = Modality.FINAL;
        }
        Modality modality = resolveModalityFromModifiers(trace, function.getModifierList(), defaultModality);
        Visibility visibility = resolveVisibilityFromModifiers(trace, function.getModifierList());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d2f43_d2803/rev_d2f43-d2803;/src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy;LeveledCompactionStrategy(ColumnFamilyStore,Map<String,String>);        int configuredMaxSSTableSize = 160;;        int configuredMaxSSTableSize = 5;;        int configuredMaxSSTableSize = 5;
        SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_d7c74_10cb3/rev_d7c74-10cb3;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/repositories/resolver/MavenResolver;getTypedArtifacts(ModuleVersionMetaData,Class<?extendsSoftwareArtifact>);public Set<ModuleVersionArtifactMetaData> getTypedArtifacts(ModuleVersionMetaData module, Class<? extends SoftwareArtifact> artifactType) {;public Set<? extends ComponentArtifactMetaData> getTypedArtifacts(ModuleVersionMetaData module, Class<? extends SoftwareArtifact> artifactType) {;public Set<? extends ComponentArtifactMetaData> getTypedArtifacts(ModuleVersionMetaData module, Class<? extends SoftwareArtifact> artifactType) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019;/src/java/voldemort/server/rebalance/Rebalancer;attemptRebalance(RebalancePartitionsInfo);        adminClient.waitForCompletion(stealInfo.getStealerId(),
                                      rebalanceAsyncId,
                                      voldemortConfig.getAdminSocketTimeout(),
                                      TimeUnit.SECONDS);;        for(String storeName: unbalanceStoreList) {
            AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                           metadataStore.getCluster());
            try {
                int rebalanceAsyncId = rebalanceLocalNode(storeName, stealInfo);
                
                adminClient.waitForCompletion(stealInfo.getStealerId(),
                                              rebalanceAsyncId,
                                              voldemortConfig.getAdminSocketTimeout(),
                                              TimeUnit.SECONDS);
                // remove store from rebalance list
                stealInfo.getUnbalancedStoreList().remove(storeName);
            } catch(Exception e) {
                logger.warn("rebalanceSubTask:" + stealInfo + " failed for store:" + storeName, e);
            } finally {
                adminClient.stop();
            }
        };        for(String storeName: unbalanceStoreList) {
            AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                           metadataStore.getCluster());
            try {
                int rebalanceAsyncId = rebalanceLocalNode(storeName, stealInfo);

                adminClient.waitForCompletion(stealInfo.getStealerId(),
                                              rebalanceAsyncId,
                                              voldemortConfig.getAdminSocketTimeout(),
                                              TimeUnit.SECONDS);
                // remove store from rebalance list
                stealInfo.getUnbalancedStoreList().remove(storeName);
            } catch(Exception e) {
                logger.warn("rebalanceSubTask:" + stealInfo + " failed for store:" + storeName, e);
            } finally {
                adminClient.stop();
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d19f8_88e39/rev_d19f8-88e39;/src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator;readIndexedColumns(CFMetaData,FileDataInput,SortedSet<ByteBuffer>,List<IndexHelper.IndexInfo>,long,List<OnDiskAtom>);                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);;                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
                ByteBuffer columnName = column.name();;                OnDiskAtom column = atomIterator.next();
                ByteBuffer columnName = column.name();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d24d7_eaf20/rev_d24d7-eaf20;/src/java/org/apache/cassandra/thrift/CassandraServer;insert(ByteBuffer,ColumnParent,Column,ConsistencyLevel);        state().hasColumnFamilyAccess(column_parent.column_family, Permission.WRITE);

        ThriftValidation.validateKey(key);
        ThriftValidation.validateColumnParent(state().getKeyspace(), column_parent);
        // SuperColumn field is usually optional, but not when we're inserting
        if (DatabaseDescriptor.getColumnFamilyType(state().getKeyspace(), column_parent.column_family) == ColumnFamilyType.Super
            && column_parent.super_column == null)
        {
            throw new InvalidRequestException("missing mandatory super column name for super CF " + column_parent.column_family);
        }
        ThriftValidation.validateColumnNames(state().getKeyspace(), column_parent, Arrays.asList(column.name));
        ThriftValidation.validateColumnData(state().getKeyspace(), column_parent.column_family, column);

        RowMutation rm = new RowMutation(state().getKeyspace(), key);
        try
        {
            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, column.timestamp, column.ttl);
        }
        catch (MarshalException e)
        {
            throw new InvalidRequestException(e.getMessage());
        }
        doInsert(consistency_level, Arrays.asList(rm));;        state().hasColumnFamilyAccess(column_parent.column_family, Permission.WRITE);

        ThriftValidation.validateKey(key);
        ThriftValidation.validateColumnParent(state().getKeyspace(), column_parent);
        ThriftValidation.validateColumnNames(state().getKeyspace(), column_parent, Arrays.asList(column.name));
        ThriftValidation.validateColumnData(state().getKeyspace(), column_parent.column_family, column);

        RowMutation rm = new RowMutation(state().getKeyspace(), key);
        try
        {
            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, column.timestamp, column.ttl);
        }
        catch (MarshalException e)
        {
            throw new InvalidRequestException(e.getMessage());
        }
        doInsert(consistency_level, Arrays.asList(rm));;        internal_insert(key, column_parent, column, consistency_level);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_d75a0_26923/rev_d75a0-26923;/tightdb-java-test/src/test/java/com/tightdb/JNITableTest;tableBinaryTest();        t.insertBinary(0, 0, row0);
        t.insertDone();
        t.insertBinary(0, 1, row1);
        t.insertDone();;        t.insertBinary(0, 0, row0);
        t.insertBinary(0, 1, row1);
        t.insertDone();;        t.getInternalMethods().insertBinary(0, 0, row0);
        t.getInternalMethods().insertBinary(0, 1, row1);
        t.getInternalMethods().insertDone();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d288e_add89/rev_d288e-add89;/projects/OG-Analytics/src/com/opengamma/financial/forex/method/ForexOptionVanillaMethod;presentValue(ForexOptionVanilla,SmileDeltaTermStructureDataBundle);    double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime()) / df;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount()) * (optionForex.isLong() ? 1.0 : -1.0);
    CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);;    double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime()) / df;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);;    final double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double spot = smile.getSpot();
    final double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime())
        / df;
    final double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    final BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    final Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    final double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    final CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d288e_add89/rev_d288e-add89;/projects/OG-Analytics/src/com/opengamma/financial/forex/method/ForexOptionVanillaMethod;currencyExposure(ForexOptionVanilla,SmileDeltaTermStructureDataBundle);    double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * dfForeign / dfDomestic;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    double sign = (optionForex.isLong() ? 1.0 : -1.0);
    double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount()) * sign;
    double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    CurrencyAmount[] currencyExposure = new CurrencyAmount[2];;    double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * dfForeign / dfDomestic;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    CurrencyAmount[] currencyExposure = new CurrencyAmount[2];;    final double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double spot = smile.getSpot();
    final double forward = spot * dfForeign / dfDomestic;
    final double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    final BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    final double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    final double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    final double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    final CurrencyAmount[] currencyExposure = new CurrencyAmount[2];
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d288e_add89/rev_d288e-add89;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/InterestRateDerivativeVisitorTest;test();    assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR, curves), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR, curves), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    assertEquals(VISITOR.visit(CASH), Cash.class);
    assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    assertEquals(SWAPTION_CASH.accept(VISITOR), SwaptionCashFixedIbor.class);
    assertEquals(SWAPTION_PHYS.accept(VISITOR), SwaptionPhysicalFixedIbor.class);;    assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR, curves), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR, curves), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    assertEquals(VISITOR.visit(CASH), Cash.class);
    assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    assertEquals(IR_FUTURE.accept(VISITOR), InterestRateFuture.class);
    assertEquals(BOND.accept(VISITOR), Bond.class);
    assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    //    assertEquals(FRN.accept(VISITOR), FloatingRateNote.class);
    assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);;    AssertJUnit.assertEquals(VISITOR.visit(CASH, curves), Cash.class);
    AssertJUnit.assertEquals(FRA.accept(VISITOR, curves), ForwardRateAgreement.class);
    AssertJUnit.assertEquals(BOND.accept(VISITOR, curves), Bond.class);
    AssertJUnit.assertEquals(BOND_FORWARD.accept(VISITOR, curves), BondForward.class);
    AssertJUnit.assertEquals(BOND_FUTURE.accept(VISITOR, curves), BondFuture.class);
    AssertJUnit.assertEquals(FIXED_LEG.accept(VISITOR, curves), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLOAT_LEG.accept(VISITOR, curves), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(SWAP.accept(VISITOR, curves), FixedFloatSwap.class);
    AssertJUnit.assertEquals(TENOR_SWAP.accept(VISITOR, curves), TenorSwap.class);
    AssertJUnit.assertEquals(FIXED_PAYMENT.accept(VISITOR, curves), PaymentFixed.class);
    AssertJUnit.assertEquals(LIBOR_PAYMENT.accept(VISITOR, curves), CouponIbor.class);
    AssertJUnit.assertEquals(FCA.accept(VISITOR, curves), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLA.accept(VISITOR, curves), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(FCS.accept(VISITOR, curves), FixedCouponSwap.class);
    AssertJUnit.assertEquals(FCP.accept(VISITOR, curves), CouponFixed.class);
    AssertJUnit.assertEquals(CM.accept(VISITOR, curves), ContinuouslyMonitoredAverageRatePayment.class);
    AssertJUnit.assertEquals(GA.accept(VISITOR, curves), GenericAnnuity.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR, curves), Swap.class);
    AssertJUnit.assertEquals(VISITOR.visit(CASH), Cash.class);
    AssertJUnit.assertEquals(FRA.accept(VISITOR), ForwardRateAgreement.class);
    AssertJUnit.assertEquals(BOND.accept(VISITOR), Bond.class);
    AssertJUnit.assertEquals(BOND_FORWARD.accept(VISITOR), BondForward.class);
    AssertJUnit.assertEquals(BOND_FUTURE.accept(VISITOR), BondFuture.class);
    AssertJUnit.assertEquals(FIXED_LEG.accept(VISITOR), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLOAT_LEG.accept(VISITOR), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(SWAP.accept(VISITOR), FixedFloatSwap.class);
    AssertJUnit.assertEquals(TENOR_SWAP.accept(VISITOR), TenorSwap.class);
    AssertJUnit.assertEquals(FIXED_PAYMENT.accept(VISITOR), PaymentFixed.class);
    AssertJUnit.assertEquals(LIBOR_PAYMENT.accept(VISITOR), CouponIbor.class);
    AssertJUnit.assertEquals(GA.accept(VISITOR), GenericAnnuity.class);
    AssertJUnit.assertEquals(FCA.accept(VISITOR), AnnuityCouponFixed.class);
    AssertJUnit.assertEquals(FLA.accept(VISITOR), AnnuityCouponIbor.class);
    AssertJUnit.assertEquals(FCS.accept(VISITOR), FixedCouponSwap.class);
    AssertJUnit.assertEquals(FCP.accept(VISITOR), CouponFixed.class);
    AssertJUnit.assertEquals(CM.accept(VISITOR), ContinuouslyMonitoredAverageRatePayment.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    AssertJUnit.assertEquals(FIXED_FIXED.accept(VISITOR), Swap.class);
    AssertJUnit.assertEquals(FLOATING_COUPON.accept(VISITOR), CouponFloating.class);
    AssertJUnit.assertEquals(FLOATING_COUPON.accept(VISITOR, curves), CouponFloating.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d288e_ae5e4/rev_d288e-ae5e4;/projects/OG-Analytics/src/com/opengamma/financial/forex/method/ForexOptionVanillaMethod;presentValue(ForexOptionVanilla,SmileDeltaTermStructureDataBundle);    double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime()) / df;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount()) * (optionForex.isLong() ? 1.0 : -1.0);
    CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);;    double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime()) / df;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);;    final double df = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double spot = smile.getSpot();
    final double forward = spot * smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime())
        / df;
    final double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    final BlackFunctionData dataBlack = new BlackFunctionData(forward, df, volatility);
    final Function1D<BlackFunctionData, Double> func = BLACK_FUNCTION.getPriceFunction(optionForex);
    final double price = func.evaluate(dataBlack) * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    final CurrencyAmount priceCurrency = CurrencyAmount.of(optionForex.getUnderlyingForex().getCurrency2(), price);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d288e_ae5e4/rev_d288e-ae5e4;/projects/OG-Analytics/src/com/opengamma/financial/forex/method/ForexOptionVanillaMethod;currencyExposure(ForexOptionVanilla,SmileDeltaTermStructureDataBundle);    double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * dfForeign / dfDomestic;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    double sign = (optionForex.isLong() ? 1.0 : -1.0);
    double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount()) * sign;
    double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    CurrencyAmount[] currencyExposure = new CurrencyAmount[2];;    double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    double spot = smile.getSpot();
    double forward = spot * dfForeign / dfDomestic;
    double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    CurrencyAmount[] currencyExposure = new CurrencyAmount[2];;    final double dfDomestic = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency2().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double dfForeign = smile.getCurve(optionForex.getUnderlyingForex().getPaymentCurrency1().getFundingCurveName()).getDiscountFactor(optionForex.getUnderlyingForex().getPaymentTime());
    final double spot = smile.getSpot();
    final double forward = spot * dfForeign / dfDomestic;
    final double volatility = smile.getSmile().getVolatility(new Triple<Double, Double, Double>(optionForex.getTimeToExpiry(), optionForex.getStrike(), forward));
    final BlackFunctionData dataBlack = new BlackFunctionData(forward, dfDomestic, volatility);
    final double[] priceAdjoint = BLACK_FUNCTION.getPriceAdjoint(optionForex, dataBlack);
    final double price = priceAdjoint[0] * Math.abs(optionForex.getUnderlyingForex().getPaymentCurrency1().getAmount());
    final double deltaSpot = priceAdjoint[1] * dfForeign / dfDomestic;
    final CurrencyAmount[] currencyExposure = new CurrencyAmount[2];
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_d366f_af236/rev_d366f-af236;/src/java/voldemort/store/rebalancing/RedirectingStore;proxyGet(ByteArray);            failureDetector.recordException(donorNode, System.currentTimeMillis() - start, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);;            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node "
                                                           + donorNode, e);;            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_d366f_af236/rev_d366f-af236;/src/java/voldemort/store/rebalancing/RedirectingStore;proxyGetAll(Iterable<ByteArray>);            failureDetector.recordException(donorNode, System.currentTimeMillis() - start, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);;            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node "
                                                           + donorNode, e);;            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d685f_e571e/rev_d685f-e571e;/src/java/org/apache/cassandra/io/sstable/SSTableReader;load(boolean,Set<DecoratedKey>);                long dataPosition = input.readLong();
                if (decoratedKey != null);                if(null == left)
                    left = decodeKey(partitioner, descriptor, skippedKey);
                right = decodeKey(partitioner, descriptor, skippedKey);

                long dataPosition = input.readLong();
                if (key != null);                if(null == left)
                    left = decodeKey(partitioner, descriptor, skippedKey);
                right = decodeKey(partitioner, descriptor, skippedKey);

                RowIndexEntry indexEntry = RowIndexEntry.serializer.deserialize(input, descriptor);
                if (key != null)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_d3362_f6254/rev_d3362-f6254;/src/main/java/redis/clients/jedis/Jedis;Jedis(JedisShardInfo);public Jedis(final JedisShardInfo shardInfo) {
    	super(shardInfo);;public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        if (shardInfo.getPassword() != null) {
            this.auth(shardInfo.getPassword());
        };public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        this.password = shardInfo.getPassword();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_d4744_b8202/rev_d4744-b8202;/src/java/org/apache/cassandra/db/Directories;migrateFile(File,File,String);            String cfname = isManifest
                          ? getCfNameFromManifest(name)
                          : name.substring(0, name.indexOf(Component.separator));;            String cfname = isManifest
                          ? name.substring(0, name.length() - LeveledManifest.EXTENSION.length())
                          : name.substring(0, name.indexOf(Component.separator));;            int separatorIndex = name.indexOf(Component.separator);

            if (isManifest || (separatorIndex >= 0))
            {
                String cfname = isManifest
                              ? name.substring(0, name.length() - LeveledManifest.EXTENSION.length())
                              : name.substring(0, separatorIndex);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d4934_3c625/rev_d4934-3c625;/projects/OG-Analytics/src/com/opengamma/financial/model/volatility/smile/function/SABRHaganVolatilityFunction;getVolatilityFunction(EuropeanVanillaOption,double);        final double alpha = data.getAlpha();
        if (alpha == 0.0) {
          return 0.0;
        }
        final double beta = data.getBeta();
        final double rho = data.getRho();
        final double nu = data.getNu();
        double k = option.getStrike();
        final double cutoff = forward * CUTOFF_MONEYNESS;
        if (k < cutoff) {
          s_logger.info("Given strike of " + k + " is less than cutoff at " + cutoff + ", therefore the strike is taken as " + cutoff);
          k = cutoff;
        }
        double vol, z, zOverChi;
        final double beta1 = 1 - beta;
        if (CompareUtils.closeEquals(forward, k, ATM_EPS)) {
          final double f1 = Math.pow(forward, beta1);
          vol = alpha * (1 + t * (beta1 * beta1 * alpha * alpha / 24 / f1 / f1 + rho * alpha * beta * nu / 4 / f1 + nu * nu * (2 - 3 * rho * rho) / 24)) / f1;

        } else {
          if (CompareUtils.closeEquals(beta, 0, BETA_EPS)) {
            final double ln = Math.log(forward / k);
            z = nu * Math.sqrt(forward * k) * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            vol = alpha * ln * zOverChi * (1 + t * (alpha * alpha / forward / k + nu * nu * (2 - 3 * rho * rho)) / 24) / (forward - k);
          } else if (CompareUtils.closeEquals(beta, 1, BETA_EPS)) {
            final double ln = Math.log(forward / k);
            z = nu * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            vol = alpha * zOverChi * (1 + t * (rho * alpha * nu / 4 + nu * nu * (2 - 3 * rho * rho) / 24));
          } else {
            final double ln = Math.log(forward / k);
            final double f1 = Math.pow(forward * k, beta1);
            final double f1Sqrt = Math.sqrt(f1);
            final double lnBetaSq = Math.pow(beta1 * ln, 2);
            z = nu * f1Sqrt * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            final double first = alpha / (f1Sqrt * (1 + lnBetaSq / 24 + lnBetaSq * lnBetaSq / 1920));
            final double second = zOverChi;
            final double third = 1 + t * (beta1 * beta1 * alpha * alpha / 24 / f1 + rho * nu * beta * alpha / 4 / f1Sqrt + nu * nu * (2 - 3 * rho * rho) / 24);

            vol = first * second * third;
          }
        }
        //There is nothing to prevent the nu * nu * (2 - 3 * rho * rho) / 24 part taking the third term, and hence the volatility negative 
        return Math.max(0.0, vol);;        final double alpha = data.getAlpha();
        if (alpha == 0.0) {
          return 0.0;
        }
        final double beta = data.getBeta();
        final double rho = data.getRho();
        final double nu = data.getNu();
        double k = option.getStrike();
        final double cutoff = forward * CUTOFF_MONEYNESS;
        if (k < cutoff) {
          s_logger.warn("Given strike of " + k + " is less than cutoff at " + cutoff + ", therefore the strike is taken as " + cutoff);
          k = cutoff;
        }
        double vol, z, zOverChi;
        final double beta1 = 1 - beta;
        if (CompareUtils.closeEquals(forward, k, ATM_EPS)) {
          final double f1 = Math.pow(forward, beta1);
          vol = alpha * (1 + t * (beta1 * beta1 * alpha * alpha / 24 / f1 / f1 + rho * alpha * beta * nu / 4 / f1 + nu * nu * (2 - 3 * rho * rho) / 24)) / f1;

        } else {
          if (CompareUtils.closeEquals(beta, 0, BETA_EPS)) {
            final double ln = Math.log(forward / k);
            z = nu * Math.sqrt(forward * k) * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            vol = alpha * ln * zOverChi * (1 + t * (alpha * alpha / forward / k + nu * nu * (2 - 3 * rho * rho)) / 24) / (forward - k);
          } else if (CompareUtils.closeEquals(beta, 1, BETA_EPS)) {
            final double ln = Math.log(forward / k);
            z = nu * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            vol = alpha * zOverChi * (1 + t * (rho * alpha * nu / 4 + nu * nu * (2 - 3 * rho * rho) / 24));
          } else {
            final double ln = Math.log(forward / k);
            final double f1 = Math.pow(forward * k, beta1);
            final double f1Sqrt = Math.sqrt(f1);
            final double lnBetaSq = Math.pow(beta1 * ln, 2);
            z = nu * f1Sqrt * ln / alpha;
            zOverChi = getZOverChi(rho, z);
            final double first = alpha / (f1Sqrt * (1 + lnBetaSq / 24 + lnBetaSq * lnBetaSq / 1920));
            final double second = zOverChi;
            final double third = 1 + t * (beta1 * beta1 * alpha * alpha / 24 / f1 + rho * nu * beta * alpha / 4 / f1Sqrt + nu * nu * (2 - 3 * rho * rho) / 24);

            vol = first * second * third;
          }
        }
        //There is nothing to prevent the nu * nu * (2 - 3 * rho * rho) / 24 part taking the third term, and hence the volatility negative 
        return Math.max(0.0, vol);;        return getVolatility(option, forward, data);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_d4934_3c625/rev_d4934-3c625;/projects/OG-Analytics/src/com/opengamma/math/matrix/DoubleMatrix2D;DoubleMatrix2D(double[][]);        Validate.isTrue(data[i].length == _columns, "Number of columns did not match that in first row: " + _columns + " expected but " + data[i].length + " found in row " + i);
        for (int j = 0; j < _columns; j++) {
          _data[i][j] = data[i][j];
        };        Validate.isTrue(data[i].length == _columns, "Number of columns did not match that in first row");
        for (int j = 0; j < _columns; j++) {
          _data[i][j] = data[i][j];
        };        Validate.isTrue(data[i].length == _columns, "Number of columns did not match that in first row");
        _data[i] = Arrays.copyOf(data[i], _columns);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_junit/revisions/rev_d9559_cf2a1/rev_d9559-cf2a1;/src/main/java/org/junit/internal/MethodSorter;getDeclaredMethods(Class<?>);        Comparator<Method> comparator= getSorter(clazz.getAnnotation(FixMethodOrder.class));
        
        Method[] methods= clazz.getDeclaredMethods();
        if (comparator != null) {
            Arrays.sort(methods, comparator);
        };        Method[] methods = clazz.getDeclaredMethods();
        Arrays.sort(methods, new Comparator<Method>() {
            @Override public int compare(Method m1, Method m2) {
                int i1 = m1.getName().hashCode();
                int i2 = m2.getName().hashCode();
                return i1 != i2 ? i1 - i2 : m1.toString().compareTo(m2.toString());
            }
        });;        Method[] methods = clazz.getDeclaredMethods();
        Arrays.sort(methods, new Comparator<Method>() {
            public int compare(Method m1, Method m2) {
                int i1 = m1.getName().hashCode();
                int i2 = m2.getName().hashCode();
                return i1 != i2 ? i1 - i2 : m1.toString().compareTo(m2.toString());
            }
        });
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dac60_94d76/rev_dac60-94d76;/src/java/org/apache/cassandra/io/sstable/SSTableWriter;IndexWriter(long);            summary = new IndexSummary(keyCount);
            bf = FilterFactory.getFilter(keyCount, metadata.getBloomFilterFpChance(), true);;            summary = new IndexSummary(keyCount);

            double fpChance = metadata.getBloomFilterFpChance();
            if (fpChance == 0)
            {
                // paranoia -- we've had bugs in the thrift <-> avro <-> CfDef dance before, let's not let that break things
                logger.error("Bloom filter FP chance of zero isn't supposed to happen");
                fpChance = 0.01;
            }
            bf = FilterFactory.getFilter(keyCount, fpChance, true);;            summary = new IndexSummary(keyCount, metadata.getIndexInterval());

            double fpChance = metadata.getBloomFilterFpChance();
            if (fpChance == 0)
            {
                // paranoia -- we've had bugs in the thrift <-> avro <-> CfDef dance before, let's not let that break things
                logger.error("Bloom filter FP chance of zero isn't supposed to happen");
                fpChance = 0.01;
            }
            bf = FilterFactory.getFilter(keyCount, fpChance, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dacab_615da/rev_dacab-615da;/projects/OG-Financial/src/com/opengamma/financial/fudgemsg/VolatilitySurfaceDefinitionBuilder;buildObject(FudgeDeserializationContext,FudgeMsg);  public VolatilitySurfaceDefinition<?, ?> buildObject(FudgeDeserializationContext context, FudgeMsg message) {
    Currency currency = context.fieldValueToObject(Currency.class, message.getByName("currency"));
    String name = message.getString("name");
    String interpolatorName;
    if (!message.hasField("interpolatorName")) {
      interpolatorName = "Linear"; 
      s_logger.warn("Inserting Linear interpolation as future version doesn't require an interpolator");
    } else {
      interpolatorName = message.getString("interpolatorName");
    }
    List<FudgeField> xsFields = message.getAllByName("xs");
    List<Object> xs = new ArrayList<Object>();
    for (FudgeField xField : xsFields) {
      Object x = context.fieldValueToObject(xField);;  public VolatilitySurfaceDefinition<?, ?> buildObject(FudgeDeserializationContext context, FudgeMsg message) {
    Currency currency = context.fieldValueToObject(Currency.class, message.getByName("currency"));
    String name = message.getString("name");
    String interpolatorName = message.getString("interpolatorName");
    List<FudgeField> xsFields = message.getAllByName("xs");
    List<Object> xs = new ArrayList<Object>();
    for (FudgeField xField : xsFields) {
      Object x = context.fieldValueToObject(xField);;  public VolatilitySurfaceDefinition<?, ?> buildObject(final FudgeDeserializationContext context, final FudgeMsg message) {
    final Currency currency = context.fieldValueToObject(Currency.class, message.getByName("currency"));
    final String name = message.getString("name");
    final List<FudgeField> xsFields = message.getAllByName("xs");
    final List<Object> xs = new ArrayList<Object>();
    for (final FudgeField xField : xsFields) {
      final Object x = context.fieldValueToObject(xField);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_db467_899f7/rev_db467-899f7;/projects/OG-Analytics/src/com/opengamma/financial/model/volatility/surface/DupireLocalVolatilityCalculator;getLocalVolatility(BlackVolatilitySurface,double,double);      public Double evaluate(final Double... x) {
        final double t = x[0];
        final double k = x[1];
        final double vol = impliedVolatilitySurface.getVolatility(t, k);
        if (t == 0) {;      public Double evaluate(Double... x) {
        double t = x[0];
        double k = x[1];
        double vol = impliedVolatilitySurface.getVolatility(t, k);
        if (t == 0) {;      public Double evaluate(Double... x) {
        double t = x[0];
        double k = x[1];
        double vol = impliedVolatilitySurface.getVolatility(t, k);
        if (t == 0 && k == spot) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_db467_899f7/rev_db467-899f7;/projects/OG-Analytics/src/com/opengamma/financial/model/volatility/surface/DupireLocalVolatilityCalculator;getFirstTimeDev(Surface<Double,Double,Double>,double,double);    final double up = surface.getZValue(t + _eps, k);
    final double down = surface.getZValue(t - _eps, k);;    double up = surface.getZValue(t + _eps, k);
    double down = surface.getZValue(t - _eps, k);;    if (t == 0) {
      double up = surface.getZValue(_eps, k);
      double mid = surface.getZValue(0.0, k);
      return (up - mid) / _eps;
    }
    double up = surface.getZValue(t + _eps, k);
    double down = surface.getZValue(t - _eps, k);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_db467_899f7/rev_db467-899f7;/projects/OG-Analytics/tests/unit/com/opengamma/financial/model/finitedifference/FokkerPlankPDETest;test();    final ConvectionDiffusionPDESolver solver = new ThetaMethodFiniteDifference(1.0, true);
    final int tNodes = 30;
    final int xNodes = 101;
    final MeshingFunction timeMesh = new ExponentalMeshing(0, T - 0.01, tNodes, 0.0);;    ConvectionDiffusionPDESolver solver = new ThetaMethodFiniteDifference(1.0, true);
    int tNodes = 30;
    int xNodes = 101;
    MeshingFunction timeMesh = new ExponentalMeshing(0, T - 0.01, tNodes, 0.0);;    ConvectionDiffusionPDESolver solver = new ThetaMethodFiniteDifference(1.0, true);
    int tNodes = 30;
    int xNodes = 101;
    MeshingFunction timeMesh = new ExponentialMeshing(0, T - 0.01, tNodes, 0.0);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dc9f2_6a943/rev_dc9f2-6a943;/projects/OG-Financial/src/com/opengamma/financial/analytics/model/irfutureoption/InterestRateFutureOptionHestonPresentValueFunction;execute(FunctionExecutionContext,FunctionInputs,ComputationTarget,Set<ValueRequirement>);    final InstrumentDefinition<InstrumentDerivative> irFutureOptionDefinition = (InstrumentDefinition<InstrumentDerivative>) _converter.convert(trade);
    final InstrumentDerivative irFutureOption = _dataConverter.convert(trade.getSecurity(), irFutureOptionDefinition, now, new String[] {_fundingCurveName, _forwardCurveName}, dataSource);;    final FixedIncomeInstrumentDefinition<InterestRateDerivative> irFutureOptionDefinition = (FixedIncomeInstrumentDefinition<InterestRateDerivative>) _converter.convert(trade);
    final InterestRateDerivative irFutureOption = _dataConverter.convert(trade.getSecurity(), irFutureOptionDefinition, now, new String[] {_fundingCurveName, _forwardCurveName}, dataSource);;    @SuppressWarnings("unchecked")
    final FixedIncomeInstrumentDefinition<InterestRateDerivative> irFutureOptionDefinition = (FixedIncomeInstrumentDefinition<InterestRateDerivative>) _converter.convert(trade);
    final InterestRateDerivative irFutureOption = _dataConverter.convert(trade.getSecurity(), irFutureOptionDefinition, now, new String[] {_fundingCurveName, _forwardCurveName}, dataSource);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dc95c_56b5c/rev_dc95c-56b5c;/src/java/org/apache/cassandra/db/Memtable;updateLiveRatio();        meterExecutor.submit(new MeteringRunnable(cfs));;        Runnable runnable = new Runnable()
        {
            public void run()
            {
                try
                {
                    activelyMeasuring = Memtable.this;

                    long start = System.currentTimeMillis();
                    // ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits.
                    // So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time.
                    long deepSize = meter.measure(columnFamilies);
                    int objects = 0;
                    for (Map.Entry<RowPosition, ColumnFamily> entry : columnFamilies.entrySet())
                    {
                        deepSize += meter.measureDeep(entry.getKey()) + meter.measureDeep(entry.getValue());
                        objects += entry.getValue().getColumnCount();
                    }
                    double newRatio = (double) deepSize / currentSize.get();

                    if (newRatio < MIN_SANE_LIVE_RATIO)
                    {
                        logger.warn("setting live ratio to minimum of {} instead of {}", MIN_SANE_LIVE_RATIO, newRatio);
                        newRatio = MIN_SANE_LIVE_RATIO;
                    }
                    if (newRatio > MAX_SANE_LIVE_RATIO)
                    {
                        logger.warn("setting live ratio to maximum of {} instead of {}", MAX_SANE_LIVE_RATIO, newRatio);
                        newRatio = MAX_SANE_LIVE_RATIO;
                    }

                    // we want to be very conservative about our estimate, since the penalty for guessing low is OOM
                    // death.  thus, higher estimates are believed immediately; lower ones are averaged w/ the old
                    if (newRatio > cfs.liveRatio)
                        cfs.liveRatio = newRatio;
                    else
                        cfs.liveRatio = (cfs.liveRatio + newRatio) / 2.0;

                    logger.info("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} columns",
                                cfs, cfs.liveRatio, newRatio, System.currentTimeMillis() - start, objects);
                    activelyMeasuring = null;
                }
                finally
                {
                    meteringInProgress.remove(cfs);
                }
            }
        };

        meterExecutor.submit(runnable);;        Runnable runnable = new Runnable()
        {
            public void run()
            {
                try
                {
                    activelyMeasuring = Memtable.this;

                    long start = System.nanoTime();
                    // ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits.
                    // So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time.
                    long deepSize = meter.measure(rows);
                    int objects = 0;
                    for (Map.Entry<RowPosition, AtomicSortedColumns> entry : rows.entrySet())
                    {
                        deepSize += meter.measureDeep(entry.getKey()) + meter.measureDeep(entry.getValue());
                        objects += entry.getValue().getColumnCount();
                    }
                    double newRatio = (double) deepSize / currentSize.get();

                    if (newRatio < MIN_SANE_LIVE_RATIO)
                    {
                        logger.warn("setting live ratio to minimum of {} instead of {}", MIN_SANE_LIVE_RATIO, newRatio);
                        newRatio = MIN_SANE_LIVE_RATIO;
                    }
                    if (newRatio > MAX_SANE_LIVE_RATIO)
                    {
                        logger.warn("setting live ratio to maximum of {} instead of {}", MAX_SANE_LIVE_RATIO, newRatio);
                        newRatio = MAX_SANE_LIVE_RATIO;
                    }

                    // we want to be very conservative about our estimate, since the penalty for guessing low is OOM
                    // death.  thus, higher estimates are believed immediately; lower ones are averaged w/ the old
                    if (newRatio > cfs.liveRatio)
                        cfs.liveRatio = newRatio;
                    else
                        cfs.liveRatio = (cfs.liveRatio + newRatio) / 2.0;

                    logger.info("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} columns",
                                cfs, cfs.liveRatio, newRatio, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start), objects);
                    activelyMeasuring = null;
                }
                finally
                {
                    meteringInProgress.remove(cfs);
                }
            }
        };

        meterExecutor.submit(runnable);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dc917_de8c9/rev_dc917-de8c9;/projects/OG-Financial/src/main/java/com/opengamma/financial/security/FinancialSecurityUtils;getCurrencyConstraint(ComputationTarget);    switch (target.getType()) {
      case PORTFOLIO_NODE:
        break;
      case POSITION: {
        final Security security = target.getPosition().getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
        break;
      case PRIMITIVE: {
        final UniqueId uid = target.getUniqueId();
        if (uid.getScheme().equals(Currency.OBJECT_SCHEME)) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, uid.getValue()).get();
        }
      }
        break;
      case SECURITY: {
        final Security security = target.getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
        break;
      case TRADE: {
        final Security security = target.getTrade().getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
        break;;    switch (target.getType()) {
      case PORTFOLIO_NODE:
        break;
      case POSITION: {
        final Security security = target.getPosition().getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
      break;
      case PRIMITIVE: {
        final UniqueId uid = target.getUniqueId();
        if (uid.getScheme().equals(Currency.OBJECT_SCHEME)) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, uid.getValue()).get();
        }
      }
      break;
      case SECURITY: {
        final Security security = target.getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
      break;
      case TRADE: {
        final Security security = target.getTrade().getSecurity();
        final Currency ccy = getCurrency(security);
        if (ccy != null) {
          return ValueProperties.with(ValuePropertyNames.CURRENCY, ccy.getCode()).get();
        }
      }
      break;;    final Function1<ComputationTarget, ValueProperties> operation = s_getCurrencyConstraint.get(target.getType());
    if (operation != null) {
      return operation.execute(target);
    } else {
      return ValueProperties.none();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dc999_e8bfc/rev_dc999-e8bfc;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);            Message digestMessage = null;
            for (InetAddress digestPoint : handler.endpoints.subList(1, handler.endpoints.size()));            Message digestMessage = null;
            for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()));            MessageProducer prod = new CachingMessageProducer(digestCommand);
            for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dc999_e8bfc/rev_dc999-e8bfc;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                        logger.debug("reading digest for from " + digestPoint);
                    MessagingService.instance().sendRR(digestMessage, digestPoint, handler);;                        logger.debug("reading digest for " + command + " from " + digestPoint);
                    MessagingService.instance().sendRR(digestMessage, digestPoint, handler);;                        logger.debug("reading digest for " + command + " from " + digestPoint);
                    MessagingService.instance().sendRR(prod, digestPoint, handler);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dce20_530c4/rev_dce20-530c4;/projects/OG-Financial/src/com/opengamma/financial/batch/BatchJob;getViewByNameWithTime();    searchRequest.setEffectiveTime(_viewDateTime.toInstant());
    ConfigSearchResult<ViewDefinition> searchResult = _configDb.search(searchRequest);
    List<ConfigDocument<ViewDefinition>> documents = searchResult.getDocuments();
    if (documents.isEmpty()) {
      throw new IllegalStateException("Could not find view definition " + getViewName() + " at " +
          _viewDateTime.toInstant() + " in config db");
    }
    return documents.get(0);;    searchRequest.setEffectiveTime(_viewDateTime.toInstant());
    ConfigSearchResult<ViewDefinition> searchResult = _configDb.search(searchRequest);
    List<ConfigDocument<ViewDefinition>> documents = searchResult.getDocuments();
    return documents.get(0);;    searchRequest.setVersionAsOfInstant(_viewDateTime.toInstant());
    ConfigSearchResult<ViewDefinition> searchResult = _configSource.getMaster(ViewDefinition.class).search(searchRequest);
    return searchResult.getFirstDocument();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dce20_530c4/rev_dce20-530c4;/projects/OG-Financial/tests/unit/com/opengamma/financial/analytics/ircurve/InterpolatedYieldAndDiscountCurveFunctionTest;discountCurveRequirements();    CompiledFunctionDefinition compiledFunction = function.compile(context, curveDate.atStartOfDayInZone(TimeZone.UTC));;    CompiledFunctionDefinition compiledFunction = function.compile(context, Instant.nowSystemClock());;    CompiledFunctionDefinition compiledFunction = function.compile(context, Instant.nowSystemClock());
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dce20_530c4/rev_dce20-530c4;/projects/OG-Financial/tests/unit/com/opengamma/financial/analytics/ircurve/InterpolatedYieldAndDiscountCurveFunctionTest;yieldCurveRequirements();    CompiledFunctionDefinition compiledFunction = function.compile(context, curveDate.atStartOfDayInZone(TimeZone.UTC));

    requirements = compiledFunction.getRequirements(context, new ComputationTarget(ComputationTargetType.PRIMITIVE, Currency
        .getInstance("USD")));;    CompiledFunctionDefinition compiledFunction = function.compile(context, Instant.nowSystemClock());

    requirements = compiledFunction.getRequirements(context, new ComputationTarget(ComputationTargetType.PRIMITIVE, Currency
        .getInstance("USD")));;    CompiledFunctionDefinition compiledFunction = function.compile(context, Instant.nowSystemClock());
    
    requirements = compiledFunction.getRequirements(context, new ComputationTarget(ComputationTargetType.PRIMITIVE, Currency.getInstance("USD")));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_dce20_530c4/rev_dce20-530c4;/projects/OG-Financial/tests/unit/com/opengamma/financial/analytics/ircurve/InterpolatedYieldAndDiscountCurveFunctionTest;yieldCurveRequirements();    assertEquals(12, foundKeys.size());;    assertEquals(18, foundKeys.size());;    assertEquals(18, foundKeys.size());
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/Jedis;hdel(String,String);public Long hdel(final String key, final String... fields) {
        checkIsInMulti();
        client.hdel(key, fields);
        return client.getIntegerReply();;public Long hdel(final String key, final String field) {
        checkIsInMulti();
        client.hdel(key, field);
        return client.getIntegerReply();;public Long hdel(final String key, final String field) {
	checkIsInMulti();
	client.hdel(key, field);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/Jedis;sadd(String,String);public Long sadd(final String key, final String... members) {
        checkIsInMulti();
        client.sadd(key, members);
        return client.getIntegerReply();;public Long sadd(final String key, final String member) {
        checkIsInMulti();
        client.sadd(key, member);
        return client.getIntegerReply();;public Long sadd(final String key, final String member) {
	checkIsInMulti();
	client.sadd(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/Jedis;srem(String,String);public Long srem(final String key, final String... members) {
        checkIsInMulti();
        client.srem(key, members);
        return client.getIntegerReply();;public Long srem(final String key, final String member) {
        checkIsInMulti();
        client.srem(key, member);
        return client.getIntegerReply();;public Long srem(final String key, final String member) {
	checkIsInMulti();
	client.srem(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/Jedis;zrem(String,String);public Long zrem(final String key, final String... members) {
        checkIsInMulti();
        client.zrem(key, members);
        return client.getIntegerReply();;public Long zrem(final String key, final String member) {
        checkIsInMulti();
        client.zrem(key, member);
        return client.getIntegerReply();;public Long zrem(final String key, final String member) {
	checkIsInMulti();
	client.zrem(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryClient;hdel(byte[],byte[]);public void hdel(final byte[] key, final byte[]... fields) {
        sendCommand(HDEL, joinParameters(key, fields));;public void hdel(final byte[] key, final byte[] field) {
        sendCommand(HDEL, key, field);;public void hdel(final byte[] key, final byte[] field) {
	sendCommand(HDEL, key, field);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryClient;sadd(byte[],byte[]);public void sadd(final byte[] key, final byte[]... members) {
        sendCommand(SADD, joinParameters(key, members));;public void sadd(final byte[] key, final byte[] member) {
        sendCommand(SADD, key, member);;public void sadd(final byte[] key, final byte[] member) {
	sendCommand(SADD, key, member);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryClient;srem(byte[],byte[]);public void srem(final byte[] key, final byte[]... members) {
        sendCommand(SREM, joinParameters(key, members));;public void srem(final byte[] key, final byte[] member) {
        sendCommand(SREM, key, member);;public void srem(final byte[] key, final byte[] member) {
	sendCommand(SREM, key, member);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryClient;zrem(byte[],byte[]);public void zrem(final byte[] key, final byte[]... members) {
        sendCommand(ZREM, joinParameters( key, members));;public void zrem(final byte[] key, final byte[] member) {
        sendCommand(ZREM, key, member);;public void zrem(final byte[] key, final byte[] member) {
	sendCommand(ZREM, key, member);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryJedis;hdel(byte[],byte[]);public Long hdel(final byte[] key, final byte[]... fields) {
        checkIsInMulti();
        client.hdel(key, fields);
        return client.getIntegerReply();;public Long hdel(final byte[] key, final byte[] field) {
        checkIsInMulti();
        client.hdel(key, field);
        return client.getIntegerReply();;public Long hdel(final byte[] key, final byte[] field) {
	checkIsInMulti();
	client.hdel(key, field);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryJedis;sadd(byte[],byte[]);public Long sadd(final byte[] key, final byte[]... members) {
        checkIsInMulti();
        client.sadd(key, members);
        return client.getIntegerReply();;public Long sadd(final byte[] key, final byte[] member) {
        checkIsInMulti();
        client.sadd(key, member);
        return client.getIntegerReply();;public Long sadd(final byte[] key, final byte[] member) {
	checkIsInMulti();
	client.sadd(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryJedis;srem(byte[],byte[]);public Long srem(final byte[] key, final byte[]... member) {
        checkIsInMulti();
        client.srem(key, member);
        return client.getIntegerReply();;public Long srem(final byte[] key, final byte[] member) {
        checkIsInMulti();
        client.srem(key, member);
        return client.getIntegerReply();;public Long srem(final byte[] key, final byte[] member) {
	checkIsInMulti();
	client.srem(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_dd88c_3da2f/rev_dd88c-3da2f;/src/main/java/redis/clients/jedis/BinaryJedis;zrem(byte[],byte[]);public Long zrem(final byte[] key, final byte[]... members) {
        checkIsInMulti();
        client.zrem(key, members);
        return client.getIntegerReply();;public Long zrem(final byte[] key, final byte[] member) {
        checkIsInMulti();
        client.zrem(key, member);
        return client.getIntegerReply();;public Long zrem(final byte[] key, final byte[] member) {
	checkIsInMulti();
	client.zrem(key, member);
	return client.getIntegerReply();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dd972_719bb/rev_dd972-719bb;/src/java/org/apache/cassandra/tools/NodeProbe;forceKeyspaceCleanup(PrintStream,String,String);            failed = true;
            out.println("Aborted cleaning up atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");;            case ABORTED:
                failed = true;
                out.println("Aborted cleaning up atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");
                break;;            case ABORTED:
                failed = true;
                out.println("Aborted cleaning up atleast one table in keyspace "+keyspaceName+", check server logs for more information.");
                break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dd972_719bb/rev_dd972-719bb;/src/java/org/apache/cassandra/tools/NodeProbe;scrub(PrintStream,boolean,boolean,String,String);            failed = true;
            out.println("Aborted scrubbing atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");;            case ABORTED:
                failed = true;
                out.println("Aborted scrubbing atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");
                break;;            case ABORTED:
                failed = true;
                out.println("Aborted scrubbing atleast one table in keyspace "+keyspaceName+", check server logs for more information.");
                break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_dd972_719bb/rev_dd972-719bb;/src/java/org/apache/cassandra/tools/NodeProbe;upgradeSSTables(PrintStream,String,boolean,String);            failed = true;
            out.println("Aborted upgrading sstables for atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");;            case ABORTED:
                failed = true;
                out.println("Aborted upgrading sstables for atleast one column family in keyspace "+keyspaceName+", check server logs for more information.");
                break;;            case ABORTED:
                failed = true;
                out.println("Aborted upgrading sstables for atleast one table in keyspace "+keyspaceName+", check server logs for more information.");
                break;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ddab6_0d492/rev_ddab6-0d492;/src/java/org/apache/cassandra/locator/GossipingPropertyFileSnitch;GossipingPropertyFileSnitch();            throw new ConfigurationException("DC or rack not found in snitch properties, Plz check your configuration in: " + SnitchProperties.RACKDC_PROPERTY_FILENAME);;            throw new ConfigurationException("DC or rack not found in snitch properties");;            throw new ConfigurationException("DC or rack not found in snitch properties");

        myDC = myDC.trim();
        myRack = myRack.trim();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a;/src/java/voldemort/VoldemortAdminTool;main(String[]);                String metadataKey = ALL_METADATA;
                if(options.hasArgument("get-metadata")) {
                    metadataKey = (String) options.valueOf("get-metadata");
                };                String metadataKey = (String) options.valueOf("get-metadata");;                if(options.has("outdir")) {
                    outputDir = (String) options.valueOf("outdir");
                }
                String metadataKey = (String) options.valueOf("get-metadata");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a;/src/java/voldemort/VoldemortAdminTool;executeGetMetadata(Integer,AdminClient,String,String);            for(String key: metadataKeys) {
                System.out.println("Key - " + key);
                Versioned<String> versioned = null;
                try {
                    versioned = adminClient.getRemoteMetadata(currentNodeId, key);
                } catch(Exception e) {
                    System.out.println("Error in retrieving " + e.getMessage());;            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }
            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");;            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }

            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a;/src/java/voldemort/VoldemortAdminTool;executeGetMetadata(Integer,AdminClient,String,String);                    continue;;                } else {
                    FileUtils.writeStringToFile(new File(directory, "cluster.xml_" + currentNodeId),
                                                "");;                } else {
                    FileUtils.writeStringToFile(new File(directory, metadataKey + "."
                                                                    + currentNodeId), "");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_def0c_5ecec/rev_def0c-5ecec;/src/com/opengamma/financial/batch/BatchJob;initView();    CalculationNodeRequestReceiver calcRequestReceiver = new CalculationNodeRequestReceiver(cacheFactory, 
        getFunctionRepository(), 
        executionContext, 
        targetResolver, 
        viewProcessorQuerySender,
        InetAddressUtils.getLocalHostName());
    JobRequestSender calcRequestSender = new FudgeJobRequestSender(InMemoryRequestConduit.create(calcRequestReceiver));;    CalculationNodeRequestReceiver calcRequestReceiver = new CalculationNodeRequestReceiver(cacheFactory, 
        getFunctionRepository(), 
        executionContext, 
        targetResolver, 
        viewProcessorQuerySender,
        resultWriterFactory,
        InetAddressUtils.getLocalHostName());
    JobRequestSender calcRequestSender = new FudgeJobRequestSender(InMemoryRequestConduit.create(calcRequestReceiver),
        resultWriterFactory,
        null);;    LocalNodeJobInvoker localNode = new LocalNodeJobInvoker(new LocalCalculationNode(cacheFactory, getFunctionRepository(), executionContext, targetResolver, viewProcessorQuerySender));
    localNode.setResultWriterFactory(resultWriterFactory);
    JobDispatcher jobDispatcher = new JobDispatcher(localNode);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_def0c_5ecec/rev_def0c-5ecec;/src/com/opengamma/financial/batch/BatchJob;initView();    DependencyGraphExecutorFactory dependencyGraphExecutorFactory = getBatchDbManager().createDependencyGraphExecutorFactory(this);
    
    ViewProcessingContext vpc = new ViewProcessingContext(
        new PermissiveLiveDataEntitlementChecker(), 
        snapshotProvider, snapshotProvider, 
        getFunctionRepository(), 
        new DefaultFunctionResolver(getFunctionRepository()), 
        positionSource, 
        securitySource, 
        cacheFactory, 
        calcRequestSender, 
        viewProcessorQueryReceiver, 
        compilationContext, 
        executor,
        dependencyGraphExecutorFactory);;    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionRepository(), new DefaultFunctionResolver(
        getFunctionRepository()), positionSource, securitySource, cacheFactory, calcRequestSender, viewProcessorQueryReceiver, compilationContext, executor, new BatchExecutorFactory(),
        resultWriterFactory);;    ViewProcessingContext vpc = new ViewProcessingContext(new PermissiveLiveDataEntitlementChecker(), snapshotProvider, snapshotProvider, getFunctionRepository(), new DefaultFunctionResolver(
        getFunctionRepository()), positionSource, securitySource, cacheFactory, jobDispatcher, viewProcessorQueryReceiver, compilationContext, executor, new BatchExecutorFactory());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_dfeb9_06e8f/rev_dfeb9-06e8f;/server/src/main/java/com/orientechnologies/orient/server/schedule/OScheduleHandler;getDatabase();      if (this.exists(url)) {
        db = new ODatabaseDocumentTx("plocal:" + url).open(this.user, this.pass);;      if (this.exists(url)) {
        db = new ODatabaseDocumentTx("local:" + url).open(this.user, this.pass);;      if(this.existsPLocal(url)) {
        db = new ODatabaseDocumentTx("plocal:" + url).open(this.user, this.pass);
      } else if (this.existsLocal(url)) {
        db = new ODatabaseDocumentTx("local:" + url).open(this.user, this.pass);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e1b10_769fe/rev_e1b10-769fe;/src/java/org/apache/cassandra/db/CollationController;collectAllData();                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);
                iterators.add(iter);;                IColumnIterator iter = filter.getSSTableColumnIterator(sstable);
                iteratorMaxTimes.put(iter, sstable.getMaxTimestamp());;                OnDiskAtomIterator iter = filter.getSSTableColumnIterator(sstable);
                iteratorMaxTimes.put(iter, sstable.getMaxTimestamp());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e3a88_66a3d/rev_e3a88-66a3d;/src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics;ColumnFamilyMetrics(ColumnFamilyStore);        pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
        {
            public Integer value()
            {
                return cfs.getCompactionStrategy().getEstimatedRemainingTasks();
            }
        });
        pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
        {
            public Integer value()
            {
                // TODO this actually isn't a good measure of pending tasks
                return Keyspace.switchLock.getQueueLength();
            }
        });;        pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
        {
            public Integer value()
            {
                // TODO this actually isn't a good measure of pending tasks
                return Keyspace.switchLock.getQueueLength();
            }
        });;        pendingFlushes = Metrics.newCounter(factory.createMetricName("PendingFlushes"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e3b9d_9cc05/rev_e3b9d-9cc05;/projects/OG-Analytics/src/com/opengamma/analytics/financial/model/volatility/smile/fitting/interpolation/SmileInterpolatorSpline;getVolatilityFunction(double,double[],double,double[]);    final double gradL = dSigmaDx.evaluate(kL);
    final double gradH = dSigmaDx.evaluate(kH);
    //
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f1 = getDifferenceFunc(forward, kL, expiry, volL, gradL);
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f2 = getDifferenceFunc(forward, kH, expiry, volH, gradH);
    //
    //    final double[] res1 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f1, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volL)))).getData();
    //    final double[] res2 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f2, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volH)))).getData();;    double gradL = dSigmaDx.evaluate(kL);
    double gradH = dSigmaDx.evaluate(kH);
    //
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f1 = getDifferenceFunc(forward, kL, expiry, volL, gradL);
    //    Function1D<DoubleMatrix1D, DoubleMatrix1D> f2 = getDifferenceFunc(forward, kH, expiry, volH, gradH);
    //
    //    final double[] res1 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f1, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volL)))).getData();
    //    final double[] res2 = TRANSFORMS.inverseTransform(ROOTFINDER.getRoot(f2, TRANSFORMS.transform(new DoubleMatrix1D(0.0, volH)))).getData();;    double gradL = dSigmaDx.evaluate(kL);
    double gradH = dSigmaDx.evaluate(kH);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_e4c44_6d744/rev_e4c44-6d744;/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/provider/ModelBuilder;build(Project);        List<EclipseProjectDependencyVersion2> projectDependencies = new EclipseProjectDependenciesFactory().create(projectMapping, eclipseDomainModel.getClasspath());;        final List<EclipseProjectDependencyVersion2> projectDependencies = new ArrayList<EclipseProjectDependencyVersion2>();

        if (configuration != null) {
            for (final ProjectDependency projectDependency : configuration.getAllDependencies(ProjectDependency.class)) {
                projectDependencies.add(new EclipseProjectDependencyVersion2() {
                    public HierarchicalEclipseProjectVersion1 getTargetProject() {
                        return projectMapping.get(projectDependency.getDependencyProject().getPath());
                    }

                    public String getPath() {
                        return projectDependency.getDependencyProject().getName();
                    }
                });
            }
        };        final List<EclipseProjectDependencyVersion2> projectDependencies = new ArrayList<EclipseProjectDependencyVersion2>();

        if (configuration != null) {
            for (final ProjectDependency projectDependency : configuration.getAllDependencies(ProjectDependency.class)) {
                projectDependencies.add(new EclipseProjectDependencyVersion2() {
                    public HierarchicalEclipseProjectVersion1 getTargetProject() {
                        return get(projectDependency.getDependencyProject());
                    }

                    public String getPath() {
                        return projectDependency.getDependencyProject().getName();
                    }
                });
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e5bc9_2a709/rev_e5bc9-2a709;/projects/OG-Bloomberg/src/com/opengamma/bbg/livedata/AbstractBloombergLiveDataServer;getDefaultDistributionSpecificationResolver();      DefaultDistributionSpecificationResolver distributionSpecResolver = new DefaultDistributionSpecificationResolver(getIdResolver(), getNormalizationRules(), new BloombergJmsTopicNameResolver(
          getCachingReferenceDataProvider()));
      return new EHCachingDistributionSpecificationResolver(distributionSpecResolver, getCacheManager(), "BBG");;      CacheManager cacheManager = EHCacheUtils.createCacheManager();
      DefaultDistributionSpecificationResolver distributionSpecResolver = new DefaultDistributionSpecificationResolver(getIdResolver(), getNormalizationRules(), new BloombergJmsTopicNameResolver(
          getCachingReferenceDataProvider()));
      return new EHCachingDistributionSpecificationResolver(distributionSpecResolver, cacheManager, "BBG");;      CacheManager cacheManager = EHCacheUtils.createCacheManager();
      DefaultDistributionSpecificationResolver distributionSpecResolver = new DefaultDistributionSpecificationResolver(
          getIdResolver(), getNormalizationRules(), new BloombergJmsTopicNameResolver(getReferenceDataProvider()));
      return new EHCachingDistributionSpecificationResolver(distributionSpecResolver, cacheManager, "BBG");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e5c34_5b0d4/rev_e5c34-5b0d4;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                    MessageOut<ReadCommand> message = command.createMessage();
                    for (InetAddress endpoint : handler.endpoints)
                    {
                        Tracing.trace("Enqueuing full data read to {}", endpoint);;                    for (InetAddress endpoint : handler.endpoints)
                    {
                        MessageOut<ReadCommand> message = command.createMessage();;                    MessageOut<ReadCommand> message = exec.command.createMessage();
                    for (InetAddress endpoint : exec.handler.endpoints)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e6d74_91808/rev_e6d74-91808;/src/java/org/apache/cassandra/service/MigrationManager;passiveAnnounce(UUID);        Gossiper.instance.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.instance.valueFactory.migration(version));;        if (!StorageService.instance.isClientMode())
            Gossiper.instance.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.instance.valueFactory.migration(version));;        // this is for notifying nodes as they arrive in the cluster.
        if (!StorageService.instance.isClientMode())
            Gossiper.instance.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.instance.valueFactory.migration(version));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e6d74_91808/rev_e6d74-91808;/src/java/org/apache/cassandra/gms/Gossiper;addLocalApplicationState(ApplicationState,VersionedValue);        EndpointState epState = endpointStateMap_.get(localEndpoint_);;        assert !StorageService.instance.isClientMode();
        EndpointState epState = endpointStateMap_.get(localEndpoint_);;        assert !StorageService.instance.isClientMode();
        EndpointState epState = endpointStateMap.get(FBUtilities.getLocalAddress());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e7bb0_b47a6/rev_e7bb0-b47a6;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/SecurityToFixedIncomeFutureDefinitionConverter;visitBondFutureSecurity(BondFutureSecurity);    Validate.notNull(security, "security");
    if (_underlyingConverter == null) {
      _underlyingConverter = new SecurityToFixedIncomeDefinitionConverter(_holidaySource, _conventionSource, _regionSource);
    }
    final LocalDate deliveryDateLD = null;//deliveryDate.toLocalDate();
    final List<BondFutureDeliverable> deliverableBasket = security.getBasket();
    final int n = deliverableBasket.size();
    final BondDefinition[] deliverableBonds = new BondDefinition[n];
    final double[] conversionFactors = new double[n];
    final int i = 0;
    for (final BondFutureDeliverable bfd : deliverableBasket) {
      final BondSecurity underlyingBond = null;
      final LocalDate lastTradeDate = underlyingBond.getLastTradeDate().getExpiry().toLocalDate();
      Validate.isTrue(deliveryDateLD.isBefore(lastTradeDate), "The bond has expired before delivery");
      //TODO bond futures are exchange-traded - check that this is the same calendar for the exchange as the currency
      final Calendar calendar = new HolidaySourceCalendarAdapter(_holidaySource, security.getCurrency());
      final CurrencyUnit currency = security.getCurrency();
      final String conventionName = currency + "_BOND_FUTURE_DELIVERABLE_CONVENTION";
      final Identifier id = Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, conventionName);
      final ConventionBundle conventionBundle = _conventionSource.getConventionBundle(id);
      Validate.notNull(conventionBundle, "convention bundle " + conventionName);
      final BusinessDayConvention businessDayConvention = conventionBundle.getBusinessDayConvention();
      final BondDefinition deliverable = (BondDefinition) _underlyingConverter.visitBondSecurity(underlyingBond, conventionBundle);
      final BondConvention bondForwardConvention = new BondConvention(conventionBundle.getSettlementDays(), conventionBundle.getDayCount(), businessDayConvention, calendar,
          conventionBundle.isEOMConvention(), conventionName, conventionBundle.getExDividendDays(), conventionBundle.getYieldConvention());

    }
    return null;//new BondForwardDefinition(underlyingBond, deliveryDate.toLocalDate(), bondForwardConvention);;    Validate.notNull(security, "security");
    if (_underlyingConverter == null) {
      _underlyingConverter = new SecurityToFixedIncomeDefinitionConverter(_holidaySource, _conventionSource, _regionSource);
    }
    final LocalDate deliveryDateLD = null;//deliveryDate.toLocalDate();
    final List<BondFutureDeliverable> deliverableBasket = security.getBasket();
    final int n = deliverableBasket.size();
    final BondDefinition[] deliverableBonds = new BondDefinition[n];
    final double[] conversionFactors = new double[n];
    final int i = 0;
    for (final BondFutureDeliverable bfd : deliverableBasket) {
      final BondSecurity underlyingBond = null;
      final LocalDate lastTradeDate = underlyingBond.getLastTradeDate().getExpiry().toLocalDate();
      Validate.isTrue(deliveryDateLD.isBefore(lastTradeDate), "The bond has expired before delivery");
      //TODO bond futures are exchange-traded - check that this is the same calendar for the exchange as the currency
      final Calendar calendar = new HolidaySourceCalendarAdapter(_holidaySource, security.getCurrency());
      final Currency currency = security.getCurrency();
      final String conventionName = currency + "_BOND_FUTURE_DELIVERABLE_CONVENTION";
      final Identifier id = Identifier.of(InMemoryConventionBundleMaster.SIMPLE_NAME_SCHEME, conventionName);
      final ConventionBundle conventionBundle = _conventionSource.getConventionBundle(id);
      Validate.notNull(conventionBundle, "convention bundle " + conventionName);
      final BusinessDayConvention businessDayConvention = conventionBundle.getBusinessDayConvention();
      final BondDefinition deliverable = (BondDefinition) _underlyingConverter.visitBondSecurity(underlyingBond, conventionBundle);
      final BondConvention bondForwardConvention = new BondConvention(conventionBundle.getSettlementDays(), conventionBundle.getDayCount(), businessDayConvention, calendar,
          conventionBundle.isEOMConvention(), conventionName, conventionBundle.getExDividendDays(), conventionBundle.getYieldConvention());

    }
    return null;//new BondForwardDefinition(underlyingBond, deliveryDate.toLocalDate(), bondForwardConvention);;    throw new OpenGammaRuntimeException("Cannot construct a FixedIncomeInstrumentDefinition from an BondFutureSecurity");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_e7bc4_db765/rev_e7bc4-db765;/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler;initializeSlotsCache(Set<HostAndPort>);private void initializeSlotsCache(Set<HostAndPort> startNodes) {
	for (HostAndPort hostAndPort : startNodes) {
	    JedisPool jp = new JedisPool(hostAndPort.getHost(),;private void initializeSlotsCache(Set<HostAndPort> nodes) {
	for (HostAndPort hostAndPort : nodes) {
	    JedisPool jp = new JedisPool(hostAndPort.getHost(),;private void initializeSlotsCache(Set<HostAndPort> nodes) {
	for (HostAndPort hostAndPort : nodes) {
	    JedisPool jp = new JedisPool(poolConfig, hostAndPort.getHost(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_mct/revisions/rev_e9d24_0103b/rev_e9d24-0103b;/limits/src/main/java/gov/nasa/arc/mct/limits/LimitLineComponentProvider;LimitLineComponentProvider();				LimitLineComponent.class, 
				new LimitLineCreateWizardUI()
				);;				LimitLineComponent.class, 
				new LimitLineCreateWizardUI(),
				new ImageIcon(LimitLineComponent.class.getResource("/icons/limit.png")));;				LimitLineComponent.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e39e9_90058/rev_e39e9-90058;/src/java/org/apache/cassandra/metrics/KeyspaceMetrics;release();        for(String name : allMetrics) 
        {
            Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
        }
        // latency metrics contain multiple metrics internally and need to be released manually
        readLatency.release();
        writeLatency.release();
        rangeLatency.release();;        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));;        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e63e1_8abcf/rev_e63e1-8abcf;/projects/OG-Language/Client/src/com/opengamma/language/external/ExternalFunctionProvider;createFunctions(ExternalFunctionCache);    try {
      for (Class<?> clazz : cache.getClasses()) {
        // Use the following test when running with the Test classes in the classpath to
        // avoid generating documentation for them.
        /*if (isTestClass(clazz)) {
          continue;
        }*/
        final ExternalFunctionHandler handler = new ExternalFunctionHandler(clazz);
        functions.addAll(handler.getFunctions());
      }
    } catch (ClassNotFoundException ex) {
      s_logger.info("Class not found", ex);
      return null;;    try {
      for (Class<?> clazz : cache.getClasses()) {
        final ExternalFunctionHandler handler = new ExternalFunctionHandler(clazz);
        functions.addAll(handler.getFunctions());
      }
    } catch (ClassNotFoundException ex) {
      s_logger.info("Class not found", ex);
      return null;;    for (Class<?> clazz : cache.getClasses()) {
      final ExternalFunctionHandler handler = new ExternalFunctionHandler(clazz);
      functions.addAll(handler.getFunctions());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e70f4_071b5/rev_e70f4-071b5;/src/java/org/apache/cassandra/net/IncomingTcpConnection;run();            if (version < MessagingService.VERSION_12)
                throw new UnsupportedOperationException("Unable to read obsolete message version " + version + "; the earliest version supported is 1.2.0");

            receiveMessages();;            if (version < MessagingService.VERSION_12)
                handleLegacyVersion();
            else
                handleModernVersion();;            if (version < MessagingService.VERSION_20)
                throw new UnsupportedOperationException(String.format("Unable to read obsolete message version %s; "
                                                                      + "The earliest version supported is 2.0.0",
                                                                      version));

            handleModernVersion();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd;/src/java/org/apache/cassandra/db/SystemTable;getCurrentLocalNodeId();        Table table = Table.open(Table.SYSTEM_TABLE);

        // Get the last NodeId (since NodeId are timeuuid is thus ordered from the older to the newer one)
        QueryFilter filter = QueryFilter.getSliceFilter(decorate(ALL_LOCAL_NODE_ID_KEY),
                                                        new QueryPath(NODE_ID_CF),
                                                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
                                                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
                                                        true,
                                                        1);;        Table table = Table.open(Table.SYSTEM_TABLE);
        QueryFilter filter = QueryFilter.getIdentityFilter(decorate(CURRENT_LOCAL_NODE_ID_KEY),
                new QueryPath(NODE_ID_CF));;        Table table = Table.open(Table.SYSTEM_KS);

        // Get the last NodeId (since NodeId are timeuuid is thus ordered from the older to the newer one)
        QueryFilter filter = QueryFilter.getSliceFilter(decorate(ALL_LOCAL_NODE_ID_KEY),
                                                        new QueryPath(NODE_ID_CF),
                                                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
                                                        ByteBufferUtil.EMPTY_BYTE_BUFFER,
                                                        true,
                                                        1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e172a_804dd/rev_e172a-804dd;/src/java/org/apache/cassandra/db/SystemTable;getOldLocalNodeIds();        Table table = Table.open(Table.SYSTEM_TABLE);
        QueryFilter filter = QueryFilter.getIdentityFilter(decorate(ALL_LOCAL_NODE_ID_KEY), new QueryPath(NODE_ID_CF));;        Table table = Table.open(Table.SYSTEM_TABLE);
        QueryFilter filter = QueryFilter.getIdentityFilter(decorate(ALL_LOCAL_NODE_ID_KEY),
                new QueryPath(NODE_ID_CF));;        Table table = Table.open(Table.SYSTEM_KS);
        QueryFilter filter = QueryFilter.getIdentityFilter(decorate(ALL_LOCAL_NODE_ID_KEY), new QueryPath(NODE_ID_CF));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e0367_7a5a9/rev_e0367-7a5a9;/projects/OG-Analytics/src/com/opengamma/financial/interestrate/payments/FixedCouponPayment;withRate(double);  public FixedCouponPayment withRate(final double rate) {
    return new FixedCouponPayment(getPaymentTime(), getNotional(), getYearFraction(), rate, getFundingCurveName());;  public FixedCouponPayment withRate(double rate) {
    return new FixedCouponPayment(getPaymentTime(), getYearFraction(), rate, getFundingCurveName());;  public FixedCouponPayment withRate(double rate) {
    return new FixedCouponPayment(getPaymentTime(), getNotional(), getYearFraction(), rate, getFundingCurveName());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e580e_04397/rev_e580e-04397;/src/java/org/apache/cassandra/io/sstable/SSTableMetadata;deserialize(DataInputStream,Descriptor);            EstimatedHistogram rowSizes = EstimatedHistogram.serializer.deserialize(dis);
            EstimatedHistogram columnCounts = EstimatedHistogram.serializer.deserialize(dis);
            ReplayPosition replayPosition = desc.version.metadataIncludesReplayPosition
                                          ? ReplayPosition.serializer.deserialize(dis)
                                          : ReplayPosition.NONE;
            if (!desc.version.metadataIncludesModernReplayPosition)
            {
                // replay position may be "from the future" thanks to older versions generating them with nanotime.
                // make sure we don't omit replaying something that we should.  see CASSANDRA-4782
                replayPosition = ReplayPosition.NONE;
            }
            long minTimestamp = desc.version.tracksMinTimestamp ? dis.readLong() : Long.MIN_VALUE;
            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MAX_VALUE;
            if (!desc.version.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                maxTimestamp = Long.MAX_VALUE;
            double compressionRatio = desc.version.hasCompressionRatio
                                    ? dis.readDouble()
                                    : NO_COMPRESSION_RATIO;
            String partitioner = desc.version.hasPartitioner ? dis.readUTF() : null;
            int nbAncestors = desc.version.hasAncestors ? dis.readInt() : 0;
            Set<Integer> ancestors = new HashSet<Integer>(nbAncestors);
            for (int i = 0; i < nbAncestors; i++)
                ancestors.add(dis.readInt());
            StreamingHistogram tombstoneHistogram = desc.version.tracksTombstones
                                                   ? StreamingHistogram.serializer.deserialize(dis)
                                                   : defaultTombstoneDropTimeHistogram();
            return new SSTableMetadata(rowSizes, columnCounts, replayPosition, minTimestamp, maxTimestamp, compressionRatio, partitioner, ancestors, tombstoneHistogram);;            EstimatedHistogram rowSizes = EstimatedHistogram.serializer.deserialize(dis);
            EstimatedHistogram columnCounts = EstimatedHistogram.serializer.deserialize(dis);
            ReplayPosition replayPosition = desc.version.metadataIncludesReplayPosition
                                          ? ReplayPosition.serializer.deserialize(dis)
                                          : ReplayPosition.NONE;
            if (!desc.version.metadataIncludesModernReplayPosition)
            {
                // replay position may be "from the future" thanks to older versions generating them with nanotime.
                // make sure we don't omit replaying something that we should.  see CASSANDRA-4782
                replayPosition = ReplayPosition.NONE;
            }
            long minTimestamp = desc.version.tracksMinTimestamp ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.version.tracksMinTimestamp)
                minTimestamp = Long.MAX_VALUE;
            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
            if (!desc.version.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                maxTimestamp = Long.MAX_VALUE;
            double compressionRatio = desc.version.hasCompressionRatio
                                    ? dis.readDouble()
                                    : NO_COMPRESSION_RATIO;
            String partitioner = desc.version.hasPartitioner ? dis.readUTF() : null;
            int nbAncestors = desc.version.hasAncestors ? dis.readInt() : 0;
            Set<Integer> ancestors = new HashSet<Integer>(nbAncestors);
            for (int i = 0; i < nbAncestors; i++)
                ancestors.add(dis.readInt());
            StreamingHistogram tombstoneHistogram = desc.version.tracksTombstones
                                                   ? StreamingHistogram.serializer.deserialize(dis)
                                                   : defaultTombstoneDropTimeHistogram();
            return new SSTableMetadata(rowSizes, columnCounts, replayPosition, minTimestamp, maxTimestamp, compressionRatio, partitioner, ancestors, tombstoneHistogram);;            return deserialize(dis, desc, true);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e580e_04397/rev_e580e-04397;/src/java/org/apache/cassandra/db/CollationController;reduceNameFilter(QueryFilter,ColumnFamily,long);        AbstractColumnContainer container = filter.path.superColumnName == null
                                          ? returnCF
                                          : (SuperColumn) returnCF.getColumn(filter.path.superColumnName);
        if (container == null);        AbstractColumnContainer container = filter.path.superColumnName == null
                                          ? returnCF
                                          : (SuperColumn) returnCF.getColumn(filter.path.superColumnName);
        // MIN_VALUE means we don't know any information
        if (container == null || sstableTimestamp == Long.MIN_VALUE);        // MIN_VALUE means we don't know any information
        if (container == null || sstableTimestamp == Long.MIN_VALUE)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_e639d_5eb1c/rev_e639d-5eb1c;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/repositories/legacy/IvyDependencyResolverAdapter;resolveModuleArtifacts(ComponentMetaData,ArtifactResolveContext,BuildableArtifactSetResolveResult);        localResolveModuleArtifacts(component, context, result);;        ModuleVersionMetaData moduleVersion = (ModuleVersionMetaData) component;
        if (context instanceof ConfigurationResolveContext) {
            String configurationName = ((ConfigurationResolveContext) context).getConfigurationName();
            result.resolved(component.getConfiguration(configurationName).getArtifacts());
        } else {
            Class<? extends SoftwareArtifact> artifactType = ((ArtifactTypeResolveContext) context).getArtifactType();
            try {
                result.resolved(doGetCandidateArtifacts(moduleVersion, artifactType));
            } catch (Exception e) {
                result.failed(new ArtifactResolveException(component.getComponentId(), e));
            }
        };        ModuleVersionMetaData moduleVersion = (ModuleVersionMetaData) component;
        if (context instanceof ConfigurationResolveContext) {
            String configurationName = ((ConfigurationResolveContext) context).getConfigurationName();
            result.resolved(component.getConfiguration(configurationName).getArtifacts());
        } else {
            Class<? extends SoftwareArtifact> artifactType = ((ArtifactTypeResolveContext) context).getArtifactType();
            try {
                result.resolved(getCandidateArtifacts(moduleVersion, artifactType));
            } catch (Exception e) {
                result.failed(new ArtifactResolveException(component.getComponentId(), e));
            }
        }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e771b_58910/rev_e771b-58910;/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage;getNextWide();                        if (tuple == null)
                            tuple = keyToTuple(lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        else
                            addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, IColumn> entry : lastRow.entrySet());                        tuple = addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, IColumn> entry : lastRow.entrySet());                        tuple = addKeyToTuple(tuple, lastKey, cfDef, parseType(cfDef.getKey_validation_class()));
                        for (Map.Entry<ByteBuffer, Column> entry : lastRow.entrySet())
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_e1891_fd368/rev_e1891-fd368;/core/src/main/java/com/orientechnologies/orient/core/metadata/schema/OSchemaShared;createClassInternal(String,OClass,int[]);        if (minimumClusters <= 1) {
          clusterIds[0] = database.getClusterIdByName(className);
          if (clusterIds[0] == -1)
            clusterIds[0] = database.addCluster(CLUSTER_TYPE.PHYSICAL.toString(), className, null, null);
        };        if (minimumClusters <= 1)
          clusterIds[0] = database.addCluster(CLUSTER_TYPE.PHYSICAL.toString(), className, null, null);;        if (minimumClusters <= 1)
          clusterIds[0] = database.addCluster(className);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_e1891_fd368/rev_e1891-fd368;/core/src/main/java/com/orientechnologies/orient/core/db/raw/ODatabaseRaw;set(ATTRIBUTES,Object);      storage.getConfiguration().setTimeZone(TimeZone.getTimeZone(stringValue));;      storage.getConfiguration().setTimeZone(TimeZone.getTimeZone(stringValue.toUpperCase()));;      if (stringValue == null)
        throw new IllegalArgumentException("Timezone can't be null");

      storage.getConfiguration().setTimeZone(TimeZone.getTimeZone(stringValue.toUpperCase()));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_e1891_fd368/rev_e1891-fd368;/server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/command/get/OServerCommandGetStorageAllocation;execute(OHttpRequest,OHttpResponse);    ODatabaseDocumentTx db = null;

    try {
      db = getProfiledDatabaseInstance(iRequest);

      if (!(db.getStorage() instanceof OStorageLocal))
        throw new IllegalArgumentException("Cannot get allocation information for database '" + iRequest.databaseName
            + "' because the storage is not 'local'");

      final List<ODataHoleInfo> holes = ((OStorageLocal) db.getStorage()).getHolesList();
      Collections.sort(holes);

      final StringWriter buffer = new StringWriter();
      final OJSONWriter json = new OJSONWriter(buffer);

      final ODataLocal dataSegment = ((OStorageLocal) db.getStorage()).getDataSegmentById(0);
      final long dbSize = dataSegment.getFilledUpTo();

      json.beginObject();
      json.writeAttribute(1, true, "size", dbSize);

      long current = 0;

      long holesSize = 0;

      json.beginCollection(1, true, "segments");
      for (ODataHoleInfo h : holes) {
        if (h.dataOffset == -1)
          continue;

        if (current < h.dataOffset) {
          // DATA SEGMENT
          json.beginObject(2, true, null);
          json.writeAttribute(3, false, "type", "d");
          json.writeAttribute(3, false, "offset", current);
          json.writeAttribute(3, false, "size", h.dataOffset - current);
          json.endObject(2, false);
        }

        json.beginObject(2, true, null);
        json.writeAttribute(3, false, "type", "h");
        json.writeAttribute(3, false, "offset", h.dataOffset);
        json.writeAttribute(3, false, "size", h.size);
        json.endObject(2, false);
        holesSize += h.size;

        current = h.dataOffset + h.size;
      }

      if (dbSize > current) {
        // DATA SEGMENT
        json.beginObject(2, true, null);
        json.writeAttribute(3, false, "type", "d");
        json.writeAttribute(3, false, "offset", current);
        json.writeAttribute(3, false, "size", dbSize - current);
        json.endObject(2, false);
      }

      json.endCollection(1, true);

      json.writeAttribute(1, true, "dataSize", dbSize - holesSize);
      json.writeAttribute(1, true, "dataSizePercent", (dbSize - holesSize) * 100 / dbSize);
      json.writeAttribute(1, true, "holesSize", holesSize);
      json.writeAttribute(1, true, "holesSizePercent", 100 - (dbSize - holesSize) * 100 / dbSize);

      json.endObject();
      json.flush();

      iResponse.send(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON, buffer.toString(), null);
    } finally {
      if (db != null)
        db.close();
    }
    return false;;    ODatabaseDocumentTx db = null;

    try {
      db = getProfiledDatabaseInstance(iRequest);

      if (!(db.getStorage() instanceof OStorageLocal))
        throw new IllegalArgumentException("Cannot get allocation information for database '" + iRequest.databaseName
            + "' because it is not a disk-based database");

      final List<ODataHoleInfo> holes = ((OStorageLocal) db.getStorage()).getHolesList();
      Collections.sort(holes);

      final StringWriter buffer = new StringWriter();
      final OJSONWriter json = new OJSONWriter(buffer);

      final ODataLocal dataSegment = ((OStorageLocal) db.getStorage()).getDataSegmentById(0);
      final long dbSize = dataSegment.getFilledUpTo();

      json.beginObject();
      json.writeAttribute(1, true, "size", dbSize);

      long current = 0;

      long holesSize = 0;

      json.beginCollection(1, true, "segments");
      for (ODataHoleInfo h : holes) {
        if (h.dataOffset == -1)
          continue;

        if (current < h.dataOffset) {
          // DATA SEGMENT
          json.beginObject(2, true, null);
          json.writeAttribute(3, false, "type", "d");
          json.writeAttribute(3, false, "offset", current);
          json.writeAttribute(3, false, "size", h.dataOffset - current);
          json.endObject(2, false);
        }

        json.beginObject(2, true, null);
        json.writeAttribute(3, false, "type", "h");
        json.writeAttribute(3, false, "offset", h.dataOffset);
        json.writeAttribute(3, false, "size", h.size);
        json.endObject(2, false);
        holesSize += h.size;

        current = h.dataOffset + h.size;
      }

      if (dbSize > current) {
        // DATA SEGMENT
        json.beginObject(2, true, null);
        json.writeAttribute(3, false, "type", "d");
        json.writeAttribute(3, false, "offset", current);
        json.writeAttribute(3, false, "size", dbSize - current);
        json.endObject(2, false);
      }

      json.endCollection(1, true);

      json.writeAttribute(1, true, "dataSize", dbSize - holesSize);
      json.writeAttribute(1, true, "dataSizePercent", (dbSize - holesSize) * 100 / dbSize);
      json.writeAttribute(1, true, "holesSize", holesSize);
      json.writeAttribute(1, true, "holesSizePercent", 100 - (dbSize - holesSize) * 100 / dbSize);

      json.endObject();
      json.flush();

      iResponse.send(OHttpUtils.STATUS_OK_CODE, "OK", OHttpUtils.CONTENT_JSON, buffer.toString(), null);
    } finally {
      if (db != null)
        db.close();
    }
    return false;;    throw new IllegalArgumentException("Cannot get allocation information for database '" + iRequest.databaseName
        + "' because it is not implemented yet.");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e4738_41030/rev_e4738-41030;/projects/OG-Web/src/com/opengamma/web/spring/DemoStandardFunctionConfiguration;addEquityDerivativesFunctions(List<FunctionConfiguration>);    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityIndexDividendFuturesFunction.class.getName(), 
        Arrays.asList(ValueRequirementNames.PRESENT_VALUE, EquityFuturePricerFactory.MARK_TO_MARKET, "FUNDING")));
    //functionConfigs.add(new ParameterizedFunctionConfiguration(EquityFuturesFunction.class.getName(), Arrays.asList(ValueRequirementNames.PRESENT_VALUE, EquityFuturePricerFactory.COST_OF_CARRY)));
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityFuturesFunction.class.getName(), 
        Arrays.asList(ValueRequirementNames.PRESENT_VALUE, EquityFuturePricerFactory.DIVIDEND_YIELD, "FUNDING")));
    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityFuturesFunction.class.getName(), ;    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityFuturesFunction.class.getName(), ;    functionConfigs.add(new ParameterizedFunctionConfiguration(EquityFuturesFunction.class.getName(),
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_e7357_ba512/rev_e7357-ba512;/projects/OG-Financial/src/com/opengamma/financial/rest/AbstractRestfulJmsResultConsumer;configureResultListener();      getClient().access(uri).post(msg);
      try {
        if (!_startedSignalLatch.await(START_JMS_RESULT_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {
          s_logger.error("Timed out after {} ms waiting for JMS result stream to be started", START_JMS_RESULT_STREAM_TIMEOUT_MILLIS);
          closeJms();
          throw new OpenGammaRuntimeException("Timed out after " + START_JMS_RESULT_STREAM_TIMEOUT_MILLIS + " ms waiting for JMS result stream to be started");
        }
      } catch (InterruptedException e) {
        s_logger.warn("Interrupted while starting JMS result stream");
        closeJms();
        throw e;
      };      getClient().access(uri).post(msg);;      getClient().accessFudge(uri).post(msg);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_e9357_5102e/rev_e9357-5102e;/src/java/org/apache/cassandra/cql3/statements/SelectStatement;getIndexExpressions(List<ByteBuffer>);            if (restriction.isSlice());            if (restriction.isEquality())
            {
                assert restriction.eqValues.size() == 1; // IN is not supported for indexed columns.
                ByteBuffer value = restriction.eqValues.get(0).bindAndGet(variables);
                if (value == null)
                    throw new InvalidRequestException(String.format("Unsupported null value for indexed column %s", name));
                if (value.remaining() > 0xFFFF)
                    throw new InvalidRequestException("Index expression values may not be larger than 64K");
                expressions.add(new IndexExpression(name.name.key, IndexOperator.EQ, value));
            }
            else;            if (restriction.isEquality())
            {
                assert restriction.eqValues.size() == 1; // IN is not supported for indexed columns.
                ByteBuffer value = restriction.eqValues.get(0).bindAndGet(variables);
                if (value == null)
                    throw new InvalidRequestException(String.format("Unsupported null value for indexed column %s", name));
                if (value.remaining() > 0xFFFF)
                    throw new InvalidRequestException("Index expression values may not be larger than 64K");
                expressions.add(new IndexExpression(name.name.key, IndexExpression.Operator.EQ, value));
            }
            else
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_e9644_7803f/rev_e9644-7803f;/src/main/java/redis/clients/jedis/JedisPool;JedisPool(String,int);public JedisPool(final String host, final int port) {
        super(new Config(), new JedisFactory(host, port,
                Protocol.DEFAULT_TIMEOUT, null));;public JedisPool(String host, int port) {
        super(new Config(), new JedisFactory(host, port,
                Protocol.DEFAULT_TIMEOUT, null));;public JedisPool(String host, int port) {
        this(new Config(), host, port, Protocol.DEFAULT_TIMEOUT, null, Protocol.DEFAULT_DATABASE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ea3c9_52715/rev_ea3c9-52715;/projects/OG-Financial/src/com/opengamma/financial/analytics/conversion/EquityFutureConverter;visitEquityFutureTrade(SimpleTrade);    // I spoke to Elaine about the idea of always pricing against yesterday's close, even on trade date. 
    // Latter case is handled by tradePremium ~ (pricePrevClose - priceTradeTime)*unitAmount*nContracts;    // I spoke to Elaine about the idea of always pricing against yesterday's close, even on trade date. Latter case is handled by tradePremium ~ (pricePrevClose - priceTradeTime)*unitAmount*nContracts;    // I spoke to Elaine about the idea of always pricing against yesterday's close, even on trade date. Latter case is handled by tradePremium ~ (pricePrevClose - priceTradeTime)*unitAmount*nContracts
    // New idea is to set the referencePrice (futuresPrice) to 0.0. In the future, when a ours or another trading system supplies cash flows, we may construct the Definition with a non-zero ref price
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ebb43_2323a/rev_ebb43-2323a;/src/com/opengamma/engine/view/ViewProcessor;initializeView(String);    // view definition - it's easy to imagine that there might be different broad types of view permissioning.
    final FunctionRepository functionRepository = getFunctionCompilationService().getFunctionRepository();
    ViewProcessingContext vpc = new ViewProcessingContext(getLiveDataClient(), getLiveDataAvailabilityProvider(), getLiveDataSnapshotProvider(), functionRepository, new DefaultFunctionResolver(
        functionRepository), getPositionSource(), getSecuritySource(), getComputationCacheSource(), getComputationJobDispatcher(), getViewProcessorQueryReceiver(),
        getFunctionCompilationService().getFunctionCompilationContext(), getExecutorService(), getDependencyGraphExecutorFactory(), getViewPermissionProvider());
    View freshView = new View(viewDefinition, vpc);;    // view definition - it's easy to imagine that there might be different broad types of view permissioning. 
    getCompilationContext().setSecuritySource(getSecuritySource());
    ViewProcessingContext vpc = new ViewProcessingContext(
        getLiveDataClient(),
        getLiveDataAvailabilityProvider(),
        getLiveDataSnapshotProvider(),
        getFunctionRepository(),
        new DefaultFunctionResolver(getFunctionRepository()),
        getPositionSource(),
        getSecuritySource(),
        getComputationCacheSource(),
        getComputationJobDispatcher(),
        getViewProcessorQueryReceiver(),
        getCompilationContext(),
        getExecutorService(),
        getDependencyGraphExecutorFactory(),
        getViewPermissionProvider());
    View freshView = new View(viewDefinition, vpc);;    // view definition - it's easy to imagine that there might be different broad types of view permissioning. 
    getCompilationContext().setSecuritySource(getSecuritySource());
    InMemoryLKVSnapshotProvider viewLevelLiveData = new InMemoryLKVSnapshotProvider();
    ViewProcessingContext vpc = new ViewProcessingContext(
        getLiveDataClient(),
        getLiveDataAvailabilityProvider(),
        new CombiningLiveDataSnapshotProvider(Arrays.asList(viewLevelLiveData, getLiveDataSnapshotProvider())),
        getFunctionRepository(),
        new DefaultFunctionResolver(getFunctionRepository()),
        getPositionSource(),
        getSecuritySource(),
        getComputationCacheSource(),
        getComputationJobDispatcher(),
        getViewProcessorQueryReceiver(),
        getCompilationContext(),
        getExecutorService(),
        getDependencyGraphExecutorFactory(),
        getViewPermissionProvider());
    View freshView = new View(viewDefinition, vpc, viewLevelLiveData);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_openrefine/revisions/rev_ebdc4_31cff/rev_ebdc4-31cff;/main/src/com/google/refine/importers/SeparatorBasedImporter;parseOneFile(Project,ProjectMetadata,ImportingJob,String,Reader,int,JSONObject,List<Exception>);            (char) 0, // escape character
            strictQuotes,;            (char) 0, // escape character
            CSVParser.DEFAULT_STRICT_QUOTES,;            (char) 127, // we don't want escape processing try DEL as a rare character until we can turn it off
            CSVParser.DEFAULT_STRICT_QUOTES,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ecdd8_fabab/rev_ecdd8-fabab;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondSecurityDiscountingMethodTest;dirtyPriceCurveSensitivity();    MulticurveSensitivity sensi = METHOD_BOND_SECURITY.dirtyPriceCurveSensitivity(BOND_FIXED_SECURITY_1, ISSUER_MULTICURVES).cleaned();;    MultipleCurrencyMulticurveSensitivity sensi = METHOD_BOND_SECURITY.dirtyPriceCurveSensitivity(BOND_FIXED_SECURITY_1, ISSUER_MULTICURVES);
    MulticurveSensitivity sensiUSD = sensi.getSensitivity(CUR).cleaned();;    MultipleCurrencyMulticurveSensitivity sensi = METHOD_BOND_SECURITY.dirtyPriceCurveSensitivity(BOND_FIXED_SECURITY_1, ISSUER_MULTICURVES);
    final MulticurveSensitivity sensiUSD = sensi.getSensitivity(CUR).cleaned();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ecdd8_fabab/rev_ecdd8-fabab;/projects/OG-Analytics/src/test/java/com/opengamma/analytics/financial/interestrate/bond/provider/BondSecurityDiscountingMethodTest;dirtyPriceCurveSensitivity();    String DSC_CURVE_NAME = ISSUER_MULTICURVES.getMulticurveProvider().getName(CUR);
    String ISS_CURVE_NAME = ISSUER_MULTICURVES.getName(BOND_FIXED_SECURITY_1.getIssuerCcy());
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime(), sensi.getYieldDiscountingSensitivities().get(DSC_CURVE_NAME)
        .get(0).first, TOLERANCE_PV_DELTA);
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime() / dfSettle * pv.getAmount(CUR) / NOTIONAL, sensi;    String DSC_CURVE_NAME = ISSUER_MULTICURVES.getMulticurveProvider().getName(CUR);
    String ISS_CURVE_NAME = ISSUER_MULTICURVES.getName(BOND_FIXED_SECURITY_1.getIssuerCcy());
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime(),
        sensiUSD.getYieldDiscountingSensitivities().get(DSC_CURVE_NAME).get(0).first, TOLERANCE_PV_DELTA);
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime() / dfSettle * pv.getAmount(CUR) / NOTIONAL, sensiUSD;    final String DSC_CURVE_NAME = ISSUER_MULTICURVES.getMulticurveProvider().getName(CUR);
    final String ISS_CURVE_NAME = ISSUER_MULTICURVES.getName(BOND_FIXED_SECURITY_1.getIssuerCcy());
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime(),
        sensiUSD.getYieldDiscountingSensitivities().get(DSC_CURVE_NAME).get(0).first, TOLERANCE_PV_DELTA);
    assertEquals("Fixed coupon bond security: dirty price curve sensitivity: risk-less curve", BOND_FIXED_SECURITY_1.getSettlementTime() / dfSettle * pv.getAmount(CUR) / NOTIONAL, sensiUSD
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ecdd8_fabab/rev_ecdd8-fabab;/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/future/derivative/DeliverableSwapFuturesSecurity;accept(InstrumentDerivativeVisitor<S,T>,S);  public <S, T> T accept(InstrumentDerivativeVisitor<S, T> visitor, S data) {
    return visitor.visitDeliverableSwapFuturesSecurity(this, data);;  public <S, T> T accept(InstrumentDerivativeVisitor<S, T> visitor, S data) {
    return null;;  public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {
    ArgumentChecker.notNull(visitor, "visitor");
    return visitor.visitDeliverableSwapFuturesSecurity(this, data);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ecdd8_fabab/rev_ecdd8-fabab;/projects/OG-Analytics/src/main/java/com/opengamma/analytics/financial/interestrate/future/derivative/DeliverableSwapFuturesSecurity;accept(InstrumentDerivativeVisitor<?,T>);  public <T> T accept(InstrumentDerivativeVisitor<?, T> visitor) {
    return visitor.visitDeliverableSwapFuturesSecurity(this);;  public <T> T accept(InstrumentDerivativeVisitor<?, T> visitor) {
    return null;;  public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {
    ArgumentChecker.notNull(visitor, "visitor");
    return visitor.visitDeliverableSwapFuturesSecurity(this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_edbd7_df9ca/rev_edbd7-df9ca;/src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement;execute(QueryState,QueryOptions);        // If an IF [NOT] EXISTS clause was used, this may not result in an actual schema change.  To avoid doing
        // extra work in the drivers to handle schema changes, we return an empty message in this case. (CASSANDRA-7600)
        boolean didChangeSchema = announceMigration(false);
        return didChangeSchema ? new ResultMessage.SchemaChange(changeEvent()) : new ResultMessage.Void();;        announceMigration(false);
        return new ResultMessage.SchemaChange(changeEvent());;        announceMigration(false);
        Event.SchemaChange ce = changeEvent();
        return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_edbd7_df9ca/rev_edbd7-df9ca;/src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement;executeInternal(QueryState,QueryOptions);            boolean didChangeSchema = announceMigration(true);
            return didChangeSchema ? new ResultMessage.SchemaChange(changeEvent()) : new ResultMessage.Void();;            announceMigration(true);
            return new ResultMessage.SchemaChange(changeEvent());;            announceMigration(true);
            Event.SchemaChange ce = changeEvent();
            return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_lucenesolr/revisions/rev_edd8f_a670b/rev_edd8f-a670b;/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv;before();    } else if ("Lucene41".equals(TEST_CODEC) || ("random".equals(TEST_CODEC) &&
                                                 "random".equals(TEST_POSTINGSFORMAT) &&
                                                 randomVal == 1 &&
                                                 !shouldAvoidCodec("Lucene41"))) { 
      codec = Codec.forName("Lucene41");
      assert codec instanceof Lucene41RWCodec : "fix your classpath to have tests-framework.jar before lucene-core.jar";
    } else if (!"random".equals(TEST_POSTINGSFORMAT)) {;    } else if (!"random".equals(TEST_POSTINGSFORMAT)) {;    } else if ("Lucene41".equals(TEST_CODEC) || ("random".equals(TEST_CODEC) &&
                                                 "random".equals(TEST_POSTINGSFORMAT) &&
                                                 "random".equals(TEST_DOCVALUESFORMAT) &&
                                                 randomVal == 1 &&
                                                 !shouldAvoidCodec("Lucene41"))) { 
      codec = Codec.forName("Lucene41");
      assert codec instanceof Lucene41RWCodec : "fix your classpath to have tests-framework.jar before lucene-core.jar";
    } else if (("random".equals(TEST_POSTINGSFORMAT) == false) || ("random".equals(TEST_DOCVALUESFORMAT) == false)) {
      // the user wired postings or DV: this is messy
      // refactor into RandomCodec....
      
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_edd69_26e60/rev_edd69-26e60;/object/src/main/java/com/orientechnologies/orient/object/db/ODatabaseObjectTx;commit();  public ODatabasePojoAbstract<Object> commit() {
    try {
      // BY PASS DOCUMENT DB
      ((ODatabaseRecordTx) underlying.getUnderlying()).commit();

      if (getTransaction().getAllRecordEntries() != null) {
        // UPDATE ID & VERSION FOR ALL THE RECORDS
        Object pojo = null;
        for (ORecordOperation entry : getTransaction().getAllRecordEntries()) {
          pojo = records2Objects.get(entry.getRecord());

          if (pojo != null)
            switch (entry.type) {
            case ORecordOperation.CREATED:
              rid2Records.put(entry.getRecord().getIdentity(), (ODocument) entry.getRecord());
              OObjectSerializerHelper.setObjectID(entry.getRecord().getIdentity(), pojo);

            case ORecordOperation.UPDATED:
              OObjectSerializerHelper.setObjectVersion(entry.getRecord().getVersion(), pojo);
              break;

            case ORecordOperation.DELETED:
              OObjectSerializerHelper.setObjectID(null, pojo);
              OObjectSerializerHelper.setObjectVersion(null, pojo);

              unregisterPojo(pojo, (ODocument) entry.getRecord());
              break;
            }
        }
      }
    } finally {
      getTransaction().close();
    };	public ODatabasePojoAbstract<Object> commit() {
		try {
			// BY PASS DOCUMENT DB
			((ODatabaseRecordTx) underlying.getUnderlying()).commit();

			if (getTransaction().getAllRecordEntries() != null) {
				// UPDATE ID & VERSION FOR ALL THE RECORDS
				Object pojo = null;
				for (ORecordOperation entry : getTransaction().getAllRecordEntries()) {
					pojo = records2Objects.get(entry.getRecord());

					if (pojo != null)
						switch (entry.type) {
						case ORecordOperation.CREATED:
							rid2Records.put(entry.getRecord().getIdentity(), (ODocument) entry.getRecord());
							OObjectSerializerHelper.setObjectID(entry.getRecord().getIdentity(), pojo);

						case ORecordOperation.UPDATED:
							OObjectSerializerHelper.setObjectVersion(entry.getRecord().getVersion(), pojo);
							break;

						case ORecordOperation.DELETED:
							OObjectSerializerHelper.setObjectID(null, pojo);
							OObjectSerializerHelper.setObjectVersion(null, pojo);

							unregisterPojo(pojo, (ODocument) entry.getRecord());
							break;
						}
				}
			}
		} finally {
			getTransaction().close();
		};	public ODatabasePojoAbstract<Object> commit() {
		try {
			// BY PASS DOCUMENT DB
			((ODatabaseRecordTx) underlying.getUnderlying()).commit();

			if (getTransaction().getAllRecordEntries() != null) {
				// UPDATE ID & VERSION FOR ALL THE RECORDS
				Object pojo = null;
				for (ORecordOperation entry : getTransaction().getAllRecordEntries()) {
					pojo = records2Objects.get(entry.getRecord());

					if (pojo != null)
						switch (entry.type) {
						case ORecordOperation.CREATED:
							rid2Records.put(entry.getRecord().getIdentity(), (ODocument) entry.getRecord());
							OObjectSerializerHelper.setObjectID(entry.getRecord().getIdentity(), pojo);

            case ORecordOperation.UPDATED:
              OObjectSerializerHelper.setObjectVersion(entry.getRecord().getRecordVersion().copy(), pojo);
              break;

						case ORecordOperation.DELETED:
							OObjectSerializerHelper.setObjectID(null, pojo);
							OObjectSerializerHelper.setObjectVersion(null, pojo);

							unregisterPojo(pojo, (ODocument) entry.getRecord());
							break;
						}
				}
			}
		} finally {
			getTransaction().close();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_edd69_26e60/rev_edd69-26e60;/object/src/main/java/com/orientechnologies/orient/object/db/ODatabaseObjectTx;checkSecurity(String,int,Object);public <DBTYPE extends ODatabase> DBTYPE checkSecurity(final String iResource, final int iOperation, Object iResourceSpecific) {
    return (DBTYPE) underlying.checkSecurity(iResource, iOperation, iResourceSpecific);
  };public <DBTYPE extends ODatabase> DBTYPE checkSecurity(final String iResource, final int iOperation, Object iResourceSpecific) {
		return (DBTYPE) underlying.checkSecurity(iResource, iOperation, iResourceSpecific);
	};public <DBTYPE extends ODatabase> DBTYPE checkSecurity(final String iResource, final int iOperation, Object... iResourcesSpecific) {
		return (DBTYPE) underlying.checkSecurity(iResource, iOperation, iResourcesSpecific);
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_edfc0_5cda7/rev_edfc0-5cda7;/src/java/org/apache/cassandra/cql/QueryProcessor;getStatement(String);        try
        {
            // Lexer and parser
            CharStream stream = new ANTLRStringStream(queryStr);
            CqlLexer lexer = new CqlLexer(stream);
            TokenStream tokenStream = new CommonTokenStream(lexer);
            CqlParser parser = new CqlParser(tokenStream);
            
            // Parse the query string to a statement instance
            CQLStatement statement = parser.query();
            
            // The lexer and parser queue up any errors they may have encountered
            // along the way, if necessary, we turn them into exceptions here.
            lexer.throwLastRecognitionError();
            parser.throwLastRecognitionError();
            
            return statement;
        } 
        catch (RuntimeException re)
        {
            InvalidRequestException ire = new InvalidRequestException("Failed parsing statement: [" + queryStr + "] reason: " + re.getClass().getSimpleName() + " " + re.getMessage());
            ire.initCause(re);
            throw ire;
        };        // Lexer and parser
        CharStream stream = new ANTLRStringStream(queryStr);
        CqlLexer lexer = new CqlLexer(stream);
        TokenStream tokenStream = new CommonTokenStream(lexer);
        CqlParser parser = new CqlParser(tokenStream);
        
        // Parse the query string to a statement instance
        CQLStatement statement = parser.query();
        
        // The lexer and parser queue up any errors they may have encountered
        // along the way, if necessary, we turn them into exceptions here.
        lexer.throwLastRecognitionError();
        parser.throwLastRecognitionError();
        
        return statement;;        // Lexer and parser
        CharStream stream = new ANTLRStringStream(queryStr);
        CqlLexer lexer = new CqlLexer(stream);
        TokenStream tokenStream = new CommonTokenStream(lexer);
        CqlParser parser = new CqlParser(tokenStream);

        // Parse the query string to a statement instance
        CQLStatement statement = parser.query();

        // The lexer and parser queue up any errors they may have encountered
        // along the way, if necessary, we turn them into exceptions here.
        lexer.throwLastRecognitionError();
        parser.throwLastRecognitionError();

        return statement;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_ee0d1_36389/rev_ee0d1-36389;/src/java/org/apache/cassandra/service/StorageService;joinTokenRing(int);        Schema.instance.updateVersionAndAnnounce(); // Ensure we know our own actual Schema UUID in preparation for updates;        // gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)
        Schema.instance.updateVersion(); // Ensure we know our own actual Schema UUID in preparation for updates
        MigrationManager.passiveAnnounce(Schema.emptyVersion);;        // gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)
        Schema.instance.updateVersionAndAnnounce(); // Ensure we know our own actual Schema UUID in preparation for updates
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862;/build-tools/core/src/org/jetbrains/jet/buildtools/core/BytecodeCompiler;env(String,String[]);        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);;        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);;        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862;/compiler/cli/src/org/jetbrains/jet/cli/jvm/K2JVMCompiler;exec(PrintStream,K2JVMCompilerArguments);public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {
        if (arguments.help) {
            usage(errStream);
            return OK;
        }
        System.setProperty("java.awt.headless", "true");

        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;

        errStream.print(messageRenderer.renderPreamble());

        try {
            if (arguments.version) {
                errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, "Kotlin Compiler version " + K2JVMCompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));
            }

            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);

            File jdkHeadersJar;
            if (mode.includeJdkHeaders()) {
                if (arguments.jdkHeaders != null) {
                    jdkHeadersJar = new File(arguments.jdkHeaders);
                }
                else {
                    jdkHeadersJar = PathUtil.getAltHeadersPath();
                }
            }
            else {
                jdkHeadersJar = null;
            }
            File runtimeJar;

            if (mode.includeKotlinRuntime()) {
                if (arguments.stdlib != null) {
                    runtimeJar = new File(arguments.stdlib);
                }
                else {
                    runtimeJar = PathUtil.getDefaultRuntimePath();
                }
            }
            else {
                runtimeJar = null;
            }

            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);
            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);
            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();

            JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);
            CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, messageCollector);

            messageCollector.report(CompilerMessageSeverity.LOGGING, "Configuring the compilation environment",
                                    CompilerMessageLocation.NO_LOCATION);
            try {
                configureEnvironment(configuration, arguments);

                boolean noErrors;
                if (arguments.module != null) {
                    List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));
                    File directory = new File(arguments.module).getParentFile();
                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,
                                                                          directory, arguments.jar, arguments.outputDir,
                                                                          arguments.includeRuntime);
                }
                else {
                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs
                    if (arguments.getSourceDirs() != null) {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,
                                                                                               arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                    else {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,
                                                                     arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                }
                return noErrors ? OK : COMPILATION_ERROR;
            }
            catch (CompilationException e) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),
                                        MessageUtil.psiElementToMessageLocation(e.getElement()));
                return INTERNAL_ERROR;
            }
            catch (Throwable t) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t), CompilerMessageLocation.NO_LOCATION);
                return INTERNAL_ERROR;
            }
            finally {
                Disposer.dispose(rootDisposable);
                messageCollector.printToErrStream();
            }
        }
        finally {
             errStream.print(messageRenderer.renderConclusion());
        };public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {
        if (arguments.help) {
            usage(errStream);
            return OK;
        }
        System.setProperty("java.awt.headless", "true");

        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;

        errStream.print(messageRenderer.renderPreamble());

        try {
            if (arguments.version) {
                errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, "Kotlin Compiler version " + K2JVMCompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));
            }

            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);

            File jdkHeadersJar;
            if (mode.includeJdkHeaders()) {
                if (arguments.jdkHeaders != null) {
                    jdkHeadersJar = new File(arguments.jdkHeaders);
                }
                else {
                    jdkHeadersJar = PathUtil.getAltHeadersPath();
                }
            }
            else {
                jdkHeadersJar = null;
            }
            File runtimeJar;

            if (mode.includeKotlinRuntime()) {
                if (arguments.stdlib != null) {
                    runtimeJar = new File(arguments.stdlib);
                }
                else {
                    runtimeJar = PathUtil.getDefaultRuntimePath();
                }
            }
            else {
                runtimeJar = null;
            }

            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);
            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);
            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();

            JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);
            CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, messageCollector);

            messageCollector.report(CompilerMessageSeverity.LOGGING, "Configuring the compilation environment",
                                    CompilerMessageLocation.NO_LOCATION);
            try {
                configureEnvironment(configuration, arguments);

                boolean noErrors;
                if (arguments.module != null) {
                    List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));
                    File directory = new File(arguments.module).getParentFile();
                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,
                                                                          directory, arguments.jar, arguments.outputDir,
                                                                          arguments.includeRuntime);
                }
                else {
                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs
                    if (arguments.getSourceDirs() != null) {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,
                                                                                               arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                    else {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,
                                                                     arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                }
                return noErrors ? OK : COMPILATION_ERROR;
            }
            catch (CompilationException e) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),
                                        MessageUtil.psiElementToMessageLocation(e.getElement()));
                return INTERNAL_ERROR;
            }
            catch (Throwable t) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t), CompilerMessageLocation.NO_LOCATION);
                return INTERNAL_ERROR;
            }
            finally {
                Disposer.dispose(rootDisposable);
                messageCollector.printToErrStream();
            }
        }
        finally {
             errStream.print(messageRenderer.renderConclusion());
        };@NotNull
    @Override
    public ExitCode exec(PrintStream errStream, K2JVMCompilerArguments arguments) {
        return super.exec(errStream, arguments);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862;/compiler/tests/org/jetbrains/jet/codegen/CompileTextTest;testMe();        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(
                myEnvironment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);;        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);
        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);;        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);
        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_f1b9f_fd4dd/rev_f1b9f-fd4dd;/graphdb/src/test/java/com/tinkerpop/blueprints/impls/orient/OrientGraphTest;doTestSuite(TestSuite);    dropGraph("graph");;    String directory = getWorkingDirectory();
    deleteDirectory(new File(directory));;    String directory = getWorkingDirectory();
    deleteDirectory(new File(directory+"/graph"));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac;/src/java/voldemort/client/protocol/admin/AdminClient;waitForCompletion(int,int,long,TimeUnit);            if(delay < MAX_DELAY) {
                // keep doubling the wait period until we reach maxDelay;            if(delay < MAX_DELAY)
                // keep doubling the wait period until we rach maxDelay;            if(status.hasException())
                throw new VoldemortException(status.getException());

            logger.info("Waiting for AsyncTask to finish taskId:" + requestId + " description("
                        + status.getDescription() + ")  currentStatus:" + status.getStatus());
            if(delay < MAX_DELAY)
                // keep doubling the wait period until we reach maxDelay
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f3bad_9dfd5/rev_f3bad-9dfd5;/src/com/opengamma/engine/security/CachingSecurityMaster;getSecurities(IdentifierBundle);  public synchronized Collection<Security> getSecurities(IdentifierBundle secKey) {
    if (_bundleCache.containsKey(secKey)) {
      return _bundleCache.get(secKey);
    }
    Collection<Security> result = getUnderlying().getSecurities(secKey);
    _bundleCache.put(secKey, result);
    return result;;  public Collection<Security> getSecurities(IdentifierBundle secKey) {
    return getUnderlying().getSecurities(secKey);;  public Collection<Security> getSecurities(IdentifierBundle secKey) {
    if(_identifierBundle2SecurityCollectionCache.containsKey(secKey)) {
      return _identifierBundle2SecurityCollectionCache.get(secKey);
    }
    Collection<Security> result = getUnderlying().getSecurities(secKey);
    _identifierBundle2SecurityCollectionCache.put(secKey, result);
    return result;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f3bad_9dfd5/rev_f3bad-9dfd5;/src/com/opengamma/engine/security/CachingSecurityMaster;getSecurity(IdentifierBundle);    return matched.iterator().next();;    Security result = getUnderlying().getSecurity(secKey);
    _cache.put(secKey, result);
    return result;;    Security result = getUnderlying().getSecurity(secKey);
    _identifierBundle2SecurityCache.put(secKey, result);
    return result;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f3f69_e0c4c/rev_f3f69-e0c4c;/src/java/org/apache/cassandra/tools/SSTableExport;export(Descriptor,PrintStream,Collection<String>,String[]);                Iterator<OnDiskAtom> atomIterator = sstable.metadata.getOnDiskIterator(dfile, columnCount,
                        sstable.descriptor.version);

                checkStream(outs);;            dfile.seek(entry.position);
            ByteBufferUtil.readWithShortLength(dfile); // row key
            if (sstable.descriptor.version.hasRowSizeAndColumnCount)
                dfile.readLong(); // row size
            DeletionInfo deletionInfo = new DeletionInfo(DeletionTime.serializer.deserialize(dfile));
            int columnCount = sstable.descriptor.version.hasRowSizeAndColumnCount ? dfile.readInt() : Integer.MAX_VALUE;

            Iterator<OnDiskAtom> atomIterator = sstable.metadata.getOnDiskIterator(dfile, columnCount, sstable.descriptor.version);;            dfile.seek(entry.position);
            ByteBufferUtil.readWithShortLength(dfile); // row key
            DeletionInfo deletionInfo = new DeletionInfo(DeletionTime.serializer.deserialize(dfile));
            Iterator<OnDiskAtom> atomIterator = sstable.metadata.getOnDiskIterator(dfile, sstable.descriptor.version);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f05d1_251e2/rev_f05d1-251e2;/src/java/org/apache/cassandra/db/ColumnFamilyStore;scheduleCacheSaving(int,int);        if (saveRowCacheTask != null)
        {
            saveRowCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveRowCacheTask = null;
        }
        if (rowCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitRowCacheWrite();
                }
            };
            saveRowCacheTask = StorageService.tasks.scheduleWithFixedDelay(runnable,
                                                                           rowCacheSavePeriodInSeconds,
                                                                           rowCacheSavePeriodInSeconds,
                                                                           TimeUnit.SECONDS);
        }

        if (saveKeyCacheTask != null)
        {
            saveKeyCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveKeyCacheTask = null;
        }
        if (keyCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitKeyCacheWrite();
                }
            };
            saveKeyCacheTask = StorageService.tasks.scheduleWithFixedDelay(runnable,
                                                                           keyCacheSavePeriodInSeconds,
                                                                           keyCacheSavePeriodInSeconds,
                                                                           TimeUnit.SECONDS);
        };        if (saveRowCacheTask != null)
        {
            saveRowCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveRowCacheTask = null;
        }
        if (rowCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitRowCacheWrite();
                }
            };
            saveRowCacheTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable,
                                                                                    rowCacheSavePeriodInSeconds,
                                                                                    rowCacheSavePeriodInSeconds,
                                                                                    TimeUnit.SECONDS);
        }

        if (saveKeyCacheTask != null)
        {
            saveKeyCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveKeyCacheTask = null;
        }
        if (keyCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitKeyCacheWrite();
                }
            };
            saveKeyCacheTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable,
                                                                                    keyCacheSavePeriodInSeconds,
                                                                                    keyCacheSavePeriodInSeconds,
                                                                                    TimeUnit.SECONDS);
        };        keyCache.scheduleSaving(keyCacheSavePeriodInSeconds);
        rowCache.scheduleSaving(rowCacheSavePeriodInSeconds);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f05d1_251e2/rev_f05d1-251e2;/src/java/org/apache/cassandra/gms/Gossiper;start(int);        scheduledGossipTask = executor.scheduleWithFixedDelay(new GossipTask(),
                                                              Gossiper.intervalInMillis_,
                                                              Gossiper.intervalInMillis_,
                                                              TimeUnit.MILLISECONDS);;        scheduledGossipTask = StorageService.scheduledTasks.scheduleWithFixedDelay(new GossipTask(),
                                                                                   Gossiper.intervalInMillis_,
                                                                                   Gossiper.intervalInMillis_,
                                                                                   TimeUnit.MILLISECONDS);;        scheduledGossipTask = StorageService.scheduledTasks.scheduleWithFixedDelay(new GossipTask(),
                                                                                   Gossiper.intervalInMillis,
                                                                                   Gossiper.intervalInMillis,
                                                                                   TimeUnit.MILLISECONDS);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f05d1_cd62c/rev_f05d1-cd62c;/src/java/org/apache/cassandra/db/ColumnFamilyStore;scheduleCacheSaving(int,int);        if (saveRowCacheTask != null)
        {
            saveRowCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveRowCacheTask = null;
        }
        if (rowCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitRowCacheWrite();
                }
            };
            saveRowCacheTask = StorageService.tasks.scheduleWithFixedDelay(runnable,
                                                                           rowCacheSavePeriodInSeconds,
                                                                           rowCacheSavePeriodInSeconds,
                                                                           TimeUnit.SECONDS);
        }

        if (saveKeyCacheTask != null)
        {
            saveKeyCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveKeyCacheTask = null;
        }
        if (keyCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitKeyCacheWrite();
                }
            };
            saveKeyCacheTask = StorageService.tasks.scheduleWithFixedDelay(runnable,
                                                                           keyCacheSavePeriodInSeconds,
                                                                           keyCacheSavePeriodInSeconds,
                                                                           TimeUnit.SECONDS);
        };        if (saveRowCacheTask != null)
        {
            saveRowCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveRowCacheTask = null;
        }
        if (rowCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitRowCacheWrite();
                }
            };
            saveRowCacheTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable,
                                                                                    rowCacheSavePeriodInSeconds,
                                                                                    rowCacheSavePeriodInSeconds,
                                                                                    TimeUnit.SECONDS);
        }

        if (saveKeyCacheTask != null)
        {
            saveKeyCacheTask.cancel(false); // Do not interrupt an in-progress save
            saveKeyCacheTask = null;
        }
        if (keyCacheSavePeriodInSeconds > 0)
        {
            Runnable runnable = new WrappedRunnable()
            {
                public void runMayThrow()
                {
                    submitKeyCacheWrite();
                }
            };
            saveKeyCacheTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable,
                                                                                    keyCacheSavePeriodInSeconds,
                                                                                    keyCacheSavePeriodInSeconds,
                                                                                    TimeUnit.SECONDS);
        };        keyCache.scheduleSaving(keyCacheSavePeriodInSeconds);
        rowCache.scheduleSaving(rowCacheSavePeriodInSeconds);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f05d1_cd62c/rev_f05d1-cd62c;/src/java/org/apache/cassandra/gms/Gossiper;start(int);        scheduledGossipTask = executor.scheduleWithFixedDelay(new GossipTask(),
                                                              Gossiper.intervalInMillis_,
                                                              Gossiper.intervalInMillis_,
                                                              TimeUnit.MILLISECONDS);;        scheduledGossipTask = StorageService.scheduledTasks.scheduleWithFixedDelay(new GossipTask(),
                                                                                   Gossiper.intervalInMillis_,
                                                                                   Gossiper.intervalInMillis_,
                                                                                   TimeUnit.MILLISECONDS);;        scheduledGossipTask = StorageService.scheduledTasks.scheduleWithFixedDelay(new GossipTask(),
                                                                                   Gossiper.intervalInMillis,
                                                                                   Gossiper.intervalInMillis,
                                                                                   TimeUnit.MILLISECONDS);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f5d63_2bcfa/rev_f5d63-2bcfa;/src/java/org/apache/cassandra/service/CacheService;deserialize(DataInputStream,ColumnFamilyStore);            RowIndexEntry entry = promotedIndexes
                                ? RowIndexEntry.serializer.deserialize(input, reader.descriptor.version)
                                : reader.getPosition(reader.partitioner.decorateKey(key), Operator.EQ, false);;            RowIndexEntry entry = promotedIndexes
                                ? RowIndexEntry.serializer.deserialize(input, reader.descriptor.version)
                                : reader.getPosition(reader.partitioner.decorateKey(key), Operator.EQ);;            RowIndexEntry entry = RowIndexEntry.serializer.deserialize(input, reader.descriptor.version);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;install();@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
				.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
				.numberOfPartitions(1)
				// All PUs on this role share the same machine. Machines
				// are identified by zone.
				.sharedMachineProvisioning(
						"public",
						new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
								.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
								.create())
				// Eager scale (1 container per machine per PU)
				.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create())
				.addCommandLineArgument(this.lrmiCommandLineArgument);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}
		// The gsc java options define the lrmi port range and memory size if not defined.

		getGridServiceManager().deploy(deployment);;@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
				.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
				.numberOfPartitions(1)
				// All PUs on this role share the same machine. Machines
				// are identified by zone.
				.sharedMachineProvisioning(
						"public",
						new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
								.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
								.create())
				// Eager scale (1 container per machine per PU)
				.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create());

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);;@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final File puFile = getManagementSpacePUFile();

		// final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
		final ElasticStatefulProcessingUnitDeployment deployment =
				new ElasticStatefulProcessingUnitDeployment(puFile).name(serviceName)
						.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
						.numberOfPartitions(1)
						// All PUs on this role share the same machine. Machines
						// are identified by zone.
						.sharedMachineProvisioning(
								"public",
								new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
										.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
										.create())
						// Eager scale (1 container per machine per PU)
						.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create())
						.addCommandLineArgument(this.lrmiCommandLineArgument);

		if (this.persistentStoragePath != null) {
			deployment.addCommandLineArgument("-Dspring.profiles.active=persistent");
		}

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}
		// The gsc java options define the lrmi port range and memory size if not defined.

		getGridServiceManager().deploy(deployment);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;installOnLocalCloud();public void installOnLocalCloud() 
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);;public void installOnLocalCloud() 
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);;public void installOnLocalCloud()
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final File puFile = getManagementSpacePUFile();

		final ProcessingUnitDeployment deployment =
				new ProcessingUnitDeployment(puFile).name(serviceName).addZone(serviceName);

		// SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;waitForInstallation(AdminFacade,GridServiceAgent,long,TimeUnit);@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}
				
				logger.fine("Connecting to management space.");
				if (verbose){
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});
		
		logger.fine("Management space is available.");
		if (verbose){
			logger.fine("Management space is available.");
		};@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}
				
				logger.fine("Connecting to management space.");
				if (verbose){
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});
		
		logger.fine("Management space is available.");
		if (verbose){
			logger.fine("Management space is available.");
		};@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}

				logger.fine("Connecting to management space.");
				if (verbose) {
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});

		logger.fine("Management space is available.");
		if (verbose) {
			logger.fine("Management space is available.");
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;addListener(LocalhostBootstrapperListener);public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);;public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);;public void addListener(final LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;addListeners(List<LocalhostBootstrapperListener>);public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		};public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		};public void addListeners(final List<LocalhostBootstrapperListener> listeners) {
		for (final LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller;setIsLocalCloud(boolean);public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;;public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
		;public void setIsLocalCloud(final boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;installLocalCloud();public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}
		
		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName) 
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);;public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}
		
		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName) 
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);;public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName)
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;waitForProcessingUnitInstance(GridServiceAgent,long,TimeUnit);public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			boolean messagePublished = false;
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished){
					String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone){
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;;public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			boolean messagePublished = false;
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished){
					String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone){
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;;public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			private boolean messagePublished = false;

			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished) {
					final String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone) {
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		final String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;waitForConnection(AdminFacade,String,String,URL,long,TimeUnit);private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
					throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});;private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
					throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});;private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;getWebProcessingUnitURL(GridServiceAgent,ProcessingUnit,boolean);public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu, 
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		};public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu, 
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		};public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu,
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;addListener(LocalhostBootstrapperListener);public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);;public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);;public void addListener(final LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;addListeners(List<LocalhostBootstrapperListener>);public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		};public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		};public void addListeners(final List<LocalhostBootstrapperListener> listeners) {
		for (final LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;setIsLocalCloud(boolean);public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;;public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;;public void setIsLocalCloud(final boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller;setIsSecureConnection(boolean);public void setIsSecureConnection(boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;;public void setIsSecureConnection(boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;;public void setIsSecureConnection(final boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;startLocalCloudOnLocalhostAndWait(String,String,String,String,String,String,int,TimeUnit);public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath, 
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		};public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath, 
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		};public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile,
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile,
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;startManagementOnLocalhostAndWait(String,String,String,String,String,String,int,TimeUnit);public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);;public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);;public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		try {
			this.cloud = ServiceReader.readCloud(new File(this.cloudFilePath));
		} catch (final IOException e) {
			throw new CLIException("Failed to read cloud file: " + e.getMessage(), e);
		} catch (final DSLException e) {
			throw new CLIException("Failed to read cloud file: " + e.getMessage(), e);
		}

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;uninstallApplications(long,TimeUnit);private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
                                CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		};private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
                                CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		};private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
								CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;shutdownAgentAndWait(GridServiceAgent,long,TimeUnit);private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was
			 * shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
                            "shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});;private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was
			 * shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
                            "shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});;private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;runGsAgentOnLocalHost(String,String[],String,String,String,String);private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments, 
			final String securityProfile, final String securityFilePath, final String keystoreFilePath, 
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);;private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments, 
			final String securityProfile, final String securityFilePath, final String keystoreFilePath, 
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);;private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments,
			final String securityProfile, final String securityFilePath, final String keystoreFilePath,
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;startManagementOnLocalhostAndWaitInternal(String[],String,String,String,String,String,String,int,TimeUnit,boolean);private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile, 
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(CloudifyConstants.MANAGEMENT_SPACE_MEMORY_IN_MB, MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					managementSpaceInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud, 
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent, 
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		};private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile, 
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(MANAGEMENT_SPACE_MEMORY_IN_MB, MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud, 
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent, 
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		};private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile,
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					final String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(CloudifyConstants.MANAGEMENT_SPACE_MEMORY_IN_MB,
							MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					managementSpaceInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

					if (!this.isLocalCloud) {
						final String persistentStoragePath = this.cloud.getConfiguration().getPersistentStoragePath();
						if (persistentStoragePath != null) {
							final String spaceStoragePath = persistentStoragePath + "/management-space/db.h2";
							managementSpaceInstaller.setPersistentStoragePath(spaceStoragePath);
						}
					}
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud,
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent,
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;installWebServices(String,String,boolean,boolean,GridServiceAgent,List<AbstractManagementServiceInstaller>);private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent, 
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
		long webuiMemory = getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR);
		int webuiPort = getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection);
		
		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(webuiMemory, MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(webuiPort);
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		webuiInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
		
		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		int restPort = getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection);
		long webServiceMemory = getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR);
		
		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(webServiceMemory, MemoryUnit.MEGABYTES);
		restInstaller.setPort(restPort);
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		restInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
		
		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);;private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent, 
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR), MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection));
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		
		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR), MemoryUnit.MEGABYTES);
		restInstaller.setPort(getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection));
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		
		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);;private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent,
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		final String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
		final long webuiMemory = getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR);
		final int webuiPort = getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection);

		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(webuiMemory, MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(webuiPort);
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		webuiInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		final int restPort = getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection);
		final long webServiceMemory = getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR);

		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(webServiceMemory, MemoryUnit.MEGABYTES);
		restInstaller.setPort(restPort);
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		restInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;getWebservicePort(String,boolean);private int getWebservicePort(String portEnvVriable, boolean isSecureConnection) {
		String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		} 
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}
		;private int getWebservicePort(String portEnvVriable, boolean isSecureConnection) {
		String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		} 
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}
		;private int getWebservicePort(final String portEnvVriable, final boolean isSecureConnection) {
		final String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		}
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection) {
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection) {
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;startAgentOnLocalhostAndWait(String,String,long,TimeUnit);public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /*securityFilePath*/,
					"" /*keystoreFilePath*/, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		};public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /*securityFilePath*/,
					"" /*keystoreFilePath*/, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		};public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /* securityFilePath */,
					"" /* keystoreFilePath */, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;runCommand(String[],String[],String,String,String,String);private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword) 
					throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions = "-Xmx" + CloudifyConstants.DEFAULT_LOCALCLOUD_GSA_GSM_ESM_LUS_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
				+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
				+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_AGENT_MAX_MEMORY;
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_LUS_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_GSM_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL + " -D"
				+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		String esmJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_ESM_MAX_MEMORY + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.  
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");
		
		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + securityProfile);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, securityProfile);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);	
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: " + securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			logger.fine("Setting env vars COMPONENT_JAVA_OPTIONS: " + localCloudOptions);
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}
		} else {
			logger.fine("Setting env vars " + "GSA_JAVA_OPTIONS: gsaJavaOptions" + gsaJavaOptions 
					+ "; LUS_JAVA_OPTIONS: " + lusJavaOptions + "; GSM_JAVA_OPTIONS: " + gsmJavaOptions 
					+ "; ESM_JAVA_OPTIONS: " + esmJavaOptions + "; GSC_JAVA_OPTIONS: " + gscJavaOptions);
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		};private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword) 
					throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions = "-Xmx" + LOCALCLOUD_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
				+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
				+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + GSA_MEMORY_IN_MB + "m";
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions = "-Xmx" + LUS_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions = "-Xmx" + GSM_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL + " -D"
				+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		String esmJavaOptions = "-Xmx" + ESM_MEMORY_IN_MB + "m" + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.  
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");
		
		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + securityProfile);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, securityProfile);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);	
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: " + securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}

		} else {
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		};private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword)
			throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_LOCALCLOUD_GSA_GSM_ESM_LUS_MEMORY_IN_MB + "m" + " -D"
						+ CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
						+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "="
						+ GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
						+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_AGENT_MAX_MEMORY;
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_LUS_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY
						+ "=" + lusPort
						+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_GSM_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY
						+ "=" + lusPort
						+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
						+ " -D"
						+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		if (!this.isLocalCloud) {
			final String persistentStoragePath = this.cloud.getConfiguration().getPersistentStoragePath();
			if (persistentStoragePath != null) {
				final String gsmStoragePath = persistentStoragePath + "/gsm";
				gsmJavaOptions = gsmJavaOptions + " com.gs.persistency.logDirectory=" + gsmStoragePath;
			}
		}

		String esmJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_ESM_MAX_MEMORY + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");

		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");

		final String springProfiles = createSpringProfilesList(securityProfile);
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + springProfiles);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, springProfiles);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: "
				+ securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			logger.fine("Setting env vars COMPONENT_JAVA_OPTIONS: " + localCloudOptions);
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}
		} else {
			logger.fine("Setting env vars " + "GSA_JAVA_OPTIONS: gsaJavaOptions" + gsaJavaOptions
					+ "; LUS_JAVA_OPTIONS: " + lusJavaOptions + "; GSM_JAVA_OPTIONS: " + gsmJavaOptions
					+ "; ESM_JAVA_OPTIONS: " + esmJavaOptions + "; GSC_JAVA_OPTIONS: " + gscJavaOptions);
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper;setCloudFilePath(String);public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;;public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;;public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/CLI/src/main/java/org/cloudifysource/shell/rest/RestAdminFacade;listTemplates();			Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (Entry<String, Object> entry : responseMap.entrySet()) {
				ObjectMapper mapper = new ObjectMapper();
				ComputeTemplate convertValue = mapper.convertValue(entry.getValue(), ComputeTemplate.class);;			Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (Entry<String, Object> entry : responseMap.entrySet()) {
				ObjectMapper mapper = new ObjectMapper();
				CloudTemplate convertValue = mapper.convertValue(entry.getValue(), CloudTemplate.class);;			final Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (final Entry<String, Object> entry : responseMap.entrySet()) {
				final ObjectMapper mapper = new ObjectMapper();
				final CloudTemplate convertValue = mapper.convertValue(entry.getValue(), CloudTemplate.class);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/dsl/src/test/java/org/cloudifysource/dsl/CloudParserTest;testCloudParser();		assertNotNull(cloud.getCloudCompute().getTemplates().size() == 1);
		assertNotNull(cloud.getCloudCompute().getTemplates().get("SMALL_LINUX"));
		Assert.assertEquals(FileTransferModes.CIFS, cloud.getCloudCompute()
				.getTemplates().get("SMALL_LINUX").getFileTransfer());;		assertNotNull(cloud.getTemplates().size() == 1);
		assertNotNull(cloud.getTemplates().get("SMALL_LINUX"));
		Assert.assertEquals(FileTransferModes.CIFS, cloud.getTemplates().get("SMALL_LINUX").getFileTransfer());;		assertNotNull(cloud.getTemplates().size() == 1);
		assertNotNull(cloud.getTemplates().get("SMALL_LINUX"));
		assertEquals(FileTransferModes.CIFS, cloud.getTemplates().get("SMALL_LINUX").getFileTransfer());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143;/dsl/src/main/java/org/cloudifysource/dsl/internal/BaseDslScript;getDSLInitializers();public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudCompute.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudStorage.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StorageTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StorageDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplateInstallerConfiguration.class);

		}
		return dslObjectInitializersByName;;public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

		}
		return dslObjectInitializersByName;;public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplateInstallerConfiguration.class);

		}
		return dslObjectInitializersByName;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_f8df5_3ee13/rev_f8df5-3ee13;/src/main/java/org/graylog2/messagehandlers/gelf/SimpleGELFClientHandler;handle();            // This is doing the upcounting for statistics.
            ReceiveHookManager.postProcess(new MessageCounterHook(), this.message);;            // This is doing the upcounting for statistics.
            ReceiveHookManager.postProcess(new MessageCounterHook(), message);;                // Counts up host in hosts collection.
                ReceiveHookManager.postProcess(new HostUpsertHook(), message);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f11c1_d7c58/rev_f11c1-d7c58;/src/main/java/redis/clients/jedis/Connection;getObjectMultiBulkReply();public List<Object> getObjectMultiBulkReply() {
        flush();
        pipelinedCommands--;
        return getRawObjectMultiBulkReply();;@SuppressWarnings("unchecked")
    public List<Object> getObjectMultiBulkReply() {
        flush();
        pipelinedCommands--;
        return (List<Object>) Protocol.read(inputStream);;@SuppressWarnings("unchecked")
    public List<Object> getObjectMultiBulkReply() {
	flush();
	pipelinedCommands--;
	return (List<Object>) Protocol.read(inputStream);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f13ce_fee71/rev_f13ce-fee71;/src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter;makeFilename(File,String,String);        {
            while (desc.generation > maxGen)
            {
                maxGen = generation.getAndIncrement();
            }
        }

        return new Descriptor(directory, keyspace, columnFamily, maxGen + 1, true).filenameFor(Component.DATA);;            maxGen = Math.max(maxGen, desc.generation);
        return new Descriptor(directory, keyspace, columnFamily, maxGen + 1, true).filenameFor(Component.DATA);;            maxGen = Math.max(maxGen, desc.generation);
        return new Descriptor(directory, keyspace, columnFamily, maxGen + 1, Descriptor.Type.TEMP).filenameFor(Component.DATA);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f90b7_c6b03/rev_f90b7-c6b03;/projects/OG-Bloomberg/src/test/java/com/opengamma/bbg/livedata/faketicks/CombiningBloombergLiveDataServerTest;setUpClass();    _server = BloombergLiveDataServerUtils.startTestServer(CombiningBloombergLiveDataServerTest.class,
        new UnionFakeSubscriptionSelector(new BySchemeFakeSubscriptionSelector(ExternalSchemes.BLOOMBERG_BUID_WEAK, ExternalSchemes.BLOOMBERG_TICKER_WEAK), new ByTypeFakeSubscriptionSelector(
            "SWAPTION VOLATILITY"))
        , _unitTestingProvider);;    _server = BloombergLiveDataServerUtils.startTestServer(CombiningBloombergLiveDataServerTest.class,
        new UnionFakeSubscriptionSelector(new BySchemeFakeSubscriptionSelector(ExternalSchemes.BLOOMBERG_BUID_WEAK, ExternalSchemes.BLOOMBERG_TICKER_WEAK), new ByTypeFakeSubscriptionSelector("SWAPTION VOLATILITY"))
    , _unitTestingProvider);;    BySchemeFakeSubscriptionSelector selector1 = new BySchemeFakeSubscriptionSelector(ExternalSchemes.BLOOMBERG_BUID_WEAK, ExternalSchemes.BLOOMBERG_TICKER_WEAK);
    UnionFakeSubscriptionSelector selector = new UnionFakeSubscriptionSelector(selector1, new ByTypeFakeSubscriptionSelector("SWAPTION VOLATILITY"));
    _server = BloombergLiveDataServerUtils.startTestServer(CombiningBloombergLiveDataServerTest.class, selector, _unitTestingProvider);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f90b7_c6b03/rev_f90b7-c6b03;/projects/OG-Bloomberg/src/test/java/com/opengamma/bbg/livedata/faketicks/CombiningBloombergLiveDataServerTest;testMixedSubscribe();
    unsubscribe(_liveDataClient, listener, instruments);;    
    unsubscribe(_liveDataClient, listener, instruments);;    unsubscribe(_liveDataClient, listener, instruments);
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f90b7_c6b03/rev_f90b7-c6b03;/projects/OG-Bloomberg/src/test/java/com/opengamma/bbg/livedata/faketicks/CombiningBloombergLiveDataServerTest;testBrokenSubscribe();
    unsubscribe(_liveDataClient, listener, instruments);;    
    unsubscribe(_liveDataClient, listener, instruments);;    unsubscribe(_liveDataClient, listener, instruments);
    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_infinispan/revisions/rev_f95e9_3dd8d/rev_f95e9-3dd8d;/core/src/test/java/org/infinispan/test/AbstractCacheTest;getDefaultClusteredConfig(Configuration.CacheMode,boolean);      if (mode.isSynchronous()) {
         return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
            .mode(mode)
            .clustering()
               .sync()
                  .stateRetrieval().fetchInMemoryState(false)
               .transaction().syncCommitPhase(true).syncRollbackPhase(true)
            .build();
      } else {
         return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
            .mode(mode)
            .clustering()
               .async()
                  .stateRetrieval().fetchInMemoryState(false)
               .transaction().syncCommitPhase(true).syncRollbackPhase(true)
            .build();
      };      return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
         .mode(mode)
         .clustering()
            .sync()
               .stateRetrieval().fetchInMemoryState(false)
            .transaction().syncCommitPhase(true).syncRollbackPhase(true)
         .build();;      return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
         .mode(mode)
         .clustering()
            .sync()
               .stateRetrieval().fetchInMemoryState(false)
            .transaction().syncCommitPhase(true).syncRollbackPhase(true)
               .cacheStopTimeout(0)
         .build();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f0190_e219a/rev_f0190-e219a;/src/java/voldemort/serialization/DefaultSerializerFactory;getSerializer(SerializerDefinition);            return new ThriftSerializer<TBase>(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_GENERIC_TYPE_NAME)) {
            return new AvroGenericSerializer(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_SPECIFIC_TYPE_NAME)) {
            return new AvroSpecificSerializer(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_REFLECTIVE_TYPE_NAME)) {
            return new AvroReflectiveSerializer(serializerDef.getCurrentSchemaInfo());;            return new ThriftSerializer<TBase>(serializerDef.getCurrentSchemaInfo());;            return new ThriftSerializer<TBase<?>>(serializerDef.getCurrentSchemaInfo());
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_f531a_b68a4/rev_f531a-b68a4;/graylog2-server/src/main/java/org/graylog2/users/User;setTimeZone(DateTimeZone);public void setTimeZone(DateTimeZone timeZone) {
        fields.put(TIMEZONE, timeZone == null ? null : timeZone.getID());
    };public void setTimeZone(DateTimeZone timeZone) {
        fields.put(TIMEZONE, timeZone.getID());
    };void setTimeZone(DateTimeZone timeZone);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f932a_cfc16/rev_f932a-cfc16;/src/java/org/apache/cassandra/io/sstable/SSTableReader;open(Descriptor,Set<Component>,CFMetaData,IPartitioner,boolean);        assert partitioner != null;
        // Minimum components without which we can't do anything
        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
        assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;

        long start = System.currentTimeMillis();
        logger.info("Opening {} ({} bytes)", descriptor, new File(descriptor.filenameFor(COMPONENT_DATA)).length());

        SSTableMetadata sstableMetadata = SSTableMetadata.serializer.deserialize(descriptor);

        // Check if sstable is created using same partitioner.
        // Partitioner can be null, which indicates older version of sstable or no stats available.
        // In that case, we skip the check.
        String partitionerName = partitioner.getClass().getCanonicalName();
        if (sstableMetadata.partitioner != null && !partitionerName.equals(sstableMetadata.partitioner))
        {
            logger.error(String.format("Cannot open %s; partitioner %s does not match system partitioner %s.  Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading.",
                                       descriptor, sstableMetadata.partitioner, partitionerName));
            System.exit(1);
        };        long start = System.currentTimeMillis();
        SSTableMetadata sstableMetadata = openMetadata(descriptor, components, partitioner);;        long start = System.nanoTime();
        SSTableMetadata sstableMetadata = openMetadata(descriptor, components, partitioner);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_f2295_1acfb/rev_f2295-1acfb;/tests/unit/com/opengamma/math/rootfinding/MultiInstrumentDoubleCurveBootstrapTest;setupSwap(double,String,String);private static Swap setupSwap(final double time, final String fundCurveName, final String liborCurveName) {
    final int index = (int) Math.round(2 * time);;private static Swap setupSwap(final double time, final String fundCurveName, final String liborCurveName) {
    int index = (int) Math.round(2 * time);;private static FixedFloatSwap setupSwap(final double time, final String fundCurveName, final String liborCurveName) {
    int index = (int) Math.round(2 * time);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6;/src/java/voldemort/client/AbstractStoreClientFactory;bootstrapMetadataWithRetries(String,URI[]);                if(nTries < this.maxBootstrapRetries) {
                    int backOffTime = 5 * nTries;
                    logger.warn("Failed to bootstrap will try again after " + backOffTime + "s.");
                    try {
                        Thread.sleep(backOffTime * 1000);
                    } catch(InterruptedException e1) {
                        throw new RuntimeException(e1);
                    };                int backOffTime = 5 * nTries;
                logger.warn("Failed to bootstrap will try again after" + backOffTime);
                try {
                    Thread.sleep(backOffTime * 1000);
                } catch(InterruptedException e1) {
                    throw new RuntimeException(e1);;                int backOffTime = 5 * nTries;
                logger.warn("Failed to bootstrap will try again after " + backOffTime);
                try {
                    Thread.sleep(backOffTime * 1000);
                } catch(InterruptedException e1) {
                    throw new RuntimeException(e1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkConnections();    public void checkConnections() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();;    public void checkConnections() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT, 2000);
	pool.setResourcesNumber(10);
	pool.init();;	public void checkConnections() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port, 2000);
		pool.setResourcesNumber(10);
		pool.init();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkConnections();	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    };	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    };		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkConnectionWithDefaultPort();    public void checkConnectionWithDefaultPort() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();;    public void checkConnectionWithDefaultPort() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(10);
	pool.init();;	public void checkConnectionWithDefaultPort() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(10);
		pool.init();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkConnectionWithDefaultPort();	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    };	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    };		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkJedisIsReusedWhenReturned();    public void checkJedisIsReusedWhenReturned() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();;    public void checkJedisIsReusedWhenReturned() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();;	public void checkJedisIsReusedWhenReturned() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkJedisIsReusedWhenReturned();	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");
	pool.returnResource(jedis);;	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "0");
	pool.returnResource(jedis);;		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");
		pool.returnResource(jedis);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkJedisIsReusedWhenReturned();	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    };	jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    };		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolRepairedWhenJedisIsBroken();    public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
	    IOException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();;    public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
	    IOException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();;	public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
			IOException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolRepairedWhenJedisIsBroken();	Jedis jedis = pool.getResource(200);
	jedis.quit();
	pool.returnBrokenResource(jedis);;	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.quit();
	pool.returnBrokenResource(jedis);;		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.quit();
		pool.returnBrokenResource(jedis);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolRepairedWhenJedisIsBroken();	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    };	jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    };		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolOverflow();    public void checkPoolOverflow() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();;    public void checkPoolOverflow() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();;	public void checkPoolOverflow() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolOverflow();	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");;	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "0");;		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_f4548_e4ee2/rev_f4548-e4ee2;/src/test/java/redis/clients/jedis/tests/JedisPoolTest;checkPoolOverflow();	Jedis newJedis = pool.getResource(200);
	newJedis.incr("foo");
    };	Jedis newJedis = pool.getResource(200);
	newJedis.auth("foobared");
	newJedis.incr("foo");
    };		Jedis newJedis = pool.getResource(200);
		newJedis.auth("foobared");
		newJedis.incr("foo");
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f5618_1ae99/rev_f5618-1ae99;/src/java/org/apache/cassandra/hadoop/pig/AbstractCassandraStorage;initSchema(String);            catch (Exception e)
            {
                throw new RuntimeException(e);
            };            catch (TException e)
            {
                throw new RuntimeException(e);
            }
            catch (InvalidRequestException e)
            {
                throw new RuntimeException(e);
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
            catch (UnavailableException e)
            {
                throw new RuntimeException(e);
            }
            catch (TimedOutException e)
            {
                throw new RuntimeException(e);
            }
            catch (SchemaDisagreementException e)
            {
                throw new RuntimeException(e);
            };            catch (TException e)
            {
                throw new RuntimeException(e);
            }
            catch (CharacterCodingException e)
            {
                throw new RuntimeException(e);
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_f7273_c5495/rev_f7273-c5495;/src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer;serve();                try
                {
                    Thread.sleep(10);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                };                try
                {
                    Thread.sleep(100);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                };                Uninterruptibles.sleepUninterruptibly(10, TimeUnit.MILLISECONDS);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_voldemort/revisions/rev_f9687_83bfb/rev_f9687-83bfb;/src/java/voldemort/client/AbstractStoreClientFactory;getFailureDetector();        if (result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);;        if (result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml));;        if(result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY,
                                                             bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml));
/home/ines/gjcc/fpfnanalysis/samplerpl/java_realmjava/revisions/rev_fa192_5545f/rev_fa192-5545f;/tightdb-java-test/src/test/java/com/tightdb/JNIViewTest;init();    void init() {
        //Specify table		
        t = new Table();
        t.addColumn(ColumnType.ColumnTypeString, "Name");
        t.addColumn(ColumnType.ColumnTypeBool,   "Study");
        t.addColumn(ColumnType.ColumnTypeInt,    "Age");
        t.addColumn(ColumnType.ColumnTypeDate,   "Birthday");

        // Add unsupported column types
        t.addColumn(ColumnType.ColumnTypeString, "Unsupported0");
        t.addColumn(ColumnType.ColumnTypeFloat,  "Unsupported1");
        t.addColumn(ColumnType.ColumnTypeDouble, "Unsupported2");
        t.addColumn(ColumnType.ColumnTypeMixed,  "Unsupported3");
        t.addColumn(ColumnType.ColumnTypeTable,  "Unsupported4");

        //Add data
        t.add("cc", true,  24, date1, "", 0.0f, 0.0, 0, null);
        t.add("dd", false, 35, date2, "", 0.0f, 0.0, 0, null);
        t.add("bb", true,  22, date3, "", 0.0f, 0.0, 0, null);
        t.add("aa", false, 22, date4, "", 0.0f, 0.0, 0, null);

        assertEquals(date1, t.getDate(3, 0));      
        assertEquals(date2, t.getDate(3, 1));
        assertEquals(date3, t.getDate(3, 2));
        assertEquals(date4, t.getDate(3, 3));
    };    void init() {
        //Specify table		
        t = new Table();
        t.addColumn(ColumnType.ColumnTypeString, "Name");
        t.addColumn(ColumnType.ColumnTypeBool,   "Study");
        t.addColumn(ColumnType.ColumnTypeInt,    "Age");
        t.addColumn(ColumnType.ColumnTypeDate,   "Birthday");

        // Add unsupported column types
        t.addColumn(ColumnType.ColumnTypeString, "Unsupported0");
        t.addColumn(ColumnType.ColumnTypeFloat,  "Unsupported1");
        t.addColumn(ColumnType.ColumnTypeDouble, "Unsupported2");
        t.addColumn(ColumnType.ColumnTypeMixed,  "Unsupported3");
        t.addColumn(ColumnType.ColumnTypeTable,  "Unsupported4");

        //Add data
        t.add("cc", true,  24, date1, "", 0.0f, 0.0, 0, null);
        t.add("dd", false, 35, date2, "", 0.0f, 0.0, 0, null);
        t.add("bb", true,  22, date3, "", 0.0f, 0.0, 0, null);
        t.add("aa", false, 22, date4, "", 0.0f, 0.0, 0, null);
    };	void init() {
		//Specify table		
	    t = new Table();
	    t.addColumn(ColumnType.STRING, "Name");
	    t.addColumn(ColumnType.BOOLEAN,   "Study");
	    t.addColumn(ColumnType.INTEGER,    "Age");
	    t.addColumn(ColumnType.DATE,   "Birthday");
	    
	    // Add unsupported column types
	    t.addColumn(ColumnType.STRING, "Unsupported0");
	    t.addColumn(ColumnType.FLOAT,  "Unsupported1");
	    t.addColumn(ColumnType.DOUBLE, "Unsupported2");
	    t.addColumn(ColumnType.MIXED,  "Unsupported3");
	    t.addColumn(ColumnType.TABLE,  "Unsupported4");
	    
	    //Add data
	    t.add("cc", true,  24, date1, "", 0.0f, 0.0, 0, null);
	    t.add("dd", false, 35, date2, "", 0.0f, 0.0, 0, null);
	    t.add("bb", true,  22, date3, "", 0.0f, 0.0, 0, null);
	    t.add("aa", false, 22, date4, "", 0.0f, 0.0, 0, null);
	    
	    assertEquals(date1, t.getDate(3, 0));	    
	    assertEquals(date2, t.getDate(3, 1));
	    assertEquals(date3, t.getDate(3, 2));
	    assertEquals(date4, t.getDate(3, 3));
	}
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_fb9eb_fb80f/rev_fb9eb-fb80f;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/repositories/transport/http/HttpResourceCollection;findCachedResource(String,List<CachedArtifact>);        String checksumType = "SHA-1";
        String checksumUrl = source + ".sha1";;        ChecksumType checksumType = ChecksumType.sha1;
        String checksumUrl = source + checksumType.ext();;        // TODO:DAZ This is the last remnant of Wharf dependency: replace it
        ChecksumType checksumType = ChecksumType.sha1;
        String checksumUrl = source + checksumType.ext();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fbe8a_b73f9/rev_fbe8a-b73f9;/src/java/org/apache/cassandra/tracing/TraceState;trace(String);        TraceState.trace(sessionIdBytes, message, elapsed());;        final int elapsed = elapsed();
        final ByteBuffer eventId = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());

        final String threadName = Thread.currentThread().getName();

        StageManager.getStage(Stage.TRACING).execute(new WrappedRunnable()
        {
            public void runMayThrow() throws Exception
            {
                CFMetaData cfMeta = CFMetaData.TraceEventsCf;
                ColumnFamily cf = ColumnFamily.create(cfMeta);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source")), FBUtilities.getBroadcastAddress());
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source_elapsed")), elapsed);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
                RowMutation mutation = new RowMutation(Tracing.TRACE_KS, sessionIdBytes);
                mutation.add(cf);
                StorageProxy.mutate(Arrays.asList(mutation), ConsistencyLevel.ANY);
            }
        });;        final int elapsed = elapsed();
        final ByteBuffer eventId = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());

        final String threadName = Thread.currentThread().getName();

        StageManager.getStage(Stage.TRACING).execute(new WrappedRunnable()
        {
            public void runMayThrow() throws Exception
            {
                CFMetaData cfMeta = CFMetaData.TraceEventsCf;
                ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source")), FBUtilities.getBroadcastAddress());
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source_elapsed")), elapsed);
                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                RowMutation mutation = new RowMutation(Tracing.TRACE_KS, sessionIdBytes, cf);
                StorageProxy.mutate(Arrays.asList(mutation), ConsistencyLevel.ANY);
            }
        });
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc5d2_b9832/rev_fc5d2-b9832;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/future/method/InterestRateFutureSecurityHullWhiteMethodTest;comparisonDiscounting();    YieldCurveBundle curves = TestsDataSets.createCurves1();
    InterestRateFutureSecurityDiscountingMethod methodDiscounting = new InterestRateFutureSecurityDiscountingMethod();
    double priceDiscounting = methodDiscounting.priceFromCurves(ERU2, curves);
    double priceHullWhite = METHOD.price(ERU2, curves);;    YieldCurveBundle curves = TestsDataSets.createCurves1();
    InterestRateFutureSecurityDiscountingMethod methodDiscounting = new InterestRateFutureSecurityDiscountingMethod();
    double priceDiscounting = methodDiscounting.price(ERU2, curves);
    double priceHullWhite = METHOD.price(ERU2, curves);;    final YieldCurveBundle curves = TestsDataSets.createCurves1();
    final InterestRateFutureSecurityDiscountingMethod methodDiscounting = InterestRateFutureSecurityDiscountingMethod.getInstance();
    final double priceDiscounting = methodDiscounting.price(ERU2, curves);
    final double priceHullWhite = METHOD.price(ERU2, curves);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc5d2_b9832/rev_fc5d2-b9832;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/future/method/InterestRateFutureOptionMarginSecuritySABRMethodTest;priceStandard();    InterestRateFutureOptionMarginSecurity optionEDU2Standard = new InterestRateFutureOptionMarginSecurity(EDU2, expirationTime, STRIKE, IS_CALL);
    double priceOption = METHOD.optionPrice(optionEDU2Standard, SABR_BUNDLE);
    InterestRateFutureSecurityDiscountingMethod methodFuture = new InterestRateFutureSecurityDiscountingMethod();
    double priceFuture = methodFuture.priceFromCurves(EDU2, CURVES_BUNDLE);
    double priceOptionExpected = METHOD.optionPriceFromFuturePrice(optionEDU2Standard, SABR_BUNDLE, priceFuture);;    InterestRateFutureOptionMarginSecurity optionEDU2Standard = new InterestRateFutureOptionMarginSecurity(EDU2, expirationTime, STRIKE, IS_CALL);
    double priceOption = METHOD.optionPrice(optionEDU2Standard, SABR_BUNDLE);
    InterestRateFutureSecurityDiscountingMethod methodFuture = new InterestRateFutureSecurityDiscountingMethod();
    double priceFuture = methodFuture.price(EDU2, CURVES_BUNDLE);
    double priceOptionExpected = METHOD.optionPriceFromFuturePrice(optionEDU2Standard, SABR_BUNDLE, priceFuture);;    final InterestRateFutureOptionMarginSecurity optionEDU2Standard = new InterestRateFutureOptionMarginSecurity(EDU2, expirationTime, STRIKE, IS_CALL);
    final double priceOption = METHOD.optionPrice(optionEDU2Standard, SABR_BUNDLE);
    final InterestRateFutureSecurityDiscountingMethod methodFuture = InterestRateFutureSecurityDiscountingMethod.getInstance();
    final double priceFuture = methodFuture.price(EDU2, CURVES_BUNDLE);
    final double priceOptionExpected = METHOD.optionPriceFromFuturePrice(optionEDU2Standard, SABR_BUNDLE, priceFuture);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc5d2_b9832/rev_fc5d2-b9832;/projects/OG-Analytics/tests/unit/com/opengamma/financial/interestrate/future/method/InterestRateFutureOptionMarginTransactionSABRMethodTest;presentValue();    final InterestRateFutureSecurityDiscountingMethod methodFuture = new InterestRateFutureSecurityDiscountingMethod();
    final double priceFuture = methodFuture.priceFromCurves(EDU2, CURVES_BUNDLE);;    final InterestRateFutureSecurityDiscountingMethod methodFuture = new InterestRateFutureSecurityDiscountingMethod();
    final double priceFuture = methodFuture.price(EDU2, CURVES_BUNDLE);;    final InterestRateFutureSecurityDiscountingMethod methodFuture = InterestRateFutureSecurityDiscountingMethod.getInstance();
    final double priceFuture = methodFuture.price(EDU2, CURVES_BUNDLE);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc39b_c831c/rev_fc39b-c831c;/projects/OG-Financial/src/com/opengamma/financial/analytics/fixedincome/FixedIncomeInstrumentCurveExposureHelper;getCurveNamesForSecurity(FinancialSecurity,String,String);        return new String[] {fundingCurveName, forwardCurveName };
      case SWAP_FIXED_IBOR_WITH_SPREAD:
        return new String[] {fundingCurveName, forwardCurveName };;        return new String[] {fundingCurveName, forwardCurveName };;        return new String[] {fundingCurveName, forwardCurveName};
      case SWAP_FIXED_IBOR_WITH_SPREAD:
        return new String[] {fundingCurveName, forwardCurveName};
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc39b_c831c/rev_fc39b-c831c;/projects/OG-Financial/src/com/opengamma/financial/analytics/conversion/FixedIncomeConverterDataProvider;getIndexTimeSeries(InterestRateInstrumentType,SwapLeg,ZonedDateTime,ZonedDateTime,HistoricalTimeSeriesSource);      final LocalDate startDate = swapStartDate.isBefore(now) ? swapStartDate.toLocalDate().minusDays(7) : now.toLocalDate()
          .minusMonths(2);
      final HistoricalTimeSeries ts = dataSource
          .getHistoricalTimeSeries(MarketDataRequirementNames.MARKET_VALUE, id, null, null, startDate, true, now.toLocalDate(), false);;      final LocalDate startDate = swapStartDate.isBefore(now) ? swapStartDate.toLocalDate().minusDays(7) : now.toLocalDate()
          .minusDays(7);
      final HistoricalTimeSeries ts = dataSource
          .getHistoricalTimeSeries(MarketDataRequirementNames.MARKET_VALUE, id, null, null, startDate, true, now.toLocalDate(), false);;      final LocalDate startDate = swapStartDate.isBefore(now) ? swapStartDate.toLocalDate().minusDays(7) : now.toLocalDate().minusMonths(2);
      final HistoricalTimeSeries ts = dataSource.getHistoricalTimeSeries(MarketDataRequirementNames.MARKET_VALUE, id, null, null, startDate, true, now.toLocalDate(), false);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_fc39b_c831c/rev_fc39b-c831c;/projects/OG-Financial/src/com/opengamma/financial/analytics/conversion/FixedIncomeConverterDataProvider;getIndexTimeSeries(InterestRateInstrumentType,SwapLeg,ZonedDateTime,ZonedDateTime,HistoricalTimeSeriesSource);      if (type == InterestRateInstrumentType.SWAP_FIXED_IBOR || type == InterestRateInstrumentType.SWAP_FIXED_CMS ||
          type == InterestRateInstrumentType.SWAP_IBOR_CMS || type == InterestRateInstrumentType.SWAP_IBOR_CMS ||
          type == InterestRateInstrumentType.SWAP_CMS_CMS || type == InterestRateInstrumentType.SWAP_FIXED_IBOR_WITH_SPREAD) {;      if (type == InterestRateInstrumentType.SWAP_FIXED_IBOR || type == InterestRateInstrumentType.SWAP_FIXED_CMS ||
          type == InterestRateInstrumentType.SWAP_IBOR_CMS || type == InterestRateInstrumentType.SWAP_IBOR_CMS ||
          type == InterestRateInstrumentType.SWAP_CMS_CMS) {;      if (type == InterestRateInstrumentType.SWAP_FIXED_IBOR || type == InterestRateInstrumentType.SWAP_FIXED_CMS || type == InterestRateInstrumentType.SWAP_IBOR_CMS
          || type == InterestRateInstrumentType.SWAP_IBOR_CMS || type == InterestRateInstrumentType.SWAP_CMS_CMS) {
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_fd4dd_11eb6/rev_fd4dd-11eb6;/graphdb/src/test/java/com/tinkerpop/blueprints/impls/orient/OrientGraphTest;doTestSuite(TestSuite);    String directory = getWorkingDirectory();
    deleteDirectory(new File(directory+"/graph"));;    String directory = getWorkingDirectory();
    deleteDirectory(new File(directory));;    dropGraph("graph");
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fd129_678aa/rev_fd129-678aa;/src/java/org/apache/cassandra/db/index/SecondaryIndexManager;validate(Column);        SecondaryIndex index = getIndexForColumn(column.name);
        return index == null || index.validate(column);;        SecondaryIndex index = getIndexForColumn(column.name);
        return index != null ? index.validate(column) : true;;        SecondaryIndex index = getIndexForColumn(column.name());
        return index != null ? index.validate(column) : true;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fe10b_740e3/rev_fe10b-740e3;/src/java/org/apache/cassandra/db/compaction/CompactionManager;doCleanupCompaction(ColumnFamilyStore,Collection<SSTableReader>,CounterId.OneShotRenewer);            SSTableScanner scanner = sstable.getDirectScanner(getRateLimiter());
            List<IColumn> indexedColumnsInRow = null;;            SSTableScanner scanner = sstable.getDirectScanner(getRateLimiter());
            long rowsRead = 0;
            List<IColumn> indexedColumnsInRow = null;;            SSTableScanner scanner = sstable.getScanner(getRateLimiter());
            List<Column> indexedColumnsInRow = null;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_feae9_c7eb1/rev_feae9-c7eb1;/src/java/org/apache/cassandra/db/ColumnFamilyStore;initRowCache();        AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;

        // results are sorted on read (via treeset) because there are few reads and many writes and reads only happen at startup
        int cachedRowsRead = 0;
        for (DecoratedKey key : rowCache.readSaved(table.name, columnFamily, partitioner))
        {
            ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)),
                                                   Integer.MIN_VALUE,
                                                   true);
            if (data != null)
                CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
            cachedRowsRead++;
        };        AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;

        // results are sorted on read (via treeset) because there are few reads and many writes and reads only happen at startup
        int cachedRowsRead = 0;
        for (DecoratedKey key : rowCache.readSaved(table.name, columnFamily, partitioner))
        {
            ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)),
                                                   Integer.MIN_VALUE,
                                                   true);
            CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
            cachedRowsRead++;
        };        int cachedRowsRead = CacheService.instance.rowCache.loadSaved(this);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_fee36_13219/rev_fee36-13219;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;log(OWALRecord);public OLogSequenceNumber log(OWALRecord record) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      final byte[] serializedForm = OWALRecordsFactory.INSTANCE.toStream(record);

      LogSegment last = logSegments.get(logSegments.size() - 1);
      long lastSize = last.filledUpTo();

      final OLogSequenceNumber lsn = last.logRecord(serializedForm);
      record.setLsn(lsn);

      if (record.isUpdateMasterRecord()) {
        lastCheckpoint = lsn;
        if (useFirstMasterRecord) {
          firstMasterRecord = lsn;
          writeMasterRecord(0, firstMasterRecord);
          useFirstMasterRecord = false;
        } else {
          secondMasterRecord = lsn;
          writeMasterRecord(1, secondMasterRecord);
          useFirstMasterRecord = true;
        }
      }

      final long sizeDiff = last.filledUpTo() - lastSize;
      logSize += sizeDiff;

      if (logSize >= maxLogSize) {
        final LogSegment first = removeHeadSegmentFromList();

        if (first != null) {
          first.stopFlush(false);

          first.delete(false);

          recalculateLogSize();

          fixMasterRecords();
        }
      }

      if (last.filledUpTo() >= maxSegmentSize) {
        last.stopFlush(true);

        last = new LogSegment(new File(walLocation, getSegmentName(last.getOrder() + 1)), maxPagesCacheSize);
        last.init();
        last.startFlush();

        logSegments.add(last);
      }

      return lsn;
    }
  };public OLogSequenceNumber log(OWALRecord record) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      final byte[] serializedForm = OWALRecordsFactory.INSTANCE.toStream(record);

      LogSegment last = logSegments.get(logSegments.size() - 1);
      long lastSize = last.filledUpTo();

      final OLogSequenceNumber lsn = last.logRecord(serializedForm);
      record.setLsn(lsn);

      if (record.isUpdateMasterRecord()) {
        lastCheckpoint = lsn;
        if (useFirstMasterRecord) {
          firstMasterRecord = lsn;
          writeMasterRecord(0, firstMasterRecord);
          useFirstMasterRecord = false;
        } else {
          secondMasterRecord = lsn;
          writeMasterRecord(1, secondMasterRecord);
          useFirstMasterRecord = true;
        }
      }

      final long sizeDiff = last.filledUpTo() - lastSize;
      logSize += sizeDiff;

      if (logSize >= maxLogSize) {
        final LogSegment first = removeHeadSegmentFromList();

				if (first != null) {
					first.stopFlush(false);

					logSize -= first.filledUpTo();

					first.delete(false);
					fixMasterRecords();
				}
      }

      if (last.filledUpTo() >= maxSegmentSize) {
        last.stopFlush(true);

        last = new LogSegment(new File(walLocation, getSegmentName(last.getOrder() + 1)), maxPagesCacheSize);
        last.init();
        last.startFlush();

        logSegments.add(last);
      }

      return lsn;
    }
  };OLogSequenceNumber log(OWALRecord record) throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_fee36_13219/rev_fee36-13219;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;truncate();public void truncate() throws IOException {
    synchronized (syncObject) {
      if (logSegments.size() < 2)
        return;

      ListIterator<LogSegment> iterator = logSegments.listIterator(logSegments.size() - 1);
      while (iterator.hasPrevious()) {
        final LogSegment logSegment = iterator.previous();
        logSegment.delete(false);
        iterator.remove();
      }

			recalculateLogSize();
    }
  };public void truncate() throws IOException {
    synchronized (syncObject) {
      if (logSegments.size() < 2)
        return;

      ListIterator<LogSegment> iterator = logSegments.listIterator(logSegments.size() - 1);
      while (iterator.hasPrevious()) {
        final LogSegment logSegment = iterator.previous();
        logSegment.delete(false);
        iterator.remove();
      }
    }
  };void truncate() throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_orientdb/revisions/rev_fee36_13219/rev_fee36-13219;/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/paginated/wal/OWriteAheadLog;cutTill(OLogSequenceNumber);public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size() - 1; i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = removeHeadSegmentFromList();
        if (logSegment != null)
          logSegment.delete(false);
      }

      recalculateLogSize();
    }
  };public void cutTill(OLogSequenceNumber lsn) throws IOException {
    synchronized (syncObject) {
      checkForClose();

      flush();

      int lastTruncateIndex = -1;

      for (int i = 0; i < logSegments.size() - 1; i++) {
        final LogSegment logSegment = logSegments.get(i);

        if (logSegment.end().compareTo(lsn) < 0)
          lastTruncateIndex = i;
        else
          break;
      }

      for (int i = 0; i <= lastTruncateIndex; i++) {
        final LogSegment logSegment = removeHeadSegmentFromList();
        if (logSegment != null)
          logSegment.delete(false);
      }
    }
  };void cutTill(OLogSequenceNumber lsn) throws IOException;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_fee63_8dac5/rev_fee63-8dac5;/graylog2-server/src/main/java/org/graylog2/Main;main(String[]);        server.inputs().register(SyslogUDPInput.class, SyslogUDPInput.NAME);
        server.inputs().register(SyslogTCPInput.class, SyslogTCPInput.NAME);
        server.inputs().register(RawUDPInput.class, RawUDPInput.NAME);
        server.inputs().register(RawTCPInput.class, RawTCPInput.NAME);
        server.inputs().register(GELFUDPInput.class, GELFUDPInput.NAME);
        server.inputs().register(GELFTCPInput.class, GELFTCPInput.NAME);
        server.inputs().register(GELFHttpInput.class, GELFHttpInput.NAME);
        server.inputs().register(FakeHttpMessageInput.class, FakeHttpMessageInput.NAME);
        server.inputs().register(LocalMetricsInput.class, LocalMetricsInput.NAME);
        server.inputs().register(JsonPathInput.class, JsonPathInput.NAME);
        server.inputs().register(KafkaInput.class, KafkaInput.NAME);
        server.inputs().register(RadioKafkaInput.class, RadioKafkaInput.NAME);
        server.inputs().register(AMQPInput.class, AMQPInput.NAME);
        server.inputs().register(RadioAMQPInput.class, RadioAMQPInput.NAME);;        server.inputs().register(SyslogUDPInput.class, SyslogUDPInput.NAME);
        server.inputs().register(SyslogTCPInput.class, SyslogTCPInput.NAME);
        server.inputs().register(RawUDPInput.class, RawUDPInput.NAME);
        server.inputs().register(RawTCPInput.class, RawTCPInput.NAME);
        server.inputs().register(GELFUDPInput.class, GELFUDPInput.NAME);
        server.inputs().register(GELFTCPInput.class, GELFTCPInput.NAME);
        server.inputs().register(GELFHttpInput.class, GELFHttpInput.NAME);
        server.inputs().register(FakeHttpMessageInput.class, FakeHttpMessageInput.NAME);
        server.inputs().register(LocalMetricsInput.class, LocalMetricsInput.NAME);
        server.inputs().register(JsonPathInput.class, JsonPathInput.NAME);
        server.inputs().register(KafkaInput.class, KafkaInput.NAME);
        server.inputs().register(RadioInput.class, RadioInput.NAME);;        InputRegistry inputRegistry = injector.getInstance(ServerInputRegistry.class);
        inputRegistry.register(SyslogUDPInput.class, SyslogUDPInput.NAME);
        inputRegistry.register(SyslogTCPInput.class, SyslogTCPInput.NAME);
        inputRegistry.register(RawUDPInput.class, RawUDPInput.NAME);
        inputRegistry.register(RawTCPInput.class, RawTCPInput.NAME);
        inputRegistry.register(GELFUDPInput.class, GELFUDPInput.NAME);
        inputRegistry.register(GELFTCPInput.class, GELFTCPInput.NAME);
        inputRegistry.register(GELFHttpInput.class, GELFHttpInput.NAME);
        inputRegistry.register(FakeHttpMessageInput.class, FakeHttpMessageInput.NAME);
        inputRegistry.register(LocalMetricsInput.class, LocalMetricsInput.NAME);
        inputRegistry.register(JsonPathInput.class, JsonPathInput.NAME);
        inputRegistry.register(KafkaInput.class, KafkaInput.NAME);
        inputRegistry.register(RadioInput.class, RadioInput.NAME);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_graylog2server/revisions/rev_fee63_8dac5/rev_fee63-8dac5;/graylog2-server/src/main/java/org/graylog2/inputs/Input;getExtractors();public List<Extractor> getExtractors() {
        List<Extractor> extractors = Lists.newArrayList();

        if (fields.get(EMBEDDED_EXTRACTORS) == null) {
            return extractors;
        }

        BasicDBList mEx = (BasicDBList) fields.get(EMBEDDED_EXTRACTORS);
        Iterator<Object> iterator = mEx.iterator();
        while(iterator.hasNext()) {
            DBObject ex = (BasicDBObject) iterator.next();

            // SOFT MIGRATION: does this extractor have an order set? Implemented for issue: #726
            Long order = new Long(0);
            if (ex.containsField("order")) {
                order = (Long) ex.get("order"); // mongodb driver gives us a java.lang.Long
            }

            try {
                Extractor extractor = ExtractorFactory.factory(
                        (String) ex.get("id"),
                        (String) ex.get("title"),
                        order.intValue(),
                        Extractor.CursorStrategy.valueOf(((String) ex.get("cursor_strategy")).toUpperCase()),
                        Extractor.Type.valueOf(((String) ex.get("type")).toUpperCase()),
                        (String) ex.get("source_field"),
                        (String) ex.get("target_field"),
                        (Map<String, Object>) ex.get("extractor_config"),
                        (String) ex.get("creator_user_id"),
                        getConvertersOfExtractor(ex),
                        Extractor.ConditionType.valueOf(((String) ex.get("condition_type")).toUpperCase()),
                        (String) ex.get("condition_value")
                );

                extractors.add(extractor);
            } catch (Exception e) {
                LOG.error("Cannot build extractor from persisted data. Skipping.", e);
                continue;
            }
        }

        return extractors;
    };public List<Extractor> getExtractors() {
        List<Extractor> extractors = Lists.newArrayList();

        if (fields.get(EMBEDDED_EXTRACTORS) == null) {
            return extractors;
        }

        BasicDBList mEx = (BasicDBList) fields.get(EMBEDDED_EXTRACTORS);
        Iterator<Object> iterator = mEx.iterator();
        while(iterator.hasNext()) {
            DBObject ex = (BasicDBObject) iterator.next();
            try {
                Extractor extractor = ExtractorFactory.factory(
                        (String) ex.get("id"),
                        (String) ex.get("title"),
                        Extractor.CursorStrategy.valueOf(((String) ex.get("cursor_strategy")).toUpperCase()),
                        Extractor.Type.valueOf(((String) ex.get("type")).toUpperCase()),
                        (String) ex.get("source_field"),
                        (String) ex.get("target_field"),
                        (Map<String, Object>) ex.get("extractor_config"),
                        (String) ex.get("creator_user_id"),
                        getConvertersOfExtractor(ex),
                        Extractor.ConditionType.valueOf(((String) ex.get("condition_type")).toUpperCase()),
                        (String) ex.get("condition_value")
                );

                extractors.add(extractor);
            } catch (Exception e) {
                LOG.error("Cannot build extractor from persisted data. Skipping.", e);
                continue;
            }
        }

        return extractors;
    };List<Extractor> getExtractors();
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fee71_45084/rev_fee71-45084;/test/unit/org/apache/cassandra/db/RecoveryManagerTest;testOne();        CommitLog.instance.resetUnsafe();
        Keyspace keyspace1 = Keyspace.open("Keyspace1");
        Keyspace keyspace2 = Keyspace.open("Keyspace2");;        Keyspace keyspace1 = Keyspace.open("Keyspace1");
        Keyspace keyspace2 = Keyspace.open("Keyspace2");;        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
        Keyspace keyspace2 = Keyspace.open(KEYSPACE2);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fee71_45084/rev_fee71-45084;/test/unit/org/apache/cassandra/db/RecoveryManagerTest;testRecoverCounter();        CommitLog.instance.resetUnsafe();
        Keyspace keyspace1 = Keyspace.open("Keyspace1");;        Keyspace keyspace1 = Keyspace.open("Keyspace1");;        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_ogplatform/revisions/rev_ff1cb_21979/rev_ff1cb-21979;/projects/OG-Financial/src/com/opengamma/financial/analytics/volatility/surface/Grid2DInterpolatedVolatilitySurfaceFunctionDeprecated;init(FunctionCompilationContext);        .withAny(EquityVarianceSwapStaticReplicationFunction.STRIKE_PARAMETERIZATION_METHOD/*, VarianceSwapStaticReplication.StrikeParameterization.STRIKE.toString()*/).get();
    _requirement = new ValueRequirement(ValueRequirementNames.STANDARD_VOLATILITY_SURFACE_DATA, _definition.getTarget(), surfaceProperties);
    _result = new ValueSpecification(ValueRequirementNames.INTERPOLATED_VOLATILITY_SURFACE, new ComputationTargetSpecification(_definition.getTarget()),;        .withAny(EquityVarianceSwapFunction.STRIKE_PARAMETERIZATION_METHOD/*, VarianceSwapStaticReplication.StrikeParameterization.STRIKE.toString()*/).get();
    _requirement = new ValueRequirement(ValueRequirementNames.STANDARD_VOLATILITY_SURFACE_DATA, _definition.getTarget(), surfaceProperties);
    _result = new ValueSpecification(ValueRequirementNames.INTERPOLATED_VOLATILITY_SURFACE, new ComputationTargetSpecification(_definition.getTarget()),;        .withAny(EquityVarianceSwapFunction.STRIKE_PARAMETERIZATION_METHOD/*, VarianceSwapStaticReplication.StrikeParameterization.STRIKE.toString()*/).get();
    final ComputationTargetSpecification targetSpec = ComputationTargetSpecification.of(_definition.getTarget().getUniqueId());
    _requirement = new ValueRequirement(ValueRequirementNames.STANDARD_VOLATILITY_SURFACE_DATA, targetSpec, surfaceProperties);
    _result = new ValueSpecification(ValueRequirementNames.INTERPOLATED_VOLATILITY_SURFACE, targetSpec,
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_ff519_092e3/rev_ff519-092e3;/subprojects/core/src/main/groovy/org/gradle/api/tasks/bundling/Tar;Tar();        Instantiator instantiator = getServices().get(Instantiator.class);
        FileResolver fileResolver = getServices().get(FileResolver.class);
        action = instantiator.newInstance(TarCopyActionImpl.class, this, instantiator, fileResolver);
        getConventionMapping().map("extension", new Callable<Object>() {;        Instantiator instantiator = getServices().get(Instantiator.class);
        FileResolver fileResolver = getServices().get(FileResolver.class);
        action = instantiator.newInstance(TarCopyActionImpl.class, this, instantiator, fileResolver);
        getConventionMapping().map("extension", new Callable<Object>(){;        getConventionMapping().map("extension", new Callable<Object>(){
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_fffec_7eb44/rev_fffec-7eb44;/src/java/org/apache/cassandra/service/StorageProxy;scan(String,String,IndexClause,SlicePredicate,ConsistencyLevel);            Message message = command.getMessage();
            for (InetAddress endpoint : handler.endpoints);            Message message = command.getMessage();
            for (InetAddress endpoint : liveEndpoints);            MessageProducer producer = new CachingMessageProducer(command);
            for (InetAddress endpoint : liveEndpoints)
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_00b96_308af/rev_00b96-308af;/src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader;IndexedSliceReader(SSTableReader,RowIndexEntry,FileDataInput,ColumnSlice[],boolean);                setToRowStart(sstable, indexEntry, input);
                IndexHelper.skipBloomFilter(file);
                this.indexes = IndexHelper.deserializeIndex(file);
                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
                emptyColumnFamily.delete(DeletionTime.serializer.deserialize(file));
                fetcher = indexes.isEmpty()
                        ? new SimpleBlockFetcher()
                        : new IndexedBlockFetcher(file.getFilePointer() + 4); // We still have the column count to
                                                                              // skip to get the basePosition;                setToRowStart(sstable, indexEntry, input);
                IndexHelper.skipBloomFilter(file);
                this.indexes = IndexHelper.deserializeIndex(file);
                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
                emptyColumnFamily.delete(indexEntry.deletionTime());
                fetcher = indexes.isEmpty()
                        ? new SimpleBlockFetcher()
                        : new IndexedBlockFetcher(file.getFilePointer() + 4); // We still have the column count to
                                                                              // skip to get the basePosition;                emptyColumnFamily.delete(indexEntry.deletionTime());
                fetcher = new IndexedBlockFetcher(indexEntry.position);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_0a8aa_670e0/rev_0a8aa-670e0;/src/main/java/redis/clients/jedis/JedisSentinelPool;returnBrokenResource(Jedis);public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	};public void returnBrokenResource(final Jedis resource) {
	returnBrokenResourceObject(resource);;@Override
    public void returnBrokenResource(final Jedis resource) {
	returnBrokenResourceObject(resource);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_jedis/revisions/rev_0a8aa_670e0/rev_0a8aa-670e0;/src/main/java/redis/clients/jedis/JedisSentinelPool;returnResource(Jedis);public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	};public void returnResource(final Jedis resource) {
	resource.resetState();
	returnResourceObject(resource);;@Override
    public void returnResource(final Jedis resource) {
	resource.resetState();
	returnResourceObject(resource);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_atmosphere/revisions/rev_0b01c_00562/rev_0b01c-00562;/modules/cpr/src/main/java/org/atmosphere/container/BlockingIOCometSupport;service(HttpServletRequest,HttpServletResponse);                    logger.debug("Suspending after resuming response: {}", res);
                    suspend(action, req, res);;                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("Suspending after Resuming" + res);
                        suspend(action, req, res);
                    };                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("Suspending after Resuming" + res);
                    }
                    suspend(action, req, res);                    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_atmosphere/revisions/rev_0b01c_00562/rev_0b01c-00562;/modules/cpr/src/main/java/org/atmosphere/container/Servlet30Support;service(HttpServletRequest,HttpServletResponse);                    logger.debug("Suspending after resuming response: {}", response);
                    suspend(action, request, response);;                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("Suspending after Resuming" + res);
                        suspend(action, req, res);
                    };                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("Suspending after Resuming" + res);
                    }
                    suspend(action, req, res);                    
/home/ines/gjcc/fpfnanalysis/samplerpl/java_atmosphere/revisions/rev_0b01c_00562/rev_0b01c-00562;/modules/cpr/src/main/java/org/atmosphere/cpr/DefaultBroadcaster;push(AtmosphereResource<?,?>,Object);                    logger.warn("Preventing corruption of a recycled request: resource" + resource, event);
                    resources.remove(resource);
                    return;;                    if (LoggerUtils.getLogger().isLoggable(Level.FINE)) {
                        LoggerUtils.getLogger().log(Level.FINE, "Preventing corruption of a recycled request", e);
                        resources.remove(r);
                        return;
                    };                    if (LoggerUtils.getLogger().isLoggable(Level.FINE)) {
                        LoggerUtils.getLogger().log(Level.FINE, "Preventing corruption of a recycled request", e);
                    }
                    resources.remove(r);
                    return;
/home/ines/gjcc/fpfnanalysis/samplerpl/java_atmosphere/revisions/rev_0b01c_00562/rev_0b01c-00562;/plugins/jms/src/main/java/org/atmosphere/plugin/jms/JMSBroadcaster;incomingBroadcast();            logger.info("Looking up topic: {}", topicId);
            Topic topic = (Topic) ctx.lookup("jms/" + topicId);;            logger.info(String.format("Looking up topic: %s", topicId));
            Topic topic = (Topic) ctx.lookup("jms/" + topicId);;            logger.info(String.format("Looking up topic: %s", topicId));
            Topic topic = (Topic) ctx.lookup(namespace + topicId);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_atmosphere/revisions/rev_0b01c_00562/rev_0b01c-00562;/plugins/jms/src/main/java/org/atmosphere/plugin/jms/JMSFilter;filter(Object,Object);@Override
    public BroadcastAction filter(Object originalMessage, Object o) {
        if (o instanceof String){
            String message = (String)o;
            try {
                // Avoid re-broadcasting
                if (!receivedMessages.remove(message)) {
                    publisher.send(session.createTextMessage(message));;public BroadcastAction filter(Object originalMessage, Object o) {
        if (o instanceof String){
            String message = (String)o;
            try {
                // Avoid re-broadcasting
                if (!receivedMessages.remove(message)) {
                    publisher.send(session.createTextMessage(message));;public BroadcastAction filter(Object originalMessage, Object o) {
        if (o instanceof String) {
            String message = (String) o;
            // Avoid re-broadcasting
            if (!receivedMessages.remove(message)) {
                try {
                    String id = bc.getID();
                    if (id.startsWith("/*")) {
                        id = "atmosphere";
                    }

                    TextMessage textMessage = session.createTextMessage(message.toString());
                    textMessage.setStringProperty("BroadcasterId", id);
                    publisher.send(textMessage);
                } catch (JMSException ex) {
                    logger.log(Level.WARNING, "", ex);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_0c5c3_18044/rev_0c5c3-18044;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/ivyservice/resolveengine/DefaultDependencyResolver;resolve(ConfigurationInternal,List<?extendsResolutionAwareRepository>);                Store<ResolvedModuleVersionResult> newModelCache = storeFactory.createNewModelCache(configuration);
                ResolvedConfigurationListener newModelBuilder = new StreamingResolutionResultBuilder(newModelStore, newModelCache);;                Store<ResolvedModuleVersionResult> newModelCache = storeFactory.createNewModelCache(configuration.getPath());
                ResolvedConfigurationListener newModelBuilder = new StreamingResolutionResultBuilder(newModelStore, newModelCache);;                Store<ResolvedModuleVersionResult> newModelCache = storeFactory.createNewModelCache(configuration.getPath());
                ResolutionResultBuilder newModelBuilder = new StreamingResolutionResultBuilder(newModelStore, newModelCache);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_gradle/revisions/rev_0c5c3_18044/rev_0c5c3-18044;/subprojects/core-impl/src/main/groovy/org/gradle/api/internal/artifacts/ivyservice/resolveengine/DefaultDependencyResolver;resolve(ConfigurationInternal,List<?extendsResolutionAwareRepository>);                Store<TransientConfigurationResults> oldModelCache = storeFactory.createOldModelCache(configuration);
                TransientResultsStore oldModelResults = new TransientResultsStore(oldModelStore, oldModelCache);
                DefaultResolvedConfigurationBuilder oldModelBuilder = new DefaultResolvedConfigurationBuilder(resolvedArtifactFactory, oldModelResults);;                Store<TransientConfigurationResults> oldModelCache = storeFactory.createOldModelCache(configuration.getPath());
                TransientResultsStore oldModelResults = new TransientResultsStore(oldModelStore, oldModelCache);
                DefaultResolvedConfigurationBuilder oldModelBuilder = new DefaultResolvedConfigurationBuilder(resolvedArtifactFactory, oldModelResults);;                Store<TransientConfigurationResults> oldModelCache = storeFactory.createOldModelCache(configuration.getPath());
                TransientConfigurationResultsBuilder oldTransientModelBuilder = new TransientConfigurationResultsBuilder(oldModelStore, oldModelCache);
                DefaultResolvedConfigurationBuilder oldModelBuilder = new DefaultResolvedConfigurationBuilder(resolvedArtifactFactory, oldTransientModelBuilder);
/home/ines/gjcc/fpfnanalysis/samplerpl/java_cassandra/revisions/rev_0c81e_093e1/rev_0c81e-093e1;/src/java/org/apache/cassandra/service/StorageProxy;fetchRows(List<ReadCommand>,ConsistencyLevel);                RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
                ReadCallback<ReadResponse, Row> handler = new ReadCallback(resolver, consistency_level, command, endpoints);
                handler.assureSufficientLiveNodes();
                assert !endpoints.isEmpty();
                readCallbacks[i] = handler;

                // The data-request message is sent to dataPoint, the node that will actually get the data for us
                InetAddress dataPoint = endpoints.get(0);
                if (dataPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                {
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
                }
                else
                {
                    Tracing.trace("Enqueuing data request to {}", dataPoint);
                    MessagingService.instance().sendRR(command.createMessage(), dataPoint, handler);
                }

                if (endpoints.size() == 1)
                    continue;

                // send the other endpoints a digest request
                ReadCommand digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
                MessageOut message = null;
                for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
                {
                    if (digestPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                    {
                        StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                    }
                    else
                    {
                        Tracing.trace("Enqueuing digest request to {}", dataPoint);
                        // (We lazy-construct the digest Message object since it may not be necessary if we
                        // are doing a local digest read, or no digest reads at all.)
                        if (message == null)
                            message = digestCommand.createMessage();
                        MessagingService.instance().sendRR(message, digestPoint, handler);
                    }
                }
            };                RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
                ReadCallback<ReadResponse, Row> handler = new ReadCallback(resolver, consistency_level, command, endpoints);
                handler.assureSufficientLiveNodes();
                assert !endpoints.isEmpty();
                readCallbacks[i] = handler;

                // The data-request message is sent to dataPoint, the node that will actually get the data for us
                InetAddress dataPoint = endpoints.get(0);
                if (dataPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                {
                    logger.trace("reading data locally");
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
                }
                else
                {
                    logger.trace("reading data from {}", dataPoint);
                    MessagingService.instance().sendRR(command.createMessage(), dataPoint, handler);
                }

                if (endpoints.size() == 1)
                    continue;

                // send the other endpoints a digest request
                ReadCommand digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
                MessageOut message = null;
                for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
                {
                    if (digestPoint.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)
                    {
                        logger.trace("reading digest locally");
                        StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                    }
                    else
                    {
                        logger.trace("reading digest from {}", digestPoint);
                        // (We lazy-construct the digest Message object since it may not be necessary if we
                        // are doing a local digest read, or no digest reads at all.)
                        if (message == null)
                            message = digestCommand.createMessage();
                        MessagingService.instance().sendRR(message, digestPoint, handler);
                    }
                }
            };            for (AbstractReadExecutor exec: readExecutors)
                exec.speculate();
