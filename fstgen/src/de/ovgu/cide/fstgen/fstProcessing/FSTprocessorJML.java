package de.ovgu.cide.fstgen.fstProcessing;

import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.StringTokenizer;
import de.ovgu.cide.fstgen.ast.FSTNode;
import de.ovgu.cide.fstgen.ast.FSTNonTerminal;
import de.ovgu.cide.fstgen.ast.FSTTerminal;

/** processes the FST generated by the Java parser to make JML annotations explicit. */
public class FSTprocessorJML implements FSTprocessor {
	
	public void processFST(List<FSTNode> fst) {
		// visit all FST nodes and apply transformations
		for (ListIterator<FSTNode> fstIt = fst.listIterator(); fstIt.hasNext(); ) {
			FSTNode node = fstIt.next();	
			fstIt.remove();
			fstIt.add(processFST(node));
		}
		// SOMETIME make JML invariants explicit by promoting them to FSTTerminal with unique name
		// SOMETIME support for methods designated as 'helper' (method attribute)
		//          -> is to be done by specialized MethodDecl composition
		
	}
	
	/** Recursively traverses a FST to transform FST nodes.
	 * <p>Note that the flow of control disallows certain transformations
	 * like joining two terminal nodes (splitting a terminal node into two is possible)
	 * @param node - node to start traversal
	 * @return - new node to replace node given as parameter (caller must do replacement)
	 * <br>null is returned only if given node was null */
	private FSTNode processFST(FSTNode node) {
		// Terminal node: transform method nodes
		if (node instanceof FSTTerminal) {
			FSTTerminal terminalNode = (FSTTerminal) node;
			System.out.println(terminalNode.getType() + " " + terminalNode.getName()
					+"\n" + terminalNode.getBody() 
					+ "\n" + terminalNode.getSpecialTokenPrefix());
			if (terminalNode.getType().equals("MethodDecl") ||
					terminalNode.getType().equals("ConstructorDecl")) {
				// Transform all methods to non terminals 
				// and subordinate their code as FSTTerminal with the name "code"
				FSTNonTerminal methodNode = new FSTNonTerminal(
						terminalNode.getType(), terminalNode.getName());
				for (FSTTerminal jmlNode : generateCommentNodes(terminalNode)) {
					// extract JML pre- and postconditions and apply them 
					// as FSTTerminal children of the method
					methodNode.addChild(jmlNode);
				}
				// extract the method's code and apply it as terminal node
				FSTTerminal codeNode = new FSTTerminal("MethodCode", "",
						terminalNode.getBody(), "", "JavaJMLMethodOverriding");
				methodNode.addChild(codeNode);
				return methodNode;				
			} 
		}
		// Non terminal node: recursively visit all child nodes
		if (node instanceof FSTNonTerminal) {
			FSTNonTerminal nonTerminalNode = (FSTNonTerminal) node;
			LinkedList<FSTNode> newChildren = new LinkedList<FSTNode>();
			for(FSTNode childNode : nonTerminalNode.getChildren()) {
				FSTNode newChildNode = processFST(childNode);
				if (newChildNode != null) {
					newChildren.add(newChildNode);
				}
			}
			nonTerminalNode.setChildren(newChildren);
		}
		return node;
	}
	
	/** types of comment discerned 
	 * <p>The earlier ones are prioritized over the ones which follow */
	private enum CommentType {MultiJML, JavaDoc, MultiComment, SingleJML, SingleComment};
	
	/**
	 * extracts JML annotations out of the given node's special token prefix 
	 * (the node's comment).
	 * @param node - FST node (<code>MethodDecl</code> or <code>ConstructorDecl</code> type)
	 * to extract JML from 
	 * @return a list of FST terminal nodes, each one resembling a JML specification clause
	 */
	private List<FSTTerminal> generateCommentNodes(FSTTerminal node) {
		// extract JML pre- and postconditions out of the node's special token prefix
		// remove JML annotations out of the node's special token prefix
		LinkedList<FSTTerminal> commentNodes = new LinkedList<FSTTerminal>();
		String methodComment = node.getSpecialTokenPrefix();
		node.setSpecialTokenPrefix("");
		
		/** accumulates regular comment; note that JML nodes form an individual node each.*/
		String regularCommentAccum = "";
		/** accumulates JavaDoc; note that JML nodes form an individual node each. */
		String javaDocAccum = "";
		/** accumulator string for current comment type */
		String unknownAccum = "";
		
		// separate comment types
		/** current working cursor inside the method comment */
		int cursor = 0;
		int[] commentOffsets = new int[5];
		int tmp;
		while(cursor < methodComment.length()) {
			// search for comment types: /*@ /** /* //@ //
			tmp = methodComment.indexOf("/*@", cursor);
			if (tmp == -1) tmp = Integer.MAX_VALUE;
			commentOffsets[CommentType.MultiJML.ordinal()] = tmp;
			tmp = methodComment.indexOf("/**", cursor);
			if (tmp == -1) tmp = Integer.MAX_VALUE;
			commentOffsets[CommentType.JavaDoc.ordinal()] = tmp;
			tmp = methodComment.indexOf("/*", cursor);
			if (tmp == -1) tmp = Integer.MAX_VALUE;
			commentOffsets[CommentType.MultiComment.ordinal()] = tmp;
			tmp = methodComment.indexOf("//@", cursor);
			if (tmp == -1) tmp = Integer.MAX_VALUE;
			commentOffsets[CommentType.SingleJML.ordinal()] = tmp;
			tmp = methodComment.indexOf("//", cursor);
			if (tmp == -1) tmp = Integer.MAX_VALUE;
			commentOffsets[CommentType.SingleComment.ordinal()] = tmp;
			
			// which comment type is first
			int earliestCommentTypeIdx = 0; //index of comment type with first offset
			for (int i = 1; i < commentOffsets.length; i++) {
				if (commentOffsets[earliestCommentTypeIdx] > commentOffsets[i])
					earliestCommentTypeIdx = i;
			}
			// gap between cursor and first comment type offset?
			String tmpAccum = methodComment.substring(cursor, 
					Math.min(commentOffsets[earliestCommentTypeIdx], methodComment.length()-1));
			if (!tmpAccum.matches("[ \t\n\r\f@\\*]*")) {
				unknownAccum += tmpAccum;				
			}
			cursor = commentOffsets[earliestCommentTypeIdx];
			if (cursor == Integer.MAX_VALUE) break;
			
			int commentEndCursor; //end of comment
			StringTokenizer jmlTok;
			switch (CommentType.values()[earliestCommentTypeIdx]) {			
			case MultiJML: //generate a individual JML node for every clause keyword
				cursor += 3; //move cursor to position after /*@
				commentEndCursor = methodComment.indexOf("*/", cursor);
				if (commentEndCursor == -1) throw new RuntimeException(
						"premature end of multiline JML comment (beginning at position "
						+ cursor + "):\n" + methodComment);
				jmlTok = new StringTokenizer(
						methodComment.substring(cursor, commentEndCursor), 
						" \t\n\r\f@;()", true);
				while (jmlTok.hasMoreTokens()) {
					// create terminal JML FST node
					FSTTerminal jmlNode = createJMLnode(jmlTok);
					if (jmlNode != null) commentNodes.add(jmlNode);
				}
				cursor = commentEndCursor + 2;
				break;
				
			case JavaDoc: //append JavaDoc
				cursor += 3; //move cursor to position after /**
				commentEndCursor = methodComment.indexOf("*/", cursor);
				if (commentEndCursor == -1) throw new RuntimeException(
						"premature end of JavaDoc (beginning at position "
						+ cursor + "):\n" + methodComment);
				javaDocAccum += methodComment.substring(cursor, commentEndCursor);
				cursor = commentEndCursor + 2;
				break;
				
			case MultiComment: //append comment
				cursor += 2; //move cursor to position after /*
				commentEndCursor = methodComment.indexOf("*/", cursor);
				if (commentEndCursor == -1) throw new RuntimeException(
						"premature end of multiline comment (beginning at position "
						+ cursor + "):\n" + methodComment);
				regularCommentAccum += methodComment.substring(cursor, commentEndCursor);
				cursor = commentEndCursor + 2;
				break;
			
			case SingleJML: //generate a individual JML node for every clause keyword
				cursor += 3; //move cursor to position after //@
				commentEndCursor = methodComment.indexOf("\n", cursor);
				if (commentEndCursor == -1) throw new RuntimeException(
						"premature end of single line JML comment (beginning at position "
						+ cursor + "):\n" + methodComment);
				jmlTok = new StringTokenizer(
						methodComment.substring(cursor, commentEndCursor), 
						" \t\n\r\f@;()", true);
				while (jmlTok.hasMoreTokens()) {
					// create terminal JML FST node
					FSTTerminal jmlNode = createJMLnode(jmlTok);
					if (jmlNode != null) commentNodes.add(jmlNode);
				}
				cursor = commentEndCursor + 1;
				break;
				
			case SingleComment: //append comment
				cursor += 2; //move cursor to position after //
				commentEndCursor = methodComment.indexOf("\n", cursor);
				if (commentEndCursor == -1) throw new RuntimeException(
						"premature end of single line comment (beginning at position "
						+ cursor + "):\n" + methodComment);
				regularCommentAccum += methodComment.substring(cursor, commentEndCursor);
				cursor = commentEndCursor + 1;
				break;

			default:
				break;
			}
			
		}
		// generate comment nodes
		if (!javaDocAccum.matches("[ \t\n\r\f@\\*]*")) {
			commentNodes.add(new FSTTerminal("JavaDoc", "",
					unknownAccum, "", "StringConcatenation"));
		}
		if (!regularCommentAccum.matches("[ \t\n\r\f@\\*]*")) {
			commentNodes.add(new FSTTerminal("RegularComment", "",
					unknownAccum, "", "StringConcatenation"));
		}
		if (!unknownAccum.matches("[ \t\n\r\f@\\*]*")) {
			commentNodes.add(new FSTTerminal("UnknownCommentType", "",
					unknownAccum, "", "StringConcatenation"));
		}
		
		return commentNodes;
	}
	
	/**
	 * creates a terminal JML FST node out of the given string tokenizer
	 * <p>The JML node is initialized with correct  
	 * @param sTok - <code>StringTokenizer</code>, which will be altered during call;
	 * <br><b>expected:</b> <code>returnDelims</code>, 
	 * <code>delims</code> contains "\n ;()", first word is interpreted as 
	 * JML clause keyword 
	 * @return initialized terminal JML FST node or <code>null</code> if the
	 * given JML comment block is empty
	 */
	private FSTTerminal createJMLnode(StringTokenizer sTok) {
		String clauseKeyword;
		do {
			if (!sTok.hasMoreTokens()) return null;
			clauseKeyword = sTok.nextToken();
		} while (clauseKeyword.matches("[ \t\n\r\f@]*"));
		if (clauseKeyword.equals("requires"))
			return new FSTTerminal("MethodJML"+clauseKeyword, "",
					scanUntilSemicolon(sTok), "", "JMLdisjunction");
		else if (clauseKeyword.equals("ensures"))
			return new FSTTerminal("MethodJML"+clauseKeyword, "",
					scanUntilSemicolon(sTok), "", "JMLconjunction");
		else if (clauseKeyword.equals("assignable"))
			return new FSTTerminal("MethodJML"+clauseKeyword, "",
					scanUntilSemicolon(sTok), "", "JMLassignableListConcatenation");
		else if (clauseKeyword.equals("invariant"))
			return new FSTTerminal("JMLclassInvariant", "",
					scanUntilSemicolon(sTok), "", "JMLinvariantsConcatenation");
		else 
			return new FSTTerminal("MethodJML"+clauseKeyword, "",
					scanUntilSemicolon(sTok), "", "StringConcatenation");
		// TODO use another standard composition mechanism for JMl clauses
		// TODO support more JML clause keywords
	}		
	
	/** advances the given <code>StringTokenizer</code> to the point after the next
	 * semicolon (';'). 
	 * <p>Round braces ('(' and ')') enframe inner semicolons, which cause no method return.
	 * @param sTok - <code>StringTokenizer</code>, which will be altered during call;
	 * <br><b>expected:</b> <code>returnDelims</code>, <code>delims</code> contains ";()"
	 * @return a string containing all tokens encountered (the last semicolon is excluded).*/
	private String scanUntilSemicolon(StringTokenizer sTok) {
		String result = "";
		int braceLevel = 0;
		String token;
		while (sTok.hasMoreTokens()) {
			token = sTok.nextToken();
			if (token.equals("(")) braceLevel++;
			else if (braceLevel > 0) {
				if (token.equals(")")) braceLevel--;				
			} else if (token.equals(";")) {
				return result;	
			}
			result += token;
		}
		throw new RuntimeException("Premature end of JML input: expecting ';'" +
				" open braces at end: " + braceLevel + "\n" +
				result);
		//return result; //premature end of input, but never mind
	}
	


	public void reconstructFST(List<FSTNode> fst) {
		// visit all FST nodes and apply transformations
		for (ListIterator<FSTNode> fstIt = fst.listIterator(); fstIt.hasNext(); ) {
			FSTNode node = fstIt.next();	
			fstIt.remove();
			fstIt.add(reconstructFST(node));
		}
	}
	
	/** Recursively traverses a FST to reconstruct FST nodes.
	 * <p>Note that the flow of control disallows certain transformations.
	 * @param node - node to start traversal
	 * @return - new node to replace node given as parameter (caller must do replacement)
	 * <br>null is returned only if given node was null */
	private FSTNode reconstructFST(FSTNode node) {
		// reconstruct terminal method nodes
		if (node == null) return null;
		if (node.getType() != null) {
		if (node.getType().equals("MethodDecl") ||
				node.getType().equals("ConstructorDecl")) {
			// join all subordinate nodes into one terminal method node
			if (node instanceof FSTNonTerminal) {
				FSTNonTerminal methodNonTerminal = (FSTNonTerminal) node;
				String body = "";
				String methodComment = "";
				String regularComment = "";
				String jmlComment = "";
				String otherComment = "";
				String prefix = "";
				for (FSTNode child : methodNonTerminal.getChildren()) {
					if (child instanceof FSTTerminal) {
						String childType = child.getType();
						// add child node info to method body and prefix
						if (childType.equals("MethodCode")) 
							body += ((FSTTerminal) child).getBody();
						else if (childType.equals("RegularComment")) 
							regularComment += ((FSTTerminal) child).getBody() + "\n";
						else if (childType.equals("JavaDoc")) 
							methodComment += ((FSTTerminal) child).getBody() + "\n";
						else if (childType.equals("UnknownCommentType")) 
							otherComment += ((FSTTerminal) child).getBody() + "\n";	
						else if (childType.startsWith("JMLclassInvariant"))
							// for visibility always place invariants first (although not necessary)
							prefix += "/*@\n    @ invariant " + ((FSTTerminal) child).getBody() + "; */\n";	
						else if (childType.startsWith("MethodJML"))
							jmlComment += "@ " + childType.substring(9) + ((FSTTerminal) child).getBody() + ";\n";
					    //TODO eliminate duplicates in MethodJMLensures clauses (they look odd)
					} else throw new RuntimeException(
							"Only terminal children of MethodDecl/ConstructorDecl nodes expected: "
							+ child.getName() + " " + child.getType());
				}
				
				// trim comments for pretty print
				otherComment = otherComment.trim();
				methodComment = methodComment.trim();
				regularComment = regularComment.trim();
				jmlComment = jmlComment.trim();
				
				// aggregate method's comment
				// TODO note that whitespaces between start of comment and '@' are not recognized as JML
				// by ESC/Java2
				if (!otherComment.matches("[ \t\n\r\f@\\*]*"))
					prefix += "/*" + otherComment + "*/\n";
				if (!methodComment.matches("[ \t\n\r\f@\\*]*")) 
					prefix += "/**\n" + methodComment + " */\n";
				if (!regularComment.matches("[ \t\n\r\f@\\*]*"))
					prefix += "/*\n" + regularComment + " */\n";				
				if (!jmlComment.matches("[ \t\n\r\f@\\*]*"))
					prefix += "/*@\n    " + jmlComment + " */\n";
				return new FSTTerminal(
						methodNonTerminal.getType(),
						methodNonTerminal.getName(),
						body,
						prefix);
				
			} else {
				// do nothing - it seems that some non terminals are visited more than once
//				throw new RuntimeException(
//					"Only non terminal MethodDecl nodes expected: "
//					+ node.getName() + " " + node.getType() + " "
//					+ node.getClass().getSimpleName());
			}
		} }
		
		// Non terminal node: recursively visit all child nodes
		if (node instanceof FSTNonTerminal) {
			FSTNonTerminal nonTerminalNode = (FSTNonTerminal) node;
			LinkedList<FSTNode> newChildren = new LinkedList<FSTNode>();
			for(FSTNode childNode : nonTerminalNode.getChildren()) {
				FSTNode newChildNode = reconstructFST(childNode);
				if (newChildNode != null) {
					newChildren.add(newChildNode);
				}
			}
			nonTerminalNode.setChildren(newChildren);
		}
		return node;
		
	}
	

}
